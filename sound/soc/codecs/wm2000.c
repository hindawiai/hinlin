<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 * wm2000.c  --  WM2000 ALSA Soc Audio driver
 *
 * Copyright 2008-2011 Wolfson Microelectronics PLC.
 *
 * Author: Mark Brown <broonie@खोलोsource.wolfsonmicro.com>
 *
 * The करोwnload image क्रम the WM2000 will be requested as
 * 'wm2000_anc.bin' by शेष (overridable via platक्रमm data) at
 * runसमय and is expected to be in flat binary क्रमmat.  This is
 * generated by Wolfson configuration tools and includes
 * प्रणाली-specअगरic calibration inक्रमmation.  If supplied as a
 * sequence of ASCII-encoded hexidecimal bytes this can be converted
 * पूर्णांकo a flat binary with a command such as this on the command line:
 *
 * perl -e 'while (<>) { s/[\r\n]+// ; printf("%c", hex($_)); }'
 *                 < file  > wm2000_anc.bin
 */

#समावेश <linux/module.h>
#समावेश <linux/moduleparam.h>
#समावेश <linux/kernel.h>
#समावेश <linux/init.h>
#समावेश <linux/firmware.h>
#समावेश <linux/clk.h>
#समावेश <linux/delay.h>
#समावेश <linux/pm.h>
#समावेश <linux/i2c.h>
#समावेश <linux/regmap.h>
#समावेश <linux/debugfs.h>
#समावेश <linux/regulator/consumer.h>
#समावेश <linux/slab.h>
#समावेश <sound/core.h>
#समावेश <sound/pcm.h>
#समावेश <sound/pcm_params.h>
#समावेश <sound/soc.h>
#समावेश <sound/initval.h>
#समावेश <sound/tlv.h>

#समावेश <sound/wm2000.h>

#समावेश "wm2000.h"

#घोषणा WM2000_NUM_SUPPLIES 3

अटल स्थिर अक्षर *wm2000_supplies[WM2000_NUM_SUPPLIES] = अणु
	"SPKVDD",
	"DBVDD",
	"DCVDD",
पूर्ण;

क्रमागत wm2000_anc_mode अणु
	ANC_ACTIVE = 0,
	ANC_BYPASS = 1,
	ANC_STANDBY = 2,
	ANC_OFF = 3,
पूर्ण;

काष्ठा wm2000_priv अणु
	काष्ठा i2c_client *i2c;
	काष्ठा regmap *regmap;
	काष्ठा clk *mclk;

	काष्ठा regulator_bulk_data supplies[WM2000_NUM_SUPPLIES];

	क्रमागत wm2000_anc_mode anc_mode;

	अचिन्हित पूर्णांक anc_active:1;
	अचिन्हित पूर्णांक anc_eng_ena:1;
	अचिन्हित पूर्णांक spk_ena:1;

	अचिन्हित पूर्णांक speech_clarity:1;

	पूर्णांक anc_करोwnload_size;
	अक्षर *anc_करोwnload;

	काष्ठा mutex lock;
पूर्ण;

अटल पूर्णांक wm2000_ग_लिखो(काष्ठा i2c_client *i2c, अचिन्हित पूर्णांक reg,
			अचिन्हित पूर्णांक value)
अणु
	काष्ठा wm2000_priv *wm2000 = i2c_get_clientdata(i2c);
	वापस regmap_ग_लिखो(wm2000->regmap, reg, value);
पूर्ण

अटल व्योम wm2000_reset(काष्ठा wm2000_priv *wm2000)
अणु
	काष्ठा i2c_client *i2c = wm2000->i2c;

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);
	wm2000_ग_लिखो(i2c, WM2000_REG_ID1, 0);

	wm2000->anc_mode = ANC_OFF;
पूर्ण

अटल पूर्णांक wm2000_poll_bit(काष्ठा i2c_client *i2c,
			   अचिन्हित पूर्णांक reg, u8 mask)
अणु
	काष्ठा wm2000_priv *wm2000 = i2c_get_clientdata(i2c);
	पूर्णांक समयout = 4000;
	अचिन्हित पूर्णांक val;

	regmap_पढ़ो(wm2000->regmap, reg, &val);

	जबतक (!(val & mask) && --समयout) अणु
		msleep(1);
		regmap_पढ़ो(wm2000->regmap, reg, &val);
	पूर्ण

	अगर (समयout == 0)
		वापस 0;
	अन्यथा
		वापस 1;
पूर्ण

अटल पूर्णांक wm2000_घातer_up(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	अचिन्हित दीर्घ rate;
	अचिन्हित पूर्णांक val;
	पूर्णांक ret;

	अगर (WARN_ON(wm2000->anc_mode != ANC_OFF))
		वापस -EINVAL;

	dev_dbg(&i2c->dev, "Beginning power up\n");

	ret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);
		वापस ret;
	पूर्ण

	rate = clk_get_rate(wm2000->mclk);
	अगर (rate <= 13500000) अणु
		dev_dbg(&i2c->dev, "Disabling MCLK divider\n");
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2,
			     WM2000_MCLK_DIV2_ENA_CLR);
	पूर्ण अन्यथा अणु
		dev_dbg(&i2c->dev, "Enabling MCLK divider\n");
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2,
			     WM2000_MCLK_DIV2_ENA_SET);
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_SET);

	/* Wait क्रम ANC engine to become पढ़ोy */
	अगर (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,
			     WM2000_ANC_ENG_IDLE)) अणु
		dev_err(&i2c->dev, "ANC engine failed to reset\n");
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस -ETIMEDOUT;
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_BOOT_COMPLETE)) अणु
		dev_err(&i2c->dev, "ANC engine failed to initialise\n");
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस -ETIMEDOUT;
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);

	/* Open code करोwnload of the data since it is the only bulk
	 * ग_लिखो we करो. */
	dev_dbg(&i2c->dev, "Downloading %d bytes\n",
		wm2000->anc_करोwnload_size - 2);

	ret = i2c_master_send(i2c, wm2000->anc_करोwnload,
			      wm2000->anc_करोwnload_size);
	अगर (ret < 0) अणु
		dev_err(&i2c->dev, "i2c_transfer() failed: %d\n", ret);
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस ret;
	पूर्ण
	अगर (ret != wm2000->anc_करोwnload_size) अणु
		dev_err(&i2c->dev, "i2c_transfer() failed, %d != %d\n",
			ret, wm2000->anc_करोwnload_size);
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस -EIO;
	पूर्ण

	dev_dbg(&i2c->dev, "Download complete\n");

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);

		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	पूर्ण

	ret = regmap_पढ़ो(wm2000->regmap, WM2000_REG_SPEECH_CLARITY, &val);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Unable to read Speech Clarity: %d\n", ret);
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस ret;
	पूर्ण
	अगर (wm2000->speech_clarity)
		val |= WM2000_SPEECH_CLARITY;
	अन्यथा
		val &= ~WM2000_SPEECH_CLARITY;
	wm2000_ग_लिखो(i2c, WM2000_REG_SPEECH_CLARITY, val);

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_START0, 0x33);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_START1, 0x02);

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_MOUSE_ACTIVE)) अणु
		dev_err(&i2c->dev, "Timed out waiting for device\n");
		regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);
		वापस -ETIMEDOUT;
	पूर्ण

	dev_dbg(&i2c->dev, "ANC active\n");
	अगर (analogue)
		dev_dbg(&i2c->dev, "Analogue active\n");
	wm2000->anc_mode = ANC_ACTIVE;

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_घातer_करोwn(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_POWER_DOWN);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_POWER_DOWN);
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_POWER_DOWN_COMPLETE)) अणु
		dev_err(&i2c->dev, "Timeout waiting for ANC power down\n");
		वापस -ETIMEDOUT;
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,
			     WM2000_ANC_ENG_IDLE)) अणु
		dev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");
		वापस -ETIMEDOUT;
	पूर्ण

	regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);

	dev_dbg(&i2c->dev, "powered off\n");
	wm2000->anc_mode = ANC_OFF;

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_enter_bypass(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	अगर (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))
		वापस -EINVAL;

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_ANC_DISABLED)) अणु
		dev_err(&i2c->dev, "Timeout waiting for ANC disable\n");
		वापस -ETIMEDOUT;
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,
			     WM2000_ANC_ENG_IDLE)) अणु
		dev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");
		वापस -ETIMEDOUT;
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);

	wm2000->anc_mode = ANC_BYPASS;
	dev_dbg(&i2c->dev, "bypass enabled\n");

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_निकास_bypass(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	अगर (WARN_ON(wm2000->anc_mode != ANC_BYPASS))
		वापस -EINVAL;
	
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL1, 0);

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_MOUSE_ACTIVE)) अणु
		dev_err(&i2c->dev, "Timed out waiting for MOUSE\n");
		वापस -ETIMEDOUT;
	पूर्ण

	wm2000->anc_mode = ANC_ACTIVE;
	dev_dbg(&i2c->dev, "MOUSE active\n");

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_enter_standby(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	अगर (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))
		वापस -EINVAL;

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);

		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_ANC_DISABLED)) अणु
		dev_err(&i2c->dev,
			"Timed out waiting for ANC disable after 1ms\n");
		वापस -ETIMEDOUT;
	पूर्ण

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT, WM2000_ANC_ENG_IDLE)) अणु
		dev_err(&i2c->dev,
			"Timed out waiting for standby\n");
		वापस -ETIMEDOUT;
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);

	wm2000->anc_mode = ANC_STANDBY;
	dev_dbg(&i2c->dev, "standby\n");
	अगर (analogue)
		dev_dbg(&i2c->dev, "Analogue disabled\n");

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_निकास_standby(काष्ठा i2c_client *i2c, पूर्णांक analogue)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	अगर (WARN_ON(wm2000->anc_mode != ANC_STANDBY))
		वापस -EINVAL;

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL1, 0);

	अगर (analogue) अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);

		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_MOUSE_ENABLE);
	पूर्ण अन्यथा अणु
		wm2000_ग_लिखो(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_MOUSE_ENABLE);
	पूर्ण

	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_ग_लिखो(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	अगर (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_MOUSE_ACTIVE)) अणु
		dev_err(&i2c->dev, "Timed out waiting for MOUSE\n");
		वापस -ETIMEDOUT;
	पूर्ण

	wm2000->anc_mode = ANC_ACTIVE;
	dev_dbg(&i2c->dev, "MOUSE active\n");
	अगर (analogue)
		dev_dbg(&i2c->dev, "Analogue enabled\n");

	वापस 0;
पूर्ण

प्रकार पूर्णांक (*wm2000_mode_fn)(काष्ठा i2c_client *i2c, पूर्णांक analogue);

अटल काष्ठा अणु
	क्रमागत wm2000_anc_mode source;
	क्रमागत wm2000_anc_mode dest;
	पूर्णांक analogue;
	wm2000_mode_fn step[2];
पूर्ण anc_transitions[] = अणु
	अणु
		.source = ANC_OFF,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = अणु
			wm2000_घातer_up,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_OFF,
		.dest = ANC_STANDBY,
		.step = अणु
			wm2000_घातer_up,
			wm2000_enter_standby,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_OFF,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = अणु
			wm2000_घातer_up,
			wm2000_enter_bypass,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_ACTIVE,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = अणु
			wm2000_enter_bypass,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_ACTIVE,
		.dest = ANC_STANDBY,
		.analogue = 1,
		.step = अणु
			wm2000_enter_standby,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_ACTIVE,
		.dest = ANC_OFF,
		.analogue = 1,
		.step = अणु
			wm2000_घातer_करोwn,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_BYPASS,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = अणु
			wm2000_निकास_bypass,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_BYPASS,
		.dest = ANC_STANDBY,
		.analogue = 1,
		.step = अणु
			wm2000_निकास_bypass,
			wm2000_enter_standby,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_BYPASS,
		.dest = ANC_OFF,
		.step = अणु
			wm2000_निकास_bypass,
			wm2000_घातer_करोwn,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_STANDBY,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = अणु
			wm2000_निकास_standby,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_STANDBY,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = अणु
			wm2000_निकास_standby,
			wm2000_enter_bypass,
		पूर्ण,
	पूर्ण,
	अणु
		.source = ANC_STANDBY,
		.dest = ANC_OFF,
		.step = अणु
			wm2000_निकास_standby,
			wm2000_घातer_करोwn,
		पूर्ण,
	पूर्ण,
पूर्ण;

अटल पूर्णांक wm2000_anc_transition(काष्ठा wm2000_priv *wm2000,
				 क्रमागत wm2000_anc_mode mode)
अणु
	काष्ठा i2c_client *i2c = wm2000->i2c;
	पूर्णांक i, j;
	पूर्णांक ret;

	अगर (wm2000->anc_mode == mode)
		वापस 0;

	क्रम (i = 0; i < ARRAY_SIZE(anc_transitions); i++)
		अगर (anc_transitions[i].source == wm2000->anc_mode &&
		    anc_transitions[i].dest == mode)
			अवरोध;
	अगर (i == ARRAY_SIZE(anc_transitions)) अणु
		dev_err(&i2c->dev, "No transition for %d->%d\n",
			wm2000->anc_mode, mode);
		वापस -EINVAL;
	पूर्ण

	/* Maपूर्णांकain घड़ी जबतक active */
	अगर (anc_transitions[i].source == ANC_OFF) अणु
		ret = clk_prepare_enable(wm2000->mclk);
		अगर (ret != 0) अणु
			dev_err(&i2c->dev, "Failed to enable MCLK: %d\n", ret);
			वापस ret;
		पूर्ण
	पूर्ण

	क्रम (j = 0; j < ARRAY_SIZE(anc_transitions[j].step); j++) अणु
		अगर (!anc_transitions[i].step[j])
			अवरोध;
		ret = anc_transitions[i].step[j](i2c,
						 anc_transitions[i].analogue);
		अगर (ret != 0)
			वापस ret;
	पूर्ण

	अगर (anc_transitions[i].dest == ANC_OFF)
		clk_disable_unprepare(wm2000->mclk);

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_anc_set_mode(काष्ठा wm2000_priv *wm2000)
अणु
	काष्ठा i2c_client *i2c = wm2000->i2c;
	क्रमागत wm2000_anc_mode mode;

	अगर (wm2000->anc_eng_ena && wm2000->spk_ena)
		अगर (wm2000->anc_active)
			mode = ANC_ACTIVE;
		अन्यथा
			mode = ANC_BYPASS;
	अन्यथा
		mode = ANC_STANDBY;

	dev_dbg(&i2c->dev, "Set mode %d (enabled %d, mute %d, active %d)\n",
		mode, wm2000->anc_eng_ena, !wm2000->spk_ena,
		wm2000->anc_active);

	वापस wm2000_anc_transition(wm2000, mode);
पूर्ण

अटल पूर्णांक wm2000_anc_mode_get(काष्ठा snd_kcontrol *kcontrol,
			       काष्ठा snd_ctl_elem_value *ucontrol)
अणु
	काष्ठा snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	ucontrol->value.पूर्णांकeger.value[0] = wm2000->anc_active;

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_anc_mode_put(काष्ठा snd_kcontrol *kcontrol,
			       काष्ठा snd_ctl_elem_value *ucontrol)
अणु
	काष्ठा snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);
	अचिन्हित पूर्णांक anc_active = ucontrol->value.पूर्णांकeger.value[0];
	पूर्णांक ret;

	अगर (anc_active > 1)
		वापस -EINVAL;

	mutex_lock(&wm2000->lock);

	wm2000->anc_active = anc_active;

	ret = wm2000_anc_set_mode(wm2000);

	mutex_unlock(&wm2000->lock);

	वापस ret;
पूर्ण

अटल पूर्णांक wm2000_speaker_get(काष्ठा snd_kcontrol *kcontrol,
			      काष्ठा snd_ctl_elem_value *ucontrol)
अणु
	काष्ठा snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	ucontrol->value.पूर्णांकeger.value[0] = wm2000->spk_ena;

	वापस 0;
पूर्ण

अटल पूर्णांक wm2000_speaker_put(काष्ठा snd_kcontrol *kcontrol,
			      काष्ठा snd_ctl_elem_value *ucontrol)
अणु
	काष्ठा snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);
	अचिन्हित पूर्णांक val = ucontrol->value.पूर्णांकeger.value[0];
	पूर्णांक ret;

	अगर (val > 1)
		वापस -EINVAL;

	mutex_lock(&wm2000->lock);

	wm2000->spk_ena = val;

	ret = wm2000_anc_set_mode(wm2000);

	mutex_unlock(&wm2000->lock);

	वापस ret;
पूर्ण

अटल स्थिर काष्ठा snd_kcontrol_new wm2000_controls[] = अणु
	SOC_SINGLE("ANC Volume", WM2000_REG_ANC_GAIN_CTRL, 0, 255, 0),
	SOC_SINGLE_BOOL_EXT("WM2000 ANC Switch", 0,
			    wm2000_anc_mode_get,
			    wm2000_anc_mode_put),
	SOC_SINGLE_BOOL_EXT("WM2000 Switch", 0,
			    wm2000_speaker_get,
			    wm2000_speaker_put),
पूर्ण;

अटल पूर्णांक wm2000_anc_घातer_event(काष्ठा snd_soc_dapm_widget *w,
				  काष्ठा snd_kcontrol *kcontrol, पूर्णांक event)
अणु
	काष्ठा snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);
	पूर्णांक ret;

	mutex_lock(&wm2000->lock);

	अगर (SND_SOC_DAPM_EVENT_ON(event))
		wm2000->anc_eng_ena = 1;

	अगर (SND_SOC_DAPM_EVENT_OFF(event))
		wm2000->anc_eng_ena = 0;

	ret = wm2000_anc_set_mode(wm2000);

	mutex_unlock(&wm2000->lock);

	वापस ret;
पूर्ण

अटल स्थिर काष्ठा snd_soc_dapm_widget wm2000_dapm_widमाला_लो[] = अणु
/* Externally visible pins */
SND_SOC_DAPM_OUTPUT("SPKN"),
SND_SOC_DAPM_OUTPUT("SPKP"),

SND_SOC_DAPM_INPUT("LINN"),
SND_SOC_DAPM_INPUT("LINP"),

SND_SOC_DAPM_PGA_E("ANC Engine", SND_SOC_NOPM, 0, 0, शून्य, 0,
		   wm2000_anc_घातer_event,
		   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
पूर्ण;

/* Target, Path, Source */
अटल स्थिर काष्ठा snd_soc_dapm_route wm2000_audio_map[] = अणु
	अणु "SPKN", शून्य, "ANC Engine" पूर्ण,
	अणु "SPKP", शून्य, "ANC Engine" पूर्ण,
	अणु "ANC Engine", शून्य, "LINN" पूर्ण,
	अणु "ANC Engine", शून्य, "LINP" पूर्ण,
पूर्ण;

#अगर_घोषित CONFIG_PM
अटल पूर्णांक wm2000_suspend(काष्ठा snd_soc_component *component)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	वापस wm2000_anc_transition(wm2000, ANC_OFF);
पूर्ण

अटल पूर्णांक wm2000_resume(काष्ठा snd_soc_component *component)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	वापस wm2000_anc_set_mode(wm2000);
पूर्ण
#अन्यथा
#घोषणा wm2000_suspend शून्य
#घोषणा wm2000_resume शून्य
#पूर्ण_अगर

अटल bool wm2000_पढ़ोable_reg(काष्ठा device *dev, अचिन्हित पूर्णांक reg)
अणु
	चयन (reg) अणु
	हाल WM2000_REG_SYS_START:
	हाल WM2000_REG_ANC_GAIN_CTRL:
	हाल WM2000_REG_MSE_TH1:
	हाल WM2000_REG_MSE_TH2:
	हाल WM2000_REG_SPEECH_CLARITY:
	हाल WM2000_REG_SYS_WATCHDOG:
	हाल WM2000_REG_ANA_VMID_PD_TIME:
	हाल WM2000_REG_ANA_VMID_PU_TIME:
	हाल WM2000_REG_CAT_FLTR_INDX:
	हाल WM2000_REG_CAT_GAIN_0:
	हाल WM2000_REG_SYS_STATUS:
	हाल WM2000_REG_SYS_MODE_CNTRL:
	हाल WM2000_REG_SYS_START0:
	हाल WM2000_REG_SYS_START1:
	हाल WM2000_REG_ID1:
	हाल WM2000_REG_ID2:
	हाल WM2000_REG_REVISON:
	हाल WM2000_REG_SYS_CTL1:
	हाल WM2000_REG_SYS_CTL2:
	हाल WM2000_REG_ANC_STAT:
	हाल WM2000_REG_IF_CTL:
	हाल WM2000_REG_ANA_MIC_CTL:
	हाल WM2000_REG_SPK_CTL:
		वापस true;
	शेष:
		वापस false;
	पूर्ण
पूर्ण

अटल स्थिर काष्ठा regmap_config wm2000_regmap = अणु
	.reg_bits = 16,
	.val_bits = 8,

	.max_रेजिस्टर = WM2000_REG_SPK_CTL,
	.पढ़ोable_reg = wm2000_पढ़ोable_reg,
पूर्ण;

अटल पूर्णांक wm2000_probe(काष्ठा snd_soc_component *component)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	/* This will trigger a transition to standby mode by शेष */
	wm2000_anc_set_mode(wm2000);

	वापस 0;
पूर्ण

अटल व्योम wm2000_हटाओ(काष्ठा snd_soc_component *component)
अणु
	काष्ठा wm2000_priv *wm2000 = dev_get_drvdata(component->dev);

	wm2000_anc_transition(wm2000, ANC_OFF);
पूर्ण

अटल स्थिर काष्ठा snd_soc_component_driver soc_component_dev_wm2000 = अणु
	.probe			= wm2000_probe,
	.हटाओ			= wm2000_हटाओ,
	.suspend		= wm2000_suspend,
	.resume			= wm2000_resume,
	.controls		= wm2000_controls,
	.num_controls		= ARRAY_SIZE(wm2000_controls),
	.dapm_widमाला_लो		= wm2000_dapm_widमाला_लो,
	.num_dapm_widमाला_लो	= ARRAY_SIZE(wm2000_dapm_widमाला_लो),
	.dapm_routes		= wm2000_audio_map,
	.num_dapm_routes	= ARRAY_SIZE(wm2000_audio_map),
	.idle_bias_on		= 1,
	.use_pmकरोwn_समय	= 1,
	.endianness		= 1,
	.non_legacy_dai_naming	= 1,
पूर्ण;

अटल पूर्णांक wm2000_i2c_probe(काष्ठा i2c_client *i2c,
			    स्थिर काष्ठा i2c_device_id *i2c_id)
अणु
	काष्ठा wm2000_priv *wm2000;
	काष्ठा wm2000_platक्रमm_data *pdata;
	स्थिर अक्षर *filename;
	स्थिर काष्ठा firmware *fw = शून्य;
	पूर्णांक ret, i;
	अचिन्हित पूर्णांक reg;
	u16 id;

	wm2000 = devm_kzalloc(&i2c->dev, माप(*wm2000), GFP_KERNEL);
	अगर (!wm2000)
		वापस -ENOMEM;

	mutex_init(&wm2000->lock);

	dev_set_drvdata(&i2c->dev, wm2000);

	wm2000->regmap = devm_regmap_init_i2c(i2c, &wm2000_regmap);
	अगर (IS_ERR(wm2000->regmap)) अणु
		ret = PTR_ERR(wm2000->regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		जाओ out;
	पूर्ण

	क्रम (i = 0; i < WM2000_NUM_SUPPLIES; i++)
		wm2000->supplies[i].supply = wm2000_supplies[i];

	ret = devm_regulator_bulk_get(&i2c->dev, WM2000_NUM_SUPPLIES,
				      wm2000->supplies);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Failed to get supplies: %d\n", ret);
		वापस ret;
	पूर्ण

	ret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);
		वापस ret;
	पूर्ण

	/* Verअगरy that this is a WM2000 */
	ret = regmap_पढ़ो(wm2000->regmap, WM2000_REG_ID1, &reg);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Unable to read ID1: %d\n", ret);
		वापस ret;
	पूर्ण
	id = reg << 8;
	ret = regmap_पढ़ो(wm2000->regmap, WM2000_REG_ID2, &reg);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Unable to read ID2: %d\n", ret);
		वापस ret;
	पूर्ण
	id |= reg & 0xff;

	अगर (id != 0x2000) अणु
		dev_err(&i2c->dev, "Device is not a WM2000 - ID %x\n", id);
		ret = -ENODEV;
		जाओ err_supplies;
	पूर्ण

	ret = regmap_पढ़ो(wm2000->regmap, WM2000_REG_REVISON, &reg);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Unable to read Revision: %d\n", ret);
		वापस ret;
	पूर्ण
	dev_info(&i2c->dev, "revision %c\n", reg + 'A');

	wm2000->mclk = devm_clk_get(&i2c->dev, "MCLK");
	अगर (IS_ERR(wm2000->mclk)) अणु
		ret = PTR_ERR(wm2000->mclk);
		dev_err(&i2c->dev, "Failed to get MCLK: %d\n", ret);
		जाओ err_supplies;
	पूर्ण

	filename = "wm2000_anc.bin";
	pdata = dev_get_platdata(&i2c->dev);
	अगर (pdata) अणु
		wm2000->speech_clarity = !pdata->speech_enh_disable;

		अगर (pdata->करोwnload_file)
			filename = pdata->करोwnload_file;
	पूर्ण

	ret = request_firmware(&fw, filename, &i2c->dev);
	अगर (ret != 0) अणु
		dev_err(&i2c->dev, "Failed to acquire ANC data: %d\n", ret);
		जाओ err_supplies;
	पूर्ण

	/* Pre-cook the concatenation of the रेजिस्टर address onto the image */
	wm2000->anc_करोwnload_size = fw->size + 2;
	wm2000->anc_करोwnload = devm_kzalloc(&i2c->dev,
					    wm2000->anc_करोwnload_size,
					    GFP_KERNEL);
	अगर (wm2000->anc_करोwnload == शून्य) अणु
		ret = -ENOMEM;
		जाओ err_supplies;
	पूर्ण

	wm2000->anc_करोwnload[0] = 0x80;
	wm2000->anc_करोwnload[1] = 0x00;
	स_नकल(wm2000->anc_करोwnload + 2, fw->data, fw->size);

	wm2000->anc_eng_ena = 1;
	wm2000->anc_active = 1;
	wm2000->spk_ena = 1;
	wm2000->i2c = i2c;

	wm2000_reset(wm2000);

	ret = devm_snd_soc_रेजिस्टर_component(&i2c->dev,
					&soc_component_dev_wm2000, शून्य, 0);

err_supplies:
	regulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);

out:
	release_firmware(fw);
	वापस ret;
पूर्ण

अटल स्थिर काष्ठा i2c_device_id wm2000_i2c_id[] = अणु
	अणु "wm2000", 0 पूर्ण,
	अणु पूर्ण
पूर्ण;
MODULE_DEVICE_TABLE(i2c, wm2000_i2c_id);

अटल काष्ठा i2c_driver wm2000_i2c_driver = अणु
	.driver = अणु
		.name = "wm2000",
	पूर्ण,
	.probe = wm2000_i2c_probe,
	.id_table = wm2000_i2c_id,
पूर्ण;

module_i2c_driver(wm2000_i2c_driver);

MODULE_DESCRIPTION("ASoC WM2000 driver");
MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfonmicro.com>");
MODULE_LICENSE("GPL");
