<शैली गुरु>
/*
 * AMD64 class Memory Controller kernel module
 *
 * Copyright (c) 2009 SoftwareBitMaker.
 * Copyright (c) 2009-15 Advanced Micro Devices, Inc.
 *
 * This file may be distributed under the terms of the
 * GNU General Public License.
 */

#समावेश <linux/module.h>
#समावेश <linux/प्रकार.स>
#समावेश <linux/init.h>
#समावेश <linux/pci.h>
#समावेश <linux/pci_ids.h>
#समावेश <linux/slab.h>
#समावेश <linux/mmzone.h>
#समावेश <linux/edac.h>
#समावेश <यंत्र/cpu_device_id.h>
#समावेश <यंत्र/msr.h>
#समावेश "edac_module.h"
#समावेश "mce_amd.h"

#घोषणा amd64_info(fmt, arg...) \
	edac_prपूर्णांकk(KERN_INFO, "amd64", fmt, ##arg)

#घोषणा amd64_warn(fmt, arg...) \
	edac_prपूर्णांकk(KERN_WARNING, "amd64", "Warning: " fmt, ##arg)

#घोषणा amd64_err(fmt, arg...) \
	edac_prपूर्णांकk(KERN_ERR, "amd64", "Error: " fmt, ##arg)

#घोषणा amd64_mc_warn(mci, fmt, arg...) \
	edac_mc_chipset_prपूर्णांकk(mci, KERN_WARNING, "amd64", fmt, ##arg)

#घोषणा amd64_mc_err(mci, fmt, arg...) \
	edac_mc_chipset_prपूर्णांकk(mci, KERN_ERR, "amd64", fmt, ##arg)

/*
 * Throughout the comments in this code, the following terms are used:
 *
 *	SysAddr, DramAddr, and InputAddr
 *
 *  These terms come directly from the amd64 करोcumentation
 * (AMD खुलाation #26094).  They are defined as follows:
 *
 *     SysAddr:
 *         This is a physical address generated by a CPU core or a device
 *         करोing DMA.  If generated by a CPU core, a SysAddr is the result of
 *         a भव to physical address translation by the CPU core's address
 *         translation mechanism (MMU).
 *
 *     DramAddr:
 *         A DramAddr is derived from a SysAddr by subtracting an offset that
 *         depends on which node the SysAddr maps to and whether the SysAddr
 *         is within a range affected by memory hoisting.  The DRAM Base
 *         (section 3.4.4.1) and DRAM Limit (section 3.4.4.2) रेजिस्टरs
 *         determine which node a SysAddr maps to.
 *
 *         If the DRAM Hole Address Register (DHAR) is enabled and the SysAddr
 *         is within the range of addresses specअगरied by this रेजिस्टर, then
 *         a value x from the DHAR is subtracted from the SysAddr to produce a
 *         DramAddr.  Here, x represents the base address क्रम the node that
 *         the SysAddr maps to plus an offset due to memory hoisting.  See
 *         section 3.4.8 and the comments in amd64_get_dram_hole_info() and
 *         sys_addr_to_dram_addr() below क्रम more inक्रमmation.
 *
 *         If the SysAddr is not affected by the DHAR then a value y is
 *         subtracted from the SysAddr to produce a DramAddr.  Here, y is the
 *         base address क्रम the node that the SysAddr maps to.  See section
 *         3.4.4 and the comments in sys_addr_to_dram_addr() below क्रम more
 *         inक्रमmation.
 *
 *     InputAddr:
 *         A DramAddr is translated to an InputAddr beक्रमe being passed to the
 *         memory controller क्रम the node that the DramAddr is associated
 *         with.  The memory controller then maps the InputAddr to a csrow.
 *         If node पूर्णांकerleaving is not in use, then the InputAddr has the same
 *         value as the DramAddr.  Otherwise, the InputAddr is produced by
 *         discarding the bits used क्रम node पूर्णांकerleaving from the DramAddr.
 *         See section 3.4.4 क्रम more inक्रमmation.
 *
 *         The memory controller क्रम a given node uses its DRAM CS Base and
 *         DRAM CS Mask रेजिस्टरs to map an InputAddr to a csrow.  See
 *         sections 3.5.4 and 3.5.5 क्रम more inक्रमmation.
 */

#घोषणा EDAC_AMD64_VERSION		"3.5.0"
#घोषणा EDAC_MOD_STR			"amd64_edac"

/* Extended Model from CPUID, क्रम CPU Revision numbers */
#घोषणा K8_REV_D			1
#घोषणा K8_REV_E			2
#घोषणा K8_REV_F			4

/* Hardware limit on ChipSelect rows per MC and processors per प्रणाली */
#घोषणा NUM_CHIPSELECTS			8
#घोषणा DRAM_RANGES			8
#घोषणा NUM_CONTROLLERS			8

#घोषणा ON true
#घोषणा OFF false

/*
 * PCI-defined configuration space रेजिस्टरs
 */
#घोषणा PCI_DEVICE_ID_AMD_15H_NB_F1	0x1601
#घोषणा PCI_DEVICE_ID_AMD_15H_NB_F2	0x1602
#घोषणा PCI_DEVICE_ID_AMD_15H_M30H_NB_F1 0x141b
#घोषणा PCI_DEVICE_ID_AMD_15H_M30H_NB_F2 0x141c
#घोषणा PCI_DEVICE_ID_AMD_15H_M60H_NB_F1 0x1571
#घोषणा PCI_DEVICE_ID_AMD_15H_M60H_NB_F2 0x1572
#घोषणा PCI_DEVICE_ID_AMD_16H_NB_F1	0x1531
#घोषणा PCI_DEVICE_ID_AMD_16H_NB_F2	0x1532
#घोषणा PCI_DEVICE_ID_AMD_16H_M30H_NB_F1 0x1581
#घोषणा PCI_DEVICE_ID_AMD_16H_M30H_NB_F2 0x1582
#घोषणा PCI_DEVICE_ID_AMD_17H_DF_F0	0x1460
#घोषणा PCI_DEVICE_ID_AMD_17H_DF_F6	0x1466
#घोषणा PCI_DEVICE_ID_AMD_17H_M10H_DF_F0 0x15e8
#घोषणा PCI_DEVICE_ID_AMD_17H_M10H_DF_F6 0x15ee
#घोषणा PCI_DEVICE_ID_AMD_17H_M30H_DF_F0 0x1490
#घोषणा PCI_DEVICE_ID_AMD_17H_M30H_DF_F6 0x1496
#घोषणा PCI_DEVICE_ID_AMD_17H_M60H_DF_F0 0x1448
#घोषणा PCI_DEVICE_ID_AMD_17H_M60H_DF_F6 0x144e
#घोषणा PCI_DEVICE_ID_AMD_17H_M70H_DF_F0 0x1440
#घोषणा PCI_DEVICE_ID_AMD_17H_M70H_DF_F6 0x1446
#घोषणा PCI_DEVICE_ID_AMD_19H_DF_F0	0x1650
#घोषणा PCI_DEVICE_ID_AMD_19H_DF_F6	0x1656

/*
 * Function 1 - Address Map
 */
#घोषणा DRAM_BASE_LO			0x40
#घोषणा DRAM_LIMIT_LO			0x44

/*
 * F15 M30h D18F1x2[1C:00]
 */
#घोषणा DRAM_CONT_BASE			0x200
#घोषणा DRAM_CONT_LIMIT			0x204

/*
 * F15 M30h D18F1x2[4C:40]
 */
#घोषणा DRAM_CONT_HIGH_OFF		0x240

#घोषणा dram_rw(pvt, i)			((u8)(pvt->ranges[i].base.lo & 0x3))
#घोषणा dram_पूर्णांकlv_sel(pvt, i)		((u8)((pvt->ranges[i].lim.lo >> 8) & 0x7))
#घोषणा dram_dst_node(pvt, i)		((u8)(pvt->ranges[i].lim.lo & 0x7))

#घोषणा DHAR				0xf0
#घोषणा dhar_mem_hoist_valid(pvt)	((pvt)->dhar & BIT(1))
#घोषणा dhar_base(pvt)			((pvt)->dhar & 0xff000000)
#घोषणा k8_dhar_offset(pvt)		(((pvt)->dhar & 0x0000ff00) << 16)

					/* NOTE: Extra mask bit vs K8 */
#घोषणा f10_dhar_offset(pvt)		(((pvt)->dhar & 0x0000ff80) << 16)

#घोषणा DCT_CFG_SEL			0x10C

#घोषणा DRAM_LOCAL_NODE_BASE		0x120
#घोषणा DRAM_LOCAL_NODE_LIM		0x124

#घोषणा DRAM_BASE_HI			0x140
#घोषणा DRAM_LIMIT_HI			0x144


/*
 * Function 2 - DRAM controller
 */
#घोषणा DCSB0				0x40
#घोषणा DCSB1				0x140
#घोषणा DCSB_CS_ENABLE			BIT(0)

#घोषणा DCSM0				0x60
#घोषणा DCSM1				0x160

#घोषणा csrow_enabled(i, dct, pvt)	((pvt)->csels[(dct)].csbases[(i)]     & DCSB_CS_ENABLE)
#घोषणा csrow_sec_enabled(i, dct, pvt)	((pvt)->csels[(dct)].csbases_sec[(i)] & DCSB_CS_ENABLE)

#घोषणा DRAM_CONTROL			0x78

#घोषणा DBAM0				0x80
#घोषणा DBAM1				0x180

/* Extract the DIMM 'type' on the i'th DIMM from the DBAM reg value passed */
#घोषणा DBAM_DIMM(i, reg)		((((reg) >> (4*(i)))) & 0xF)

#घोषणा DBAM_MAX_VALUE			11

#घोषणा DCLR0				0x90
#घोषणा DCLR1				0x190
#घोषणा REVE_WIDTH_128			BIT(16)
#घोषणा WIDTH_128			BIT(11)

#घोषणा DCHR0				0x94
#घोषणा DCHR1				0x194
#घोषणा DDR3_MODE			BIT(8)

#घोषणा DCT_SEL_LO			0x110
#घोषणा dct_high_range_enabled(pvt)	((pvt)->dct_sel_lo & BIT(0))
#घोषणा dct_पूर्णांकerleave_enabled(pvt)	((pvt)->dct_sel_lo & BIT(2))

#घोषणा dct_ganging_enabled(pvt)	((boot_cpu_data.x86 == 0x10) && ((pvt)->dct_sel_lo & BIT(4)))

#घोषणा dct_data_पूर्णांकlv_enabled(pvt)	((pvt)->dct_sel_lo & BIT(5))
#घोषणा dct_memory_cleared(pvt)		((pvt)->dct_sel_lo & BIT(10))

#घोषणा SWAP_INTLV_REG			0x10c

#घोषणा DCT_SEL_HI			0x114

#घोषणा F15H_M60H_SCRCTRL		0x1C8
#घोषणा F17H_SCR_BASE_ADDR		0x48
#घोषणा F17H_SCR_LIMIT_ADDR		0x4C

/*
 * Function 3 - Misc Control
 */
#घोषणा NBCTL				0x40

#घोषणा NBCFG				0x44
#घोषणा NBCFG_CHIPKILL			BIT(23)
#घोषणा NBCFG_ECC_ENABLE		BIT(22)

/* F3x48: NBSL */
#घोषणा F10_NBSL_EXT_ERR_ECC		0x8
#घोषणा NBSL_PP_OBS			0x2

#घोषणा SCRCTRL				0x58

#घोषणा F10_ONLINE_SPARE		0xB0
#घोषणा online_spare_swap_करोne(pvt, c)	(((pvt)->online_spare >> (1 + 2 * (c))) & 0x1)
#घोषणा online_spare_bad_dramcs(pvt, c)	(((pvt)->online_spare >> (4 + 4 * (c))) & 0x7)

#घोषणा F10_NB_ARRAY_ADDR		0xB8
#घोषणा F10_NB_ARRAY_DRAM		BIT(31)

/* Bits [2:1] are used to select 16-byte section within a 64-byte cacheline  */
#घोषणा SET_NB_ARRAY_ADDR(section)	(((section) & 0x3) << 1)

#घोषणा F10_NB_ARRAY_DATA		0xBC
#घोषणा F10_NB_ARR_ECC_WR_REQ		BIT(17)
#घोषणा SET_NB_DRAM_INJECTION_WRITE(inj)  \
					(BIT(((inj.word) & 0xF) + 20) | \
					F10_NB_ARR_ECC_WR_REQ | inj.bit_map)
#घोषणा SET_NB_DRAM_INJECTION_READ(inj)  \
					(BIT(((inj.word) & 0xF) + 20) | \
					BIT(16) |  inj.bit_map)


#घोषणा NBCAP				0xE8
#घोषणा NBCAP_CHIPKILL			BIT(4)
#घोषणा NBCAP_SECDED			BIT(3)
#घोषणा NBCAP_DCT_DUAL			BIT(0)

#घोषणा EXT_NB_MCA_CFG			0x180

/* MSRs */
#घोषणा MSR_MCGCTL_NBE			BIT(4)

/* F17h */

/* F0: */
#घोषणा DF_DHAR				0x104

/* UMC CH रेजिस्टर offsets */
#घोषणा UMCCH_BASE_ADDR			0x0
#घोषणा UMCCH_BASE_ADDR_SEC		0x10
#घोषणा UMCCH_ADDR_MASK			0x20
#घोषणा UMCCH_ADDR_MASK_SEC		0x28
#घोषणा UMCCH_ADDR_CFG			0x30
#घोषणा UMCCH_DIMM_CFG			0x80
#घोषणा UMCCH_UMC_CFG			0x100
#घोषणा UMCCH_SDP_CTRL			0x104
#घोषणा UMCCH_ECC_CTRL			0x14C
#घोषणा UMCCH_ECC_BAD_SYMBOL		0xD90
#घोषणा UMCCH_UMC_CAP			0xDF0
#घोषणा UMCCH_UMC_CAP_HI		0xDF4

/* UMC CH bitfields */
#घोषणा UMC_ECC_CHIPKILL_CAP		BIT(31)
#घोषणा UMC_ECC_ENABLED			BIT(30)

#घोषणा UMC_SDP_INIT			BIT(31)

क्रमागत amd_families अणु
	K8_CPUS = 0,
	F10_CPUS,
	F15_CPUS,
	F15_M30H_CPUS,
	F15_M60H_CPUS,
	F16_CPUS,
	F16_M30H_CPUS,
	F17_CPUS,
	F17_M10H_CPUS,
	F17_M30H_CPUS,
	F17_M60H_CPUS,
	F17_M70H_CPUS,
	F19_CPUS,
	NUM_FAMILIES,
पूर्ण;

/* Error injection control काष्ठाure */
काष्ठा error_injection अणु
	u32	 section;
	u32	 word;
	u32	 bit_map;
पूर्ण;

/* low and high part of PCI config space regs */
काष्ठा reg_pair अणु
	u32 lo, hi;
पूर्ण;

/*
 * See F1x[1, 0][7C:40] DRAM Base/Limit Registers
 */
काष्ठा dram_range अणु
	काष्ठा reg_pair base;
	काष्ठा reg_pair lim;
पूर्ण;

/* A DCT chip selects collection */
काष्ठा chip_select अणु
	u32 csbases[NUM_CHIPSELECTS];
	u32 csbases_sec[NUM_CHIPSELECTS];
	u8 b_cnt;

	u32 csmasks[NUM_CHIPSELECTS];
	u32 csmasks_sec[NUM_CHIPSELECTS];
	u8 m_cnt;
पूर्ण;

काष्ठा amd64_umc अणु
	u32 dimm_cfg;		/* DIMM Configuration reg */
	u32 umc_cfg;		/* Configuration reg */
	u32 sdp_ctrl;		/* SDP Control reg */
	u32 ecc_ctrl;		/* DRAM ECC Control reg */
	u32 umc_cap_hi;		/* Capabilities High reg */
पूर्ण;

काष्ठा amd64_pvt अणु
	काष्ठा low_ops *ops;

	/* pci_device handles which we utilize */
	काष्ठा pci_dev *F0, *F1, *F2, *F3, *F6;

	u16 mc_node_id;		/* MC index of this MC node */
	u8 fam;			/* CPU family */
	u8 model;		/* ... model */
	u8 stepping;		/* ... stepping */

	पूर्णांक ext_model;		/* extended model value of this node */
	पूर्णांक channel_count;

	/* Raw रेजिस्टरs */
	u32 dclr0;		/* DRAM Configuration Low DCT0 reg */
	u32 dclr1;		/* DRAM Configuration Low DCT1 reg */
	u32 dchr0;		/* DRAM Configuration High DCT0 reg */
	u32 dchr1;		/* DRAM Configuration High DCT1 reg */
	u32 nbcap;		/* North Bridge Capabilities */
	u32 nbcfg;		/* F10 North Bridge Configuration */
	u32 ext_nbcfg;		/* Extended F10 North Bridge Configuration */
	u32 dhar;		/* DRAM Hoist reg */
	u32 dbam0;		/* DRAM Base Address Mapping reg क्रम DCT0 */
	u32 dbam1;		/* DRAM Base Address Mapping reg क्रम DCT1 */

	/* one क्रम each DCT/UMC */
	काष्ठा chip_select csels[NUM_CONTROLLERS];

	/* DRAM base and limit pairs F1x[78,70,68,60,58,50,48,40] */
	काष्ठा dram_range ranges[DRAM_RANGES];

	u64 top_mem;		/* top of memory below 4GB */
	u64 top_mem2;		/* top of memory above 4GB */

	u32 dct_sel_lo;		/* DRAM Controller Select Low */
	u32 dct_sel_hi;		/* DRAM Controller Select High */
	u32 online_spare;	/* On-Line spare Reg */

	/* x4, x8, or x16 syndromes in use */
	u8 ecc_sym_sz;

	/* place to store error injection parameters prior to issue */
	काष्ठा error_injection injection;

	/* cache the dram_type */
	क्रमागत mem_type dram_type;

	काष्ठा amd64_umc *umc;	/* UMC रेजिस्टरs */
पूर्ण;

क्रमागत err_codes अणु
	DECODE_OK	=  0,
	ERR_NODE	= -1,
	ERR_CSROW	= -2,
	ERR_CHANNEL	= -3,
	ERR_SYND	= -4,
	ERR_NORM_ADDR	= -5,
पूर्ण;

काष्ठा err_info अणु
	पूर्णांक err_code;
	काष्ठा mem_ctl_info *src_mci;
	पूर्णांक csrow;
	पूर्णांक channel;
	u16 syndrome;
	u32 page;
	u32 offset;
पूर्ण;

अटल अंतरभूत u32 get_umc_base(u8 channel)
अणु
	/* chY: 0xY50000 */
	वापस 0x50000 + (channel << 20);
पूर्ण

अटल अंतरभूत u64 get_dram_base(काष्ठा amd64_pvt *pvt, u8 i)
अणु
	u64 addr = ((u64)pvt->ranges[i].base.lo & 0xffff0000) << 8;

	अगर (boot_cpu_data.x86 == 0xf)
		वापस addr;

	वापस (((u64)pvt->ranges[i].base.hi & 0x000000ff) << 40) | addr;
पूर्ण

अटल अंतरभूत u64 get_dram_limit(काष्ठा amd64_pvt *pvt, u8 i)
अणु
	u64 lim = (((u64)pvt->ranges[i].lim.lo & 0xffff0000) << 8) | 0x00ffffff;

	अगर (boot_cpu_data.x86 == 0xf)
		वापस lim;

	वापस (((u64)pvt->ranges[i].lim.hi & 0x000000ff) << 40) | lim;
पूर्ण

अटल अंतरभूत u16 extract_syndrome(u64 status)
अणु
	वापस ((status >> 47) & 0xff) | ((status >> 16) & 0xff00);
पूर्ण

अटल अंतरभूत u8 dct_sel_पूर्णांकerleave_addr(काष्ठा amd64_pvt *pvt)
अणु
	अगर (pvt->fam == 0x15 && pvt->model >= 0x30)
		वापस (((pvt->dct_sel_hi >> 9) & 0x1) << 2) |
			((pvt->dct_sel_lo >> 6) & 0x3);

	वापस	((pvt)->dct_sel_lo >> 6) & 0x3;
पूर्ण
/*
 * per-node ECC settings descriptor
 */
काष्ठा ecc_settings अणु
	u32 old_nbctl;
	bool nbctl_valid;

	काष्ठा flags अणु
		अचिन्हित दीर्घ nb_mce_enable:1;
		अचिन्हित दीर्घ nb_ecc_prev:1;
	पूर्ण flags;
पूर्ण;

/*
 * Each of the PCI Device IDs types have their own set of hardware accessor
 * functions and per device encoding/decoding logic.
 */
काष्ठा low_ops अणु
	पूर्णांक (*early_channel_count)	(काष्ठा amd64_pvt *pvt);
	व्योम (*map_sysaddr_to_csrow)	(काष्ठा mem_ctl_info *mci, u64 sys_addr,
					 काष्ठा err_info *);
	पूर्णांक (*dbam_to_cs)		(काष्ठा amd64_pvt *pvt, u8 dct,
					 अचिन्हित cs_mode, पूर्णांक cs_mask_nr);
पूर्ण;

काष्ठा amd64_family_type अणु
	स्थिर अक्षर *ctl_name;
	u16 f0_id, f1_id, f2_id, f6_id;
	/* Maximum number of memory controllers per die/node. */
	u8 max_mcs;
	काष्ठा low_ops ops;
पूर्ण;

पूर्णांक __amd64_पढ़ो_pci_cfg_dword(काष्ठा pci_dev *pdev, पूर्णांक offset,
			       u32 *val, स्थिर अक्षर *func);
पूर्णांक __amd64_ग_लिखो_pci_cfg_dword(काष्ठा pci_dev *pdev, पूर्णांक offset,
				u32 val, स्थिर अक्षर *func);

#घोषणा amd64_पढ़ो_pci_cfg(pdev, offset, val)	\
	__amd64_पढ़ो_pci_cfg_dword(pdev, offset, val, __func__)

#घोषणा amd64_ग_लिखो_pci_cfg(pdev, offset, val)	\
	__amd64_ग_लिखो_pci_cfg_dword(pdev, offset, val, __func__)

#घोषणा to_mci(k) container_of(k, काष्ठा mem_ctl_info, dev)

/* Injection helpers */
अटल अंतरभूत व्योम disable_caches(व्योम *dummy)
अणु
	ग_लिखो_cr0(पढ़ो_cr0() | X86_CR0_CD);
	wbinvd();
पूर्ण

अटल अंतरभूत व्योम enable_caches(व्योम *dummy)
अणु
	ग_लिखो_cr0(पढ़ो_cr0() & ~X86_CR0_CD);
पूर्ण

अटल अंतरभूत u8 dram_पूर्णांकlv_en(काष्ठा amd64_pvt *pvt, अचिन्हित पूर्णांक i)
अणु
	अगर (pvt->fam == 0x15 && pvt->model >= 0x30) अणु
		u32 पंचांगp;
		amd64_पढ़ो_pci_cfg(pvt->F1, DRAM_CONT_LIMIT, &पंचांगp);
		वापस (u8) पंचांगp & 0xF;
	पूर्ण
	वापस (u8) (pvt->ranges[i].base.lo >> 8) & 0x7;
पूर्ण

अटल अंतरभूत u8 dhar_valid(काष्ठा amd64_pvt *pvt)
अणु
	अगर (pvt->fam == 0x15 && pvt->model >= 0x30) अणु
		u32 पंचांगp;
		amd64_पढ़ो_pci_cfg(pvt->F1, DRAM_CONT_BASE, &पंचांगp);
		वापस (पंचांगp >> 1) & BIT(0);
	पूर्ण
	वापस (pvt)->dhar & BIT(0);
पूर्ण

अटल अंतरभूत u32 dct_sel_baseaddr(काष्ठा amd64_pvt *pvt)
अणु
	अगर (pvt->fam == 0x15 && pvt->model >= 0x30) अणु
		u32 पंचांगp;
		amd64_पढ़ो_pci_cfg(pvt->F1, DRAM_CONT_BASE, &पंचांगp);
		वापस (पंचांगp >> 11) & 0x1FFF;
	पूर्ण
	वापस (pvt)->dct_sel_lo & 0xFFFFF800;
पूर्ण
