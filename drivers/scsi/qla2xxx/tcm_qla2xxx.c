<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*******************************************************************************
 * This file contains tcm implementation using v4 configfs fabric infraकाष्ठाure
 * क्रम QLogic target mode HBAs
 *
 * (c) Copyright 2010-2013 Datera, Inc.
 *
 * Author: Nicholas A. Bellinger <nab@daterainc.com>
 *
 * tcm_qla2xxx_parse_wwn() and tcm_qla2xxx_क्रमmat_wwn() contains code from
 * the TCM_FC / Open-FCoE.org fabric module.
 *
 * Copyright (c) 2010 Cisco Systems, Inc
 *
 ****************************************************************************/


#समावेश <linux/module.h>
#समावेश <linux/utsname.h>
#समावेश <linux/vदो_स्मृति.h>
#समावेश <linux/list.h>
#समावेश <linux/slab.h>
#समावेश <linux/types.h>
#समावेश <linux/माला.स>
#समावेश <linux/configfs.h>
#समावेश <linux/प्रकार.स>
#समावेश <यंत्र/unaligned.h>
#समावेश <scsi/scsi_host.h>
#समावेश <target/target_core_base.h>
#समावेश <target/target_core_fabric.h>

#समावेश "qla_def.h"
#समावेश "qla_target.h"
#समावेश "tcm_qla2xxx.h"

अटल काष्ठा workqueue_काष्ठा *tcm_qla2xxx_मुक्त_wq;

/*
 * Parse WWN.
 * If strict, we require lower-हाल hex and colon separators to be sure
 * the name is the same as what would be generated by ft_क्रमmat_wwn()
 * so the name and wwn are mapped one-to-one.
 */
अटल sमाप_प्रकार tcm_qla2xxx_parse_wwn(स्थिर अक्षर *name, u64 *wwn, पूर्णांक strict)
अणु
	स्थिर अक्षर *cp;
	अक्षर c;
	u32 nibble;
	u32 byte = 0;
	u32 pos = 0;
	u32 err;

	*wwn = 0;
	क्रम (cp = name; cp < &name[TCM_QLA2XXX_NAMELEN - 1]; cp++) अणु
		c = *cp;
		अगर (c == '\n' && cp[1] == '\0')
			जारी;
		अगर (strict && pos++ == 2 && byte++ < 7) अणु
			pos = 0;
			अगर (c == ':')
				जारी;
			err = 1;
			जाओ fail;
		पूर्ण
		अगर (c == '\0') अणु
			err = 2;
			अगर (strict && byte != 8)
				जाओ fail;
			वापस cp - name;
		पूर्ण
		err = 3;
		अगर (है_अंक(c))
			nibble = c - '0';
		अन्यथा अगर (है_षष्ठादशक(c) && (है_छोटा(c) || !strict))
			nibble = छोटे(c) - 'a' + 10;
		अन्यथा
			जाओ fail;
		*wwn = (*wwn << 4) | nibble;
	पूर्ण
	err = 4;
fail:
	pr_debug("err %u len %zu pos %u byte %u\n",
			err, cp - name, pos, byte);
	वापस -1;
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_क्रमmat_wwn(अक्षर *buf, माप_प्रकार len, u64 wwn)
अणु
	u8 b[8];

	put_unaligned_be64(wwn, b);
	वापस snम_लिखो(buf, len,
		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",
		b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
पूर्ण

/*
 * From drivers/scsi/scsi_transport_fc.c:fc_parse_wwn
 */
अटल पूर्णांक tcm_qla2xxx_npiv_extract_wwn(स्थिर अक्षर *ns, u64 *nm)
अणु
	अचिन्हित पूर्णांक i, j;
	u8 wwn[8];

	स_रखो(wwn, 0, माप(wwn));

	/* Validate and store the new name */
	क्रम (i = 0, j = 0; i < 16; i++) अणु
		पूर्णांक value;

		value = hex_to_bin(*ns++);
		अगर (value >= 0)
			j = (j << 4) | value;
		अन्यथा
			वापस -EINVAL;

		अगर (i % 2) अणु
			wwn[i/2] = j & 0xff;
			j = 0;
		पूर्ण
	पूर्ण

	*nm = wwn_to_u64(wwn);
	वापस 0;
पूर्ण

/*
 * This parsing logic follows drivers/scsi/scsi_transport_fc.c:
 * store_fc_host_vport_create()
 */
अटल पूर्णांक tcm_qla2xxx_npiv_parse_wwn(
	स्थिर अक्षर *name,
	माप_प्रकार count,
	u64 *wwpn,
	u64 *wwnn)
अणु
	अचिन्हित पूर्णांक cnt = count;
	पूर्णांक rc;

	*wwpn = 0;
	*wwnn = 0;

	/* count may include a LF at end of string */
	अगर (name[cnt-1] == '\n' || name[cnt-1] == 0)
		cnt--;

	/* validate we have enough अक्षरacters क्रम WWPN */
	अगर ((cnt != (16+1+16)) || (name[16] != ':'))
		वापस -EINVAL;

	rc = tcm_qla2xxx_npiv_extract_wwn(&name[0], wwpn);
	अगर (rc != 0)
		वापस rc;

	rc = tcm_qla2xxx_npiv_extract_wwn(&name[17], wwnn);
	अगर (rc != 0)
		वापस rc;

	वापस 0;
पूर्ण

अटल अक्षर *tcm_qla2xxx_get_fabric_wwn(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);
	काष्ठा tcm_qla2xxx_lport *lport = tpg->lport;

	वापस lport->lport_naa_name;
पूर्ण

अटल u16 tcm_qla2xxx_get_tag(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);
	वापस tpg->lport_tpgt;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_demo_mode(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.generate_node_acls;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_demo_mode_cache(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.cache_dynamic_acls;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_demo_ग_लिखो_protect(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.demo_mode_ग_लिखो_protect;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_prod_ग_लिखो_protect(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.prod_mode_ग_लिखो_protect;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_demo_mode_login_only(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.demo_mode_login_only;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_check_prot_fabric_only(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->tpg_attrib.fabric_prot_type;
पूर्ण

अटल u32 tcm_qla2xxx_tpg_get_inst_index(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस tpg->lport_tpgt;
पूर्ण

अटल व्योम tcm_qla2xxx_complete_mcmd(काष्ठा work_काष्ठा *work)
अणु
	काष्ठा qla_tgt_mgmt_cmd *mcmd = container_of(work,
			काष्ठा qla_tgt_mgmt_cmd, मुक्त_work);

	transport_generic_मुक्त_cmd(&mcmd->se_cmd, 0);
पूर्ण

/*
 * Called from qla_target_ढाँचा->मुक्त_mcmd(), and will call
 * tcm_qla2xxx_release_cmd() via normal काष्ठा target_core_fabric_ops
 * release callback.  qla_hw_data->hardware_lock is expected to be held
 */
अटल व्योम tcm_qla2xxx_मुक्त_mcmd(काष्ठा qla_tgt_mgmt_cmd *mcmd)
अणु
	अगर (!mcmd)
		वापस;
	INIT_WORK(&mcmd->मुक्त_work, tcm_qla2xxx_complete_mcmd);
	queue_work(tcm_qla2xxx_मुक्त_wq, &mcmd->मुक्त_work);
पूर्ण

अटल व्योम tcm_qla2xxx_complete_मुक्त(काष्ठा work_काष्ठा *work)
अणु
	काष्ठा qla_tgt_cmd *cmd = container_of(work, काष्ठा qla_tgt_cmd, work);
	अचिन्हित दीर्घ flags;

	cmd->cmd_in_wq = 0;

	WARN_ON(cmd->trc_flags & TRC_CMD_FREE);

	/* To करो: protect all tgt_counters manipulations with proper locking. */
	cmd->qpair->tgt_counters.qla_core_ret_sta_ctio++;
	cmd->trc_flags |= TRC_CMD_FREE;
	cmd->cmd_sent_to_fw = 0;

	spin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);
	list_del_init(&cmd->sess_cmd_list);
	spin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);

	transport_generic_मुक्त_cmd(&cmd->se_cmd, 0);
पूर्ण

अटल काष्ठा qla_tgt_cmd *tcm_qla2xxx_get_cmd(काष्ठा fc_port *sess)
अणु
	काष्ठा se_session *se_sess = sess->se_sess;
	काष्ठा qla_tgt_cmd *cmd;
	पूर्णांक tag, cpu;

	tag = sbiपंचांगap_queue_get(&se_sess->sess_tag_pool, &cpu);
	अगर (tag < 0)
		वापस शून्य;

	cmd = &((काष्ठा qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
	स_रखो(cmd, 0, माप(काष्ठा qla_tgt_cmd));
	cmd->se_cmd.map_tag = tag;
	cmd->se_cmd.map_cpu = cpu;

	वापस cmd;
पूर्ण

अटल व्योम tcm_qla2xxx_rel_cmd(काष्ठा qla_tgt_cmd *cmd)
अणु
	target_मुक्त_tag(cmd->sess->se_sess, &cmd->se_cmd);
पूर्ण

/*
 * Called from qla_target_ढाँचा->मुक्त_cmd(), and will call
 * tcm_qla2xxx_release_cmd via normal काष्ठा target_core_fabric_ops
 * release callback.  qla_hw_data->hardware_lock is expected to be held
 */
अटल व्योम tcm_qla2xxx_मुक्त_cmd(काष्ठा qla_tgt_cmd *cmd)
अणु
	cmd->qpair->tgt_counters.core_qla_मुक्त_cmd++;
	cmd->cmd_in_wq = 1;

	WARN_ON(cmd->trc_flags & TRC_CMD_DONE);
	cmd->trc_flags |= TRC_CMD_DONE;

	INIT_WORK(&cmd->work, tcm_qla2xxx_complete_मुक्त);
	queue_work_on(smp_processor_id(), tcm_qla2xxx_मुक्त_wq, &cmd->work);
पूर्ण

/*
 * Called from काष्ठा target_core_fabric_ops->check_stop_मुक्त() context
 */
अटल पूर्णांक tcm_qla2xxx_check_stop_मुक्त(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd;

	अगर ((se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) == 0) अणु
		cmd = container_of(se_cmd, काष्ठा qla_tgt_cmd, se_cmd);
		cmd->trc_flags |= TRC_CMD_CHK_STOP;
	पूर्ण

	वापस target_put_sess_cmd(se_cmd);
पूर्ण

/* tcm_qla2xxx_release_cmd - Callback from TCM Core to release underlying
 * fabric descriptor @se_cmd command to release
 */
अटल व्योम tcm_qla2xxx_release_cmd(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd;

	अगर (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) अणु
		काष्ठा qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,
				काष्ठा qla_tgt_mgmt_cmd, se_cmd);
		qlt_मुक्त_mcmd(mcmd);
		वापस;
	पूर्ण
	cmd = container_of(se_cmd, काष्ठा qla_tgt_cmd, se_cmd);

	अगर (WARN_ON(cmd->cmd_sent_to_fw))
		वापस;

	qlt_मुक्त_cmd(cmd);
पूर्ण

अटल व्योम tcm_qla2xxx_release_session(काष्ठा kref *kref)
अणु
	काष्ठा fc_port  *sess = container_of(kref,
	    काष्ठा fc_port, sess_kref);

	qlt_unreg_sess(sess);
पूर्ण

अटल व्योम tcm_qla2xxx_put_sess(काष्ठा fc_port *sess)
अणु
	अगर (!sess)
		वापस;

	kref_put(&sess->sess_kref, tcm_qla2xxx_release_session);
पूर्ण

अटल व्योम tcm_qla2xxx_बंद_session(काष्ठा se_session *se_sess)
अणु
	काष्ठा fc_port *sess = se_sess->fabric_sess_ptr;

	BUG_ON(!sess);

	target_stop_session(se_sess);

	sess->explicit_logout = 1;
	tcm_qla2xxx_put_sess(sess);
पूर्ण

अटल u32 tcm_qla2xxx_sess_get_index(काष्ठा se_session *se_sess)
अणु
	वापस 0;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_ग_लिखो_pending(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd = container_of(se_cmd,
				काष्ठा qla_tgt_cmd, se_cmd);

	अगर (cmd->पातed) अणु
		/* Cmd can loop during Q-full.  tcm_qla2xxx_पातed_task
		 * can get ahead of this cmd. tcm_qla2xxx_पातed_task
		 * alपढ़ोy kick start the मुक्त.
		 */
		pr_debug("write_pending aborted cmd[%p] refcount %d "
			"transport_state %x, t_state %x, se_cmd_flags %x\n",
			cmd, kref_पढ़ो(&cmd->se_cmd.cmd_kref),
			cmd->se_cmd.transport_state,
			cmd->se_cmd.t_state,
			cmd->se_cmd.se_cmd_flags);
		transport_generic_request_failure(&cmd->se_cmd,
			TCM_CHECK_CONDITION_ABORT_CMD);
		वापस 0;
	पूर्ण
	cmd->trc_flags |= TRC_XFR_RDY;
	cmd->bufflen = se_cmd->data_length;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);

	cmd->sg_cnt = se_cmd->t_data_nents;
	cmd->sg = se_cmd->t_data_sg;

	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
	cmd->prot_sg = se_cmd->t_prot_sg;
	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
	se_cmd->pi_err = 0;

	/*
	 * qla_target.c:qlt_rdy_to_xfer() will call dma_map_sg() to setup
	 * the SGL mappings पूर्णांकo PCIe memory क्रम incoming FCP WRITE data.
	 */
	वापस qlt_rdy_to_xfer(cmd);
पूर्ण

अटल व्योम tcm_qla2xxx_set_शेष_node_attrs(काष्ठा se_node_acl *nacl)
अणु
	वापस;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_get_cmd_state(काष्ठा se_cmd *se_cmd)
अणु
	अगर (!(se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) अणु
		काष्ठा qla_tgt_cmd *cmd = container_of(se_cmd,
				काष्ठा qla_tgt_cmd, se_cmd);
		वापस cmd->state;
	पूर्ण

	वापस 0;
पूर्ण

/*
 * Called from process context in qla_target.c:qlt_करो_work() code
 */
अटल पूर्णांक tcm_qla2xxx_handle_cmd(scsi_qla_host_t *vha, काष्ठा qla_tgt_cmd *cmd,
	अचिन्हित अक्षर *cdb, uपूर्णांक32_t data_length, पूर्णांक fcp_task_attr,
	पूर्णांक data_dir, पूर्णांक bidi)
अणु
	काष्ठा se_cmd *se_cmd = &cmd->se_cmd;
	काष्ठा se_session *se_sess;
	काष्ठा fc_port *sess;
#अगर_घोषित CONFIG_TCM_QLA2XXX_DEBUG
	काष्ठा se_portal_group *se_tpg;
	काष्ठा tcm_qla2xxx_tpg *tpg;
#पूर्ण_अगर
	पूर्णांक rc, target_flags = TARGET_SCF_ACK_KREF;
	अचिन्हित दीर्घ flags;

	अगर (bidi)
		target_flags |= TARGET_SCF_BIDI_OP;

	अगर (se_cmd->cpuid != WORK_CPU_UNBOUND)
		target_flags |= TARGET_SCF_USE_CPUID;

	sess = cmd->sess;
	अगर (!sess) अणु
		pr_err("Unable to locate struct fc_port from qla_tgt_cmd\n");
		वापस -EINVAL;
	पूर्ण

	se_sess = sess->se_sess;
	अगर (!se_sess) अणु
		pr_err("Unable to locate active struct se_session\n");
		वापस -EINVAL;
	पूर्ण

#अगर_घोषित CONFIG_TCM_QLA2XXX_DEBUG
	se_tpg = se_sess->se_tpg;
	tpg = container_of(se_tpg, काष्ठा tcm_qla2xxx_tpg, se_tpg);
	अगर (unlikely(tpg->tpg_attrib.jam_host)) अणु
		/* वापस, and करोnt run target_submit_cmd,discarding command */
		वापस 0;
	पूर्ण
#पूर्ण_अगर
	cmd->qpair->tgt_counters.qla_core_sbt_cmd++;

	spin_lock_irqsave(&sess->sess_cmd_lock, flags);
	list_add_tail(&cmd->sess_cmd_list, &sess->sess_cmd_list);
	spin_unlock_irqrestore(&sess->sess_cmd_lock, flags);

	rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
			     cmd->unpacked_lun, data_length, fcp_task_attr,
			     data_dir, target_flags);
	अगर (rc)
		वापस rc;

	अगर (target_submit_prep(se_cmd, cdb, शून्य, 0, शून्य, 0, शून्य, 0,
			       GFP_KERNEL))
		वापस 0;

	target_submit(se_cmd);
	वापस 0;
पूर्ण

अटल व्योम tcm_qla2xxx_handle_data_work(काष्ठा work_काष्ठा *work)
अणु
	काष्ठा qla_tgt_cmd *cmd = container_of(work, काष्ठा qla_tgt_cmd, work);

	/*
	 * Ensure that the complete FCP WRITE payload has been received.
	 * Otherwise वापस an exception via CHECK_CONDITION status.
	 */
	cmd->cmd_in_wq = 0;
	cmd->cmd_sent_to_fw = 0;
	अगर (cmd->पातed) अणु
		transport_generic_request_failure(&cmd->se_cmd,
			TCM_CHECK_CONDITION_ABORT_CMD);
		वापस;
	पूर्ण

	cmd->qpair->tgt_counters.qla_core_ret_ctio++;
	अगर (!cmd->ग_लिखो_data_transferred) अणु
		चयन (cmd->dअगर_err_code) अणु
		हाल DIF_ERR_GRD:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
			अवरोध;
		हाल DIF_ERR_REF:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
			अवरोध;
		हाल DIF_ERR_APP:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;
			अवरोध;
		हाल DIF_ERR_NONE:
		शेष:
			अवरोध;
		पूर्ण

		अगर (cmd->se_cmd.pi_err)
			transport_generic_request_failure(&cmd->se_cmd,
				cmd->se_cmd.pi_err);
		अन्यथा
			transport_generic_request_failure(&cmd->se_cmd,
				TCM_CHECK_CONDITION_ABORT_CMD);

		वापस;
	पूर्ण

	वापस target_execute_cmd(&cmd->se_cmd);
पूर्ण

/*
 * Called from qla_target.c:qlt_करो_ctio_completion()
 */
अटल व्योम tcm_qla2xxx_handle_data(काष्ठा qla_tgt_cmd *cmd)
अणु
	cmd->trc_flags |= TRC_DATA_IN;
	cmd->cmd_in_wq = 1;
	INIT_WORK(&cmd->work, tcm_qla2xxx_handle_data_work);
	queue_work_on(smp_processor_id(), tcm_qla2xxx_मुक्त_wq, &cmd->work);
पूर्ण

अटल पूर्णांक tcm_qla2xxx_chk_dअगर_tags(uपूर्णांक32_t tag)
अणु
	वापस 0;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_dअगर_tags(काष्ठा qla_tgt_cmd *cmd,
    uपूर्णांक16_t *pfw_prot_opts)
अणु
	काष्ठा se_cmd *se_cmd = &cmd->se_cmd;

	अगर (!(se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD))
		*pfw_prot_opts |= PO_DISABLE_GUARD_CHECK;

	अगर (!(se_cmd->prot_checks & TARGET_DIF_CHECK_APPTAG))
		*pfw_prot_opts |= PO_DIS_APP_TAG_VALD;

	वापस 0;
पूर्ण

/*
 * Called from qla_target.c:qlt_issue_task_mgmt()
 */
अटल पूर्णांक tcm_qla2xxx_handle_पंचांगr(काष्ठा qla_tgt_mgmt_cmd *mcmd, u64 lun,
	uपूर्णांक16_t पंचांगr_func, uपूर्णांक32_t tag)
अणु
	काष्ठा fc_port *sess = mcmd->sess;
	काष्ठा se_cmd *se_cmd = &mcmd->se_cmd;
	पूर्णांक transl_पंचांगr_func = 0;

	चयन (पंचांगr_func) अणु
	हाल QLA_TGT_ABTS:
		pr_debug("%ld: ABTS received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_ABORT_TASK;
		अवरोध;
	हाल QLA_TGT_2G_ABORT_TASK:
		pr_debug("%ld: 2G Abort Task received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_ABORT_TASK;
		अवरोध;
	हाल QLA_TGT_CLEAR_ACA:
		pr_debug("%ld: CLEAR_ACA received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_CLEAR_ACA;
		अवरोध;
	हाल QLA_TGT_TARGET_RESET:
		pr_debug("%ld: TARGET_RESET received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_TARGET_WARM_RESET;
		अवरोध;
	हाल QLA_TGT_LUN_RESET:
		pr_debug("%ld: LUN_RESET received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_LUN_RESET;
		अवरोध;
	हाल QLA_TGT_CLEAR_TS:
		pr_debug("%ld: CLEAR_TS received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_CLEAR_TASK_SET;
		अवरोध;
	हाल QLA_TGT_ABORT_TS:
		pr_debug("%ld: ABORT_TS received\n", sess->vha->host_no);
		transl_पंचांगr_func = TMR_ABORT_TASK_SET;
		अवरोध;
	शेष:
		pr_debug("%ld: Unknown task mgmt fn 0x%x\n",
		    sess->vha->host_no, पंचांगr_func);
		वापस -ENOSYS;
	पूर्ण

	वापस target_submit_पंचांगr(se_cmd, sess->se_sess, शून्य, lun, mcmd,
	    transl_पंचांगr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
पूर्ण

अटल काष्ठा qla_tgt_cmd *tcm_qla2xxx_find_cmd_by_tag(काष्ठा fc_port *sess,
    uपूर्णांक64_t tag)
अणु
	काष्ठा qla_tgt_cmd *cmd;
	अचिन्हित दीर्घ flags;

	अगर (!sess->se_sess)
		वापस शून्य;

	spin_lock_irqsave(&sess->sess_cmd_lock, flags);
	list_क्रम_each_entry(cmd, &sess->sess_cmd_list, sess_cmd_list) अणु
		अगर (cmd->se_cmd.tag == tag)
			जाओ करोne;
	पूर्ण
	cmd = शून्य;
करोne:
	spin_unlock_irqrestore(&sess->sess_cmd_lock, flags);

	वापस cmd;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_queue_data_in(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd = container_of(se_cmd,
				काष्ठा qla_tgt_cmd, se_cmd);

	अगर (cmd->पातed) अणु
		/* Cmd can loop during Q-full.  tcm_qla2xxx_पातed_task
		 * can get ahead of this cmd. tcm_qla2xxx_पातed_task
		 * alपढ़ोy kick start the मुक्त.
		 */
		pr_debug("queue_data_in aborted cmd[%p] refcount %d "
			"transport_state %x, t_state %x, se_cmd_flags %x\n",
			cmd, kref_पढ़ो(&cmd->se_cmd.cmd_kref),
			cmd->se_cmd.transport_state,
			cmd->se_cmd.t_state,
			cmd->se_cmd.se_cmd_flags);
		वापस 0;
	पूर्ण

	cmd->trc_flags |= TRC_XMIT_DATA;
	cmd->bufflen = se_cmd->data_length;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);

	cmd->sg_cnt = se_cmd->t_data_nents;
	cmd->sg = se_cmd->t_data_sg;
	cmd->offset = 0;

	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
	cmd->prot_sg = se_cmd->t_prot_sg;
	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
	se_cmd->pi_err = 0;

	/*
	 * Now queue completed DATA_IN the qla2xxx LLD and response ring
	 */
	वापस qlt_xmit_response(cmd, QLA_TGT_XMIT_DATA|QLA_TGT_XMIT_STATUS,
				se_cmd->scsi_status);
पूर्ण

अटल पूर्णांक tcm_qla2xxx_queue_status(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd = container_of(se_cmd,
				काष्ठा qla_tgt_cmd, se_cmd);
	पूर्णांक xmit_type = QLA_TGT_XMIT_STATUS;

	अगर (cmd->पातed) अणु
		/*
		 * Cmd can loop during Q-full. tcm_qla2xxx_पातed_task
		 * can get ahead of this cmd. tcm_qla2xxx_पातed_task
		 * alपढ़ोy kick start the मुक्त.
		 */
		pr_debug(
		    "queue_data_in aborted cmd[%p] refcount %d transport_state %x, t_state %x, se_cmd_flags %x\n",
		    cmd, kref_पढ़ो(&cmd->se_cmd.cmd_kref),
		    cmd->se_cmd.transport_state, cmd->se_cmd.t_state,
		    cmd->se_cmd.se_cmd_flags);
		वापस 0;
	पूर्ण
	cmd->bufflen = se_cmd->data_length;
	cmd->sg = शून्य;
	cmd->sg_cnt = 0;
	cmd->offset = 0;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
	cmd->trc_flags |= TRC_XMIT_STATUS;

	अगर (se_cmd->data_direction == DMA_FROM_DEVICE) अणु
		/*
		 * For FCP_READ with CHECK_CONDITION status, clear cmd->bufflen
		 * क्रम qla_tgt_xmit_response LLD code
		 */
		अगर (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) अणु
			se_cmd->se_cmd_flags &= ~SCF_OVERFLOW_BIT;
			se_cmd->residual_count = 0;
		पूर्ण
		se_cmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;
		se_cmd->residual_count += se_cmd->data_length;

		cmd->bufflen = 0;
	पूर्ण
	/*
	 * Now queue status response to qla2xxx LLD code and response ring
	 */
	वापस qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);
पूर्ण

अटल व्योम tcm_qla2xxx_queue_पंचांग_rsp(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा se_पंचांगr_req *se_पंचांगr = se_cmd->se_पंचांगr_req;
	काष्ठा qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,
				काष्ठा qla_tgt_mgmt_cmd, se_cmd);

	pr_debug("queue_tm_rsp: mcmd: %p func: 0x%02x response: 0x%02x\n",
			mcmd, se_पंचांगr->function, se_पंचांगr->response);
	/*
	 * Do translation between TCM TM response codes and
	 * QLA2xxx FC TM response codes.
	 */
	चयन (se_पंचांगr->response) अणु
	हाल TMR_FUNCTION_COMPLETE:
		mcmd->fc_पंचांग_rsp = FC_TM_SUCCESS;
		अवरोध;
	हाल TMR_TASK_DOES_NOT_EXIST:
		mcmd->fc_पंचांग_rsp = FC_TM_BAD_CMD;
		अवरोध;
	हाल TMR_FUNCTION_REJECTED:
		mcmd->fc_पंचांग_rsp = FC_TM_REJECT;
		अवरोध;
	हाल TMR_LUN_DOES_NOT_EXIST:
	शेष:
		mcmd->fc_पंचांग_rsp = FC_TM_FAILED;
		अवरोध;
	पूर्ण
	/*
	 * Queue the TM response to QLA2xxx LLD to build a
	 * CTIO response packet.
	 */
	qlt_xmit_पंचांग_rsp(mcmd);
पूर्ण

अटल व्योम tcm_qla2xxx_पातed_task(काष्ठा se_cmd *se_cmd)
अणु
	काष्ठा qla_tgt_cmd *cmd;
	अचिन्हित दीर्घ flags;

	अगर (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)
		वापस;

	cmd  = container_of(se_cmd, काष्ठा qla_tgt_cmd, se_cmd);

	spin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);
	list_del_init(&cmd->sess_cmd_list);
	spin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);

	qlt_पात_cmd(cmd);
पूर्ण

अटल व्योम tcm_qla2xxx_clear_sess_lookup(काष्ठा tcm_qla2xxx_lport *,
			काष्ठा tcm_qla2xxx_nacl *, काष्ठा fc_port *);
/*
 * Expected to be called with काष्ठा qla_hw_data->tgt.sess_lock held
 */
अटल व्योम tcm_qla2xxx_clear_nacl_from_fcport_map(काष्ठा fc_port *sess)
अणु
	काष्ठा se_node_acl *se_nacl = sess->se_sess->se_node_acl;
	काष्ठा se_portal_group *se_tpg = se_nacl->se_tpg;
	काष्ठा se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	काष्ठा tcm_qla2xxx_lport *lport = container_of(se_wwn,
				काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
				काष्ठा tcm_qla2xxx_nacl, se_node_acl);
	व्योम *node;

	pr_debug("fc_rport domain: port_id 0x%06x\n", nacl->nport_id);

	node = btree_हटाओ32(&lport->lport_fcport_map, nacl->nport_id);
	अगर (WARN_ON(node && (node != se_nacl))) अणु
		/*
		 * The nacl no दीर्घer matches what we think it should be.
		 * Most likely a new dynamic acl has been added जबतक
		 * someone dropped the hardware lock.  It clearly is a
		 * bug अन्यथाwhere, but this bit can't make things worse.
		 */
		btree_insert32(&lport->lport_fcport_map, nacl->nport_id,
			       node, GFP_ATOMIC);
	पूर्ण

	pr_debug("Removed from fcport_map: %p for WWNN: 0x%016LX, port_id: 0x%06x\n",
	    se_nacl, nacl->nport_wwnn, nacl->nport_id);
	/*
	 * Now clear the se_nacl and session poपूर्णांकers from our HW lport lookup
	 * table mapping क्रम this initiator's fabric S_ID and LOOP_ID entries.
	 *
	 * This is करोne ahead of callbacks पूर्णांकo tcm_qla2xxx_मुक्त_session() ->
	 * target_रुको_क्रम_sess_cmds() beक्रमe the session रुकोs क्रम outstanding
	 * I/O to complete, to aव्योम a race between session shutकरोwn execution
	 * and incoming ATIOs or TMRs picking up a stale se_node_act reference.
	 */
	tcm_qla2xxx_clear_sess_lookup(lport, nacl, sess);
पूर्ण

अटल व्योम tcm_qla2xxx_shutकरोwn_sess(काष्ठा fc_port *sess)
अणु
	target_stop_session(sess->se_sess);
पूर्ण

अटल पूर्णांक tcm_qla2xxx_init_nodeacl(काष्ठा se_node_acl *se_nacl,
		स्थिर अक्षर *name)
अणु
	काष्ठा tcm_qla2xxx_nacl *nacl =
		container_of(se_nacl, काष्ठा tcm_qla2xxx_nacl, se_node_acl);
	u64 wwnn;

	अगर (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)
		वापस -EINVAL;

	nacl->nport_wwnn = wwnn;
	tcm_qla2xxx_क्रमmat_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);

	वापस 0;
पूर्ण

/* Start items क्रम tcm_qla2xxx_tpg_attrib_cit */

#घोषणा DEF_QLA_TPG_ATTRIB(name)					\
									\
अटल sमाप_प्रकार tcm_qla2xxx_tpg_attrib_##name##_show(			\
		काष्ठा config_item *item, अक्षर *page)			\
अणु									\
	काष्ठा se_portal_group *se_tpg = attrib_to_tpg(item);		\
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,		\
			काष्ठा tcm_qla2xxx_tpg, se_tpg);		\
									\
	वापस प्र_लिखो(page, "%d\n", tpg->tpg_attrib.name);	\
पूर्ण									\
									\
अटल sमाप_प्रकार tcm_qla2xxx_tpg_attrib_##name##_store(			\
		काष्ठा config_item *item, स्थिर अक्षर *page, माप_प्रकार count) \
अणु									\
	काष्ठा se_portal_group *se_tpg = attrib_to_tpg(item);		\
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,		\
			काष्ठा tcm_qla2xxx_tpg, se_tpg);		\
	काष्ठा tcm_qla2xxx_tpg_attrib *a = &tpg->tpg_attrib;		\
	अचिन्हित दीर्घ val;						\
	पूर्णांक ret;							\
									\
	ret = kम_से_अदीर्घ(page, 0, &val);					\
	अगर (ret < 0) अणु							\
		pr_err("kstrtoul() failed with"				\
				" ret: %d\n", ret);			\
		वापस -EINVAL;						\
	पूर्ण								\
									\
	अगर ((val != 0) && (val != 1)) अणु					\
		pr_err("Illegal boolean value %lu\n", val);		\
		वापस -EINVAL;						\
	पूर्ण								\
									\
	a->name = val;							\
									\
	वापस count;							\
पूर्ण									\
CONFIGFS_ATTR(tcm_qla2xxx_tpg_attrib_, name)

DEF_QLA_TPG_ATTRIB(generate_node_acls);
DEF_QLA_TPG_ATTRIB(cache_dynamic_acls);
DEF_QLA_TPG_ATTRIB(demo_mode_ग_लिखो_protect);
DEF_QLA_TPG_ATTRIB(prod_mode_ग_लिखो_protect);
DEF_QLA_TPG_ATTRIB(demo_mode_login_only);
#अगर_घोषित CONFIG_TCM_QLA2XXX_DEBUG
DEF_QLA_TPG_ATTRIB(jam_host);
#पूर्ण_अगर

अटल काष्ठा configfs_attribute *tcm_qla2xxx_tpg_attrib_attrs[] = अणु
	&tcm_qla2xxx_tpg_attrib_attr_generate_node_acls,
	&tcm_qla2xxx_tpg_attrib_attr_cache_dynamic_acls,
	&tcm_qla2xxx_tpg_attrib_attr_demo_mode_ग_लिखो_protect,
	&tcm_qla2xxx_tpg_attrib_attr_prod_mode_ग_लिखो_protect,
	&tcm_qla2xxx_tpg_attrib_attr_demo_mode_login_only,
#अगर_घोषित CONFIG_TCM_QLA2XXX_DEBUG
	&tcm_qla2xxx_tpg_attrib_attr_jam_host,
#पूर्ण_अगर
	शून्य,
पूर्ण;

/* End items क्रम tcm_qla2xxx_tpg_attrib_cit */

अटल sमाप_प्रकार tcm_qla2xxx_tpg_enable_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	काष्ठा se_portal_group *se_tpg = to_tpg(item);
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस snम_लिखो(page, PAGE_SIZE, "%d\n",
			atomic_पढ़ो(&tpg->lport_tpg_enabled));
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_tpg_enable_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_portal_group *se_tpg = to_tpg(item);
	काष्ठा se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	काष्ठा tcm_qla2xxx_lport *lport = container_of(se_wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा scsi_qla_host *vha = lport->qla_vha;
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			काष्ठा tcm_qla2xxx_tpg, se_tpg);
	अचिन्हित दीर्घ op;
	पूर्णांक rc;

	rc = kम_से_अदीर्घ(page, 0, &op);
	अगर (rc < 0) अणु
		pr_err("kstrtoul() returned %d\n", rc);
		वापस -EINVAL;
	पूर्ण
	अगर ((op != 1) && (op != 0)) अणु
		pr_err("Illegal value for tpg_enable: %lu\n", op);
		वापस -EINVAL;
	पूर्ण
	अगर (op) अणु
		अगर (atomic_पढ़ो(&tpg->lport_tpg_enabled))
			वापस -EEXIST;

		atomic_set(&tpg->lport_tpg_enabled, 1);
		qlt_enable_vha(vha);
	पूर्ण अन्यथा अणु
		अगर (!atomic_पढ़ो(&tpg->lport_tpg_enabled))
			वापस count;

		atomic_set(&tpg->lport_tpg_enabled, 0);
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);
	पूर्ण

	वापस count;
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_tpg_dynamic_sessions_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	वापस target_show_dynamic_sessions(to_tpg(item), page);
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_tpg_fabric_prot_type_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_portal_group *se_tpg = to_tpg(item);
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);
	अचिन्हित दीर्घ val;
	पूर्णांक ret = kम_से_अदीर्घ(page, 0, &val);

	अगर (ret) अणु
		pr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);
		वापस ret;
	पूर्ण
	अगर (val != 0 && val != 1 && val != 3) अणु
		pr_err("Invalid qla2xxx fabric_prot_type: %lu\n", val);
		वापस -EINVAL;
	पूर्ण
	tpg->tpg_attrib.fabric_prot_type = val;

	वापस count;
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_tpg_fabric_prot_type_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	काष्ठा se_portal_group *se_tpg = to_tpg(item);
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);

	वापस प्र_लिखो(page, "%d\n", tpg->tpg_attrib.fabric_prot_type);
पूर्ण

CONFIGFS_ATTR(tcm_qla2xxx_tpg_, enable);
CONFIGFS_ATTR_RO(tcm_qla2xxx_tpg_, dynamic_sessions);
CONFIGFS_ATTR(tcm_qla2xxx_tpg_, fabric_prot_type);

अटल काष्ठा configfs_attribute *tcm_qla2xxx_tpg_attrs[] = अणु
	&tcm_qla2xxx_tpg_attr_enable,
	&tcm_qla2xxx_tpg_attr_dynamic_sessions,
	&tcm_qla2xxx_tpg_attr_fabric_prot_type,
	शून्य,
पूर्ण;

अटल काष्ठा se_portal_group *tcm_qla2xxx_make_tpg(काष्ठा se_wwn *wwn,
						    स्थिर अक्षर *name)
अणु
	काष्ठा tcm_qla2xxx_lport *lport = container_of(wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा tcm_qla2xxx_tpg *tpg;
	अचिन्हित दीर्घ tpgt;
	पूर्णांक ret;

	अगर (म_माला(name, "tpgt_") != name)
		वापस ERR_PTR(-EINVAL);
	अगर (kम_से_अदीर्घ(name + 5, 10, &tpgt) || tpgt > अच_लघु_उच्च)
		वापस ERR_PTR(-EINVAL);

	अगर ((tpgt != 1)) अणु
		pr_err("In non NPIV mode, a single TPG=1 is used for HW port mappings\n");
		वापस ERR_PTR(-ENOSYS);
	पूर्ण

	tpg = kzalloc(माप(काष्ठा tcm_qla2xxx_tpg), GFP_KERNEL);
	अगर (!tpg) अणु
		pr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");
		वापस ERR_PTR(-ENOMEM);
	पूर्ण
	tpg->lport = lport;
	tpg->lport_tpgt = tpgt;
	/*
	 * By शेष allow READ-ONLY TPG demo-mode access w/ cached dynamic
	 * NodeACLs
	 */
	tpg->tpg_attrib.generate_node_acls = 1;
	tpg->tpg_attrib.demo_mode_ग_लिखो_protect = 1;
	tpg->tpg_attrib.cache_dynamic_acls = 1;
	tpg->tpg_attrib.demo_mode_login_only = 1;
	tpg->tpg_attrib.jam_host = 0;

	ret = core_tpg_रेजिस्टर(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
	अगर (ret < 0) अणु
		kमुक्त(tpg);
		वापस शून्य;
	पूर्ण

	lport->tpg_1 = tpg;

	वापस &tpg->se_tpg;
पूर्ण

अटल व्योम tcm_qla2xxx_drop_tpg(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			काष्ठा tcm_qla2xxx_tpg, se_tpg);
	काष्ठा tcm_qla2xxx_lport *lport = tpg->lport;
	काष्ठा scsi_qla_host *vha = lport->qla_vha;
	/*
	 * Call पूर्णांकo qla2x_target.c LLD logic to shutकरोwn the active
	 * FC Nexuses and disable target mode operation क्रम this qla_hw_data
	 */
	अगर (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stop)
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);

	core_tpg_deरेजिस्टर(se_tpg);
	/*
	 * Clear local TPG=1 poपूर्णांकer क्रम non NPIV mode.
	 */
	lport->tpg_1 = शून्य;
	kमुक्त(tpg);
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_npiv_tpg_enable_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	वापस tcm_qla2xxx_tpg_enable_show(item, page);
पूर्ण

अटल sमाप_प्रकार tcm_qla2xxx_npiv_tpg_enable_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_portal_group *se_tpg = to_tpg(item);
	काष्ठा se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	काष्ठा tcm_qla2xxx_lport *lport = container_of(se_wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा scsi_qla_host *vha = lport->qla_vha;
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			काष्ठा tcm_qla2xxx_tpg, se_tpg);
	अचिन्हित दीर्घ op;
	पूर्णांक rc;

	rc = kम_से_अदीर्घ(page, 0, &op);
	अगर (rc < 0) अणु
		pr_err("kstrtoul() returned %d\n", rc);
		वापस -EINVAL;
	पूर्ण
	अगर ((op != 1) && (op != 0)) अणु
		pr_err("Illegal value for tpg_enable: %lu\n", op);
		वापस -EINVAL;
	पूर्ण
	अगर (op) अणु
		अगर (atomic_पढ़ो(&tpg->lport_tpg_enabled))
			वापस -EEXIST;

		atomic_set(&tpg->lport_tpg_enabled, 1);
		qlt_enable_vha(vha);
	पूर्ण अन्यथा अणु
		अगर (!atomic_पढ़ो(&tpg->lport_tpg_enabled))
			वापस count;

		atomic_set(&tpg->lport_tpg_enabled, 0);
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);
	पूर्ण

	वापस count;
पूर्ण

CONFIGFS_ATTR(tcm_qla2xxx_npiv_tpg_, enable);

अटल काष्ठा configfs_attribute *tcm_qla2xxx_npiv_tpg_attrs[] = अणु
        &tcm_qla2xxx_npiv_tpg_attr_enable,
        शून्य,
पूर्ण;

अटल काष्ठा se_portal_group *tcm_qla2xxx_npiv_make_tpg(काष्ठा se_wwn *wwn,
							 स्थिर अक्षर *name)
अणु
	काष्ठा tcm_qla2xxx_lport *lport = container_of(wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा tcm_qla2xxx_tpg *tpg;
	अचिन्हित दीर्घ tpgt;
	पूर्णांक ret;

	अगर (म_माला(name, "tpgt_") != name)
		वापस ERR_PTR(-EINVAL);
	अगर (kम_से_अदीर्घ(name + 5, 10, &tpgt) || tpgt > अच_लघु_उच्च)
		वापस ERR_PTR(-EINVAL);

	tpg = kzalloc(माप(काष्ठा tcm_qla2xxx_tpg), GFP_KERNEL);
	अगर (!tpg) अणु
		pr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");
		वापस ERR_PTR(-ENOMEM);
	पूर्ण
	tpg->lport = lport;
	tpg->lport_tpgt = tpgt;

	/*
	 * By शेष allow READ-ONLY TPG demo-mode access w/ cached dynamic
	 * NodeACLs
	 */
	tpg->tpg_attrib.generate_node_acls = 1;
	tpg->tpg_attrib.demo_mode_ग_लिखो_protect = 1;
	tpg->tpg_attrib.cache_dynamic_acls = 1;
	tpg->tpg_attrib.demo_mode_login_only = 1;

	ret = core_tpg_रेजिस्टर(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
	अगर (ret < 0) अणु
		kमुक्त(tpg);
		वापस शून्य;
	पूर्ण
	lport->tpg_1 = tpg;
	वापस &tpg->se_tpg;
पूर्ण

/*
 * Expected to be called with काष्ठा qla_hw_data->tgt.sess_lock held
 */
अटल काष्ठा fc_port *tcm_qla2xxx_find_sess_by_s_id(scsi_qla_host_t *vha,
						     स्थिर be_id_t s_id)
अणु
	काष्ठा tcm_qla2xxx_lport *lport;
	काष्ठा se_node_acl *se_nacl;
	काष्ठा tcm_qla2xxx_nacl *nacl;
	u32 key;

	lport = vha->vha_tgt.target_lport_ptr;
	अगर (!lport) अणु
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		वापस शून्य;
	पूर्ण

	key = sid_to_key(s_id);
	pr_debug("find_sess_by_s_id: 0x%06x\n", key);

	se_nacl = btree_lookup32(&lport->lport_fcport_map, key);
	अगर (!se_nacl) अणु
		pr_debug("Unable to locate s_id: 0x%06x\n", key);
		वापस शून्य;
	पूर्ण
	pr_debug("find_sess_by_s_id: located se_nacl: %p, initiatorname: %s\n",
	    se_nacl, se_nacl->initiatorname);

	nacl = container_of(se_nacl, काष्ठा tcm_qla2xxx_nacl, se_node_acl);
	अगर (!nacl->fc_port) अणु
		pr_err("Unable to locate struct fc_port\n");
		वापस शून्य;
	पूर्ण

	वापस nacl->fc_port;
पूर्ण

/*
 * Expected to be called with काष्ठा qla_hw_data->tgt.sess_lock held
 */
अटल व्योम tcm_qla2xxx_set_sess_by_s_id(
	काष्ठा tcm_qla2xxx_lport *lport,
	काष्ठा se_node_acl *new_se_nacl,
	काष्ठा tcm_qla2xxx_nacl *nacl,
	काष्ठा se_session *se_sess,
	काष्ठा fc_port *fc_port,
	be_id_t s_id)
अणु
	u32 key;
	व्योम *slot;
	पूर्णांक rc;

	key = sid_to_key(s_id);
	pr_debug("set_sess_by_s_id: %06x\n", key);

	slot = btree_lookup32(&lport->lport_fcport_map, key);
	अगर (!slot) अणु
		अगर (new_se_nacl) अणु
			pr_debug("Setting up new fc_port entry to new_se_nacl\n");
			nacl->nport_id = key;
			rc = btree_insert32(&lport->lport_fcport_map, key,
					new_se_nacl, GFP_ATOMIC);
			अगर (rc)
				prपूर्णांकk(KERN_ERR "Unable to insert s_id into fcport_map: %06x\n",
				    (पूर्णांक)key);
		पूर्ण अन्यथा अणु
			pr_debug("Wiping nonexisting fc_port entry\n");
		पूर्ण

		fc_port->se_sess = se_sess;
		nacl->fc_port = fc_port;
		वापस;
	पूर्ण

	अगर (nacl->fc_port) अणु
		अगर (new_se_nacl == शून्य) अणु
			pr_debug("Clearing existing nacl->fc_port and fc_port entry\n");
			btree_हटाओ32(&lport->lport_fcport_map, key);
			nacl->fc_port = शून्य;
			वापस;
		पूर्ण
		pr_debug("Replacing existing nacl->fc_port and fc_port entry\n");
		btree_update32(&lport->lport_fcport_map, key, new_se_nacl);
		fc_port->se_sess = se_sess;
		nacl->fc_port = fc_port;
		वापस;
	पूर्ण

	अगर (new_se_nacl == शून्य) अणु
		pr_debug("Clearing existing fc_port entry\n");
		btree_हटाओ32(&lport->lport_fcport_map, key);
		वापस;
	पूर्ण

	pr_debug("Replacing existing fc_port entry w/o active nacl->fc_port\n");
	btree_update32(&lport->lport_fcport_map, key, new_se_nacl);
	fc_port->se_sess = se_sess;
	nacl->fc_port = fc_port;

	pr_debug("Setup nacl->fc_port %p by s_id for se_nacl: %p, initiatorname: %s\n",
	    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);
पूर्ण

/*
 * Expected to be called with काष्ठा qla_hw_data->tgt.sess_lock held
 */
अटल काष्ठा fc_port *tcm_qla2xxx_find_sess_by_loop_id(
	scsi_qla_host_t *vha,
	स्थिर uपूर्णांक16_t loop_id)
अणु
	काष्ठा tcm_qla2xxx_lport *lport;
	काष्ठा se_node_acl *se_nacl;
	काष्ठा tcm_qla2xxx_nacl *nacl;
	काष्ठा tcm_qla2xxx_fc_loopid *fc_loopid;

	lport = vha->vha_tgt.target_lport_ptr;
	अगर (!lport) अणु
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		वापस शून्य;
	पूर्ण

	pr_debug("find_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);

	fc_loopid = lport->lport_loopid_map + loop_id;
	se_nacl = fc_loopid->se_nacl;
	अगर (!se_nacl) अणु
		pr_debug("Unable to locate se_nacl by loop_id: 0x%04x\n",
		    loop_id);
		वापस शून्य;
	पूर्ण

	nacl = container_of(se_nacl, काष्ठा tcm_qla2xxx_nacl, se_node_acl);

	अगर (!nacl->fc_port) अणु
		pr_err("Unable to locate struct fc_port\n");
		वापस शून्य;
	पूर्ण

	वापस nacl->fc_port;
पूर्ण

/*
 * Expected to be called with काष्ठा qla_hw_data->tgt.sess_lock held
 */
अटल व्योम tcm_qla2xxx_set_sess_by_loop_id(
	काष्ठा tcm_qla2xxx_lport *lport,
	काष्ठा se_node_acl *new_se_nacl,
	काष्ठा tcm_qla2xxx_nacl *nacl,
	काष्ठा se_session *se_sess,
	काष्ठा fc_port *fc_port,
	uपूर्णांक16_t loop_id)
अणु
	काष्ठा se_node_acl *saved_nacl;
	काष्ठा tcm_qla2xxx_fc_loopid *fc_loopid;

	pr_debug("set_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);

	fc_loopid = &((काष्ठा tcm_qla2xxx_fc_loopid *)
			lport->lport_loopid_map)[loop_id];

	saved_nacl = fc_loopid->se_nacl;
	अगर (!saved_nacl) अणु
		pr_debug("Setting up new fc_loopid->se_nacl to new_se_nacl\n");
		fc_loopid->se_nacl = new_se_nacl;
		अगर (fc_port->se_sess != se_sess)
			fc_port->se_sess = se_sess;
		अगर (nacl->fc_port != fc_port)
			nacl->fc_port = fc_port;
		वापस;
	पूर्ण

	अगर (nacl->fc_port) अणु
		अगर (new_se_nacl == शून्य) अणु
			pr_debug("Clearing nacl->fc_port and fc_loopid->se_nacl\n");
			fc_loopid->se_nacl = शून्य;
			nacl->fc_port = शून्य;
			वापस;
		पूर्ण

		pr_debug("Replacing existing nacl->fc_port and fc_loopid->se_nacl\n");
		fc_loopid->se_nacl = new_se_nacl;
		अगर (fc_port->se_sess != se_sess)
			fc_port->se_sess = se_sess;
		अगर (nacl->fc_port != fc_port)
			nacl->fc_port = fc_port;
		वापस;
	पूर्ण

	अगर (new_se_nacl == शून्य) अणु
		pr_debug("Clearing fc_loopid->se_nacl\n");
		fc_loopid->se_nacl = शून्य;
		वापस;
	पूर्ण

	pr_debug("Replacing existing fc_loopid->se_nacl w/o active nacl->fc_port\n");
	fc_loopid->se_nacl = new_se_nacl;
	अगर (fc_port->se_sess != se_sess)
		fc_port->se_sess = se_sess;
	अगर (nacl->fc_port != fc_port)
		nacl->fc_port = fc_port;

	pr_debug("Setup nacl->fc_port %p by loop_id for se_nacl: %p, initiatorname: %s\n",
	    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);
पूर्ण

/*
 * Should always be called with qla_hw_data->tgt.sess_lock held.
 */
अटल व्योम tcm_qla2xxx_clear_sess_lookup(काष्ठा tcm_qla2xxx_lport *lport,
		काष्ठा tcm_qla2xxx_nacl *nacl, काष्ठा fc_port *sess)
अणु
	काष्ठा se_session *se_sess = sess->se_sess;

	tcm_qla2xxx_set_sess_by_s_id(lport, शून्य, nacl, se_sess,
				     sess, port_id_to_be_id(sess->d_id));
	tcm_qla2xxx_set_sess_by_loop_id(lport, शून्य, nacl, se_sess,
				sess, sess->loop_id);
पूर्ण

अटल व्योम tcm_qla2xxx_मुक्त_session(काष्ठा fc_port *sess)
अणु
	काष्ठा qla_tgt *tgt = sess->tgt;
	काष्ठा qla_hw_data *ha = tgt->ha;
	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
	काष्ठा se_session *se_sess;
	काष्ठा tcm_qla2xxx_lport *lport;

	se_sess = sess->se_sess;
	अगर (!se_sess) अणु
		pr_err("struct fc_port->se_sess is NULL\n");
		dump_stack();
		वापस;
	पूर्ण

	lport = vha->vha_tgt.target_lport_ptr;
	अगर (!lport) अणु
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		वापस;
	पूर्ण
	target_रुको_क्रम_sess_cmds(se_sess);

	target_हटाओ_session(se_sess);
पूर्ण

अटल पूर्णांक tcm_qla2xxx_session_cb(काष्ठा se_portal_group *se_tpg,
				  काष्ठा se_session *se_sess, व्योम *p)
अणु
	काष्ठा tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				काष्ठा tcm_qla2xxx_tpg, se_tpg);
	काष्ठा tcm_qla2xxx_lport *lport = tpg->lport;
	काष्ठा qla_hw_data *ha = lport->qla_vha->hw;
	काष्ठा se_node_acl *se_nacl = se_sess->se_node_acl;
	काष्ठा tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
				काष्ठा tcm_qla2xxx_nacl, se_node_acl);
	काष्ठा fc_port *qlat_sess = p;
	uपूर्णांक16_t loop_id = qlat_sess->loop_id;
	अचिन्हित दीर्घ flags;

	/*
	 * And now setup se_nacl and session poपूर्णांकers पूर्णांकo HW lport पूर्णांकernal
	 * mappings क्रम fabric S_ID and LOOP_ID.
	 */
	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
	tcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl, se_sess, qlat_sess,
				     port_id_to_be_id(qlat_sess->d_id));
	tcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,
					se_sess, qlat_sess, loop_id);
	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);

	वापस 0;
पूर्ण

/*
 * Called via qlt_create_sess():ha->qla2x_पंचांगpl->check_initiator_node_acl()
 * to locate काष्ठा se_node_acl
 */
अटल पूर्णांक tcm_qla2xxx_check_initiator_node_acl(
	scsi_qla_host_t *vha,
	अचिन्हित अक्षर *fc_wwpn,
	काष्ठा fc_port *qlat_sess)
अणु
	काष्ठा qla_hw_data *ha = vha->hw;
	काष्ठा tcm_qla2xxx_lport *lport;
	काष्ठा tcm_qla2xxx_tpg *tpg;
	काष्ठा se_session *se_sess;
	अचिन्हित अक्षर port_name[36];
	पूर्णांक num_tags = (ha->cur_fw_xcb_count) ? ha->cur_fw_xcb_count :
		       TCM_QLA2XXX_DEFAULT_TAGS;

	lport = vha->vha_tgt.target_lport_ptr;
	अगर (!lport) अणु
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		वापस -EINVAL;
	पूर्ण
	/*
	 * Locate the TPG=1 reference..
	 */
	tpg = lport->tpg_1;
	अगर (!tpg) अणु
		pr_err("Unable to locate struct tcm_qla2xxx_lport->tpg_1\n");
		वापस -EINVAL;
	पूर्ण
	/*
	 * Format the FCP Initiator port_name पूर्णांकo colon seperated values to
	 * match the क्रमmat by tcm_qla2xxx explict ConfigFS NodeACLs.
	 */
	स_रखो(&port_name, 0, 36);
	snम_लिखो(port_name, माप(port_name), "%8phC", fc_wwpn);
	/*
	 * Locate our काष्ठा se_node_acl either from an explict NodeACL created
	 * via ConfigFS, or via running in TPG demo mode.
	 */
	se_sess = target_setup_session(&tpg->se_tpg, num_tags,
				       माप(काष्ठा qla_tgt_cmd),
				       TARGET_PROT_ALL, port_name,
				       qlat_sess, tcm_qla2xxx_session_cb);
	अगर (IS_ERR(se_sess))
		वापस PTR_ERR(se_sess);

	वापस 0;
पूर्ण

अटल व्योम tcm_qla2xxx_update_sess(काष्ठा fc_port *sess, port_id_t s_id,
				    uपूर्णांक16_t loop_id, bool conf_compl_supported)
अणु
	काष्ठा qla_tgt *tgt = sess->tgt;
	काष्ठा qla_hw_data *ha = tgt->ha;
	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
	काष्ठा tcm_qla2xxx_lport *lport = vha->vha_tgt.target_lport_ptr;
	काष्ठा se_node_acl *se_nacl = sess->se_sess->se_node_acl;
	काष्ठा tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
			काष्ठा tcm_qla2xxx_nacl, se_node_acl);
	u32 key;


	अगर (sess->loop_id != loop_id || sess->d_id.b24 != s_id.b24)
		pr_info("Updating session %p from port %8phC loop_id %d -> %d s_id %x:%x:%x -> %x:%x:%x\n",
		    sess, sess->port_name,
		    sess->loop_id, loop_id, sess->d_id.b.करोमुख्य,
		    sess->d_id.b.area, sess->d_id.b.al_pa, s_id.b.करोमुख्य,
		    s_id.b.area, s_id.b.al_pa);

	अगर (sess->loop_id != loop_id) अणु
		/*
		 * Because we can shuffle loop IDs around and we
		 * update dअगरferent sessions non-atomically, we might
		 * have overwritten this session's old loop ID
		 * alपढ़ोy, and we might end up overwriting some other
		 * session that will be updated later.  So we have to
		 * be extra careful and we can't warn about those things...
		 */
		अगर (lport->lport_loopid_map[sess->loop_id].se_nacl == se_nacl)
			lport->lport_loopid_map[sess->loop_id].se_nacl = शून्य;

		lport->lport_loopid_map[loop_id].se_nacl = se_nacl;

		sess->loop_id = loop_id;
	पूर्ण

	अगर (sess->d_id.b24 != s_id.b24) अणु
		key = (((u32) sess->d_id.b.करोमुख्य << 16) |
		       ((u32) sess->d_id.b.area   <<  8) |
		       ((u32) sess->d_id.b.al_pa));

		अगर (btree_lookup32(&lport->lport_fcport_map, key))
			WARN(btree_हटाओ32(&lport->lport_fcport_map, key) !=
			    se_nacl, "Found wrong se_nacl when updating s_id %x:%x:%x\n",
			    sess->d_id.b.करोमुख्य, sess->d_id.b.area,
			    sess->d_id.b.al_pa);
		अन्यथा
			WARN(1, "No lport_fcport_map entry for s_id %x:%x:%x\n",
			     sess->d_id.b.करोमुख्य, sess->d_id.b.area,
			     sess->d_id.b.al_pa);

		key = (((u32) s_id.b.करोमुख्य << 16) |
		       ((u32) s_id.b.area   <<  8) |
		       ((u32) s_id.b.al_pa));

		अगर (btree_lookup32(&lport->lport_fcport_map, key)) अणु
			WARN(1, "Already have lport_fcport_map entry for s_id %x:%x:%x\n",
			     s_id.b.करोमुख्य, s_id.b.area, s_id.b.al_pa);
			btree_update32(&lport->lport_fcport_map, key, se_nacl);
		पूर्ण अन्यथा अणु
			btree_insert32(&lport->lport_fcport_map, key, se_nacl,
			    GFP_ATOMIC);
		पूर्ण

		sess->d_id = s_id;
		nacl->nport_id = key;
	पूर्ण

	sess->conf_compl_supported = conf_compl_supported;

पूर्ण

/*
 * Calls पूर्णांकo tcm_qla2xxx used by qla2xxx LLD I/O path.
 */
अटल स्थिर काष्ठा qla_tgt_func_पंचांगpl tcm_qla2xxx_ढाँचा = अणु
	.find_cmd_by_tag	= tcm_qla2xxx_find_cmd_by_tag,
	.handle_cmd		= tcm_qla2xxx_handle_cmd,
	.handle_data		= tcm_qla2xxx_handle_data,
	.handle_पंचांगr		= tcm_qla2xxx_handle_पंचांगr,
	.get_cmd		= tcm_qla2xxx_get_cmd,
	.rel_cmd		= tcm_qla2xxx_rel_cmd,
	.मुक्त_cmd		= tcm_qla2xxx_मुक्त_cmd,
	.मुक्त_mcmd		= tcm_qla2xxx_मुक्त_mcmd,
	.मुक्त_session		= tcm_qla2xxx_मुक्त_session,
	.update_sess		= tcm_qla2xxx_update_sess,
	.check_initiator_node_acl = tcm_qla2xxx_check_initiator_node_acl,
	.find_sess_by_s_id	= tcm_qla2xxx_find_sess_by_s_id,
	.find_sess_by_loop_id	= tcm_qla2xxx_find_sess_by_loop_id,
	.clear_nacl_from_fcport_map = tcm_qla2xxx_clear_nacl_from_fcport_map,
	.put_sess		= tcm_qla2xxx_put_sess,
	.shutकरोwn_sess		= tcm_qla2xxx_shutकरोwn_sess,
	.get_dअगर_tags		= tcm_qla2xxx_dअगर_tags,
	.chk_dअगर_tags		= tcm_qla2xxx_chk_dअगर_tags,
पूर्ण;

अटल पूर्णांक tcm_qla2xxx_init_lport(काष्ठा tcm_qla2xxx_lport *lport)
अणु
	पूर्णांक rc;

	rc = btree_init32(&lport->lport_fcport_map);
	अगर (rc) अणु
		pr_err("Unable to initialize lport->lport_fcport_map btree\n");
		वापस rc;
	पूर्ण

	lport->lport_loopid_map =
		vzalloc(array_size(65536,
				   माप(काष्ठा tcm_qla2xxx_fc_loopid)));
	अगर (!lport->lport_loopid_map) अणु
		pr_err("Unable to allocate lport->lport_loopid_map of %zu bytes\n",
		    माप(काष्ठा tcm_qla2xxx_fc_loopid) * 65536);
		btree_destroy32(&lport->lport_fcport_map);
		वापस -ENOMEM;
	पूर्ण
	pr_debug("qla2xxx: Allocated lport_loopid_map of %zu bytes\n",
	       माप(काष्ठा tcm_qla2xxx_fc_loopid) * 65536);
	वापस 0;
पूर्ण

अटल पूर्णांक tcm_qla2xxx_lport_रेजिस्टर_cb(काष्ठा scsi_qla_host *vha,
					 व्योम *target_lport_ptr,
					 u64 npiv_wwpn, u64 npiv_wwnn)
अणु
	काष्ठा qla_hw_data *ha = vha->hw;
	काष्ठा tcm_qla2xxx_lport *lport =
			(काष्ठा tcm_qla2xxx_lport *)target_lport_ptr;
	/*
	 * Setup tgt_ops, local poपूर्णांकer to vha and target_lport_ptr
	 */
	ha->tgt.tgt_ops = &tcm_qla2xxx_ढाँचा;
	vha->vha_tgt.target_lport_ptr = target_lport_ptr;
	lport->qla_vha = vha;

	वापस 0;
पूर्ण

अटल काष्ठा se_wwn *tcm_qla2xxx_make_lport(
	काष्ठा target_fabric_configfs *tf,
	काष्ठा config_group *group,
	स्थिर अक्षर *name)
अणु
	काष्ठा tcm_qla2xxx_lport *lport;
	u64 wwpn;
	पूर्णांक ret = -ENODEV;

	अगर (tcm_qla2xxx_parse_wwn(name, &wwpn, 1) < 0)
		वापस ERR_PTR(-EINVAL);

	lport = kzalloc(माप(काष्ठा tcm_qla2xxx_lport), GFP_KERNEL);
	अगर (!lport) अणु
		pr_err("Unable to allocate struct tcm_qla2xxx_lport\n");
		वापस ERR_PTR(-ENOMEM);
	पूर्ण
	lport->lport_wwpn = wwpn;
	tcm_qla2xxx_क्रमmat_wwn(&lport->lport_name[0], TCM_QLA2XXX_NAMELEN,
				wwpn);
	प्र_लिखो(lport->lport_naa_name, "naa.%016llx", (अचिन्हित दीर्घ दीर्घ) wwpn);

	ret = tcm_qla2xxx_init_lport(lport);
	अगर (ret != 0)
		जाओ out;

	ret = qlt_lport_रेजिस्टर(lport, wwpn, 0, 0,
				 tcm_qla2xxx_lport_रेजिस्टर_cb);
	अगर (ret != 0)
		जाओ out_lport;

	वापस &lport->lport_wwn;
out_lport:
	vमुक्त(lport->lport_loopid_map);
	btree_destroy32(&lport->lport_fcport_map);
out:
	kमुक्त(lport);
	वापस ERR_PTR(ret);
पूर्ण

अटल व्योम tcm_qla2xxx_drop_lport(काष्ठा se_wwn *wwn)
अणु
	काष्ठा tcm_qla2xxx_lport *lport = container_of(wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा scsi_qla_host *vha = lport->qla_vha;
	काष्ठा se_node_acl *node;
	u32 key = 0;

	/*
	 * Call पूर्णांकo qla2x_target.c LLD logic to complete the
	 * shutकरोwn of काष्ठा qla_tgt after the call to
	 * qlt_stop_phase1() from tcm_qla2xxx_drop_tpg() above..
	 */
	अगर (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stopped)
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);

	qlt_lport_deरेजिस्टर(vha);

	vमुक्त(lport->lport_loopid_map);
	btree_क्रम_each_safe32(&lport->lport_fcport_map, key, node)
		btree_हटाओ32(&lport->lport_fcport_map, key);
	btree_destroy32(&lport->lport_fcport_map);
	kमुक्त(lport);
पूर्ण

अटल पूर्णांक tcm_qla2xxx_lport_रेजिस्टर_npiv_cb(काष्ठा scsi_qla_host *base_vha,
					      व्योम *target_lport_ptr,
					      u64 npiv_wwpn, u64 npiv_wwnn)
अणु
	काष्ठा fc_vport *vport;
	काष्ठा Scsi_Host *sh = base_vha->host;
	काष्ठा scsi_qla_host *npiv_vha;
	काष्ठा tcm_qla2xxx_lport *lport =
			(काष्ठा tcm_qla2xxx_lport *)target_lport_ptr;
	काष्ठा tcm_qla2xxx_lport *base_lport =
			(काष्ठा tcm_qla2xxx_lport *)base_vha->vha_tgt.target_lport_ptr;
	काष्ठा fc_vport_identअगरiers vport_id;

	अगर (qla_ini_mode_enabled(base_vha)) अणु
		pr_err("qla2xxx base_vha not enabled for target mode\n");
		वापस -EPERM;
	पूर्ण

	अगर (!base_lport || !base_lport->tpg_1 ||
	    !atomic_पढ़ो(&base_lport->tpg_1->lport_tpg_enabled)) अणु
		pr_err("qla2xxx base_lport or tpg_1 not available\n");
		वापस -EPERM;
	पूर्ण

	स_रखो(&vport_id, 0, माप(vport_id));
	vport_id.port_name = npiv_wwpn;
	vport_id.node_name = npiv_wwnn;
	vport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;
	vport_id.vport_type = FC_PORTTYPE_NPIV;
	vport_id.disable = false;

	vport = fc_vport_create(sh, 0, &vport_id);
	अगर (!vport) अणु
		pr_err("fc_vport_create failed for qla2xxx_npiv\n");
		वापस -ENODEV;
	पूर्ण
	/*
	 * Setup local poपूर्णांकer to NPIV vhba + target_lport_ptr
	 */
	npiv_vha = (काष्ठा scsi_qla_host *)vport->dd_data;
	npiv_vha->vha_tgt.target_lport_ptr = target_lport_ptr;
	lport->qla_vha = npiv_vha;
	scsi_host_get(npiv_vha->host);
	वापस 0;
पूर्ण


अटल काष्ठा se_wwn *tcm_qla2xxx_npiv_make_lport(
	काष्ठा target_fabric_configfs *tf,
	काष्ठा config_group *group,
	स्थिर अक्षर *name)
अणु
	काष्ठा tcm_qla2xxx_lport *lport;
	u64 phys_wwpn, npiv_wwpn, npiv_wwnn;
	अक्षर *p, पंचांगp[128];
	पूर्णांक ret;

	snम_लिखो(पंचांगp, 128, "%s", name);

	p = म_अक्षर(पंचांगp, '@');
	अगर (!p) अणु
		pr_err("Unable to locate NPIV '@' separator\n");
		वापस ERR_PTR(-EINVAL);
	पूर्ण
	*p++ = '\0';

	अगर (tcm_qla2xxx_parse_wwn(पंचांगp, &phys_wwpn, 1) < 0)
		वापस ERR_PTR(-EINVAL);

	अगर (tcm_qla2xxx_npiv_parse_wwn(p, म_माप(p)+1,
				       &npiv_wwpn, &npiv_wwnn) < 0)
		वापस ERR_PTR(-EINVAL);

	lport = kzalloc(माप(काष्ठा tcm_qla2xxx_lport), GFP_KERNEL);
	अगर (!lport) अणु
		pr_err("Unable to allocate struct tcm_qla2xxx_lport for NPIV\n");
		वापस ERR_PTR(-ENOMEM);
	पूर्ण
	lport->lport_npiv_wwpn = npiv_wwpn;
	lport->lport_npiv_wwnn = npiv_wwnn;
	प्र_लिखो(lport->lport_naa_name, "naa.%016llx", (अचिन्हित दीर्घ दीर्घ) npiv_wwpn);

	ret = tcm_qla2xxx_init_lport(lport);
	अगर (ret != 0)
		जाओ out;

	ret = qlt_lport_रेजिस्टर(lport, phys_wwpn, npiv_wwpn, npiv_wwnn,
				 tcm_qla2xxx_lport_रेजिस्टर_npiv_cb);
	अगर (ret != 0)
		जाओ out_lport;

	वापस &lport->lport_wwn;
out_lport:
	vमुक्त(lport->lport_loopid_map);
	btree_destroy32(&lport->lport_fcport_map);
out:
	kमुक्त(lport);
	वापस ERR_PTR(ret);
पूर्ण

अटल व्योम tcm_qla2xxx_npiv_drop_lport(काष्ठा se_wwn *wwn)
अणु
	काष्ठा tcm_qla2xxx_lport *lport = container_of(wwn,
			काष्ठा tcm_qla2xxx_lport, lport_wwn);
	काष्ठा scsi_qla_host *npiv_vha = lport->qla_vha;
	काष्ठा qla_hw_data *ha = npiv_vha->hw;
	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);

	scsi_host_put(npiv_vha->host);
	/*
	 * Notअगरy libfc that we want to release the vha->fc_vport
	 */
	fc_vport_terminate(npiv_vha->fc_vport);
	scsi_host_put(base_vha->host);
	kमुक्त(lport);
पूर्ण


अटल sमाप_प्रकार tcm_qla2xxx_wwn_version_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	वापस प्र_लिखो(page,
	    "TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on %s\n",
	    QLA2XXX_VERSION, utsname()->sysname,
	    utsname()->machine, utsname()->release);
पूर्ण

CONFIGFS_ATTR_RO(tcm_qla2xxx_wwn_, version);

अटल काष्ठा configfs_attribute *tcm_qla2xxx_wwn_attrs[] = अणु
	&tcm_qla2xxx_wwn_attr_version,
	शून्य,
पूर्ण;

अटल स्थिर काष्ठा target_core_fabric_ops tcm_qla2xxx_ops = अणु
	.module				= THIS_MODULE,
	.fabric_name			= "qla2xxx",
	.node_acl_size			= माप(काष्ठा tcm_qla2xxx_nacl),
	/*
	 * XXX: Limit assumes single page per scatter-gather-list entry.
	 * Current maximum is ~4.9 MB per se_cmd->t_data_sg with PAGE_SIZE=4096
	 */
	.max_data_sg_nents		= 1200,
	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
	.tpg_get_tag			= tcm_qla2xxx_get_tag,
	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
	.tpg_check_demo_mode_ग_लिखो_protect =
					tcm_qla2xxx_check_demo_ग_लिखो_protect,
	.tpg_check_prod_mode_ग_लिखो_protect =
					tcm_qla2xxx_check_prod_ग_लिखो_protect,
	.tpg_check_prot_fabric_only	= tcm_qla2xxx_check_prot_fabric_only,
	.tpg_check_demo_mode_login_only = tcm_qla2xxx_check_demo_mode_login_only,
	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
	.check_stop_मुक्त		= tcm_qla2xxx_check_stop_मुक्त,
	.release_cmd			= tcm_qla2xxx_release_cmd,
	.बंद_session			= tcm_qla2xxx_बंद_session,
	.sess_get_index			= tcm_qla2xxx_sess_get_index,
	.sess_get_initiator_sid		= शून्य,
	.ग_लिखो_pending			= tcm_qla2xxx_ग_लिखो_pending,
	.set_शेष_node_attributes	= tcm_qla2xxx_set_शेष_node_attrs,
	.get_cmd_state			= tcm_qla2xxx_get_cmd_state,
	.queue_data_in			= tcm_qla2xxx_queue_data_in,
	.queue_status			= tcm_qla2xxx_queue_status,
	.queue_पंचांग_rsp			= tcm_qla2xxx_queue_पंचांग_rsp,
	.पातed_task			= tcm_qla2xxx_पातed_task,
	/*
	 * Setup function poपूर्णांकers क्रम generic logic in
	 * target_core_fabric_configfs.c
	 */
	.fabric_make_wwn		= tcm_qla2xxx_make_lport,
	.fabric_drop_wwn		= tcm_qla2xxx_drop_lport,
	.fabric_make_tpg		= tcm_qla2xxx_make_tpg,
	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,

	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
	.tfc_tpg_base_attrs		= tcm_qla2xxx_tpg_attrs,
	.tfc_tpg_attrib_attrs		= tcm_qla2xxx_tpg_attrib_attrs,
पूर्ण;

अटल स्थिर काष्ठा target_core_fabric_ops tcm_qla2xxx_npiv_ops = अणु
	.module				= THIS_MODULE,
	.fabric_name			= "qla2xxx_npiv",
	.node_acl_size			= माप(काष्ठा tcm_qla2xxx_nacl),
	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
	.tpg_get_tag			= tcm_qla2xxx_get_tag,
	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
	.tpg_check_demo_mode_ग_लिखो_protect = tcm_qla2xxx_check_demo_mode,
	.tpg_check_prod_mode_ग_लिखो_protect =
	    tcm_qla2xxx_check_prod_ग_लिखो_protect,
	.tpg_check_demo_mode_login_only	= tcm_qla2xxx_check_demo_mode_login_only,
	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
	.check_stop_मुक्त                = tcm_qla2xxx_check_stop_मुक्त,
	.release_cmd			= tcm_qla2xxx_release_cmd,
	.बंद_session			= tcm_qla2xxx_बंद_session,
	.sess_get_index			= tcm_qla2xxx_sess_get_index,
	.sess_get_initiator_sid		= शून्य,
	.ग_लिखो_pending			= tcm_qla2xxx_ग_लिखो_pending,
	.set_शेष_node_attributes	= tcm_qla2xxx_set_शेष_node_attrs,
	.get_cmd_state			= tcm_qla2xxx_get_cmd_state,
	.queue_data_in			= tcm_qla2xxx_queue_data_in,
	.queue_status			= tcm_qla2xxx_queue_status,
	.queue_पंचांग_rsp			= tcm_qla2xxx_queue_पंचांग_rsp,
	.पातed_task			= tcm_qla2xxx_पातed_task,
	/*
	 * Setup function poपूर्णांकers क्रम generic logic in
	 * target_core_fabric_configfs.c
	 */
	.fabric_make_wwn		= tcm_qla2xxx_npiv_make_lport,
	.fabric_drop_wwn		= tcm_qla2xxx_npiv_drop_lport,
	.fabric_make_tpg		= tcm_qla2xxx_npiv_make_tpg,
	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,

	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
	.tfc_tpg_base_attrs		= tcm_qla2xxx_npiv_tpg_attrs,
पूर्ण;

अटल पूर्णांक tcm_qla2xxx_रेजिस्टर_configfs(व्योम)
अणु
	पूर्णांक ret;

	pr_debug("TCM QLOGIC QLA2XXX fabric module %s on %s/%s on %s\n",
	    QLA2XXX_VERSION, utsname()->sysname,
	    utsname()->machine, utsname()->release);

	ret = target_रेजिस्टर_ढाँचा(&tcm_qla2xxx_ops);
	अगर (ret)
		वापस ret;

	ret = target_रेजिस्टर_ढाँचा(&tcm_qla2xxx_npiv_ops);
	अगर (ret)
		जाओ out_fabric;

	tcm_qla2xxx_मुक्त_wq = alloc_workqueue("tcm_qla2xxx_free",
						WQ_MEM_RECLAIM, 0);
	अगर (!tcm_qla2xxx_मुक्त_wq) अणु
		ret = -ENOMEM;
		जाओ out_fabric_npiv;
	पूर्ण

	वापस 0;

out_fabric_npiv:
	target_unरेजिस्टर_ढाँचा(&tcm_qla2xxx_npiv_ops);
out_fabric:
	target_unरेजिस्टर_ढाँचा(&tcm_qla2xxx_ops);
	वापस ret;
पूर्ण

अटल व्योम tcm_qla2xxx_deरेजिस्टर_configfs(व्योम)
अणु
	destroy_workqueue(tcm_qla2xxx_मुक्त_wq);

	target_unरेजिस्टर_ढाँचा(&tcm_qla2xxx_ops);
	target_unरेजिस्टर_ढाँचा(&tcm_qla2xxx_npiv_ops);
पूर्ण

अटल पूर्णांक __init tcm_qla2xxx_init(व्योम)
अणु
	पूर्णांक ret;

	BUILD_BUG_ON(माप(काष्ठा abts_recv_from_24xx) != 64);
	BUILD_BUG_ON(माप(काष्ठा abts_resp_from_24xx_fw) != 64);
	BUILD_BUG_ON(माप(काष्ठा atio7_fcp_cmnd) != 32);
	BUILD_BUG_ON(माप(काष्ठा atio_from_isp) != 64);
	BUILD_BUG_ON(माप(काष्ठा ba_acc_le) != 12);
	BUILD_BUG_ON(माप(काष्ठा ba_rjt_le) != 4);
	BUILD_BUG_ON(माप(काष्ठा ctio7_from_24xx) != 64);
	BUILD_BUG_ON(माप(काष्ठा ctio7_to_24xx) != 64);
	BUILD_BUG_ON(माप(काष्ठा ctio_crc2_to_fw) != 64);
	BUILD_BUG_ON(माप(काष्ठा ctio_crc_from_fw) != 64);
	BUILD_BUG_ON(माप(काष्ठा ctio_to_2xxx) != 64);
	BUILD_BUG_ON(माप(काष्ठा fcp_hdr) != 24);
	BUILD_BUG_ON(माप(काष्ठा fcp_hdr_le) != 24);
	BUILD_BUG_ON(माप(काष्ठा nack_to_isp) != 64);

	ret = tcm_qla2xxx_रेजिस्टर_configfs();
	अगर (ret < 0)
		वापस ret;

	वापस 0;
पूर्ण

अटल व्योम __निकास tcm_qla2xxx_निकास(व्योम)
अणु
	tcm_qla2xxx_deरेजिस्टर_configfs();
पूर्ण

MODULE_DESCRIPTION("TCM QLA24XX+ series NPIV enabled fabric driver");
MODULE_LICENSE("GPL");
module_init(tcm_qla2xxx_init);
module_निकास(tcm_qla2xxx_निकास);
