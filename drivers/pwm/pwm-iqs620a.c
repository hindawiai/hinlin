<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0+
/*
 * Azoteq IQS620A PWM Generator
 *
 * Copyright (C) 2019 Jeff LaBundy <jeff@labundy.com>
 *
 * Limitations:
 * - The period is fixed to 1 ms and is generated continuously despite changes
 *   to the duty cycle or enable/disable state.
 * - Changes to the duty cycle or enable/disable state take effect immediately
 *   and may result in a glitch during the period in which the change is made.
 * - The device cannot generate a 0% duty cycle. For duty cycles below 1 / 256
 *   ms, the output is disabled and relies upon an बाह्यal pull-करोwn resistor
 *   to hold the GPIO3/LTX pin low.
 */

#समावेश <linux/device.h>
#समावेश <linux/kernel.h>
#समावेश <linux/mfd/iqs62x.h>
#समावेश <linux/module.h>
#समावेश <linux/mutex.h>
#समावेश <linux/notअगरier.h>
#समावेश <linux/platक्रमm_device.h>
#समावेश <linux/pwm.h>
#समावेश <linux/regmap.h>
#समावेश <linux/slab.h>

#घोषणा IQS620_PWR_SETTINGS			0xd2
#घोषणा IQS620_PWR_SETTINGS_PWM_OUT		BIT(7)

#घोषणा IQS620_PWM_DUTY_CYCLE			0xd8

#घोषणा IQS620_PWM_PERIOD_NS			1000000

काष्ठा iqs620_pwm_निजी अणु
	काष्ठा iqs62x_core *iqs62x;
	काष्ठा pwm_chip chip;
	काष्ठा notअगरier_block notअगरier;
	काष्ठा mutex lock;
	अचिन्हित पूर्णांक duty_scale;
पूर्ण;

अटल पूर्णांक iqs620_pwm_init(काष्ठा iqs620_pwm_निजी *iqs620_pwm,
			   अचिन्हित पूर्णांक duty_scale)
अणु
	काष्ठा iqs62x_core *iqs62x = iqs620_pwm->iqs62x;
	पूर्णांक ret;

	अगर (!duty_scale)
		वापस regmap_update_bits(iqs62x->regmap, IQS620_PWR_SETTINGS,
					  IQS620_PWR_SETTINGS_PWM_OUT, 0);

	ret = regmap_ग_लिखो(iqs62x->regmap, IQS620_PWM_DUTY_CYCLE,
			   duty_scale - 1);
	अगर (ret)
		वापस ret;

	वापस regmap_update_bits(iqs62x->regmap, IQS620_PWR_SETTINGS,
				  IQS620_PWR_SETTINGS_PWM_OUT, 0xff);
पूर्ण

अटल पूर्णांक iqs620_pwm_apply(काष्ठा pwm_chip *chip, काष्ठा pwm_device *pwm,
			    स्थिर काष्ठा pwm_state *state)
अणु
	काष्ठा iqs620_pwm_निजी *iqs620_pwm;
	अचिन्हित पूर्णांक duty_cycle;
	अचिन्हित पूर्णांक duty_scale;
	पूर्णांक ret;

	अगर (state->polarity != PWM_POLARITY_NORMAL)
		वापस -EINVAL;

	अगर (state->period < IQS620_PWM_PERIOD_NS)
		वापस -EINVAL;

	iqs620_pwm = container_of(chip, काष्ठा iqs620_pwm_निजी, chip);

	/*
	 * The duty cycle generated by the device is calculated as follows:
	 *
	 * duty_cycle = (IQS620_PWM_DUTY_CYCLE + 1) / 256 * 1 ms
	 *
	 * ...where IQS620_PWM_DUTY_CYCLE is a रेजिस्टर value between 0 and 255
	 * (inclusive). Thereक्रमe the lowest duty cycle the device can generate
	 * जबतक the output is enabled is 1 / 256 ms.
	 *
	 * For lower duty cycles (e.g. 0), the PWM output is simply disabled to
	 * allow an बाह्यal pull-करोwn resistor to hold the GPIO3/LTX pin low.
	 */
	duty_cycle = min_t(u64, state->duty_cycle, IQS620_PWM_PERIOD_NS);
	duty_scale = duty_cycle * 256 / IQS620_PWM_PERIOD_NS;

	अगर (!state->enabled)
		duty_scale = 0;

	mutex_lock(&iqs620_pwm->lock);

	ret = iqs620_pwm_init(iqs620_pwm, duty_scale);
	अगर (!ret)
		iqs620_pwm->duty_scale = duty_scale;

	mutex_unlock(&iqs620_pwm->lock);

	वापस ret;
पूर्ण

अटल व्योम iqs620_pwm_get_state(काष्ठा pwm_chip *chip, काष्ठा pwm_device *pwm,
				 काष्ठा pwm_state *state)
अणु
	काष्ठा iqs620_pwm_निजी *iqs620_pwm;

	iqs620_pwm = container_of(chip, काष्ठा iqs620_pwm_निजी, chip);

	mutex_lock(&iqs620_pwm->lock);

	/*
	 * Since the device cannot generate a 0% duty cycle, requests to करो so
	 * cause subsequent calls to iqs620_pwm_get_state to report the output
	 * as disabled. This is not ideal, but is the best compromise based on
	 * the capabilities of the device.
	 */
	state->enabled = iqs620_pwm->duty_scale > 0;
	state->duty_cycle = DIV_ROUND_UP(iqs620_pwm->duty_scale *
					 IQS620_PWM_PERIOD_NS, 256);

	mutex_unlock(&iqs620_pwm->lock);

	state->period = IQS620_PWM_PERIOD_NS;
पूर्ण

अटल पूर्णांक iqs620_pwm_notअगरier(काष्ठा notअगरier_block *notअगरier,
			       अचिन्हित दीर्घ event_flags, व्योम *context)
अणु
	काष्ठा iqs620_pwm_निजी *iqs620_pwm;
	पूर्णांक ret;

	अगर (!(event_flags & BIT(IQS62X_EVENT_SYS_RESET)))
		वापस NOTIFY_DONE;

	iqs620_pwm = container_of(notअगरier, काष्ठा iqs620_pwm_निजी,
				  notअगरier);

	mutex_lock(&iqs620_pwm->lock);

	/*
	 * The parent MFD driver alपढ़ोy prपूर्णांकs an error message in the event
	 * of a device reset, so nothing अन्यथा is prपूर्णांकed here unless there is
	 * an additional failure.
	 */
	ret = iqs620_pwm_init(iqs620_pwm, iqs620_pwm->duty_scale);

	mutex_unlock(&iqs620_pwm->lock);

	अगर (ret) अणु
		dev_err(iqs620_pwm->chip.dev,
			"Failed to re-initialize device: %d\n", ret);
		वापस NOTIFY_BAD;
	पूर्ण

	वापस NOTIFY_OK;
पूर्ण

अटल स्थिर काष्ठा pwm_ops iqs620_pwm_ops = अणु
	.apply = iqs620_pwm_apply,
	.get_state = iqs620_pwm_get_state,
	.owner = THIS_MODULE,
पूर्ण;

अटल व्योम iqs620_pwm_notअगरier_unरेजिस्टर(व्योम *context)
अणु
	काष्ठा iqs620_pwm_निजी *iqs620_pwm = context;
	पूर्णांक ret;

	ret = blocking_notअगरier_chain_unरेजिस्टर(&iqs620_pwm->iqs62x->nh,
						 &iqs620_pwm->notअगरier);
	अगर (ret)
		dev_err(iqs620_pwm->chip.dev,
			"Failed to unregister notifier: %d\n", ret);
पूर्ण

अटल पूर्णांक iqs620_pwm_probe(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा iqs62x_core *iqs62x = dev_get_drvdata(pdev->dev.parent);
	काष्ठा iqs620_pwm_निजी *iqs620_pwm;
	अचिन्हित पूर्णांक val;
	पूर्णांक ret;

	iqs620_pwm = devm_kzalloc(&pdev->dev, माप(*iqs620_pwm), GFP_KERNEL);
	अगर (!iqs620_pwm)
		वापस -ENOMEM;

	platक्रमm_set_drvdata(pdev, iqs620_pwm);
	iqs620_pwm->iqs62x = iqs62x;

	ret = regmap_पढ़ो(iqs62x->regmap, IQS620_PWR_SETTINGS, &val);
	अगर (ret)
		वापस ret;

	अगर (val & IQS620_PWR_SETTINGS_PWM_OUT) अणु
		ret = regmap_पढ़ो(iqs62x->regmap, IQS620_PWM_DUTY_CYCLE, &val);
		अगर (ret)
			वापस ret;

		iqs620_pwm->duty_scale = val + 1;
	पूर्ण

	iqs620_pwm->chip.dev = &pdev->dev;
	iqs620_pwm->chip.ops = &iqs620_pwm_ops;
	iqs620_pwm->chip.npwm = 1;

	mutex_init(&iqs620_pwm->lock);

	iqs620_pwm->notअगरier.notअगरier_call = iqs620_pwm_notअगरier;
	ret = blocking_notअगरier_chain_रेजिस्टर(&iqs620_pwm->iqs62x->nh,
					       &iqs620_pwm->notअगरier);
	अगर (ret) अणु
		dev_err(&pdev->dev, "Failed to register notifier: %d\n", ret);
		वापस ret;
	पूर्ण

	ret = devm_add_action_or_reset(&pdev->dev,
				       iqs620_pwm_notअगरier_unरेजिस्टर,
				       iqs620_pwm);
	अगर (ret)
		वापस ret;

	ret = pwmchip_add(&iqs620_pwm->chip);
	अगर (ret)
		dev_err(&pdev->dev, "Failed to add device: %d\n", ret);

	वापस ret;
पूर्ण

अटल पूर्णांक iqs620_pwm_हटाओ(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा iqs620_pwm_निजी *iqs620_pwm = platक्रमm_get_drvdata(pdev);
	पूर्णांक ret;

	ret = pwmchip_हटाओ(&iqs620_pwm->chip);
	अगर (ret)
		dev_err(&pdev->dev, "Failed to remove device: %d\n", ret);

	वापस ret;
पूर्ण

अटल काष्ठा platक्रमm_driver iqs620_pwm_platक्रमm_driver = अणु
	.driver = अणु
		.name = "iqs620a-pwm",
	पूर्ण,
	.probe = iqs620_pwm_probe,
	.हटाओ = iqs620_pwm_हटाओ,
पूर्ण;
module_platक्रमm_driver(iqs620_pwm_platक्रमm_driver);

MODULE_AUTHOR("Jeff LaBundy <jeff@labundy.com>");
MODULE_DESCRIPTION("Azoteq IQS620A PWM Generator");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:iqs620a-pwm");
