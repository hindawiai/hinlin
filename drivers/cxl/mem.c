<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/* Copyright(c) 2020 Intel Corporation. All rights reserved. */
#समावेश <uapi/linux/cxl_स्मृति.स>
#समावेश <linux/security.h>
#समावेश <linux/debugfs.h>
#समावेश <linux/module.h>
#समावेश <linux/sizes.h>
#समावेश <linux/mutex.h>
#समावेश <linux/cdev.h>
#समावेश <linux/idr.h>
#समावेश <linux/pci.h>
#समावेश <linux/पन.स>
#समावेश <linux/io-64-nonatomic-lo-hi.h>
#समावेश "pci.h"
#समावेश "cxl.h"

/**
 * DOC: cxl mem
 *
 * This implements a CXL memory device ("type-3") as it is defined by the
 * Compute Express Link specअगरication.
 *
 * The driver has several responsibilities, मुख्यly:
 *  - Create the memX device and रेजिस्टर on the CXL bus.
 *  - Enumerate device's रेजिस्टर पूर्णांकerface and map them.
 *  - Probe the device attributes to establish sysfs पूर्णांकerface.
 *  - Provide an IOCTL पूर्णांकerface to userspace to communicate with the device क्रम
 *    things like firmware update.
 *  - Support management of पूर्णांकerleave sets.
 *  - Handle and manage error conditions.
 */

/*
 * An entire PCI topology full of devices should be enough क्रम any
 * config
 */
#घोषणा CXL_MEM_MAX_DEVS 65536

#घोषणा cxl_करोorbell_busy(cxlm)                                                \
	(पढ़ोl((cxlm)->mbox_regs + CXLDEV_MBOX_CTRL_OFFSET) &                  \
	 CXLDEV_MBOX_CTRL_DOORBELL)

/* CXL 2.0 - 8.2.8.4 */
#घोषणा CXL_MAILBOX_TIMEOUT_MS (2 * HZ)

क्रमागत opcode अणु
	CXL_MBOX_OP_INVALID		= 0x0000,
	CXL_MBOX_OP_RAW			= CXL_MBOX_OP_INVALID,
	CXL_MBOX_OP_GET_FW_INFO		= 0x0200,
	CXL_MBOX_OP_ACTIVATE_FW		= 0x0202,
	CXL_MBOX_OP_GET_SUPPORTED_LOGS	= 0x0400,
	CXL_MBOX_OP_GET_LOG		= 0x0401,
	CXL_MBOX_OP_IDENTIFY		= 0x4000,
	CXL_MBOX_OP_GET_PARTITION_INFO	= 0x4100,
	CXL_MBOX_OP_SET_PARTITION_INFO	= 0x4101,
	CXL_MBOX_OP_GET_LSA		= 0x4102,
	CXL_MBOX_OP_SET_LSA		= 0x4103,
	CXL_MBOX_OP_GET_HEALTH_INFO	= 0x4200,
	CXL_MBOX_OP_SET_SHUTDOWN_STATE	= 0x4204,
	CXL_MBOX_OP_SCAN_MEDIA		= 0x4304,
	CXL_MBOX_OP_GET_SCAN_MEDIA	= 0x4305,
	CXL_MBOX_OP_MAX			= 0x10000
पूर्ण;

/**
 * काष्ठा mbox_cmd - A command to be submitted to hardware.
 * @opcode: (input) The command set and command submitted to hardware.
 * @payload_in: (input) Poपूर्णांकer to the input payload.
 * @payload_out: (output) Poपूर्णांकer to the output payload. Must be allocated by
 *		 the caller.
 * @size_in: (input) Number of bytes to load from @payload_in.
 * @size_out: (input) Max number of bytes loaded पूर्णांकo @payload_out.
 *            (output) Number of bytes generated by the device. For fixed size
 *            outमाला_दो commands this is always expected to be deterministic. For
 *            variable sized output commands, it tells the exact number of bytes
 *            written.
 * @वापस_code: (output) Error code वापसed from hardware.
 *
 * This is the primary mechanism used to send commands to the hardware.
 * All the fields except @payload_* correspond exactly to the fields described in
 * Command Register section of the CXL 2.0 8.2.8.4.5. @payload_in and
 * @payload_out are written to, and पढ़ो from the Command Payload Registers
 * defined in CXL 2.0 8.2.8.4.8.
 */
काष्ठा mbox_cmd अणु
	u16 opcode;
	व्योम *payload_in;
	व्योम *payload_out;
	माप_प्रकार size_in;
	माप_प्रकार size_out;
	u16 वापस_code;
#घोषणा CXL_MBOX_SUCCESS 0
पूर्ण;

/**
 * काष्ठा cxl_memdev - CXL bus object representing a Type-3 Memory Device
 * @dev: driver core device object
 * @cdev: अक्षर dev core object क्रम ioctl operations
 * @cxlm: poपूर्णांकer to the parent device driver data
 * @id: id number of this memdev instance.
 */
काष्ठा cxl_memdev अणु
	काष्ठा device dev;
	काष्ठा cdev cdev;
	काष्ठा cxl_mem *cxlm;
	पूर्णांक id;
पूर्ण;

अटल पूर्णांक cxl_mem_major;
अटल DEFINE_IDA(cxl_memdev_ida);
अटल DECLARE_RWSEM(cxl_memdev_rwsem);
अटल काष्ठा dentry *cxl_debugfs;
अटल bool cxl_raw_allow_all;

क्रमागत अणु
	CEL_UUID,
	VENDOR_DEBUG_UUID,
पूर्ण;

/* See CXL 2.0 Table 170. Get Log Input Payload */
अटल स्थिर uuid_t log_uuid[] = अणु
	[CEL_UUID] = UUID_INIT(0xda9c0b5, 0xbf41, 0x4b78, 0x8f, 0x79, 0x96,
			       0xb1, 0x62, 0x3b, 0x3f, 0x17),
	[VENDOR_DEBUG_UUID] = UUID_INIT(0xe1819d9, 0x11a9, 0x400c, 0x81, 0x1f,
					0xd6, 0x07, 0x19, 0x40, 0x3d, 0x86),
पूर्ण;

/**
 * काष्ठा cxl_mem_command - Driver representation of a memory device command
 * @info: Command inक्रमmation as it exists क्रम the UAPI
 * @opcode: The actual bits used क्रम the mailbox protocol
 * @flags: Set of flags effecting driver behavior.
 *
 *  * %CXL_CMD_FLAG_FORCE_ENABLE: In हालs of error, commands with this flag
 *    will be enabled by the driver regardless of what hardware may have
 *    advertised.
 *
 * The cxl_mem_command is the driver's पूर्णांकernal representation of commands that
 * are supported by the driver. Some of these commands may not be supported by
 * the hardware. The driver will use @info to validate the fields passed in by
 * the user then submit the @opcode to the hardware.
 *
 * See काष्ठा cxl_command_info.
 */
काष्ठा cxl_mem_command अणु
	काष्ठा cxl_command_info info;
	क्रमागत opcode opcode;
	u32 flags;
#घोषणा CXL_CMD_FLAG_NONE 0
#घोषणा CXL_CMD_FLAG_FORCE_ENABLE BIT(0)
पूर्ण;

#घोषणा CXL_CMD(_id, sin, sout, _flags)                                        \
	[CXL_MEM_COMMAND_ID_##_id] = अणु                                         \
	.info =	अणु                                                              \
			.id = CXL_MEM_COMMAND_ID_##_id,                        \
			.size_in = sin,                                        \
			.size_out = sout,                                      \
		पूर्ण,                                                             \
	.opcode = CXL_MBOX_OP_##_id,                                           \
	.flags = _flags,                                                       \
	पूर्ण

/*
 * This table defines the supported mailbox commands क्रम the driver. This table
 * is made up of a UAPI काष्ठाure. Non-negative values as parameters in the
 * table will be validated against the user's input. For example, अगर size_in is
 * 0, and the user passed in 1, it is an error.
 */
अटल काष्ठा cxl_mem_command mem_commands[CXL_MEM_COMMAND_ID_MAX] = अणु
	CXL_CMD(IDENTIFY, 0, 0x43, CXL_CMD_FLAG_FORCE_ENABLE),
#अगर_घोषित CONFIG_CXL_MEM_RAW_COMMANDS
	CXL_CMD(RAW, ~0, ~0, 0),
#पूर्ण_अगर
	CXL_CMD(GET_SUPPORTED_LOGS, 0, ~0, CXL_CMD_FLAG_FORCE_ENABLE),
	CXL_CMD(GET_FW_INFO, 0, 0x50, 0),
	CXL_CMD(GET_PARTITION_INFO, 0, 0x20, 0),
	CXL_CMD(GET_LSA, 0x8, ~0, 0),
	CXL_CMD(GET_HEALTH_INFO, 0, 0x12, 0),
	CXL_CMD(GET_LOG, 0x18, ~0, CXL_CMD_FLAG_FORCE_ENABLE),
पूर्ण;

/*
 * Commands that RAW करोesn't permit. The rationale क्रम each:
 *
 * CXL_MBOX_OP_ACTIVATE_FW: Firmware activation requires adjusपंचांगent /
 * coordination of transaction समयout values at the root bridge level.
 *
 * CXL_MBOX_OP_SET_PARTITION_INFO: The device memory map may change live
 * and needs to be coordinated with HDM updates.
 *
 * CXL_MBOX_OP_SET_LSA: The label storage area may be cached by the
 * driver and any ग_लिखोs from userspace invalidates those contents.
 *
 * CXL_MBOX_OP_SET_SHUTDOWN_STATE: Set shutकरोwn state assumes no ग_लिखोs
 * to the device after it is marked clean, userspace can not make that
 * निश्चितion.
 *
 * CXL_MBOX_OP_[GET_]SCAN_MEDIA: The kernel provides a native error list that
 * is kept up to date with patrol notअगरications and error management.
 */
अटल u16 cxl_disabled_raw_commands[] = अणु
	CXL_MBOX_OP_ACTIVATE_FW,
	CXL_MBOX_OP_SET_PARTITION_INFO,
	CXL_MBOX_OP_SET_LSA,
	CXL_MBOX_OP_SET_SHUTDOWN_STATE,
	CXL_MBOX_OP_SCAN_MEDIA,
	CXL_MBOX_OP_GET_SCAN_MEDIA,
पूर्ण;

/*
 * Command sets that RAW करोesn't permit. All opcodes in this set are
 * disabled because they pass plain text security payloads over the
 * user/kernel boundary. This functionality is पूर्णांकended to be wrapped
 * behind the keys ABI which allows क्रम encrypted payloads in the UAPI
 */
अटल u8 security_command_sets[] = अणु
	0x44, /* Sanitize */
	0x45, /* Persistent Memory Data-at-rest Security */
	0x46, /* Security Passthrough */
पूर्ण;

#घोषणा cxl_क्रम_each_cmd(cmd)                                                  \
	क्रम ((cmd) = &mem_commands[0];                                         \
	     ((cmd) - mem_commands) < ARRAY_SIZE(mem_commands); (cmd)++)

#घोषणा cxl_cmd_count ARRAY_SIZE(mem_commands)

अटल पूर्णांक cxl_mem_रुको_क्रम_करोorbell(काष्ठा cxl_mem *cxlm)
अणु
	स्थिर अचिन्हित दीर्घ start = jअगरfies;
	अचिन्हित दीर्घ end = start;

	जबतक (cxl_करोorbell_busy(cxlm)) अणु
		end = jअगरfies;

		अगर (समय_after(end, start + CXL_MAILBOX_TIMEOUT_MS)) अणु
			/* Check again in हाल preempted beक्रमe समयout test */
			अगर (!cxl_करोorbell_busy(cxlm))
				अवरोध;
			वापस -ETIMEDOUT;
		पूर्ण
		cpu_relax();
	पूर्ण

	dev_dbg(&cxlm->pdev->dev, "Doorbell wait took %dms",
		jअगरfies_to_msecs(end) - jअगरfies_to_msecs(start));
	वापस 0;
पूर्ण

अटल bool cxl_is_security_command(u16 opcode)
अणु
	पूर्णांक i;

	क्रम (i = 0; i < ARRAY_SIZE(security_command_sets); i++)
		अगर (security_command_sets[i] == (opcode >> 8))
			वापस true;
	वापस false;
पूर्ण

अटल व्योम cxl_mem_mbox_समयout(काष्ठा cxl_mem *cxlm,
				 काष्ठा mbox_cmd *mbox_cmd)
अणु
	काष्ठा device *dev = &cxlm->pdev->dev;

	dev_dbg(dev, "Mailbox command (opcode: %#x size: %zub) timed out\n",
		mbox_cmd->opcode, mbox_cmd->size_in);
पूर्ण

/**
 * __cxl_mem_mbox_send_cmd() - Execute a mailbox command
 * @cxlm: The CXL memory device to communicate with.
 * @mbox_cmd: Command to send to the memory device.
 *
 * Context: Any context. Expects mbox_mutex to be held.
 * Return: -ETIMEDOUT अगर समयout occurred रुकोing क्रम completion. 0 on success.
 *         Caller should check the वापस code in @mbox_cmd to make sure it
 *         succeeded.
 *
 * This is a generic क्रमm of the CXL mailbox send command thus only using the
 * रेजिस्टरs defined by the mailbox capability ID - CXL 2.0 8.2.8.4. Memory
 * devices, and perhaps other types of CXL devices may have further inक्रमmation
 * available upon error conditions. Driver facilities wishing to send mailbox
 * commands should use the wrapper command.
 *
 * The CXL spec allows क्रम up to two mailboxes. The पूर्णांकention is क्रम the primary
 * mailbox to be OS controlled and the secondary mailbox to be used by प्रणाली
 * firmware. This allows the OS and firmware to communicate with the device and
 * not need to coordinate with each other. The driver only uses the primary
 * mailbox.
 */
अटल पूर्णांक __cxl_mem_mbox_send_cmd(काष्ठा cxl_mem *cxlm,
				   काष्ठा mbox_cmd *mbox_cmd)
अणु
	व्योम __iomem *payload = cxlm->mbox_regs + CXLDEV_MBOX_PAYLOAD_OFFSET;
	u64 cmd_reg, status_reg;
	माप_प्रकार out_len;
	पूर्णांक rc;

	lockdep_निश्चित_held(&cxlm->mbox_mutex);

	/*
	 * Here are the steps from 8.2.8.4 of the CXL 2.0 spec.
	 *   1. Caller पढ़ोs MB Control Register to verअगरy करोorbell is clear
	 *   2. Caller ग_लिखोs Command Register
	 *   3. Caller ग_लिखोs Command Payload Registers अगर input payload is non-empty
	 *   4. Caller ग_लिखोs MB Control Register to set करोorbell
	 *   5. Caller either polls क्रम करोorbell to be clear or रुकोs क्रम पूर्णांकerrupt अगर configured
	 *   6. Caller पढ़ोs MB Status Register to fetch Return code
	 *   7. If command successful, Caller पढ़ोs Command Register to get Payload Length
	 *   8. If output payload is non-empty, host पढ़ोs Command Payload Registers
	 *
	 * Hardware is मुक्त to करो whatever it wants beक्रमe the करोorbell is rung,
	 * and isn't allowed to change anything after it clears the करोorbell. As
	 * such, steps 2 and 3 can happen in any order, and steps 6, 7, 8 can
	 * also happen in any order (though some orders might not make sense).
	 */

	/* #1 */
	अगर (cxl_करोorbell_busy(cxlm)) अणु
		dev_err_ratelimited(&cxlm->pdev->dev,
				    "Mailbox re-busy after acquiring\n");
		वापस -EBUSY;
	पूर्ण

	cmd_reg = FIELD_PREP(CXLDEV_MBOX_CMD_COMMAND_OPCODE_MASK,
			     mbox_cmd->opcode);
	अगर (mbox_cmd->size_in) अणु
		अगर (WARN_ON(!mbox_cmd->payload_in))
			वापस -EINVAL;

		cmd_reg |= FIELD_PREP(CXLDEV_MBOX_CMD_PAYLOAD_LENGTH_MASK,
				      mbox_cmd->size_in);
		स_नकल_toio(payload, mbox_cmd->payload_in, mbox_cmd->size_in);
	पूर्ण

	/* #2, #3 */
	ग_लिखोq(cmd_reg, cxlm->mbox_regs + CXLDEV_MBOX_CMD_OFFSET);

	/* #4 */
	dev_dbg(&cxlm->pdev->dev, "Sending command\n");
	ग_लिखोl(CXLDEV_MBOX_CTRL_DOORBELL,
	       cxlm->mbox_regs + CXLDEV_MBOX_CTRL_OFFSET);

	/* #5 */
	rc = cxl_mem_रुको_क्रम_करोorbell(cxlm);
	अगर (rc == -ETIMEDOUT) अणु
		cxl_mem_mbox_समयout(cxlm, mbox_cmd);
		वापस rc;
	पूर्ण

	/* #6 */
	status_reg = पढ़ोq(cxlm->mbox_regs + CXLDEV_MBOX_STATUS_OFFSET);
	mbox_cmd->वापस_code =
		FIELD_GET(CXLDEV_MBOX_STATUS_RET_CODE_MASK, status_reg);

	अगर (mbox_cmd->वापस_code != 0) अणु
		dev_dbg(&cxlm->pdev->dev, "Mailbox operation had an error\n");
		वापस 0;
	पूर्ण

	/* #7 */
	cmd_reg = पढ़ोq(cxlm->mbox_regs + CXLDEV_MBOX_CMD_OFFSET);
	out_len = FIELD_GET(CXLDEV_MBOX_CMD_PAYLOAD_LENGTH_MASK, cmd_reg);

	/* #8 */
	अगर (out_len && mbox_cmd->payload_out) अणु
		/*
		 * Sanitize the copy. If hardware misbehaves, out_len per the
		 * spec can actually be greater than the max allowed size (21
		 * bits available but spec defined 1M max). The caller also may
		 * have requested less data than the hardware supplied even
		 * within spec.
		 */
		माप_प्रकार n = min3(mbox_cmd->size_out, cxlm->payload_size, out_len);

		स_नकल_fromio(mbox_cmd->payload_out, payload, n);
		mbox_cmd->size_out = n;
	पूर्ण अन्यथा अणु
		mbox_cmd->size_out = 0;
	पूर्ण

	वापस 0;
पूर्ण

/**
 * cxl_mem_mbox_get() - Acquire exclusive access to the mailbox.
 * @cxlm: The memory device to gain access to.
 *
 * Context: Any context. Takes the mbox_mutex.
 * Return: 0 अगर exclusive access was acquired.
 */
अटल पूर्णांक cxl_mem_mbox_get(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा device *dev = &cxlm->pdev->dev;
	u64 md_status;
	पूर्णांक rc;

	mutex_lock_io(&cxlm->mbox_mutex);

	/*
	 * XXX: There is some amount of ambiguity in the 2.0 version of the spec
	 * around the mailbox पूर्णांकerface पढ़ोy (8.2.8.5.1.1).  The purpose of the
	 * bit is to allow firmware running on the device to notअगरy the driver
	 * that it's पढ़ोy to receive commands. It is unclear अगर the bit needs
	 * to be पढ़ो क्रम each transaction mailbox, ie. the firmware can चयन
	 * it on and off as needed. Second, there is no defined समयout क्रम
	 * mailbox पढ़ोy, like there is क्रम the करोorbell पूर्णांकerface.
	 *
	 * Assumptions:
	 * 1. The firmware might toggle the Mailbox Interface Ready bit, check
	 *    it क्रम every command.
	 *
	 * 2. If the करोorbell is clear, the firmware should have first set the
	 *    Mailbox Interface Ready bit. Thereक्रमe, रुकोing क्रम the करोorbell
	 *    to be पढ़ोy is sufficient.
	 */
	rc = cxl_mem_रुको_क्रम_करोorbell(cxlm);
	अगर (rc) अणु
		dev_warn(dev, "Mailbox interface not ready\n");
		जाओ out;
	पूर्ण

	md_status = पढ़ोq(cxlm->memdev_regs + CXLMDEV_STATUS_OFFSET);
	अगर (!(md_status & CXLMDEV_MBOX_IF_READY && CXLMDEV_READY(md_status))) अणु
		dev_err(dev, "mbox: reported doorbell ready, but not mbox ready\n");
		rc = -EBUSY;
		जाओ out;
	पूर्ण

	/*
	 * Hardware shouldn't allow a पढ़ोy status but also have failure bits
	 * set. Spit out an error, this should be a bug report
	 */
	rc = -EFAULT;
	अगर (md_status & CXLMDEV_DEV_FATAL) अणु
		dev_err(dev, "mbox: reported ready, but fatal\n");
		जाओ out;
	पूर्ण
	अगर (md_status & CXLMDEV_FW_HALT) अणु
		dev_err(dev, "mbox: reported ready, but halted\n");
		जाओ out;
	पूर्ण
	अगर (CXLMDEV_RESET_NEEDED(md_status)) अणु
		dev_err(dev, "mbox: reported ready, but reset needed\n");
		जाओ out;
	पूर्ण

	/* with lock held */
	वापस 0;

out:
	mutex_unlock(&cxlm->mbox_mutex);
	वापस rc;
पूर्ण

/**
 * cxl_mem_mbox_put() - Release exclusive access to the mailbox.
 * @cxlm: The CXL memory device to communicate with.
 *
 * Context: Any context. Expects mbox_mutex to be held.
 */
अटल व्योम cxl_mem_mbox_put(काष्ठा cxl_mem *cxlm)
अणु
	mutex_unlock(&cxlm->mbox_mutex);
पूर्ण

/**
 * handle_mailbox_cmd_from_user() - Dispatch a mailbox command क्रम userspace.
 * @cxlm: The CXL memory device to communicate with.
 * @cmd: The validated command.
 * @in_payload: Poपूर्णांकer to userspace's input payload.
 * @out_payload: Poपूर्णांकer to userspace's output payload.
 * @size_out: (Input) Max payload size to copy out.
 *            (Output) Payload size hardware generated.
 * @retval: Hardware generated वापस code from the operation.
 *
 * Return:
 *  * %0	- Mailbox transaction succeeded. This implies the mailbox
 *		  protocol completed successfully not that the operation itself
 *		  was successful.
 *  * %-ENOMEM  - Couldn't allocate a bounce buffer.
 *  * %-EFAULT	- Something happened with copy_to/from_user.
 *  * %-EINTR	- Mailbox acquisition पूर्णांकerrupted.
 *  * %-EXXX	- Transaction level failures.
 *
 * Creates the appropriate mailbox command and dispatches it on behalf of a
 * userspace request. The input and output payloads are copied between
 * userspace.
 *
 * See cxl_send_cmd().
 */
अटल पूर्णांक handle_mailbox_cmd_from_user(काष्ठा cxl_mem *cxlm,
					स्थिर काष्ठा cxl_mem_command *cmd,
					u64 in_payload, u64 out_payload,
					s32 *size_out, u32 *retval)
अणु
	काष्ठा device *dev = &cxlm->pdev->dev;
	काष्ठा mbox_cmd mbox_cmd = अणु
		.opcode = cmd->opcode,
		.size_in = cmd->info.size_in,
		.size_out = cmd->info.size_out,
	पूर्ण;
	पूर्णांक rc;

	अगर (cmd->info.size_out) अणु
		mbox_cmd.payload_out = kvzalloc(cmd->info.size_out, GFP_KERNEL);
		अगर (!mbox_cmd.payload_out)
			वापस -ENOMEM;
	पूर्ण

	अगर (cmd->info.size_in) अणु
		mbox_cmd.payload_in = vmemdup_user(u64_to_user_ptr(in_payload),
						   cmd->info.size_in);
		अगर (IS_ERR(mbox_cmd.payload_in)) अणु
			kvमुक्त(mbox_cmd.payload_out);
			वापस PTR_ERR(mbox_cmd.payload_in);
		पूर्ण
	पूर्ण

	rc = cxl_mem_mbox_get(cxlm);
	अगर (rc)
		जाओ out;

	dev_dbg(dev,
		"Submitting %s command for user\n"
		"\topcode: %x\n"
		"\tsize: %ub\n",
		cxl_command_names[cmd->info.id].name, mbox_cmd.opcode,
		cmd->info.size_in);

	dev_WARN_ONCE(dev, cmd->info.id == CXL_MEM_COMMAND_ID_RAW,
		      "raw command path used\n");

	rc = __cxl_mem_mbox_send_cmd(cxlm, &mbox_cmd);
	cxl_mem_mbox_put(cxlm);
	अगर (rc)
		जाओ out;

	/*
	 * @size_out contains the max size that's allowed to be written back out
	 * to userspace. While the payload may have written more output than
	 * this it will have to be ignored.
	 */
	अगर (mbox_cmd.size_out) अणु
		dev_WARN_ONCE(dev, mbox_cmd.size_out > *size_out,
			      "Invalid return size\n");
		अगर (copy_to_user(u64_to_user_ptr(out_payload),
				 mbox_cmd.payload_out, mbox_cmd.size_out)) अणु
			rc = -EFAULT;
			जाओ out;
		पूर्ण
	पूर्ण

	*size_out = mbox_cmd.size_out;
	*retval = mbox_cmd.वापस_code;

out:
	kvमुक्त(mbox_cmd.payload_in);
	kvमुक्त(mbox_cmd.payload_out);
	वापस rc;
पूर्ण

अटल bool cxl_mem_raw_command_allowed(u16 opcode)
अणु
	पूर्णांक i;

	अगर (!IS_ENABLED(CONFIG_CXL_MEM_RAW_COMMANDS))
		वापस false;

	अगर (security_locked_करोwn(LOCKDOWN_NONE))
		वापस false;

	अगर (cxl_raw_allow_all)
		वापस true;

	अगर (cxl_is_security_command(opcode))
		वापस false;

	क्रम (i = 0; i < ARRAY_SIZE(cxl_disabled_raw_commands); i++)
		अगर (cxl_disabled_raw_commands[i] == opcode)
			वापस false;

	वापस true;
पूर्ण

/**
 * cxl_validate_cmd_from_user() - Check fields क्रम CXL_MEM_SEND_COMMAND.
 * @cxlm: &काष्ठा cxl_mem device whose mailbox will be used.
 * @send_cmd: &काष्ठा cxl_send_command copied in from userspace.
 * @out_cmd: Sanitized and populated &काष्ठा cxl_mem_command.
 *
 * Return:
 *  * %0	- @out_cmd is पढ़ोy to send.
 *  * %-ENOTTY	- Invalid command specअगरied.
 *  * %-EINVAL	- Reserved fields or invalid values were used.
 *  * %-ENOMEM	- Input or output buffer wasn't sized properly.
 *  * %-EPERM	- Attempted to use a रक्षित command.
 *
 * The result of this command is a fully validated command in @out_cmd that is
 * safe to send to the hardware.
 *
 * See handle_mailbox_cmd_from_user()
 */
अटल पूर्णांक cxl_validate_cmd_from_user(काष्ठा cxl_mem *cxlm,
				      स्थिर काष्ठा cxl_send_command *send_cmd,
				      काष्ठा cxl_mem_command *out_cmd)
अणु
	स्थिर काष्ठा cxl_command_info *info;
	काष्ठा cxl_mem_command *c;

	अगर (send_cmd->id == 0 || send_cmd->id >= CXL_MEM_COMMAND_ID_MAX)
		वापस -ENOTTY;

	/*
	 * The user can never specअगरy an input payload larger than what hardware
	 * supports, but output can be arbitrarily large (simply ग_लिखो out as
	 * much data as the hardware provides).
	 */
	अगर (send_cmd->in.size > cxlm->payload_size)
		वापस -EINVAL;

	/*
	 * Checks are bypassed क्रम raw commands but a WARN/taपूर्णांक will occur
	 * later in the callchain
	 */
	अगर (send_cmd->id == CXL_MEM_COMMAND_ID_RAW) अणु
		स्थिर काष्ठा cxl_mem_command temp = अणु
			.info = अणु
				.id = CXL_MEM_COMMAND_ID_RAW,
				.flags = 0,
				.size_in = send_cmd->in.size,
				.size_out = send_cmd->out.size,
			पूर्ण,
			.opcode = send_cmd->raw.opcode
		पूर्ण;

		अगर (send_cmd->raw.rsvd)
			वापस -EINVAL;

		/*
		 * Unlike supported commands, the output size of RAW commands
		 * माला_लो passed aदीर्घ without further checking, so it must be
		 * validated here.
		 */
		अगर (send_cmd->out.size > cxlm->payload_size)
			वापस -EINVAL;

		अगर (!cxl_mem_raw_command_allowed(send_cmd->raw.opcode))
			वापस -EPERM;

		स_नकल(out_cmd, &temp, माप(temp));

		वापस 0;
	पूर्ण

	अगर (send_cmd->flags & ~CXL_MEM_COMMAND_FLAG_MASK)
		वापस -EINVAL;

	अगर (send_cmd->rsvd)
		वापस -EINVAL;

	अगर (send_cmd->in.rsvd || send_cmd->out.rsvd)
		वापस -EINVAL;

	/* Convert user's command पूर्णांकo the पूर्णांकernal representation */
	c = &mem_commands[send_cmd->id];
	info = &c->info;

	/* Check that the command is enabled क्रम hardware */
	अगर (!test_bit(info->id, cxlm->enabled_cmds))
		वापस -ENOTTY;

	/* Check the input buffer is the expected size */
	अगर (info->size_in >= 0 && info->size_in != send_cmd->in.size)
		वापस -ENOMEM;

	/* Check the output buffer is at least large enough */
	अगर (info->size_out >= 0 && send_cmd->out.size < info->size_out)
		वापस -ENOMEM;

	स_नकल(out_cmd, c, माप(*c));
	out_cmd->info.size_in = send_cmd->in.size;
	/*
	 * XXX: out_cmd->info.size_out will be controlled by the driver, and the
	 * specअगरied number of bytes @send_cmd->out.size will be copied back out
	 * to userspace.
	 */

	वापस 0;
पूर्ण

अटल पूर्णांक cxl_query_cmd(काष्ठा cxl_memdev *cxlmd,
			 काष्ठा cxl_mem_query_commands __user *q)
अणु
	काष्ठा device *dev = &cxlmd->dev;
	काष्ठा cxl_mem_command *cmd;
	u32 n_commands;
	पूर्णांक j = 0;

	dev_dbg(dev, "Query IOCTL\n");

	अगर (get_user(n_commands, &q->n_commands))
		वापस -EFAULT;

	/* वापसs the total number अगर 0 elements are requested. */
	अगर (n_commands == 0)
		वापस put_user(cxl_cmd_count, &q->n_commands);

	/*
	 * otherwise, वापस max(n_commands, total commands) cxl_command_info
	 * काष्ठाures.
	 */
	cxl_क्रम_each_cmd(cmd) अणु
		स्थिर काष्ठा cxl_command_info *info = &cmd->info;

		अगर (copy_to_user(&q->commands[j++], info, माप(*info)))
			वापस -EFAULT;

		अगर (j == n_commands)
			अवरोध;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक cxl_send_cmd(काष्ठा cxl_memdev *cxlmd,
			काष्ठा cxl_send_command __user *s)
अणु
	काष्ठा cxl_mem *cxlm = cxlmd->cxlm;
	काष्ठा device *dev = &cxlmd->dev;
	काष्ठा cxl_send_command send;
	काष्ठा cxl_mem_command c;
	पूर्णांक rc;

	dev_dbg(dev, "Send IOCTL\n");

	अगर (copy_from_user(&send, s, माप(send)))
		वापस -EFAULT;

	rc = cxl_validate_cmd_from_user(cxlmd->cxlm, &send, &c);
	अगर (rc)
		वापस rc;

	/* Prepare to handle a full payload क्रम variable sized output */
	अगर (c.info.size_out < 0)
		c.info.size_out = cxlm->payload_size;

	rc = handle_mailbox_cmd_from_user(cxlm, &c, send.in.payload,
					  send.out.payload, &send.out.size,
					  &send.retval);
	अगर (rc)
		वापस rc;

	अगर (copy_to_user(s, &send, माप(send)))
		वापस -EFAULT;

	वापस 0;
पूर्ण

अटल दीर्घ __cxl_memdev_ioctl(काष्ठा cxl_memdev *cxlmd, अचिन्हित पूर्णांक cmd,
			       अचिन्हित दीर्घ arg)
अणु
	चयन (cmd) अणु
	हाल CXL_MEM_QUERY_COMMANDS:
		वापस cxl_query_cmd(cxlmd, (व्योम __user *)arg);
	हाल CXL_MEM_SEND_COMMAND:
		वापस cxl_send_cmd(cxlmd, (व्योम __user *)arg);
	शेष:
		वापस -ENOTTY;
	पूर्ण
पूर्ण

अटल दीर्घ cxl_memdev_ioctl(काष्ठा file *file, अचिन्हित पूर्णांक cmd,
			     अचिन्हित दीर्घ arg)
अणु
	काष्ठा cxl_memdev *cxlmd = file->निजी_data;
	पूर्णांक rc = -ENXIO;

	करोwn_पढ़ो(&cxl_memdev_rwsem);
	अगर (cxlmd->cxlm)
		rc = __cxl_memdev_ioctl(cxlmd, cmd, arg);
	up_पढ़ो(&cxl_memdev_rwsem);

	वापस rc;
पूर्ण

अटल पूर्णांक cxl_memdev_खोलो(काष्ठा inode *inode, काष्ठा file *file)
अणु
	काष्ठा cxl_memdev *cxlmd =
		container_of(inode->i_cdev, typeof(*cxlmd), cdev);

	get_device(&cxlmd->dev);
	file->निजी_data = cxlmd;

	वापस 0;
पूर्ण

अटल पूर्णांक cxl_memdev_release_file(काष्ठा inode *inode, काष्ठा file *file)
अणु
	काष्ठा cxl_memdev *cxlmd =
		container_of(inode->i_cdev, typeof(*cxlmd), cdev);

	put_device(&cxlmd->dev);

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा file_operations cxl_memdev_fops = अणु
	.owner = THIS_MODULE,
	.unlocked_ioctl = cxl_memdev_ioctl,
	.खोलो = cxl_memdev_खोलो,
	.release = cxl_memdev_release_file,
	.compat_ioctl = compat_ptr_ioctl,
	.llseek = noop_llseek,
पूर्ण;

अटल अंतरभूत काष्ठा cxl_mem_command *cxl_mem_find_command(u16 opcode)
अणु
	काष्ठा cxl_mem_command *c;

	cxl_क्रम_each_cmd(c)
		अगर (c->opcode == opcode)
			वापस c;

	वापस शून्य;
पूर्ण

/**
 * cxl_mem_mbox_send_cmd() - Send a mailbox command to a memory device.
 * @cxlm: The CXL memory device to communicate with.
 * @opcode: Opcode क्रम the mailbox command.
 * @in: The input payload क्रम the mailbox command.
 * @in_size: The length of the input payload
 * @out: Caller allocated buffer क्रम the output.
 * @out_size: Expected size of output.
 *
 * Context: Any context. Will acquire and release mbox_mutex.
 * Return:
 *  * %>=0	- Number of bytes वापसed in @out.
 *  * %-E2BIG	- Payload is too large क्रम hardware.
 *  * %-EBUSY	- Couldn't acquire exclusive mailbox access.
 *  * %-EFAULT	- Hardware error occurred.
 *  * %-ENXIO	- Command completed, but device reported an error.
 *  * %-EIO	- Unexpected output size.
 *
 * Mailbox commands may execute successfully yet the device itself reported an
 * error. While this distinction can be useful क्रम commands from userspace, the
 * kernel will only be able to use results when both are successful.
 *
 * See __cxl_mem_mbox_send_cmd()
 */
अटल पूर्णांक cxl_mem_mbox_send_cmd(काष्ठा cxl_mem *cxlm, u16 opcode,
				 व्योम *in, माप_प्रकार in_size,
				 व्योम *out, माप_प्रकार out_size)
अणु
	स्थिर काष्ठा cxl_mem_command *cmd = cxl_mem_find_command(opcode);
	काष्ठा mbox_cmd mbox_cmd = अणु
		.opcode = opcode,
		.payload_in = in,
		.size_in = in_size,
		.size_out = out_size,
		.payload_out = out,
	पूर्ण;
	पूर्णांक rc;

	अगर (out_size > cxlm->payload_size)
		वापस -E2BIG;

	rc = cxl_mem_mbox_get(cxlm);
	अगर (rc)
		वापस rc;

	rc = __cxl_mem_mbox_send_cmd(cxlm, &mbox_cmd);
	cxl_mem_mbox_put(cxlm);
	अगर (rc)
		वापस rc;

	/* TODO: Map वापस code to proper kernel style त्रुटि_सं */
	अगर (mbox_cmd.वापस_code != CXL_MBOX_SUCCESS)
		वापस -ENXIO;

	/*
	 * Variable sized commands can't be validated and so it's up to the
	 * caller to करो that अगर they wish.
	 */
	अगर (cmd->info.size_out >= 0 && mbox_cmd.size_out != out_size)
		वापस -EIO;

	वापस 0;
पूर्ण

/**
 * cxl_mem_setup_regs() - Setup necessary MMIO.
 * @cxlm: The CXL memory device to communicate with.
 *
 * Return: 0 अगर all necessary रेजिस्टरs mapped.
 *
 * A memory device is required by spec to implement a certain set of MMIO
 * regions. The purpose of this function is to क्रमागतerate and map those
 * रेजिस्टरs.
 */
अटल पूर्णांक cxl_mem_setup_regs(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा device *dev = &cxlm->pdev->dev;
	पूर्णांक cap, cap_count;
	u64 cap_array;

	cap_array = पढ़ोq(cxlm->regs + CXLDEV_CAP_ARRAY_OFFSET);
	अगर (FIELD_GET(CXLDEV_CAP_ARRAY_ID_MASK, cap_array) !=
	    CXLDEV_CAP_ARRAY_CAP_ID)
		वापस -ENODEV;

	cap_count = FIELD_GET(CXLDEV_CAP_ARRAY_COUNT_MASK, cap_array);

	क्रम (cap = 1; cap <= cap_count; cap++) अणु
		व्योम __iomem *रेजिस्टर_block;
		u32 offset;
		u16 cap_id;

		cap_id = FIELD_GET(CXLDEV_CAP_HDR_CAP_ID_MASK,
				   पढ़ोl(cxlm->regs + cap * 0x10));
		offset = पढ़ोl(cxlm->regs + cap * 0x10 + 0x4);
		रेजिस्टर_block = cxlm->regs + offset;

		चयन (cap_id) अणु
		हाल CXLDEV_CAP_CAP_ID_DEVICE_STATUS:
			dev_dbg(dev, "found Status capability (0x%x)\n", offset);
			cxlm->status_regs = रेजिस्टर_block;
			अवरोध;
		हाल CXLDEV_CAP_CAP_ID_PRIMARY_MAILBOX:
			dev_dbg(dev, "found Mailbox capability (0x%x)\n", offset);
			cxlm->mbox_regs = रेजिस्टर_block;
			अवरोध;
		हाल CXLDEV_CAP_CAP_ID_SECONDARY_MAILBOX:
			dev_dbg(dev, "found Secondary Mailbox capability (0x%x)\n", offset);
			अवरोध;
		हाल CXLDEV_CAP_CAP_ID_MEMDEV:
			dev_dbg(dev, "found Memory Device capability (0x%x)\n", offset);
			cxlm->memdev_regs = रेजिस्टर_block;
			अवरोध;
		शेष:
			dev_dbg(dev, "Unknown cap ID: %d (0x%x)\n", cap_id, offset);
			अवरोध;
		पूर्ण
	पूर्ण

	अगर (!cxlm->status_regs || !cxlm->mbox_regs || !cxlm->memdev_regs) अणु
		dev_err(dev, "registers not found: %s%s%s\n",
			!cxlm->status_regs ? "status " : "",
			!cxlm->mbox_regs ? "mbox " : "",
			!cxlm->memdev_regs ? "memdev" : "");
		वापस -ENXIO;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक cxl_mem_setup_mailbox(काष्ठा cxl_mem *cxlm)
अणु
	स्थिर पूर्णांक cap = पढ़ोl(cxlm->mbox_regs + CXLDEV_MBOX_CAPS_OFFSET);

	cxlm->payload_size =
		1 << FIELD_GET(CXLDEV_MBOX_CAP_PAYLOAD_SIZE_MASK, cap);

	/*
	 * CXL 2.0 8.2.8.4.3 Mailbox Capabilities Register
	 *
	 * If the size is too small, mandatory commands will not work and so
	 * there's no point in going forward. If the size is too large, there's
	 * no harm is soft limiting it.
	 */
	cxlm->payload_size = min_t(माप_प्रकार, cxlm->payload_size, SZ_1M);
	अगर (cxlm->payload_size < 256) अणु
		dev_err(&cxlm->pdev->dev, "Mailbox is too small (%zub)",
			cxlm->payload_size);
		वापस -ENXIO;
	पूर्ण

	dev_dbg(&cxlm->pdev->dev, "Mailbox payload sized %zu",
		cxlm->payload_size);

	वापस 0;
पूर्ण

अटल काष्ठा cxl_mem *cxl_mem_create(काष्ठा pci_dev *pdev, u32 reg_lo,
				      u32 reg_hi)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा cxl_mem *cxlm;
	व्योम __iomem *regs;
	u64 offset;
	u8 bar;
	पूर्णांक rc;

	cxlm = devm_kzalloc(&pdev->dev, माप(*cxlm), GFP_KERNEL);
	अगर (!cxlm) अणु
		dev_err(dev, "No memory available\n");
		वापस शून्य;
	पूर्ण

	offset = ((u64)reg_hi << 32) | (reg_lo & CXL_REGLOC_ADDR_MASK);
	bar = FIELD_GET(CXL_REGLOC_BIR_MASK, reg_lo);

	/* Basic sanity check that BAR is big enough */
	अगर (pci_resource_len(pdev, bar) < offset) अणु
		dev_err(dev, "BAR%d: %pr: too small (offset: %#llx)\n", bar,
			&pdev->resource[bar], (अचिन्हित दीर्घ दीर्घ)offset);
		वापस शून्य;
	पूर्ण

	rc = pcim_iomap_regions(pdev, BIT(bar), pci_name(pdev));
	अगर (rc) अणु
		dev_err(dev, "failed to map registers\n");
		वापस शून्य;
	पूर्ण
	regs = pcim_iomap_table(pdev)[bar];

	mutex_init(&cxlm->mbox_mutex);
	cxlm->pdev = pdev;
	cxlm->regs = regs + offset;
	cxlm->enabled_cmds =
		devm_kदो_स्मृति_array(dev, BITS_TO_LONGS(cxl_cmd_count),
				   माप(अचिन्हित दीर्घ),
				   GFP_KERNEL | __GFP_ZERO);
	अगर (!cxlm->enabled_cmds) अणु
		dev_err(dev, "No memory available for bitmap\n");
		वापस शून्य;
	पूर्ण

	dev_dbg(dev, "Mapped CXL Memory Device resource\n");
	वापस cxlm;
पूर्ण

अटल पूर्णांक cxl_mem_dvsec(काष्ठा pci_dev *pdev, पूर्णांक dvsec)
अणु
	पूर्णांक pos;

	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DVSEC);
	अगर (!pos)
		वापस 0;

	जबतक (pos) अणु
		u16 venकरोr, id;

		pci_पढ़ो_config_word(pdev, pos + PCI_DVSEC_HEADER1, &venकरोr);
		pci_पढ़ो_config_word(pdev, pos + PCI_DVSEC_HEADER2, &id);
		अगर (venकरोr == PCI_DVSEC_VENDOR_ID_CXL && dvsec == id)
			वापस pos;

		pos = pci_find_next_ext_capability(pdev, pos,
						   PCI_EXT_CAP_ID_DVSEC);
	पूर्ण

	वापस 0;
पूर्ण

अटल काष्ठा cxl_memdev *to_cxl_memdev(काष्ठा device *dev)
अणु
	वापस container_of(dev, काष्ठा cxl_memdev, dev);
पूर्ण

अटल व्योम cxl_memdev_release(काष्ठा device *dev)
अणु
	काष्ठा cxl_memdev *cxlmd = to_cxl_memdev(dev);

	ida_मुक्त(&cxl_memdev_ida, cxlmd->id);
	kमुक्त(cxlmd);
पूर्ण

अटल अक्षर *cxl_memdev_devnode(काष्ठा device *dev, umode_t *mode, kuid_t *uid,
				kgid_t *gid)
अणु
	वापस kaप्र_लिखो(GFP_KERNEL, "cxl/%s", dev_name(dev));
पूर्ण

अटल sमाप_प्रकार firmware_version_show(काष्ठा device *dev,
				     काष्ठा device_attribute *attr, अक्षर *buf)
अणु
	काष्ठा cxl_memdev *cxlmd = to_cxl_memdev(dev);
	काष्ठा cxl_mem *cxlm = cxlmd->cxlm;

	वापस sysfs_emit(buf, "%.16s\n", cxlm->firmware_version);
पूर्ण
अटल DEVICE_ATTR_RO(firmware_version);

अटल sमाप_प्रकार payload_max_show(काष्ठा device *dev,
				काष्ठा device_attribute *attr, अक्षर *buf)
अणु
	काष्ठा cxl_memdev *cxlmd = to_cxl_memdev(dev);
	काष्ठा cxl_mem *cxlm = cxlmd->cxlm;

	वापस sysfs_emit(buf, "%zu\n", cxlm->payload_size);
पूर्ण
अटल DEVICE_ATTR_RO(payload_max);

अटल sमाप_प्रकार ram_size_show(काष्ठा device *dev, काष्ठा device_attribute *attr,
			     अक्षर *buf)
अणु
	काष्ठा cxl_memdev *cxlmd = to_cxl_memdev(dev);
	काष्ठा cxl_mem *cxlm = cxlmd->cxlm;
	अचिन्हित दीर्घ दीर्घ len = range_len(&cxlm->ram_range);

	वापस sysfs_emit(buf, "%#llx\n", len);
पूर्ण

अटल काष्ठा device_attribute dev_attr_ram_size =
	__ATTR(size, 0444, ram_size_show, शून्य);

अटल sमाप_प्रकार pmem_size_show(काष्ठा device *dev, काष्ठा device_attribute *attr,
			      अक्षर *buf)
अणु
	काष्ठा cxl_memdev *cxlmd = to_cxl_memdev(dev);
	काष्ठा cxl_mem *cxlm = cxlmd->cxlm;
	अचिन्हित दीर्घ दीर्घ len = range_len(&cxlm->pmem_range);

	वापस sysfs_emit(buf, "%#llx\n", len);
पूर्ण

अटल काष्ठा device_attribute dev_attr_pmem_size =
	__ATTR(size, 0444, pmem_size_show, शून्य);

अटल काष्ठा attribute *cxl_memdev_attributes[] = अणु
	&dev_attr_firmware_version.attr,
	&dev_attr_payload_max.attr,
	शून्य,
पूर्ण;

अटल काष्ठा attribute *cxl_memdev_pmem_attributes[] = अणु
	&dev_attr_pmem_size.attr,
	शून्य,
पूर्ण;

अटल काष्ठा attribute *cxl_memdev_ram_attributes[] = अणु
	&dev_attr_ram_size.attr,
	शून्य,
पूर्ण;

अटल काष्ठा attribute_group cxl_memdev_attribute_group = अणु
	.attrs = cxl_memdev_attributes,
पूर्ण;

अटल काष्ठा attribute_group cxl_memdev_ram_attribute_group = अणु
	.name = "ram",
	.attrs = cxl_memdev_ram_attributes,
पूर्ण;

अटल काष्ठा attribute_group cxl_memdev_pmem_attribute_group = अणु
	.name = "pmem",
	.attrs = cxl_memdev_pmem_attributes,
पूर्ण;

अटल स्थिर काष्ठा attribute_group *cxl_memdev_attribute_groups[] = अणु
	&cxl_memdev_attribute_group,
	&cxl_memdev_ram_attribute_group,
	&cxl_memdev_pmem_attribute_group,
	शून्य,
पूर्ण;

अटल स्थिर काष्ठा device_type cxl_memdev_type = अणु
	.name = "cxl_memdev",
	.release = cxl_memdev_release,
	.devnode = cxl_memdev_devnode,
	.groups = cxl_memdev_attribute_groups,
पूर्ण;

अटल व्योम cxl_memdev_shutकरोwn(काष्ठा cxl_memdev *cxlmd)
अणु
	करोwn_ग_लिखो(&cxl_memdev_rwsem);
	cxlmd->cxlm = शून्य;
	up_ग_लिखो(&cxl_memdev_rwsem);
पूर्ण

अटल व्योम cxl_memdev_unरेजिस्टर(व्योम *_cxlmd)
अणु
	काष्ठा cxl_memdev *cxlmd = _cxlmd;
	काष्ठा device *dev = &cxlmd->dev;

	cdev_device_del(&cxlmd->cdev, dev);
	cxl_memdev_shutकरोwn(cxlmd);
	put_device(dev);
पूर्ण

अटल काष्ठा cxl_memdev *cxl_memdev_alloc(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा pci_dev *pdev = cxlm->pdev;
	काष्ठा cxl_memdev *cxlmd;
	काष्ठा device *dev;
	काष्ठा cdev *cdev;
	पूर्णांक rc;

	cxlmd = kzalloc(माप(*cxlmd), GFP_KERNEL);
	अगर (!cxlmd)
		वापस ERR_PTR(-ENOMEM);

	rc = ida_alloc_range(&cxl_memdev_ida, 0, CXL_MEM_MAX_DEVS, GFP_KERNEL);
	अगर (rc < 0)
		जाओ err;
	cxlmd->id = rc;

	dev = &cxlmd->dev;
	device_initialize(dev);
	dev->parent = &pdev->dev;
	dev->bus = &cxl_bus_type;
	dev->devt = MKDEV(cxl_mem_major, cxlmd->id);
	dev->type = &cxl_memdev_type;
	device_set_pm_not_required(dev);

	cdev = &cxlmd->cdev;
	cdev_init(cdev, &cxl_memdev_fops);
	वापस cxlmd;

err:
	kमुक्त(cxlmd);
	वापस ERR_PTR(rc);
पूर्ण

अटल पूर्णांक cxl_mem_add_memdev(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा cxl_memdev *cxlmd;
	काष्ठा device *dev;
	काष्ठा cdev *cdev;
	पूर्णांक rc;

	cxlmd = cxl_memdev_alloc(cxlm);
	अगर (IS_ERR(cxlmd))
		वापस PTR_ERR(cxlmd);

	dev = &cxlmd->dev;
	rc = dev_set_name(dev, "mem%d", cxlmd->id);
	अगर (rc)
		जाओ err;

	/*
	 * Activate ioctl operations, no cxl_memdev_rwsem manipulation
	 * needed as this is ordered with cdev_add() publishing the device.
	 */
	cxlmd->cxlm = cxlm;

	cdev = &cxlmd->cdev;
	rc = cdev_device_add(cdev, dev);
	अगर (rc)
		जाओ err;

	वापस devm_add_action_or_reset(dev->parent, cxl_memdev_unरेजिस्टर,
					cxlmd);

err:
	/*
	 * The cdev was briefly live, shutकरोwn any ioctl operations that
	 * saw that state.
	 */
	cxl_memdev_shutकरोwn(cxlmd);
	put_device(dev);
	वापस rc;
पूर्ण

अटल पूर्णांक cxl_xfer_log(काष्ठा cxl_mem *cxlm, uuid_t *uuid, u32 size, u8 *out)
अणु
	u32 reमुख्यing = size;
	u32 offset = 0;

	जबतक (reमुख्यing) अणु
		u32 xfer_size = min_t(u32, reमुख्यing, cxlm->payload_size);
		काष्ठा cxl_mbox_get_log अणु
			uuid_t uuid;
			__le32 offset;
			__le32 length;
		पूर्ण __packed log = अणु
			.uuid = *uuid,
			.offset = cpu_to_le32(offset),
			.length = cpu_to_le32(xfer_size)
		पूर्ण;
		पूर्णांक rc;

		rc = cxl_mem_mbox_send_cmd(cxlm, CXL_MBOX_OP_GET_LOG, &log,
					   माप(log), out, xfer_size);
		अगर (rc < 0)
			वापस rc;

		out += xfer_size;
		reमुख्यing -= xfer_size;
		offset += xfer_size;
	पूर्ण

	वापस 0;
पूर्ण

/**
 * cxl_walk_cel() - Walk through the Command Effects Log.
 * @cxlm: Device.
 * @size: Length of the Command Effects Log.
 * @cel: CEL
 *
 * Iterate over each entry in the CEL and determine अगर the driver supports the
 * command. If so, the command is enabled क्रम the device and can be used later.
 */
अटल व्योम cxl_walk_cel(काष्ठा cxl_mem *cxlm, माप_प्रकार size, u8 *cel)
अणु
	काष्ठा cel_entry अणु
		__le16 opcode;
		__le16 effect;
	पूर्ण __packed * cel_entry;
	स्थिर पूर्णांक cel_entries = size / माप(*cel_entry);
	पूर्णांक i;

	cel_entry = (काष्ठा cel_entry *)cel;

	क्रम (i = 0; i < cel_entries; i++) अणु
		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
		काष्ठा cxl_mem_command *cmd = cxl_mem_find_command(opcode);

		अगर (!cmd) अणु
			dev_dbg(&cxlm->pdev->dev,
				"Opcode 0x%04x unsupported by driver", opcode);
			जारी;
		पूर्ण

		set_bit(cmd->info.id, cxlm->enabled_cmds);
	पूर्ण
पूर्ण

काष्ठा cxl_mbox_get_supported_logs अणु
	__le16 entries;
	u8 rsvd[6];
	काष्ठा gsl_entry अणु
		uuid_t uuid;
		__le32 size;
	पूर्ण __packed entry[];
पूर्ण __packed;

अटल काष्ठा cxl_mbox_get_supported_logs *cxl_get_gsl(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा cxl_mbox_get_supported_logs *ret;
	पूर्णांक rc;

	ret = kvदो_स्मृति(cxlm->payload_size, GFP_KERNEL);
	अगर (!ret)
		वापस ERR_PTR(-ENOMEM);

	rc = cxl_mem_mbox_send_cmd(cxlm, CXL_MBOX_OP_GET_SUPPORTED_LOGS, शून्य,
				   0, ret, cxlm->payload_size);
	अगर (rc < 0) अणु
		kvमुक्त(ret);
		वापस ERR_PTR(rc);
	पूर्ण

	वापस ret;
पूर्ण

/**
 * cxl_mem_क्रमागतerate_cmds() - Enumerate commands क्रम a device.
 * @cxlm: The device.
 *
 * Returns 0 अगर क्रमागतerate completed successfully.
 *
 * CXL devices have optional support क्रम certain commands. This function will
 * determine the set of supported commands क्रम the hardware and update the
 * enabled_cmds biपंचांगap in the @cxlm.
 */
अटल पूर्णांक cxl_mem_क्रमागतerate_cmds(काष्ठा cxl_mem *cxlm)
अणु
	काष्ठा cxl_mbox_get_supported_logs *gsl;
	काष्ठा device *dev = &cxlm->pdev->dev;
	काष्ठा cxl_mem_command *cmd;
	पूर्णांक i, rc;

	gsl = cxl_get_gsl(cxlm);
	अगर (IS_ERR(gsl))
		वापस PTR_ERR(gsl);

	rc = -ENOENT;
	क्रम (i = 0; i < le16_to_cpu(gsl->entries); i++) अणु
		u32 size = le32_to_cpu(gsl->entry[i].size);
		uuid_t uuid = gsl->entry[i].uuid;
		u8 *log;

		dev_dbg(dev, "Found LOG type %pU of size %d", &uuid, size);

		अगर (!uuid_equal(&uuid, &log_uuid[CEL_UUID]))
			जारी;

		log = kvदो_स्मृति(size, GFP_KERNEL);
		अगर (!log) अणु
			rc = -ENOMEM;
			जाओ out;
		पूर्ण

		rc = cxl_xfer_log(cxlm, &uuid, size, log);
		अगर (rc) अणु
			kvमुक्त(log);
			जाओ out;
		पूर्ण

		cxl_walk_cel(cxlm, size, log);
		kvमुक्त(log);

		/* In हाल CEL was bogus, enable some शेष commands. */
		cxl_क्रम_each_cmd(cmd)
			अगर (cmd->flags & CXL_CMD_FLAG_FORCE_ENABLE)
				set_bit(cmd->info.id, cxlm->enabled_cmds);

		/* Found the required CEL */
		rc = 0;
	पूर्ण

out:
	kvमुक्त(gsl);
	वापस rc;
पूर्ण

/**
 * cxl_mem_identअगरy() - Send the IDENTIFY command to the device.
 * @cxlm: The device to identअगरy.
 *
 * Return: 0 अगर identअगरy was executed successfully.
 *
 * This will dispatch the identअगरy command to the device and on success populate
 * काष्ठाures to be exported to sysfs.
 */
अटल पूर्णांक cxl_mem_identअगरy(काष्ठा cxl_mem *cxlm)
अणु
	/* See CXL 2.0 Table 175 Identअगरy Memory Device Output Payload */
	काष्ठा cxl_mbox_identअगरy अणु
		अक्षर fw_revision[0x10];
		__le64 total_capacity;
		__le64 अस्थिर_capacity;
		__le64 persistent_capacity;
		__le64 partition_align;
		__le16 info_event_log_size;
		__le16 warning_event_log_size;
		__le16 failure_event_log_size;
		__le16 fatal_event_log_size;
		__le32 lsa_size;
		u8 poison_list_max_mer[3];
		__le16 inject_poison_limit;
		u8 poison_caps;
		u8 qos_telemetry_caps;
	पूर्ण __packed id;
	पूर्णांक rc;

	rc = cxl_mem_mbox_send_cmd(cxlm, CXL_MBOX_OP_IDENTIFY, शून्य, 0, &id,
				   माप(id));
	अगर (rc < 0)
		वापस rc;

	/*
	 * TODO: क्रमागतerate DPA map, as 'ram' and 'pmem' करो not alias.
	 * For now, only the capacity is exported in sysfs
	 */
	cxlm->ram_range.start = 0;
	cxlm->ram_range.end = le64_to_cpu(id.अस्थिर_capacity) * SZ_256M - 1;

	cxlm->pmem_range.start = 0;
	cxlm->pmem_range.end =
		le64_to_cpu(id.persistent_capacity) * SZ_256M - 1;

	स_नकल(cxlm->firmware_version, id.fw_revision, माप(id.fw_revision));

	वापस 0;
पूर्ण

अटल पूर्णांक cxl_mem_probe(काष्ठा pci_dev *pdev, स्थिर काष्ठा pci_device_id *id)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा cxl_mem *cxlm = शून्य;
	u32 regloc_size, regblocks;
	पूर्णांक rc, regloc, i;

	rc = pcim_enable_device(pdev);
	अगर (rc)
		वापस rc;

	regloc = cxl_mem_dvsec(pdev, PCI_DVSEC_ID_CXL_REGLOC_OFFSET);
	अगर (!regloc) अणु
		dev_err(dev, "register location dvsec not found\n");
		वापस -ENXIO;
	पूर्ण

	/* Get the size of the Register Locator DVSEC */
	pci_पढ़ो_config_dword(pdev, regloc + PCI_DVSEC_HEADER1, &regloc_size);
	regloc_size = FIELD_GET(PCI_DVSEC_HEADER1_LENGTH_MASK, regloc_size);

	regloc += PCI_DVSEC_ID_CXL_REGLOC_BLOCK1_OFFSET;
	regblocks = (regloc_size - PCI_DVSEC_ID_CXL_REGLOC_BLOCK1_OFFSET) / 8;

	क्रम (i = 0; i < regblocks; i++, regloc += 8) अणु
		u32 reg_lo, reg_hi;
		u8 reg_type;

		/* "register low and high" contain other bits */
		pci_पढ़ो_config_dword(pdev, regloc, &reg_lo);
		pci_पढ़ो_config_dword(pdev, regloc + 4, &reg_hi);

		reg_type = FIELD_GET(CXL_REGLOC_RBI_MASK, reg_lo);

		अगर (reg_type == CXL_REGLOC_RBI_MEMDEV) अणु
			cxlm = cxl_mem_create(pdev, reg_lo, reg_hi);
			अवरोध;
		पूर्ण
	पूर्ण

	अगर (!cxlm)
		वापस -ENODEV;

	rc = cxl_mem_setup_regs(cxlm);
	अगर (rc)
		वापस rc;

	rc = cxl_mem_setup_mailbox(cxlm);
	अगर (rc)
		वापस rc;

	rc = cxl_mem_क्रमागतerate_cmds(cxlm);
	अगर (rc)
		वापस rc;

	rc = cxl_mem_identअगरy(cxlm);
	अगर (rc)
		वापस rc;

	वापस cxl_mem_add_memdev(cxlm);
पूर्ण

अटल स्थिर काष्ठा pci_device_id cxl_mem_pci_tbl[] = अणु
	/* PCI class code क्रम CXL.mem Type-3 Devices */
	अणु PCI_DEVICE_CLASS((PCI_CLASS_MEMORY_CXL << 8 | CXL_MEMORY_PROGIF), ~0)पूर्ण,
	अणु /* terminate list */ पूर्ण,
पूर्ण;
MODULE_DEVICE_TABLE(pci, cxl_mem_pci_tbl);

अटल काष्ठा pci_driver cxl_mem_driver = अणु
	.name			= KBUILD_MODNAME,
	.id_table		= cxl_mem_pci_tbl,
	.probe			= cxl_mem_probe,
	.driver	= अणु
		.probe_type	= PROBE_PREFER_ASYNCHRONOUS,
	पूर्ण,
पूर्ण;

अटल __init पूर्णांक cxl_mem_init(व्योम)
अणु
	काष्ठा dentry *mbox_debugfs;
	dev_t devt;
	पूर्णांक rc;

	rc = alloc_chrdev_region(&devt, 0, CXL_MEM_MAX_DEVS, "cxl");
	अगर (rc)
		वापस rc;

	cxl_mem_major = MAJOR(devt);

	rc = pci_रेजिस्टर_driver(&cxl_mem_driver);
	अगर (rc) अणु
		unरेजिस्टर_chrdev_region(MKDEV(cxl_mem_major, 0),
					 CXL_MEM_MAX_DEVS);
		वापस rc;
	पूर्ण

	cxl_debugfs = debugfs_create_dir("cxl", शून्य);
	mbox_debugfs = debugfs_create_dir("mbox", cxl_debugfs);
	debugfs_create_bool("raw_allow_all", 0600, mbox_debugfs,
			    &cxl_raw_allow_all);

	वापस 0;
पूर्ण

अटल __निकास व्योम cxl_mem_निकास(व्योम)
अणु
	debugfs_हटाओ_recursive(cxl_debugfs);
	pci_unरेजिस्टर_driver(&cxl_mem_driver);
	unरेजिस्टर_chrdev_region(MKDEV(cxl_mem_major, 0), CXL_MEM_MAX_DEVS);
पूर्ण

MODULE_LICENSE("GPL v2");
module_init(cxl_mem_init);
module_निकास(cxl_mem_निकास);
MODULE_IMPORT_NS(CXL);
