<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*******************************************************************************
 * Filename:  tcm_fc.c
 *
 * This file contains the configfs implementation क्रम TCM_fc fabric node.
 * Based on tcm_loop_configfs.c
 *
 * Copyright (c) 2010 Cisco Systems, Inc.
 * Copyright (c) 2009,2010 Rising Tide, Inc.
 * Copyright (c) 2009,2010 Linux-iSCSI.org
 *
 * Copyright (c) 2009,2010 Nicholas A. Bellinger <nab@linux-iscsi.org>
 *
 ****************************************************************************/

#समावेश <linux/module.h>
#समावेश <linux/moduleparam.h>
#समावेश <generated/utsrelease.h>
#समावेश <linux/utsname.h>
#समावेश <linux/init.h>
#समावेश <linux/slab.h>
#समावेश <linux/kthपढ़ो.h>
#समावेश <linux/types.h>
#समावेश <linux/माला.स>
#समावेश <linux/configfs.h>
#समावेश <linux/kernel.h>
#समावेश <linux/प्रकार.स>
#समावेश <यंत्र/unaligned.h>
#समावेश <scsi/libfc.h>

#समावेश <target/target_core_base.h>
#समावेश <target/target_core_fabric.h>

#समावेश "tcm_fc.h"

अटल LIST_HEAD(ft_wwn_list);
DEFINE_MUTEX(ft_lport_lock);

अचिन्हित पूर्णांक ft_debug_logging;
module_param_named(debug_logging, ft_debug_logging, पूर्णांक, S_IRUGO|S_IWUSR);
MODULE_PARM_DESC(debug_logging, "a bit mask of logging levels");

/*
 * Parse WWN.
 * If strict, we require lower-हाल hex and colon separators to be sure
 * the name is the same as what would be generated by ft_क्रमmat_wwn()
 * so the name and wwn are mapped one-to-one.
 */
अटल sमाप_प्रकार ft_parse_wwn(स्थिर अक्षर *name, u64 *wwn, पूर्णांक strict)
अणु
	स्थिर अक्षर *cp;
	अक्षर c;
	u32 byte = 0;
	u32 pos = 0;
	u32 err;
	पूर्णांक val;

	*wwn = 0;
	क्रम (cp = name; cp < &name[FT_NAMELEN - 1]; cp++) अणु
		c = *cp;
		अगर (c == '\n' && cp[1] == '\0')
			जारी;
		अगर (strict && pos++ == 2 && byte++ < 7) अणु
			pos = 0;
			अगर (c == ':')
				जारी;
			err = 1;
			जाओ fail;
		पूर्ण
		अगर (c == '\0') अणु
			err = 2;
			अगर (strict && byte != 8)
				जाओ fail;
			वापस cp - name;
		पूर्ण
		err = 3;
		val = hex_to_bin(c);
		अगर (val < 0 || (strict && है_बड़ा(c)))
			जाओ fail;
		*wwn = (*wwn << 4) | val;
	पूर्ण
	err = 4;
fail:
	pr_debug("err %u len %zu pos %u byte %u\n",
		    err, cp - name, pos, byte);
	वापस -1;
पूर्ण

sमाप_प्रकार ft_क्रमmat_wwn(अक्षर *buf, माप_प्रकार len, u64 wwn)
अणु
	u8 b[8];

	put_unaligned_be64(wwn, b);
	वापस snम_लिखो(buf, len,
		 "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",
		 b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
पूर्ण

अटल sमाप_प्रकार ft_wwn_show(व्योम *arg, अक्षर *buf)
अणु
	u64 *wwn = arg;
	sमाप_प्रकार len;

	len = ft_क्रमmat_wwn(buf, PAGE_SIZE - 2, *wwn);
	buf[len++] = '\n';
	वापस len;
पूर्ण

अटल sमाप_प्रकार ft_wwn_store(व्योम *arg, स्थिर अक्षर *buf, माप_प्रकार len)
अणु
	sमाप_प्रकार ret;
	u64 wwn;

	ret = ft_parse_wwn(buf, &wwn, 0);
	अगर (ret > 0)
		*(u64 *)arg = wwn;
	वापस ret;
पूर्ण

/*
 * ACL auth ops.
 */

अटल sमाप_प्रकार ft_nacl_port_name_show(काष्ठा config_item *item, अक्षर *page)
अणु
	काष्ठा se_node_acl *se_nacl = acl_to_nacl(item);
	काष्ठा ft_node_acl *acl = container_of(se_nacl,
			काष्ठा ft_node_acl, se_node_acl);

	वापस ft_wwn_show(&acl->node_auth.port_name, page);
पूर्ण

अटल sमाप_प्रकार ft_nacl_port_name_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_node_acl *se_nacl = acl_to_nacl(item);
	काष्ठा ft_node_acl *acl = container_of(se_nacl,
			काष्ठा ft_node_acl, se_node_acl);

	वापस ft_wwn_store(&acl->node_auth.port_name, page, count);
पूर्ण

अटल sमाप_प्रकार ft_nacl_node_name_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	काष्ठा se_node_acl *se_nacl = acl_to_nacl(item);
	काष्ठा ft_node_acl *acl = container_of(se_nacl,
			काष्ठा ft_node_acl, se_node_acl);

	वापस ft_wwn_show(&acl->node_auth.node_name, page);
पूर्ण

अटल sमाप_प्रकार ft_nacl_node_name_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_node_acl *se_nacl = acl_to_nacl(item);
	काष्ठा ft_node_acl *acl = container_of(se_nacl,
			काष्ठा ft_node_acl, se_node_acl);

	वापस ft_wwn_store(&acl->node_auth.node_name, page, count);
पूर्ण

CONFIGFS_ATTR(ft_nacl_, node_name);
CONFIGFS_ATTR(ft_nacl_, port_name);

अटल sमाप_प्रकार ft_nacl_tag_show(काष्ठा config_item *item,
		अक्षर *page)
अणु
	वापस snम_लिखो(page, PAGE_SIZE, "%s", acl_to_nacl(item)->acl_tag);
पूर्ण

अटल sमाप_प्रकार ft_nacl_tag_store(काष्ठा config_item *item,
		स्थिर अक्षर *page, माप_प्रकार count)
अणु
	काष्ठा se_node_acl *se_nacl = acl_to_nacl(item);
	पूर्णांक ret;

	ret = core_tpg_set_initiator_node_tag(se_nacl->se_tpg, se_nacl, page);

	अगर (ret < 0)
		वापस ret;
	वापस count;
पूर्ण

CONFIGFS_ATTR(ft_nacl_, tag);

अटल काष्ठा configfs_attribute *ft_nacl_base_attrs[] = अणु
	&ft_nacl_attr_port_name,
	&ft_nacl_attr_node_name,
	&ft_nacl_attr_tag,
	शून्य,
पूर्ण;

/*
 * ACL ops.
 */

/*
 * Add ACL क्रम an initiator.  The ACL is named arbitrarily.
 * The port_name and/or node_name are attributes.
 */
अटल पूर्णांक ft_init_nodeacl(काष्ठा se_node_acl *nacl, स्थिर अक्षर *name)
अणु
	काष्ठा ft_node_acl *acl =
		container_of(nacl, काष्ठा ft_node_acl, se_node_acl);
	u64 wwpn;

	अगर (ft_parse_wwn(name, &wwpn, 1) < 0)
		वापस -EINVAL;

	acl->node_auth.port_name = wwpn;
	वापस 0;
पूर्ण

/*
 * local_port port_group (tpg) ops.
 */
अटल काष्ठा se_portal_group *ft_add_tpg(काष्ठा se_wwn *wwn, स्थिर अक्षर *name)
अणु
	काष्ठा ft_lport_wwn *ft_wwn;
	काष्ठा ft_tpg *tpg;
	काष्ठा workqueue_काष्ठा *wq;
	अचिन्हित दीर्घ index;
	पूर्णांक ret;

	pr_debug("tcm_fc: add tpg %s\n", name);

	/*
	 * Name must be "tpgt_" followed by the index.
	 */
	अगर (म_माला(name, "tpgt_") != name)
		वापस शून्य;

	ret = kम_से_अदीर्घ(name + 5, 10, &index);
	अगर (ret)
		वापस शून्य;
	अगर (index > अच_पूर्णांक_उच्च)
		वापस शून्य;

	अगर ((index != 1)) अणु
		pr_err("Error, a single TPG=1 is used for HW port mappings\n");
		वापस ERR_PTR(-ENOSYS);
	पूर्ण

	ft_wwn = container_of(wwn, काष्ठा ft_lport_wwn, se_wwn);
	tpg = kzalloc(माप(*tpg), GFP_KERNEL);
	अगर (!tpg)
		वापस शून्य;
	tpg->index = index;
	tpg->lport_wwn = ft_wwn;
	INIT_LIST_HEAD(&tpg->lun_list);

	wq = alloc_workqueue("tcm_fc", 0, 1);
	अगर (!wq) अणु
		kमुक्त(tpg);
		वापस शून्य;
	पूर्ण

	ret = core_tpg_रेजिस्टर(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
	अगर (ret < 0) अणु
		destroy_workqueue(wq);
		kमुक्त(tpg);
		वापस शून्य;
	पूर्ण
	tpg->workqueue = wq;

	mutex_lock(&ft_lport_lock);
	ft_wwn->tpg = tpg;
	mutex_unlock(&ft_lport_lock);

	वापस &tpg->se_tpg;
पूर्ण

अटल व्योम ft_del_tpg(काष्ठा se_portal_group *se_tpg)
अणु
	काष्ठा ft_tpg *tpg = container_of(se_tpg, काष्ठा ft_tpg, se_tpg);
	काष्ठा ft_lport_wwn *ft_wwn = tpg->lport_wwn;

	pr_debug("del tpg %s\n",
		    config_item_name(&tpg->se_tpg.tpg_group.cg_item));

	destroy_workqueue(tpg->workqueue);

	/* Wait क्रम sessions to be मुक्तd thru RCU, क्रम BUG_ON below */
	synchronize_rcu();

	mutex_lock(&ft_lport_lock);
	ft_wwn->tpg = शून्य;
	अगर (tpg->tport) अणु
		tpg->tport->tpg = शून्य;
		tpg->tport = शून्य;
	पूर्ण
	mutex_unlock(&ft_lport_lock);

	core_tpg_deरेजिस्टर(se_tpg);
	kमुक्त(tpg);
पूर्ण

/*
 * Verअगरy that an lport is configured to use the tcm_fc module, and वापस
 * the target port group that should be used.
 *
 * The caller holds ft_lport_lock.
 */
काष्ठा ft_tpg *ft_lport_find_tpg(काष्ठा fc_lport *lport)
अणु
	काष्ठा ft_lport_wwn *ft_wwn;

	list_क्रम_each_entry(ft_wwn, &ft_wwn_list, ft_wwn_node) अणु
		अगर (ft_wwn->wwpn == lport->wwpn)
			वापस ft_wwn->tpg;
	पूर्ण
	वापस शून्य;
पूर्ण

/*
 * target config instance ops.
 */

/*
 * Add lport to allowed config.
 * The name is the WWPN in lower-हाल ASCII, colon-separated bytes.
 */
अटल काष्ठा se_wwn *ft_add_wwn(
	काष्ठा target_fabric_configfs *tf,
	काष्ठा config_group *group,
	स्थिर अक्षर *name)
अणु
	काष्ठा ft_lport_wwn *ft_wwn;
	काष्ठा ft_lport_wwn *old_ft_wwn;
	u64 wwpn;

	pr_debug("add wwn %s\n", name);
	अगर (ft_parse_wwn(name, &wwpn, 1) < 0)
		वापस शून्य;
	ft_wwn = kzalloc(माप(*ft_wwn), GFP_KERNEL);
	अगर (!ft_wwn)
		वापस शून्य;
	ft_wwn->wwpn = wwpn;

	mutex_lock(&ft_lport_lock);
	list_क्रम_each_entry(old_ft_wwn, &ft_wwn_list, ft_wwn_node) अणु
		अगर (old_ft_wwn->wwpn == wwpn) अणु
			mutex_unlock(&ft_lport_lock);
			kमुक्त(ft_wwn);
			वापस शून्य;
		पूर्ण
	पूर्ण
	list_add_tail(&ft_wwn->ft_wwn_node, &ft_wwn_list);
	ft_क्रमmat_wwn(ft_wwn->name, माप(ft_wwn->name), wwpn);
	mutex_unlock(&ft_lport_lock);

	वापस &ft_wwn->se_wwn;
पूर्ण

अटल व्योम ft_del_wwn(काष्ठा se_wwn *wwn)
अणु
	काष्ठा ft_lport_wwn *ft_wwn = container_of(wwn,
				काष्ठा ft_lport_wwn, se_wwn);

	pr_debug("del wwn %s\n", ft_wwn->name);
	mutex_lock(&ft_lport_lock);
	list_del(&ft_wwn->ft_wwn_node);
	mutex_unlock(&ft_lport_lock);

	kमुक्त(ft_wwn);
पूर्ण

अटल sमाप_प्रकार ft_wwn_version_show(काष्ठा config_item *item, अक्षर *page)
अणु
	वापस प्र_लिखो(page, "TCM FC " FT_VERSION " on %s/%s on "
		""UTS_RELEASE"\n",  utsname()->sysname, utsname()->machine);
पूर्ण

CONFIGFS_ATTR_RO(ft_wwn_, version);

अटल काष्ठा configfs_attribute *ft_wwn_attrs[] = अणु
	&ft_wwn_attr_version,
	शून्य,
पूर्ण;

अटल अंतरभूत काष्ठा ft_tpg *ft_tpg(काष्ठा se_portal_group *se_tpg)
अणु
	वापस container_of(se_tpg, काष्ठा ft_tpg, se_tpg);
पूर्ण

अटल अक्षर *ft_get_fabric_wwn(काष्ठा se_portal_group *se_tpg)
अणु
	वापस ft_tpg(se_tpg)->lport_wwn->name;
पूर्ण

अटल u16 ft_get_tag(काष्ठा se_portal_group *se_tpg)
अणु
	/*
	 * This tag is used when क्रमming SCSI Name identअगरier in EVPD=1 0x83
	 * to represent the SCSI Target Port.
	 */
	वापस ft_tpg(se_tpg)->index;
पूर्ण

अटल पूर्णांक ft_check_false(काष्ठा se_portal_group *se_tpg)
अणु
	वापस 0;
पूर्ण

अटल व्योम ft_set_शेष_node_attr(काष्ठा se_node_acl *se_nacl)
अणु
पूर्ण

अटल u32 ft_tpg_get_inst_index(काष्ठा se_portal_group *se_tpg)
अणु
	वापस ft_tpg(se_tpg)->index;
पूर्ण

अटल स्थिर काष्ठा target_core_fabric_ops ft_fabric_ops = अणु
	.module =			THIS_MODULE,
	.fabric_name =			"fc",
	.node_acl_size =		माप(काष्ठा ft_node_acl),
	.tpg_get_wwn =			ft_get_fabric_wwn,
	.tpg_get_tag =			ft_get_tag,
	.tpg_check_demo_mode =		ft_check_false,
	.tpg_check_demo_mode_cache =	ft_check_false,
	.tpg_check_demo_mode_ग_लिखो_protect = ft_check_false,
	.tpg_check_prod_mode_ग_लिखो_protect = ft_check_false,
	.tpg_get_inst_index =		ft_tpg_get_inst_index,
	.check_stop_मुक्त =		ft_check_stop_मुक्त,
	.release_cmd =			ft_release_cmd,
	.बंद_session =		ft_sess_बंद,
	.sess_get_index =		ft_sess_get_index,
	.sess_get_initiator_sid =	शून्य,
	.ग_लिखो_pending =		ft_ग_लिखो_pending,
	.set_शेष_node_attributes =	ft_set_शेष_node_attr,
	.get_cmd_state =		ft_get_cmd_state,
	.queue_data_in =		ft_queue_data_in,
	.queue_status =			ft_queue_status,
	.queue_पंचांग_rsp =			ft_queue_पंचांग_resp,
	.पातed_task =			ft_पातed_task,
	/*
	 * Setup function poपूर्णांकers क्रम generic logic in
	 * target_core_fabric_configfs.c
	 */
	.fabric_make_wwn =		&ft_add_wwn,
	.fabric_drop_wwn =		&ft_del_wwn,
	.fabric_make_tpg =		&ft_add_tpg,
	.fabric_drop_tpg =		&ft_del_tpg,
	.fabric_init_nodeacl =		&ft_init_nodeacl,

	.tfc_wwn_attrs			= ft_wwn_attrs,
	.tfc_tpg_nacl_base_attrs	= ft_nacl_base_attrs,
पूर्ण;

अटल काष्ठा notअगरier_block ft_notअगरier = अणु
	.notअगरier_call = ft_lport_notअगरy
पूर्ण;

अटल पूर्णांक __init ft_init(व्योम)
अणु
	पूर्णांक ret;

	ret = target_रेजिस्टर_ढाँचा(&ft_fabric_ops);
	अगर (ret)
		जाओ out;

	ret = fc_fc4_रेजिस्टर_provider(FC_TYPE_FCP, &ft_prov);
	अगर (ret)
		जाओ out_unरेजिस्टर_ढाँचा;

	blocking_notअगरier_chain_रेजिस्टर(&fc_lport_notअगरier_head, &ft_notअगरier);
	fc_lport_iterate(ft_lport_add, शून्य);
	वापस 0;

out_unरेजिस्टर_ढाँचा:
	target_unरेजिस्टर_ढाँचा(&ft_fabric_ops);
out:
	वापस ret;
पूर्ण

अटल व्योम __निकास ft_निकास(व्योम)
अणु
	blocking_notअगरier_chain_unरेजिस्टर(&fc_lport_notअगरier_head,
					   &ft_notअगरier);
	fc_fc4_deरेजिस्टर_provider(FC_TYPE_FCP, &ft_prov);
	fc_lport_iterate(ft_lport_del, शून्य);
	target_unरेजिस्टर_ढाँचा(&ft_fabric_ops);
	synchronize_rcu();
पूर्ण

MODULE_DESCRIPTION("FC TCM fabric driver " FT_VERSION);
MODULE_LICENSE("GPL");
module_init(ft_init);
module_निकास(ft_निकास);
