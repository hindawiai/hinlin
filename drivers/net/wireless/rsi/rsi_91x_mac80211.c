<शैली गुरु>
/*
 * Copyright (c) 2014 Redpine Signals Inc.
 *
 * Permission to use, copy, modअगरy, and/or distribute this software क्रम any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, सूचीECT, INसूचीECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#समावेश <linux/etherdevice.h>
#समावेश "rsi_debugfs.h"
#समावेश "rsi_mgmt.h"
#समावेश "rsi_sdio.h"
#समावेश "rsi_common.h"
#समावेश "rsi_ps.h"

अटल स्थिर काष्ठा ieee80211_channel rsi_2ghz_channels[] = अणु
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2412,
	  .hw_value = 1 पूर्ण, /* Channel 1 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2417,
	  .hw_value = 2 पूर्ण, /* Channel 2 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2422,
	  .hw_value = 3 पूर्ण, /* Channel 3 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2427,
	  .hw_value = 4 पूर्ण, /* Channel 4 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2432,
	  .hw_value = 5 पूर्ण, /* Channel 5 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2437,
	  .hw_value = 6 पूर्ण, /* Channel 6 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2442,
	  .hw_value = 7 पूर्ण, /* Channel 7 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2447,
	  .hw_value = 8 पूर्ण, /* Channel 8 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2452,
	  .hw_value = 9 पूर्ण, /* Channel 9 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2457,
	  .hw_value = 10 पूर्ण, /* Channel 10 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2462,
	  .hw_value = 11 पूर्ण, /* Channel 11 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2467,
	  .hw_value = 12 पूर्ण, /* Channel 12 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2472,
	  .hw_value = 13 पूर्ण, /* Channel 13 */
	अणु .band = NL80211_BAND_2GHZ, .center_freq = 2484,
	  .hw_value = 14 पूर्ण, /* Channel 14 */
पूर्ण;

अटल स्थिर काष्ठा ieee80211_channel rsi_5ghz_channels[] = अणु
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5180,
	  .hw_value = 36,  पूर्ण, /* Channel 36 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5200,
	  .hw_value = 40, पूर्ण, /* Channel 40 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5220,
	  .hw_value = 44, पूर्ण, /* Channel 44 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5240,
	  .hw_value = 48, पूर्ण, /* Channel 48 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5260,
	  .hw_value = 52, पूर्ण, /* Channel 52 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5280,
	  .hw_value = 56, पूर्ण, /* Channel 56 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5300,
	  .hw_value = 60, पूर्ण, /* Channel 60 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5320,
	  .hw_value = 64, पूर्ण, /* Channel 64 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5500,
	  .hw_value = 100, पूर्ण, /* Channel 100 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5520,
	  .hw_value = 104, पूर्ण, /* Channel 104 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5540,
	  .hw_value = 108, पूर्ण, /* Channel 108 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5560,
	  .hw_value = 112, पूर्ण, /* Channel 112 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5580,
	  .hw_value = 116, पूर्ण, /* Channel 116 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5600,
	  .hw_value = 120, पूर्ण, /* Channel 120 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5620,
	  .hw_value = 124, पूर्ण, /* Channel 124 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5640,
	  .hw_value = 128, पूर्ण, /* Channel 128 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5660,
	  .hw_value = 132, पूर्ण, /* Channel 132 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5680,
	  .hw_value = 136, पूर्ण, /* Channel 136 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5700,
	  .hw_value = 140, पूर्ण, /* Channel 140 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5745,
	  .hw_value = 149, पूर्ण, /* Channel 149 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5765,
	  .hw_value = 153, पूर्ण, /* Channel 153 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5785,
	  .hw_value = 157, पूर्ण, /* Channel 157 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5805,
	  .hw_value = 161, पूर्ण, /* Channel 161 */
	अणु .band = NL80211_BAND_5GHZ, .center_freq = 5825,
	  .hw_value = 165, पूर्ण, /* Channel 165 */
पूर्ण;

काष्ठा ieee80211_rate rsi_rates[12] = अणु
	अणु .bitrate = STD_RATE_01  * 5, .hw_value = RSI_RATE_1 पूर्ण,
	अणु .bitrate = STD_RATE_02  * 5, .hw_value = RSI_RATE_2 पूर्ण,
	अणु .bitrate = STD_RATE_5_5 * 5, .hw_value = RSI_RATE_5_5 पूर्ण,
	अणु .bitrate = STD_RATE_11  * 5, .hw_value = RSI_RATE_11 पूर्ण,
	अणु .bitrate = STD_RATE_06  * 5, .hw_value = RSI_RATE_6 पूर्ण,
	अणु .bitrate = STD_RATE_09  * 5, .hw_value = RSI_RATE_9 पूर्ण,
	अणु .bitrate = STD_RATE_12  * 5, .hw_value = RSI_RATE_12 पूर्ण,
	अणु .bitrate = STD_RATE_18  * 5, .hw_value = RSI_RATE_18 पूर्ण,
	अणु .bitrate = STD_RATE_24  * 5, .hw_value = RSI_RATE_24 पूर्ण,
	अणु .bitrate = STD_RATE_36  * 5, .hw_value = RSI_RATE_36 पूर्ण,
	अणु .bitrate = STD_RATE_48  * 5, .hw_value = RSI_RATE_48 पूर्ण,
	अणु .bitrate = STD_RATE_54  * 5, .hw_value = RSI_RATE_54 पूर्ण,
पूर्ण;

स्थिर u16 rsi_mcsrates[8] = अणु
	RSI_RATE_MCS0, RSI_RATE_MCS1, RSI_RATE_MCS2, RSI_RATE_MCS3,
	RSI_RATE_MCS4, RSI_RATE_MCS5, RSI_RATE_MCS6, RSI_RATE_MCS7
पूर्ण;

अटल स्थिर u32 rsi_max_ap_stas[16] = अणु
	32,	/* 1 - Wi-Fi alone */
	0,	/* 2 */
	0,	/* 3 */
	0,	/* 4 - BT EDR alone */
	4,	/* 5 - STA + BT EDR */
	32,	/* 6 - AP + BT EDR */
	0,	/* 7 */
	0,	/* 8 - BT LE alone */
	4,	/* 9 - STA + BE LE */
	0,	/* 10 */
	0,	/* 11 */
	0,	/* 12 */
	1,	/* 13 - STA + BT Dual */
	4,	/* 14 - AP + BT Dual */
पूर्ण;

अटल स्थिर काष्ठा ieee80211_अगरace_limit rsi_अगरace_limits[] = अणु
	अणु
		.max = 1,
		.types = BIT(NL80211_IFTYPE_STATION),
	पूर्ण,
	अणु
		.max = 1,
		.types = BIT(NL80211_IFTYPE_AP) |
			BIT(NL80211_IFTYPE_P2P_CLIENT) |
			BIT(NL80211_IFTYPE_P2P_GO),
	पूर्ण,
	अणु
		.max = 1,
		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
	पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा ieee80211_अगरace_combination rsi_अगरace_combinations[] = अणु
	अणु
		.num_dअगरferent_channels = 1,
		.max_पूर्णांकerfaces = 3,
		.limits = rsi_अगरace_limits,
		.n_limits = ARRAY_SIZE(rsi_अगरace_limits),
	पूर्ण,
पूर्ण;

/**
 * rsi_is_cipher_wep() -  This function determines अगर the cipher is WEP or not.
 * @common: Poपूर्णांकer to the driver निजी काष्ठाure.
 *
 * Return: If cipher type is WEP, a value of 1 is वापसed, अन्यथा 0.
 */

bool rsi_is_cipher_wep(काष्ठा rsi_common *common)
अणु
	अगर (((common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP104) ||
	     (common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP40)) &&
	    (!common->secinfo.ptk_cipher))
		वापस true;
	अन्यथा
		वापस false;
पूर्ण

/**
 * rsi_रेजिस्टर_rates_channels() - This function रेजिस्टरs channels and rates.
 * @adapter: Poपूर्णांकer to the adapter काष्ठाure.
 * @band: Operating band to be set.
 *
 * Return: पूर्णांक - 0 on success, negative error on failure.
 */
अटल पूर्णांक rsi_रेजिस्टर_rates_channels(काष्ठा rsi_hw *adapter, पूर्णांक band)
अणु
	काष्ठा ieee80211_supported_band *sbands = &adapter->sbands[band];
	व्योम *channels = शून्य;

	अगर (band == NL80211_BAND_2GHZ) अणु
		channels = kmemdup(rsi_2ghz_channels, माप(rsi_2ghz_channels),
				   GFP_KERNEL);
		अगर (!channels)
			वापस -ENOMEM;
		sbands->band = NL80211_BAND_2GHZ;
		sbands->n_channels = ARRAY_SIZE(rsi_2ghz_channels);
		sbands->bitrates = rsi_rates;
		sbands->n_bitrates = ARRAY_SIZE(rsi_rates);
	पूर्ण अन्यथा अणु
		channels = kmemdup(rsi_5ghz_channels, माप(rsi_5ghz_channels),
				   GFP_KERNEL);
		अगर (!channels)
			वापस -ENOMEM;
		sbands->band = NL80211_BAND_5GHZ;
		sbands->n_channels = ARRAY_SIZE(rsi_5ghz_channels);
		sbands->bitrates = &rsi_rates[4];
		sbands->n_bitrates = ARRAY_SIZE(rsi_rates) - 4;
	पूर्ण

	sbands->channels = channels;

	स_रखो(&sbands->ht_cap, 0, माप(काष्ठा ieee80211_sta_ht_cap));
	sbands->ht_cap.ht_supported = true;
	sbands->ht_cap.cap = (IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
			      IEEE80211_HT_CAP_SGI_20 |
			      IEEE80211_HT_CAP_SGI_40);
	sbands->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;
	sbands->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
	sbands->ht_cap.mcs.rx_mask[0] = 0xff;
	sbands->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
	/* sbands->ht_cap.mcs.rx_highest = 0x82; */
	वापस 0;
पूर्ण

अटल पूर्णांक rsi_mac80211_hw_scan_start(काष्ठा ieee80211_hw *hw,
				      काष्ठा ieee80211_vअगर *vअगर,
				      काष्ठा ieee80211_scan_request *hw_req)
अणु
	काष्ठा cfg80211_scan_request *scan_req = &hw_req->req;
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_bss_conf *bss = &vअगर->bss_conf;

	rsi_dbg(INFO_ZONE, "***** Hardware scan start *****\n");
	common->mac_ops_resumed = false;

	अगर (common->fsm_state != FSM_MAC_INIT_DONE)
		वापस -ENODEV;

	अगर ((common->wow_flags & RSI_WOW_ENABLED) ||
	    scan_req->n_channels == 0)
		वापस -EINVAL;

	/* Scan alपढ़ोy in progress. So वापस */
	अगर (common->bgscan_en)
		वापस -EBUSY;

	/* If STA is not connected, वापस with special value 1, in order
	 * to start sw_scan in mac80211
	 */
	अगर (!bss->assoc)
		वापस 1;

	mutex_lock(&common->mutex);
	common->hwscan = scan_req;
	अगर (!rsi_send_bgscan_params(common, RSI_START_BGSCAN)) अणु
		अगर (!rsi_send_bgscan_probe_req(common, vअगर)) अणु
			rsi_dbg(INFO_ZONE, "Background scan started...\n");
			common->bgscan_en = true;
		पूर्ण
	पूर्ण
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

अटल व्योम rsi_mac80211_cancel_hw_scan(काष्ठा ieee80211_hw *hw,
					काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा cfg80211_scan_info info;

	rsi_dbg(INFO_ZONE, "***** Hardware scan stop *****\n");
	mutex_lock(&common->mutex);

	अगर (common->bgscan_en) अणु
		अगर (!rsi_send_bgscan_params(common, RSI_STOP_BGSCAN))
			common->bgscan_en = false;
		info.पातed = false;
		ieee80211_scan_completed(adapter->hw, &info);
		rsi_dbg(INFO_ZONE, "Back ground scan cancelled\n");
	पूर्ण
	common->hwscan = शून्य;
	mutex_unlock(&common->mutex);
पूर्ण

/**
 * rsi_mac80211_detach() - This function is used to de-initialize the
 *			   Mac80211 stack.
 * @adapter: Poपूर्णांकer to the adapter काष्ठाure.
 *
 * Return: None.
 */
व्योम rsi_mac80211_detach(काष्ठा rsi_hw *adapter)
अणु
	काष्ठा ieee80211_hw *hw = adapter->hw;
	क्रमागत nl80211_band band;

	अगर (hw) अणु
		ieee80211_stop_queues(hw);
		ieee80211_unरेजिस्टर_hw(hw);
		ieee80211_मुक्त_hw(hw);
		adapter->hw = शून्य;
	पूर्ण

	क्रम (band = 0; band < NUM_NL80211_BANDS; band++) अणु
		काष्ठा ieee80211_supported_band *sband =
					&adapter->sbands[band];

		kमुक्त(sband->channels);
	पूर्ण

#अगर_घोषित CONFIG_RSI_DEBUGFS
	rsi_हटाओ_dbgfs(adapter);
	kमुक्त(adapter->dfsentry);
#पूर्ण_अगर
पूर्ण
EXPORT_SYMBOL_GPL(rsi_mac80211_detach);

/**
 * rsi_indicate_tx_status() - This function indicates the transmit status.
 * @adapter: Poपूर्णांकer to the adapter काष्ठाure.
 * @skb: Poपूर्णांकer to the socket buffer काष्ठाure.
 * @status: Status
 *
 * Return: None.
 */
व्योम rsi_indicate_tx_status(काष्ठा rsi_hw *adapter,
			    काष्ठा sk_buff *skb,
			    पूर्णांक status)
अणु
	काष्ठा ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	काष्ठा skb_info *tx_params;

	अगर (!adapter->hw) अणु
		rsi_dbg(ERR_ZONE, "##### No MAC #####\n");
		वापस;
	पूर्ण

	अगर (!status)
		info->flags |= IEEE80211_TX_STAT_ACK;

	tx_params = (काष्ठा skb_info *)info->driver_data;
	skb_pull(skb, tx_params->पूर्णांकernal_hdr_size);
	स_रखो(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);

	ieee80211_tx_status_irqsafe(adapter->hw, skb);
पूर्ण

/**
 * rsi_mac80211_tx() - This is the handler that 802.11 module calls क्रम each
 *		       transmitted frame.SKB contains the buffer starting
 *		       from the IEEE 802.11 header.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @control: Poपूर्णांकer to the ieee80211_tx_control काष्ठाure
 * @skb: Poपूर्णांकer to the socket buffer काष्ठाure.
 *
 * Return: None
 */
अटल व्योम rsi_mac80211_tx(काष्ठा ieee80211_hw *hw,
			    काष्ठा ieee80211_tx_control *control,
			    काष्ठा sk_buff *skb)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_hdr *wlh = (काष्ठा ieee80211_hdr *)skb->data;

	अगर (ieee80211_is_auth(wlh->frame_control))
		common->mac_ops_resumed = false;

	rsi_core_xmit(common, skb);
पूर्ण

/**
 * rsi_mac80211_start() - This is first handler that 802.11 module calls, since
 *			  the driver init is complete by then, just
 *			  वापसs success.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 *
 * Return: 0 as success.
 */
अटल पूर्णांक rsi_mac80211_start(काष्ठा ieee80211_hw *hw)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	rsi_dbg(ERR_ZONE, "===> Interface UP <===\n");
	mutex_lock(&common->mutex);
	अगर (common->hibernate_resume) अणु
		common->reinit_hw = true;
		adapter->host_पूर्णांकf_ops->reinit_device(adapter);
		रुको_क्रम_completion(&adapter->priv->wlan_init_completion);
	पूर्ण
	common->अगरace_करोwn = false;
	wiphy_rfसमाप्त_start_polling(hw->wiphy);
	rsi_send_rx_filter_frame(common, 0);
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

/**
 * rsi_mac80211_stop() - This is the last handler that 802.11 module calls.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 *
 * Return: None.
 */
अटल व्योम rsi_mac80211_stop(काष्ठा ieee80211_hw *hw)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	rsi_dbg(ERR_ZONE, "===> Interface DOWN <===\n");
	mutex_lock(&common->mutex);
	common->अगरace_करोwn = true;
	wiphy_rfसमाप्त_stop_polling(hw->wiphy);

	/* Block all rx frames */
	rsi_send_rx_filter_frame(common, 0xffff);

	mutex_unlock(&common->mutex);
पूर्ण

अटल पूर्णांक rsi_map_पूर्णांकf_mode(क्रमागत nl80211_अगरtype vअगर_type)
अणु
	चयन (vअगर_type) अणु
	हाल NL80211_IFTYPE_STATION:
		वापस RSI_OPMODE_STA;
	हाल NL80211_IFTYPE_AP:
		वापस RSI_OPMODE_AP;
	हाल NL80211_IFTYPE_P2P_DEVICE:
		वापस RSI_OPMODE_P2P_CLIENT;
	हाल NL80211_IFTYPE_P2P_CLIENT:
		वापस RSI_OPMODE_P2P_CLIENT;
	हाल NL80211_IFTYPE_P2P_GO:
		वापस RSI_OPMODE_P2P_GO;
	शेष:
		वापस RSI_OPMODE_UNSUPPORTED;
	पूर्ण
पूर्ण

/**
 * rsi_mac80211_add_पूर्णांकerface() - This function is called when a netdevice
 *				  attached to the hardware is enabled.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 *
 * Return: ret: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_add_पूर्णांकerface(काष्ठा ieee80211_hw *hw,
				      काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा vअगर_priv *vअगर_info = (काष्ठा vअगर_priv *)vअगर->drv_priv;
	क्रमागत opmode पूर्णांकf_mode;
	क्रमागत vap_status vap_status;
	पूर्णांक vap_idx = -1, i;

	vअगर->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;
	mutex_lock(&common->mutex);

	पूर्णांकf_mode = rsi_map_पूर्णांकf_mode(vअगर->type);
	अगर (पूर्णांकf_mode == RSI_OPMODE_UNSUPPORTED) अणु
		rsi_dbg(ERR_ZONE,
			"%s: Interface type %d not supported\n", __func__,
			vअगर->type);
		mutex_unlock(&common->mutex);
		वापस -EOPNOTSUPP;
	पूर्ण
	अगर ((vअगर->type == NL80211_IFTYPE_P2P_DEVICE) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_CLIENT) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO))
		common->p2p_enabled = true;

	/* Get मुक्त vap index */
	क्रम (i = 0; i < RSI_MAX_VIFS; i++) अणु
		अगर (!adapter->vअगरs[i] ||
		    !स_भेद(vअगर->addr, adapter->vअगरs[i]->addr, ETH_ALEN)) अणु
			vap_idx = i;
			अवरोध;
		पूर्ण
	पूर्ण
	अगर (vap_idx < 0) अणु
		rsi_dbg(ERR_ZONE, "Reject: Max VAPs reached\n");
		mutex_unlock(&common->mutex);
		वापस -EOPNOTSUPP;
	पूर्ण
	vअगर_info->vap_id = vap_idx;
	adapter->vअगरs[vap_idx] = vअगर;
	adapter->sc_nvअगरs++;
	vap_status = VAP_ADD;

	अगर (rsi_set_vap_capabilities(common, पूर्णांकf_mode, vअगर->addr,
				     vअगर_info->vap_id, vap_status)) अणु
		rsi_dbg(ERR_ZONE, "Failed to set VAP capabilities\n");
		mutex_unlock(&common->mutex);
		वापस -EINVAL;
	पूर्ण

	अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
		rsi_send_rx_filter_frame(common, DISALLOW_BEACONS);
		common->min_rate = RSI_RATE_AUTO;
		क्रम (i = 0; i < common->max_stations; i++)
			common->stations[i].sta = शून्य;
	पूर्ण

	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

/**
 * rsi_mac80211_हटाओ_पूर्णांकerface() - This function notअगरies driver that an
 *				     पूर्णांकerface is going करोwn.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 *
 * Return: None.
 */
अटल व्योम rsi_mac80211_हटाओ_पूर्णांकerface(काष्ठा ieee80211_hw *hw,
					  काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	क्रमागत opmode opmode;
	पूर्णांक i;

	rsi_dbg(INFO_ZONE, "Remove Interface Called\n");

	mutex_lock(&common->mutex);

	अगर (adapter->sc_nvअगरs <= 0) अणु
		mutex_unlock(&common->mutex);
		वापस;
	पूर्ण

	opmode = rsi_map_पूर्णांकf_mode(vअगर->type);
	अगर (opmode == RSI_OPMODE_UNSUPPORTED) अणु
		rsi_dbg(ERR_ZONE, "Opmode error : %d\n", opmode);
		mutex_unlock(&common->mutex);
		वापस;
	पूर्ण
	क्रम (i = 0; i < RSI_MAX_VIFS; i++) अणु
		अगर (!adapter->vअगरs[i])
			जारी;
		अगर (vअगर == adapter->vअगरs[i]) अणु
			rsi_set_vap_capabilities(common, opmode, vअगर->addr,
						 i, VAP_DELETE);
			adapter->sc_nvअगरs--;
			adapter->vअगरs[i] = शून्य;
		पूर्ण
	पूर्ण
	mutex_unlock(&common->mutex);
पूर्ण

/**
 * rsi_channel_change() - This function is a perक्रमms the checks
 *			  required क्रम changing a channel and sets
 *			  the channel accordingly.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 *
 * Return: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_channel_change(काष्ठा ieee80211_hw *hw)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	पूर्णांक status = -EOPNOTSUPP;
	काष्ठा ieee80211_channel *curchan = hw->conf.chandef.chan;
	u16 channel = curchan->hw_value;
	काष्ठा ieee80211_vअगर *vअगर;
	काष्ठा ieee80211_bss_conf *bss;
	bool assoc = false;
	पूर्णांक i;

	rsi_dbg(INFO_ZONE,
		"%s: Set channel: %d MHz type: %d channel_no %d\n",
		__func__, curchan->center_freq,
		curchan->flags, channel);

	क्रम (i = 0; i < RSI_MAX_VIFS; i++) अणु
		vअगर = adapter->vअगरs[i];
		अगर (!vअगर)
			जारी;
		अगर (vअगर->type == NL80211_IFTYPE_STATION) अणु
			bss = &vअगर->bss_conf;
			अगर (bss->assoc) अणु
				assoc = true;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण
	अगर (assoc) अणु
		अगर (!common->hw_data_qs_blocked &&
		    (rsi_get_connected_channel(vअगर) != channel)) अणु
			rsi_dbg(INFO_ZONE, "blk data q %d\n", channel);
			अगर (!rsi_send_block_unblock_frame(common, true))
				common->hw_data_qs_blocked = true;
		पूर्ण
	पूर्ण

	status = rsi_band_check(common, curchan);
	अगर (!status)
		status = rsi_set_channel(adapter->priv, curchan);

	अगर (assoc) अणु
		अगर (common->hw_data_qs_blocked &&
		    (rsi_get_connected_channel(vअगर) == channel)) अणु
			rsi_dbg(INFO_ZONE, "unblk data q %d\n", channel);
			अगर (!rsi_send_block_unblock_frame(common, false))
				common->hw_data_qs_blocked = false;
		पूर्ण
	पूर्ण

	वापस status;
पूर्ण

/**
 * rsi_config_घातer() - This function configures tx घातer to device
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 *
 * Return: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_config_घातer(काष्ठा ieee80211_hw *hw)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_conf *conf = &hw->conf;

	अगर (adapter->sc_nvअगरs <= 0) अणु
		rsi_dbg(ERR_ZONE, "%s: No virtual interface found\n", __func__);
		वापस -EINVAL;
	पूर्ण

	rsi_dbg(INFO_ZONE,
		"%s: Set tx power: %d dBM\n", __func__, conf->घातer_level);

	अगर (conf->घातer_level == common->tx_घातer)
		वापस 0;

	common->tx_घातer = conf->घातer_level;

	वापस rsi_send_radio_params_update(common);
पूर्ण

/**
 * rsi_mac80211_config() - This function is a handler क्रम configuration
 *			   requests. The stack calls this function to
 *			   change hardware configuration, e.g., channel.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @changed: Changed flags set.
 *
 * Return: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_config(काष्ठा ieee80211_hw *hw,
			       u32 changed)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_conf *conf = &hw->conf;
	पूर्णांक status = -EOPNOTSUPP;

	mutex_lock(&common->mutex);

	अगर (changed & IEEE80211_CONF_CHANGE_CHANNEL)
		status = rsi_channel_change(hw);

	/* tx घातer */
	अगर (changed & IEEE80211_CONF_CHANGE_POWER) अणु
		rsi_dbg(INFO_ZONE, "%s: Configuring Power\n", __func__);
		status = rsi_config_घातer(hw);
	पूर्ण

	/* Power save parameters */
	अगर ((changed & IEEE80211_CONF_CHANGE_PS) &&
	    !common->mac_ops_resumed) अणु
		काष्ठा ieee80211_vअगर *vअगर, *sta_vअगर = शून्य;
		अचिन्हित दीर्घ flags;
		पूर्णांक i, set_ps = 1;

		क्रम (i = 0; i < RSI_MAX_VIFS; i++) अणु
			vअगर = adapter->vअगरs[i];
			अगर (!vअगर)
				जारी;
			/* Don't go to घातer save अगर AP vap exists */
			अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
			    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
				set_ps = 0;
				अवरोध;
			पूर्ण
			अगर ((vअगर->type == NL80211_IFTYPE_STATION ||
			     vअगर->type == NL80211_IFTYPE_P2P_CLIENT) &&
			    (!sta_vअगर || vअगर->bss_conf.assoc))
				sta_vअगर = vअगर;
		पूर्ण
		अगर (set_ps && sta_vअगर) अणु
			spin_lock_irqsave(&adapter->ps_lock, flags);
			अगर (conf->flags & IEEE80211_CONF_PS)
				rsi_enable_ps(adapter, sta_vअगर);
			अन्यथा
				rsi_disable_ps(adapter, sta_vअगर);
			spin_unlock_irqrestore(&adapter->ps_lock, flags);
		पूर्ण
	पूर्ण

	/* RTS threshold */
	अगर (changed & WIPHY_PARAM_RTS_THRESHOLD) अणु
		rsi_dbg(INFO_ZONE, "RTS threshold\n");
		अगर ((common->rts_threshold) <= IEEE80211_MAX_RTS_THRESHOLD) अणु
			rsi_dbg(INFO_ZONE,
				"%s: Sending vap updates....\n", __func__);
			status = rsi_send_vap_dynamic_update(common);
		पूर्ण
	पूर्ण
	mutex_unlock(&common->mutex);

	वापस status;
पूर्ण

/**
 * rsi_get_connected_channel() - This function is used to get the current
 *				 connected channel number.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 *
 * Return: Current connected AP's channel number is वापसed.
 */
u16 rsi_get_connected_channel(काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा ieee80211_bss_conf *bss;
	काष्ठा ieee80211_channel *channel;

	अगर (!vअगर)
		वापस 0;

	bss = &vअगर->bss_conf;
	channel = bss->chandef.chan;

	अगर (!channel)
		वापस 0;

	वापस channel->hw_value;
पूर्ण

अटल व्योम rsi_चयन_channel(काष्ठा rsi_hw *adapter,
			       काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_channel *channel;

	अगर (common->अगरace_करोwn)
		वापस;
	अगर (!vअगर)
		वापस;

	channel = vअगर->bss_conf.chandef.chan;

	अगर (!channel)
		वापस;

	rsi_band_check(common, channel);
	rsi_set_channel(common, channel);
	rsi_dbg(INFO_ZONE, "Switched to channel - %d\n", channel->hw_value);
पूर्ण

/**
 * rsi_mac80211_bss_info_changed() - This function is a handler क्रम config
 *				     requests related to BSS parameters that
 *				     may vary during BSS's lअगरespan.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @bss_conf: Poपूर्णांकer to the ieee80211_bss_conf काष्ठाure.
 * @changed: Changed flags set.
 *
 * Return: None.
 */
अटल व्योम rsi_mac80211_bss_info_changed(काष्ठा ieee80211_hw *hw,
					  काष्ठा ieee80211_vअगर *vअगर,
					  काष्ठा ieee80211_bss_conf *bss_conf,
					  u32 changed)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_bss_conf *bss = &vअगर->bss_conf;
	काष्ठा ieee80211_conf *conf = &hw->conf;
	u16 rx_filter_word = 0;

	mutex_lock(&common->mutex);
	अगर (changed & BSS_CHANGED_ASSOC) अणु
		rsi_dbg(INFO_ZONE, "%s: Changed Association status: %d\n",
			__func__, bss_conf->assoc);
		अगर (bss_conf->assoc) अणु
			/* Send the RX filter frame */
			rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
					  ALLOW_CTRL_ASSOC_PEER |
					  ALLOW_MGMT_ASSOC_PEER);
			rsi_send_rx_filter_frame(common, rx_filter_word);
		पूर्ण
		rsi_inक्रमm_bss_status(common,
				      RSI_OPMODE_STA,
				      bss_conf->assoc,
				      bss_conf->bssid,
				      bss_conf->qos,
				      bss_conf->aid,
				      शून्य, 0,
				      bss_conf->assoc_capability, vअगर);
		adapter->ps_info.dtim_पूर्णांकerval_duration = bss->dtim_period;
		adapter->ps_info.listen_पूर्णांकerval = conf->listen_पूर्णांकerval;

		/* If U-APSD is updated, send ps parameters to firmware */
		अगर (bss->assoc) अणु
			अगर (common->uapsd_biपंचांगap) अणु
				rsi_dbg(INFO_ZONE, "Configuring UAPSD\n");
				rsi_conf_uapsd(adapter, vअगर);
			पूर्ण
		पूर्ण अन्यथा अणु
			common->uapsd_biपंचांगap = 0;
		पूर्ण
	पूर्ण

	अगर (changed & BSS_CHANGED_CQM) अणु
		common->cqm_info.last_cqm_event_rssi = 0;
		common->cqm_info.rssi_thold = bss_conf->cqm_rssi_thold;
		common->cqm_info.rssi_hyst = bss_conf->cqm_rssi_hyst;
		rsi_dbg(INFO_ZONE, "RSSI threshold & hysteresis are: %d %d\n",
			common->cqm_info.rssi_thold,
			common->cqm_info.rssi_hyst);
	पूर्ण

	अगर ((changed & BSS_CHANGED_BEACON_ENABLED) &&
	    ((vअगर->type == NL80211_IFTYPE_AP) ||
	     (vअगर->type == NL80211_IFTYPE_P2P_GO))) अणु
		अगर (bss->enable_beacon) अणु
			rsi_dbg(INFO_ZONE, "===> BEACON ENABLED <===\n");
			common->beacon_enabled = 1;
		पूर्ण अन्यथा अणु
			rsi_dbg(INFO_ZONE, "===> BEACON DISABLED <===\n");
			common->beacon_enabled = 0;
		पूर्ण
	पूर्ण

	mutex_unlock(&common->mutex);
पूर्ण

/**
 * rsi_mac80211_conf_filter() - This function configure the device's RX filter.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @changed_flags: Changed flags set.
 * @total_flags: Total initial flags set.
 * @multicast: Multicast.
 *
 * Return: None.
 */
अटल व्योम rsi_mac80211_conf_filter(काष्ठा ieee80211_hw *hw,
				     u32 changed_flags,
				     u32 *total_flags,
				     u64 multicast)
अणु
	/* Not करोing much here as of now */
	*total_flags &= RSI_SUPP_FILTERS;
पूर्ण

/**
 * rsi_mac80211_conf_tx() - This function configures TX queue parameters
 *			    (EDCF (aअगरs, cw_min, cw_max), bursting)
 *			    क्रम a hardware TX queue.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @queue: Queue number.
 * @params: Poपूर्णांकer to ieee80211_tx_queue_params काष्ठाure.
 *
 * Return: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_conf_tx(काष्ठा ieee80211_hw *hw,
				काष्ठा ieee80211_vअगर *vअगर, u16 queue,
				स्थिर काष्ठा ieee80211_tx_queue_params *params)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	u8 idx = 0;

	अगर (queue >= IEEE80211_NUM_ACS)
		वापस 0;

	rsi_dbg(INFO_ZONE,
		"%s: Conf queue %d, aifs: %d, cwmin: %d cwmax: %d, txop: %d\n",
		__func__, queue, params->aअगरs,
		params->cw_min, params->cw_max, params->txop);

	mutex_lock(&common->mutex);
	/* Map पूर्णांकo the way the f/w expects */
	चयन (queue) अणु
	हाल IEEE80211_AC_VO:
		idx = VO_Q;
		अवरोध;
	हाल IEEE80211_AC_VI:
		idx = VI_Q;
		अवरोध;
	हाल IEEE80211_AC_BE:
		idx = BE_Q;
		अवरोध;
	हाल IEEE80211_AC_BK:
		idx = BK_Q;
		अवरोध;
	शेष:
		idx = BE_Q;
		अवरोध;
	पूर्ण

	स_नकल(&common->edca_params[idx],
	       params,
	       माप(काष्ठा ieee80211_tx_queue_params));

	अगर (params->uapsd)
		common->uapsd_biपंचांगap |= idx;
	अन्यथा
		common->uapsd_biपंचांगap &= (~idx);

	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

/**
 * rsi_hal_key_config() - This function loads the keys पूर्णांकo the firmware.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @key: Poपूर्णांकer to the ieee80211_key_conf काष्ठाure.
 * @sta: Poपूर्णांकer to the ieee80211_sta काष्ठाure.
 *
 * Return: status: 0 on success, negative error codes on failure.
 */
अटल पूर्णांक rsi_hal_key_config(काष्ठा ieee80211_hw *hw,
			      काष्ठा ieee80211_vअगर *vअगर,
			      काष्ठा ieee80211_key_conf *key,
			      काष्ठा ieee80211_sta *sta)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_sta *rsta = शून्य;
	पूर्णांक status;
	u8 key_type;
	s16 sta_id = 0;

	अगर (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
		key_type = RSI_PAIRWISE_KEY;
	अन्यथा
		key_type = RSI_GROUP_KEY;

	rsi_dbg(ERR_ZONE, "%s: Cipher 0x%x key_type: %d key_len: %d\n",
		__func__, key->cipher, key_type, key->keylen);

	अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
		अगर (sta) अणु
			rsta = rsi_find_sta(adapter->priv, sta->addr);
			अगर (rsta)
				sta_id = rsta->sta_id;
		पूर्ण
		adapter->priv->key = key;
	पूर्ण अन्यथा अणु
		अगर ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
		    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) अणु
			status = rsi_hal_load_key(adapter->priv,
						  key->key,
						  key->keylen,
						  RSI_PAIRWISE_KEY,
						  key->keyidx,
						  key->cipher,
						  sta_id,
						  vअगर);
			अगर (status)
				वापस status;
		पूर्ण
	पूर्ण

	status = rsi_hal_load_key(adapter->priv,
				  key->key,
				  key->keylen,
				  key_type,
				  key->keyidx,
				  key->cipher,
				  sta_id,
				  vअगर);
	अगर (status)
		वापस status;

	अगर (vअगर->type == NL80211_IFTYPE_STATION &&
	    (key->cipher == WLAN_CIPHER_SUITE_WEP104 ||
	     key->cipher == WLAN_CIPHER_SUITE_WEP40)) अणु
		अगर (!rsi_send_block_unblock_frame(adapter->priv, false))
			adapter->priv->hw_data_qs_blocked = false;
	पूर्ण

	वापस 0;
पूर्ण

/**
 * rsi_mac80211_set_key() - This function sets type of key to be loaded.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @cmd: क्रमागत set_key_cmd.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @sta: Poपूर्णांकer to the ieee80211_sta काष्ठाure.
 * @key: Poपूर्णांकer to the ieee80211_key_conf काष्ठाure.
 *
 * Return: status: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_set_key(काष्ठा ieee80211_hw *hw,
				क्रमागत set_key_cmd cmd,
				काष्ठा ieee80211_vअगर *vअगर,
				काष्ठा ieee80211_sta *sta,
				काष्ठा ieee80211_key_conf *key)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा security_info *secinfo = &common->secinfo;
	पूर्णांक status;

	mutex_lock(&common->mutex);
	चयन (cmd) अणु
	हाल SET_KEY:
		secinfo->security_enable = true;
		status = rsi_hal_key_config(hw, vअगर, key, sta);
		अगर (status) अणु
			mutex_unlock(&common->mutex);
			वापस status;
		पूर्ण

		अगर (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
			secinfo->ptk_cipher = key->cipher;
		अन्यथा
			secinfo->gtk_cipher = key->cipher;

		key->hw_key_idx = key->keyidx;
		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;

		rsi_dbg(ERR_ZONE, "%s: RSI set_key\n", __func__);
		अवरोध;

	हाल DISABLE_KEY:
		अगर (vअगर->type == NL80211_IFTYPE_STATION)
			secinfo->security_enable = false;
		rsi_dbg(ERR_ZONE, "%s: RSI del key\n", __func__);
		स_रखो(key, 0, माप(काष्ठा ieee80211_key_conf));
		status = rsi_hal_key_config(hw, vअगर, key, sta);
		अवरोध;

	शेष:
		status = -EOPNOTSUPP;
		अवरोध;
	पूर्ण

	mutex_unlock(&common->mutex);
	वापस status;
पूर्ण

/**
 * rsi_mac80211_ampdu_action() - This function selects the AMPDU action क्रम
 *				 the corresponding mlme_action flag and
 *				 inक्रमms the f/w regarding this.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @params: Poपूर्णांकer to A-MPDU action parameters
 *
 * Return: status: 0 on success, negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_ampdu_action(काष्ठा ieee80211_hw *hw,
				     काष्ठा ieee80211_vअगर *vअगर,
				     काष्ठा ieee80211_ampdu_params *params)
अणु
	पूर्णांक status = -EOPNOTSUPP;
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा rsi_sta *rsta = शून्य;
	u16 seq_no = 0, seq_start = 0;
	u8 ii = 0;
	काष्ठा ieee80211_sta *sta = params->sta;
	u8 sta_id = 0;
	क्रमागत ieee80211_ampdu_mlme_action action = params->action;
	u16 tid = params->tid;
	u16 *ssn = &params->ssn;
	u8 buf_size = params->buf_size;

	क्रम (ii = 0; ii < RSI_MAX_VIFS; ii++) अणु
		अगर (vअगर == adapter->vअगरs[ii])
			अवरोध;
	पूर्ण

	mutex_lock(&common->mutex);

	अगर (ssn != शून्य)
		seq_no = *ssn;

	अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
		rsta = rsi_find_sta(common, sta->addr);
		अगर (!rsta) अणु
			rsi_dbg(ERR_ZONE, "No station mapped\n");
			status = 0;
			जाओ unlock;
		पूर्ण
		sta_id = rsta->sta_id;
	पूर्ण

	rsi_dbg(INFO_ZONE,
		"%s: AMPDU action tid=%d ssn=0x%x, buf_size=%d sta_id=%d\n",
		__func__, tid, seq_no, buf_size, sta_id);

	चयन (action) अणु
	हाल IEEE80211_AMPDU_RX_START:
		status = rsi_send_aggregation_params_frame(common,
							   tid,
							   seq_no,
							   buf_size,
							   STA_RX_ADDBA_DONE,
							   sta_id);
		अवरोध;

	हाल IEEE80211_AMPDU_RX_STOP:
		status = rsi_send_aggregation_params_frame(common,
							   tid,
							   0,
							   buf_size,
							   STA_RX_DELBA,
							   sta_id);
		अवरोध;

	हाल IEEE80211_AMPDU_TX_START:
		अगर ((vअगर->type == NL80211_IFTYPE_STATION) ||
		    (vअगर->type == NL80211_IFTYPE_P2P_CLIENT))
			common->vअगर_info[ii].seq_start = seq_no;
		अन्यथा अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
			 (vअगर->type == NL80211_IFTYPE_P2P_GO))
			rsta->seq_start[tid] = seq_no;
		status = IEEE80211_AMPDU_TX_START_IMMEDIATE;
		अवरोध;

	हाल IEEE80211_AMPDU_TX_STOP_CONT:
	हाल IEEE80211_AMPDU_TX_STOP_FLUSH:
	हाल IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
		status = rsi_send_aggregation_params_frame(common,
							   tid,
							   seq_no,
							   buf_size,
							   STA_TX_DELBA,
							   sta_id);
		अगर (!status)
			ieee80211_stop_tx_ba_cb_irqsafe(vअगर, sta->addr, tid);
		अवरोध;

	हाल IEEE80211_AMPDU_TX_OPERATIONAL:
		अगर ((vअगर->type == NL80211_IFTYPE_STATION) ||
		    (vअगर->type == NL80211_IFTYPE_P2P_CLIENT))
			seq_start = common->vअगर_info[ii].seq_start;
		अन्यथा अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
			 (vअगर->type == NL80211_IFTYPE_P2P_GO))
			seq_start = rsta->seq_start[tid];
		status = rsi_send_aggregation_params_frame(common,
							   tid,
							   seq_start,
							   buf_size,
							   STA_TX_ADDBA_DONE,
							   sta_id);
		अवरोध;

	शेष:
		rsi_dbg(ERR_ZONE, "%s: Unknown AMPDU action\n", __func__);
		अवरोध;
	पूर्ण

unlock:
	mutex_unlock(&common->mutex);
	वापस status;
पूर्ण

/**
 * rsi_mac80211_set_rts_threshold() - This function sets rts threshold value.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @value: Rts threshold value.
 *
 * Return: 0 on success.
 */
अटल पूर्णांक rsi_mac80211_set_rts_threshold(काष्ठा ieee80211_hw *hw,
					  u32 value)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	mutex_lock(&common->mutex);
	common->rts_threshold = value;
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

/**
 * rsi_mac80211_set_rate_mask() - This function sets bitrate_mask to be used.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @mask: Poपूर्णांकer to the cfg80211_bitrate_mask काष्ठाure.
 *
 * Return: 0 on success.
 */
अटल पूर्णांक rsi_mac80211_set_rate_mask(काष्ठा ieee80211_hw *hw,
				      काष्ठा ieee80211_vअगर *vअगर,
				      स्थिर काष्ठा cfg80211_bitrate_mask *mask)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	क्रमागत nl80211_band band = hw->conf.chandef.chan->band;

	mutex_lock(&common->mutex);
	common->fixedrate_mask[band] = 0;

	अगर (mask->control[band].legacy == 0xfff) अणु
		common->fixedrate_mask[band] =
			(mask->control[band].ht_mcs[0] << 12);
	पूर्ण अन्यथा अणु
		common->fixedrate_mask[band] =
			mask->control[band].legacy;
	पूर्ण
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

/**
 * rsi_perक्रमm_cqm() - This function perक्रमms cqm.
 * @common: Poपूर्णांकer to the driver निजी काष्ठाure.
 * @bssid: poपूर्णांकer to the bssid.
 * @rssi: RSSI value.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 */
अटल व्योम rsi_perक्रमm_cqm(काष्ठा rsi_common *common,
			    u8 *bssid,
			    s8 rssi,
			    काष्ठा ieee80211_vअगर *vअगर)
अणु
	s8 last_event = common->cqm_info.last_cqm_event_rssi;
	पूर्णांक thold = common->cqm_info.rssi_thold;
	u32 hyst = common->cqm_info.rssi_hyst;
	क्रमागत nl80211_cqm_rssi_threshold_event event;

	अगर (rssi < thold && (last_event == 0 || rssi < (last_event - hyst)))
		event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
	अन्यथा अगर (rssi > thold &&
		 (last_event == 0 || rssi > (last_event + hyst)))
		event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
	अन्यथा
		वापस;

	common->cqm_info.last_cqm_event_rssi = rssi;
	rsi_dbg(INFO_ZONE, "CQM: Notifying event: %d\n", event);
	ieee80211_cqm_rssi_notअगरy(vअगर, event, rssi, GFP_KERNEL);

	वापस;
पूर्ण

/**
 * rsi_fill_rx_status() - This function fills rx status in
 *			  ieee80211_rx_status काष्ठाure.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @skb: Poपूर्णांकer to the socket buffer काष्ठाure.
 * @common: Poपूर्णांकer to the driver निजी काष्ठाure.
 * @rxs: Poपूर्णांकer to the ieee80211_rx_status काष्ठाure.
 *
 * Return: None.
 */
अटल व्योम rsi_fill_rx_status(काष्ठा ieee80211_hw *hw,
			       काष्ठा sk_buff *skb,
			       काष्ठा rsi_common *common,
			       काष्ठा ieee80211_rx_status *rxs)
अणु
	काष्ठा rsi_hw *adapter = common->priv;
	काष्ठा ieee80211_vअगर *vअगर;
	काष्ठा ieee80211_bss_conf *bss = शून्य;
	काष्ठा ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	काष्ठा skb_info *rx_params = (काष्ठा skb_info *)info->driver_data;
	काष्ठा ieee80211_hdr *hdr;
	अक्षर rssi = rx_params->rssi;
	u8 hdrlen = 0;
	u8 channel = rx_params->channel;
	s32 freq;
	पूर्णांक i;

	hdr = ((काष्ठा ieee80211_hdr *)(skb->data));
	hdrlen = ieee80211_hdrlen(hdr->frame_control);

	स_रखो(info, 0, माप(काष्ठा ieee80211_tx_info));

	rxs->संकेत = -(rssi);

	rxs->band = common->band;

	freq = ieee80211_channel_to_frequency(channel, rxs->band);

	अगर (freq)
		rxs->freq = freq;

	अगर (ieee80211_has_रक्षित(hdr->frame_control)) अणु
		अगर (rsi_is_cipher_wep(common)) अणु
			स_हटाओ(skb->data + 4, skb->data, hdrlen);
			skb_pull(skb, 4);
		पूर्ण अन्यथा अणु
			स_हटाओ(skb->data + 8, skb->data, hdrlen);
			skb_pull(skb, 8);
			rxs->flag |= RX_FLAG_MMIC_STRIPPED;
		पूर्ण
		rxs->flag |= RX_FLAG_DECRYPTED;
		rxs->flag |= RX_FLAG_IV_STRIPPED;
	पूर्ण

	क्रम (i = 0; i < RSI_MAX_VIFS; i++) अणु
		vअगर = adapter->vअगरs[i];
		अगर (!vअगर)
			जारी;
		अगर (vअगर->type == NL80211_IFTYPE_STATION) अणु
			bss = &vअगर->bss_conf;
			अवरोध;
		पूर्ण
	पूर्ण
	अगर (!bss)
		वापस;
	/* CQM only क्रम connected AP beacons, the RSSI is a weighted avg */
	अगर (bss->assoc && !(स_भेद(bss->bssid, hdr->addr2, ETH_ALEN))) अणु
		अगर (ieee80211_is_beacon(hdr->frame_control))
			rsi_perक्रमm_cqm(common, hdr->addr2, rxs->संकेत, vअगर);
	पूर्ण

	वापस;
पूर्ण

/**
 * rsi_indicate_pkt_to_os() - This function sends received packet to mac80211.
 * @common: Poपूर्णांकer to the driver निजी काष्ठाure.
 * @skb: Poपूर्णांकer to the socket buffer काष्ठाure.
 *
 * Return: None.
 */
व्योम rsi_indicate_pkt_to_os(काष्ठा rsi_common *common,
			    काष्ठा sk_buff *skb)
अणु
	काष्ठा rsi_hw *adapter = common->priv;
	काष्ठा ieee80211_hw *hw = adapter->hw;
	काष्ठा ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);

	अगर ((common->अगरace_करोwn) || (!adapter->sc_nvअगरs)) अणु
		dev_kमुक्त_skb(skb);
		वापस;
	पूर्ण

	/* filling in the ieee80211_rx_status flags */
	rsi_fill_rx_status(hw, skb, common, rx_status);

	ieee80211_rx_irqsafe(hw, skb);
पूर्ण

अटल व्योम rsi_set_min_rate(काष्ठा ieee80211_hw *hw,
			     काष्ठा ieee80211_sta *sta,
			     काष्ठा rsi_common *common)
अणु
	u8 band = hw->conf.chandef.chan->band;
	u8 ii;
	u32 rate_biपंचांगap;
	bool matched = false;

	common->bitrate_mask[band] = sta->supp_rates[band];

	rate_biपंचांगap = (common->fixedrate_mask[band] & sta->supp_rates[band]);

	अगर (rate_biपंचांगap & 0xfff) अणु
		/* Find out the min rate */
		क्रम (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) अणु
			अगर (rate_biपंचांगap & BIT(ii)) अणु
				common->min_rate = rsi_rates[ii].hw_value;
				matched = true;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण

	common->vअगर_info[0].is_ht = sta->ht_cap.ht_supported;

	अगर ((common->vअगर_info[0].is_ht) && (rate_biपंचांगap >> 12)) अणु
		क्रम (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) अणु
			अगर ((rate_biपंचांगap >> 12) & BIT(ii)) अणु
				common->min_rate = rsi_mcsrates[ii];
				matched = true;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण

	अगर (!matched)
		common->min_rate = 0xffff;
पूर्ण

/**
 * rsi_mac80211_sta_add() - This function notअगरies driver about a peer getting
 *			    connected.
 * @hw: poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @sta: Poपूर्णांकer to the ieee80211_sta काष्ठाure.
 *
 * Return: 0 on success, negative error codes on failure.
 */
अटल पूर्णांक rsi_mac80211_sta_add(काष्ठा ieee80211_hw *hw,
				काष्ठा ieee80211_vअगर *vअगर,
				काष्ठा ieee80211_sta *sta)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	bool sta_exist = false;
	काष्ठा rsi_sta *rsta;
	पूर्णांक status = 0;

	rsi_dbg(INFO_ZONE, "Station Add: %pM\n", sta->addr);

	mutex_lock(&common->mutex);

	अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
		u8 cnt;
		पूर्णांक sta_idx = -1;
		पूर्णांक मुक्त_index = -1;

		/* Check अगर max stations reached */
		अगर (common->num_stations >= common->max_stations) अणु
			rsi_dbg(ERR_ZONE, "Reject: Max Stations exists\n");
			status = -EOPNOTSUPP;
			जाओ unlock;
		पूर्ण
		क्रम (cnt = 0; cnt < common->max_stations; cnt++) अणु
			rsta = &common->stations[cnt];

			अगर (!rsta->sta) अणु
				अगर (मुक्त_index < 0)
					मुक्त_index = cnt;
				जारी;
			पूर्ण
			अगर (!स_भेद(rsta->sta->addr, sta->addr, ETH_ALEN)) अणु
				rsi_dbg(INFO_ZONE, "Station exists\n");
				sta_idx = cnt;
				sta_exist = true;
				अवरोध;
			पूर्ण
		पूर्ण
		अगर (!sta_exist) अणु
			अगर (मुक्त_index >= 0)
				sta_idx = मुक्त_index;
		पूर्ण
		अगर (sta_idx < 0) अणु
			rsi_dbg(ERR_ZONE,
				"%s: Some problem reaching here...\n",
				__func__);
			status = -EINVAL;
			जाओ unlock;
		पूर्ण
		rsta = &common->stations[sta_idx];
		rsta->sta = sta;
		rsta->sta_id = sta_idx;
		क्रम (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)
			rsta->start_tx_aggr[cnt] = false;
		क्रम (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)
			rsta->seq_start[cnt] = 0;
		अगर (!sta_exist) अणु
			rsi_dbg(INFO_ZONE, "New Station\n");

			/* Send peer notअगरy to device */
			rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
			rsi_inक्रमm_bss_status(common, RSI_OPMODE_AP, 1,
					      sta->addr, sta->wme, sta->aid,
					      sta, sta_idx, 0, vअगर);

			अगर (common->key) अणु
				काष्ठा ieee80211_key_conf *key = common->key;

				अगर ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
				    (key->cipher == WLAN_CIPHER_SUITE_WEP40))
					rsi_hal_load_key(adapter->priv,
							 key->key,
							 key->keylen,
							 RSI_PAIRWISE_KEY,
							 key->keyidx,
							 key->cipher,
							 sta_idx,
							 vअगर);
			पूर्ण

			common->num_stations++;
		पूर्ण
	पूर्ण

	अगर ((vअगर->type == NL80211_IFTYPE_STATION) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_CLIENT)) अणु
		rsi_set_min_rate(hw, sta, common);
		अगर (sta->ht_cap.ht_supported) अणु
			common->vअगर_info[0].is_ht = true;
			common->bitrate_mask[NL80211_BAND_2GHZ] =
					sta->supp_rates[NL80211_BAND_2GHZ];
			अगर ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
			    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
				common->vअगर_info[0].sgi = true;
			ieee80211_start_tx_ba_session(sta, 0, 0);
		पूर्ण
	पूर्ण

unlock:
	mutex_unlock(&common->mutex);

	वापस status;
पूर्ण

/**
 * rsi_mac80211_sta_हटाओ() - This function notअगरies driver about a peer
 *			       getting disconnected.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @vअगर: Poपूर्णांकer to the ieee80211_vअगर काष्ठाure.
 * @sta: Poपूर्णांकer to the ieee80211_sta काष्ठाure.
 *
 * Return: 0 on success, negative error codes on failure.
 */
अटल पूर्णांक rsi_mac80211_sta_हटाओ(काष्ठा ieee80211_hw *hw,
				   काष्ठा ieee80211_vअगर *vअगर,
				   काष्ठा ieee80211_sta *sta)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	काष्ठा ieee80211_bss_conf *bss = &vअगर->bss_conf;
	काष्ठा rsi_sta *rsta;

	rsi_dbg(INFO_ZONE, "Station Remove: %pM\n", sta->addr);

	mutex_lock(&common->mutex);

	अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
		u8 sta_idx, cnt;

		/* Send peer notअगरy to device */
		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
		क्रम (sta_idx = 0; sta_idx < common->max_stations; sta_idx++) अणु
			rsta = &common->stations[sta_idx];

			अगर (!rsta->sta)
				जारी;
			अगर (!स_भेद(rsta->sta->addr, sta->addr, ETH_ALEN)) अणु
				rsi_inक्रमm_bss_status(common, RSI_OPMODE_AP, 0,
						      sta->addr, sta->wme,
						      sta->aid, sta, sta_idx,
						      0, vअगर);
				rsta->sta = शून्य;
				rsta->sta_id = -1;
				क्रम (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)
					rsta->start_tx_aggr[cnt] = false;
				अगर (common->num_stations > 0)
					common->num_stations--;
				अवरोध;
			पूर्ण
		पूर्ण
		अगर (sta_idx >= common->max_stations)
			rsi_dbg(ERR_ZONE, "%s: No station found\n", __func__);
	पूर्ण

	अगर ((vअगर->type == NL80211_IFTYPE_STATION) ||
	    (vअगर->type == NL80211_IFTYPE_P2P_CLIENT)) अणु
		/* Resetting all the fields to शेष values */
		स_नकल((u8 *)bss->bssid, (u8 *)sta->addr, ETH_ALEN);
		bss->qos = sta->wme;
		common->bitrate_mask[NL80211_BAND_2GHZ] = 0;
		common->bitrate_mask[NL80211_BAND_5GHZ] = 0;
		common->min_rate = 0xffff;
		common->vअगर_info[0].is_ht = false;
		common->vअगर_info[0].sgi = false;
		common->vअगर_info[0].seq_start = 0;
		common->secinfo.ptk_cipher = 0;
		common->secinfo.gtk_cipher = 0;
		अगर (!common->अगरace_करोwn)
			rsi_send_rx_filter_frame(common, 0);
	पूर्ण
	mutex_unlock(&common->mutex);
	
	वापस 0;
पूर्ण

/**
 * rsi_mac80211_set_antenna() - This function is used to configure
 *				tx and rx antennas.
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @tx_ant: Biपंचांगap क्रम tx antenna
 * @rx_ant: Biपंचांगap क्रम rx antenna
 *
 * Return: 0 on success, Negative error code on failure.
 */
अटल पूर्णांक rsi_mac80211_set_antenna(काष्ठा ieee80211_hw *hw,
				    u32 tx_ant, u32 rx_ant)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;
	u8 antenna = 0;

	अगर (tx_ant > 1 || rx_ant > 1) अणु
		rsi_dbg(ERR_ZONE,
			"Invalid antenna selection (tx: %d, rx:%d)\n",
			tx_ant, rx_ant);
		rsi_dbg(ERR_ZONE,
			"Use 0 for int_ant, 1 for ext_ant\n");
		वापस -EINVAL; 
	पूर्ण

	rsi_dbg(INFO_ZONE, "%s: Antenna map Tx %x Rx %d\n",
			__func__, tx_ant, rx_ant);

	mutex_lock(&common->mutex);

	antenna = tx_ant ? ANTENNA_SEL_UFL : ANTENNA_SEL_INT;
	अगर (common->ant_in_use != antenna)
		अगर (rsi_set_antenna(common, antenna))
			जाओ fail_set_antenna;

	rsi_dbg(INFO_ZONE, "(%s) Antenna path configured successfully\n",
		tx_ant ? "UFL" : "INT");

	common->ant_in_use = antenna;
	
	mutex_unlock(&common->mutex);
	
	वापस 0;

fail_set_antenna:
	rsi_dbg(ERR_ZONE, "%s: Failed.\n", __func__);
	mutex_unlock(&common->mutex);
	वापस -EINVAL;
पूर्ण

/**
 * rsi_mac80211_get_antenna() - This function is used to configure 
 * 				tx and rx antennas.
 *
 * @hw: Poपूर्णांकer to the ieee80211_hw काष्ठाure.
 * @tx_ant: Biपंचांगap क्रम tx antenna
 * @rx_ant: Biपंचांगap क्रम rx antenna
 * 
 * Return: 0 on success, negative error codes on failure.
 */
अटल पूर्णांक rsi_mac80211_get_antenna(काष्ठा ieee80211_hw *hw,
				    u32 *tx_ant, u32 *rx_ant)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	mutex_lock(&common->mutex);

	*tx_ant = (common->ant_in_use == ANTENNA_SEL_UFL) ? 1 : 0;
	*rx_ant = 0;

	mutex_unlock(&common->mutex);
	
	वापस 0;	
पूर्ण

अटल पूर्णांक rsi_map_region_code(क्रमागत nl80211_dfs_regions region_code)
अणु
	चयन (region_code) अणु
	हाल NL80211_DFS_FCC:
		वापस RSI_REGION_FCC;
	हाल NL80211_DFS_ETSI:
		वापस RSI_REGION_ETSI;
	हाल NL80211_DFS_JP:
		वापस RSI_REGION_TELEC;
	हाल NL80211_DFS_UNSET:
		वापस RSI_REGION_WORLD;
	पूर्ण
	वापस RSI_REGION_WORLD;
पूर्ण

अटल व्योम rsi_reg_notअगरy(काष्ठा wiphy *wiphy,
			   काष्ठा regulatory_request *request)
अणु
	काष्ठा ieee80211_supported_band *sband;
	काष्ठा ieee80211_channel *ch;
	काष्ठा ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
	काष्ठा rsi_hw * adapter = hw->priv; 
	काष्ठा rsi_common *common = adapter->priv;
	पूर्णांक i;
	
	mutex_lock(&common->mutex);

	rsi_dbg(INFO_ZONE, "country = %s dfs_region = %d\n",
		request->alpha2, request->dfs_region);

	अगर (common->num_supp_bands > 1) अणु
		sband = wiphy->bands[NL80211_BAND_5GHZ];

		क्रम (i = 0; i < sband->n_channels; i++) अणु
			ch = &sband->channels[i];
			अगर (ch->flags & IEEE80211_CHAN_DISABLED)
				जारी;

			अगर (ch->flags & IEEE80211_CHAN_RADAR)
				ch->flags |= IEEE80211_CHAN_NO_IR;
		पूर्ण
	पूर्ण
	adapter->dfs_region = rsi_map_region_code(request->dfs_region);
	rsi_dbg(INFO_ZONE, "RSI region code = %d\n", adapter->dfs_region);
	
	adapter->country[0] = request->alpha2[0];
	adapter->country[1] = request->alpha2[1];

	mutex_unlock(&common->mutex);
पूर्ण

अटल व्योम rsi_mac80211_rfसमाप्त_poll(काष्ठा ieee80211_hw *hw)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	mutex_lock(&common->mutex);
	अगर (common->fsm_state != FSM_MAC_INIT_DONE)
		wiphy_rfसमाप्त_set_hw_state(hw->wiphy, true);
	अन्यथा
		wiphy_rfसमाप्त_set_hw_state(hw->wiphy, false);
	mutex_unlock(&common->mutex);
पूर्ण

अटल व्योम rsi_resume_conn_channel(काष्ठा rsi_common *common)
अणु
	काष्ठा rsi_hw *adapter = common->priv;
	काष्ठा ieee80211_vअगर *vअगर;
	पूर्णांक cnt;

	क्रम (cnt = 0; cnt < RSI_MAX_VIFS; cnt++) अणु
		vअगर = adapter->vअगरs[cnt];
		अगर (!vअगर)
			जारी;

		अगर ((vअगर->type == NL80211_IFTYPE_AP) ||
		    (vअगर->type == NL80211_IFTYPE_P2P_GO)) अणु
			rsi_चयन_channel(adapter, vअगर);
			अवरोध;
		पूर्ण
		अगर (((vअगर->type == NL80211_IFTYPE_STATION) ||
		     (vअगर->type == NL80211_IFTYPE_P2P_CLIENT)) &&
		    vअगर->bss_conf.assoc) अणु
			rsi_चयन_channel(adapter, vअगर);
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

व्योम rsi_roc_समयout(काष्ठा समयr_list *t)
अणु
	काष्ठा rsi_common *common = from_समयr(common, t, roc_समयr);

	rsi_dbg(INFO_ZONE, "Remain on channel expired\n");

	mutex_lock(&common->mutex);
	ieee80211_reमुख्य_on_channel_expired(common->priv->hw);

	अगर (समयr_pending(&common->roc_समयr))
		del_समयr(&common->roc_समयr);

	rsi_resume_conn_channel(common);
	mutex_unlock(&common->mutex);
पूर्ण

अटल पूर्णांक rsi_mac80211_roc(काष्ठा ieee80211_hw *hw, काष्ठा ieee80211_vअगर *vअगर,
			    काष्ठा ieee80211_channel *chan, पूर्णांक duration,
			    क्रमागत ieee80211_roc_type type)
अणु
	काष्ठा rsi_hw *adapter = (काष्ठा rsi_hw *)hw->priv;
	काष्ठा rsi_common *common = (काष्ठा rsi_common *)adapter->priv;
	पूर्णांक status = 0;

	rsi_dbg(INFO_ZONE, "***** Remain on channel *****\n");

	mutex_lock(&common->mutex);
	rsi_dbg(INFO_ZONE, "%s: channel: %d duration: %dms\n",
		__func__, chan->hw_value, duration);

	अगर (समयr_pending(&common->roc_समयr)) अणु
		rsi_dbg(INFO_ZONE, "Stop on-going ROC\n");
		del_समयr(&common->roc_समयr);
	पूर्ण
	common->roc_समयr.expires = msecs_to_jअगरfies(duration) + jअगरfies;
	add_समयr(&common->roc_समयr);

	/* Configure band */
	अगर (rsi_band_check(common, chan)) अणु
		rsi_dbg(ERR_ZONE, "Failed to set band\n");
		status = -EINVAL;
		जाओ out;
	पूर्ण

	/* Configure channel */
	अगर (rsi_set_channel(common, chan)) अणु
		rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
		status = -EINVAL;
		जाओ out;
	पूर्ण

	common->roc_vअगर = vअगर;
	ieee80211_पढ़ोy_on_channel(hw);
	rsi_dbg(INFO_ZONE, "%s: Ready on channel :%d\n",
		__func__, chan->hw_value);

out:
	mutex_unlock(&common->mutex);

	वापस status;
पूर्ण

अटल पूर्णांक rsi_mac80211_cancel_roc(काष्ठा ieee80211_hw *hw,
				   काष्ठा ieee80211_vअगर *vअगर)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	rsi_dbg(INFO_ZONE, "Cancel remain on channel\n");

	mutex_lock(&common->mutex);
	अगर (!समयr_pending(&common->roc_समयr)) अणु
		mutex_unlock(&common->mutex);
		वापस 0;
	पूर्ण

	del_समयr(&common->roc_समयr);

	rsi_resume_conn_channel(common);
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

#अगर_घोषित CONFIG_PM
अटल स्थिर काष्ठा wiphy_wowlan_support rsi_wowlan_support = अणु
	.flags = WIPHY_WOWLAN_ANY |
		 WIPHY_WOWLAN_MAGIC_PKT |
		 WIPHY_WOWLAN_DISCONNECT |
		 WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
		 WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
		 WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
		 WIPHY_WOWLAN_4WAY_HANDSHAKE,
पूर्ण;

अटल u16 rsi_wow_map_triggers(काष्ठा rsi_common *common,
				काष्ठा cfg80211_wowlan *wowlan)
अणु
	u16 wow_triggers = 0;

	rsi_dbg(INFO_ZONE, "Mapping wowlan triggers\n");

	अगर (wowlan->any)
		wow_triggers |= RSI_WOW_ANY;
	अगर (wowlan->magic_pkt)
		wow_triggers |= RSI_WOW_MAGIC_PKT;
	अगर (wowlan->disconnect)
		wow_triggers |= RSI_WOW_DISCONNECT;
	अगर (wowlan->gtk_rekey_failure || wowlan->eap_identity_req ||
	    wowlan->four_way_handshake)
		wow_triggers |= RSI_WOW_GTK_REKEY;

	वापस wow_triggers;
पूर्ण

पूर्णांक rsi_config_wowlan(काष्ठा rsi_hw *adapter, काष्ठा cfg80211_wowlan *wowlan)
अणु
	काष्ठा rsi_common *common = adapter->priv;
	u16 triggers = 0;
	u16 rx_filter_word = 0;
	काष्ठा ieee80211_bss_conf *bss = शून्य;

	rsi_dbg(INFO_ZONE, "Config WoWLAN to device\n");

	अगर (!adapter->vअगरs[0])
		वापस -EINVAL;

	bss = &adapter->vअगरs[0]->bss_conf;

	अगर (WARN_ON(!wowlan)) अणु
		rsi_dbg(ERR_ZONE, "WoW triggers not enabled\n");
		वापस -EINVAL;
	पूर्ण

	common->wow_flags |= RSI_WOW_ENABLED;
	triggers = rsi_wow_map_triggers(common, wowlan);
	अगर (!triggers) अणु
		rsi_dbg(ERR_ZONE, "%s:No valid WoW triggers\n", __func__);
		वापस -EINVAL;
	पूर्ण
	अगर (!bss->assoc) अणु
		rsi_dbg(ERR_ZONE,
			"Cannot configure WoWLAN (Station not connected)\n");
		common->wow_flags |= RSI_WOW_NO_CONNECTION;
		वापस 0;
	पूर्ण
	rsi_dbg(INFO_ZONE, "TRIGGERS %x\n", triggers);

	अगर (common->coex_mode > 1)
		rsi_disable_ps(adapter, adapter->vअगरs[0]);

	rsi_send_wowlan_request(common, triggers, 1);

	/**
	 * Increase the beacon_miss threshold & keep-alive समयrs in
	 * vap_update frame
	 */
	rsi_send_vap_dynamic_update(common);

	rx_filter_word = (ALLOW_DATA_ASSOC_PEER | DISALLOW_BEACONS);
	rsi_send_rx_filter_frame(common, rx_filter_word);

	वापस 0;
पूर्ण
EXPORT_SYMBOL(rsi_config_wowlan);

अटल पूर्णांक rsi_mac80211_suspend(काष्ठा ieee80211_hw *hw,
				काष्ठा cfg80211_wowlan *wowlan)
अणु
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	rsi_dbg(INFO_ZONE, "%s: mac80211 suspend\n", __func__);
	mutex_lock(&common->mutex);
	अगर (rsi_config_wowlan(adapter, wowlan)) अणु
		rsi_dbg(ERR_ZONE, "Failed to configure WoWLAN\n");
		mutex_unlock(&common->mutex);
		वापस 1;
	पूर्ण
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

अटल पूर्णांक rsi_mac80211_resume(काष्ठा ieee80211_hw *hw)
अणु
	u16 rx_filter_word = 0;
	काष्ठा rsi_hw *adapter = hw->priv;
	काष्ठा rsi_common *common = adapter->priv;

	common->wow_flags = 0;

	rsi_dbg(INFO_ZONE, "%s: mac80211 resume\n", __func__);

	अगर (common->hibernate_resume) अणु
		common->mac_ops_resumed = true;
		/* Device need a complete restart of all MAC operations.
		 * वापसing 1 will serve this purpose.
		 */
		वापस 1;
	पूर्ण

	mutex_lock(&common->mutex);
	rsi_send_wowlan_request(common, 0, 0);

	rx_filter_word = (ALLOW_DATA_ASSOC_PEER | ALLOW_CTRL_ASSOC_PEER |
			  ALLOW_MGMT_ASSOC_PEER);
	rsi_send_rx_filter_frame(common, rx_filter_word);
	mutex_unlock(&common->mutex);

	वापस 0;
पूर्ण

#पूर्ण_अगर

अटल स्थिर काष्ठा ieee80211_ops mac80211_ops = अणु
	.tx = rsi_mac80211_tx,
	.start = rsi_mac80211_start,
	.stop = rsi_mac80211_stop,
	.add_पूर्णांकerface = rsi_mac80211_add_पूर्णांकerface,
	.हटाओ_पूर्णांकerface = rsi_mac80211_हटाओ_पूर्णांकerface,
	.config = rsi_mac80211_config,
	.bss_info_changed = rsi_mac80211_bss_info_changed,
	.conf_tx = rsi_mac80211_conf_tx,
	.configure_filter = rsi_mac80211_conf_filter,
	.set_key = rsi_mac80211_set_key,
	.set_rts_threshold = rsi_mac80211_set_rts_threshold,
	.set_bitrate_mask = rsi_mac80211_set_rate_mask,
	.ampdu_action = rsi_mac80211_ampdu_action,
	.sta_add = rsi_mac80211_sta_add,
	.sta_हटाओ = rsi_mac80211_sta_हटाओ,
	.set_antenna = rsi_mac80211_set_antenna,
	.get_antenna = rsi_mac80211_get_antenna,
	.rfसमाप्त_poll = rsi_mac80211_rfसमाप्त_poll,
	.reमुख्य_on_channel = rsi_mac80211_roc,
	.cancel_reमुख्य_on_channel = rsi_mac80211_cancel_roc,
#अगर_घोषित CONFIG_PM
	.suspend = rsi_mac80211_suspend,
	.resume  = rsi_mac80211_resume,
#पूर्ण_अगर
	.hw_scan = rsi_mac80211_hw_scan_start,
	.cancel_hw_scan = rsi_mac80211_cancel_hw_scan,
पूर्ण;

/**
 * rsi_mac80211_attach() - This function is used to initialize Mac80211 stack.
 * @common: Poपूर्णांकer to the driver निजी काष्ठाure.
 *
 * Return: 0 on success, negative error codes on failure.
 */
पूर्णांक rsi_mac80211_attach(काष्ठा rsi_common *common)
अणु
	पूर्णांक status = 0;
	काष्ठा ieee80211_hw *hw = शून्य;
	काष्ठा wiphy *wiphy = शून्य;
	काष्ठा rsi_hw *adapter = common->priv;
	u8 addr_mask[ETH_ALEN] = अणु0x0, 0x0, 0x0, 0x0, 0x0, 0x3पूर्ण;

	rsi_dbg(INIT_ZONE, "%s: Performing mac80211 attach\n", __func__);

	hw = ieee80211_alloc_hw(माप(काष्ठा rsi_hw), &mac80211_ops);
	अगर (!hw) अणु
		rsi_dbg(ERR_ZONE, "%s: ieee80211 hw alloc failed\n", __func__);
		वापस -ENOMEM;
	पूर्ण

	wiphy = hw->wiphy;

	SET_IEEE80211_DEV(hw, adapter->device);

	hw->priv = adapter;
	adapter->hw = hw;

	ieee80211_hw_set(hw, SIGNAL_DBM);
	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
	ieee80211_hw_set(hw, SUPPORTS_PS);
	ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);

	hw->queues = MAX_HW_QUEUES;
	hw->extra_tx_headroom = RSI_NEEDED_HEADROOM;

	hw->max_rates = 1;
	hw->max_rate_tries = MAX_RETRIES;
	hw->uapsd_queues = RSI_IEEE80211_UAPSD_QUEUES;
	hw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL;

	hw->max_tx_aggregation_subframes = RSI_MAX_TX_AGGR_FRMS;
	hw->max_rx_aggregation_subframes = RSI_MAX_RX_AGGR_FRMS;
	hw->rate_control_algorithm = "AARF";

	SET_IEEE80211_PERM_ADDR(hw, common->mac_addr);
	ether_addr_copy(hw->wiphy->addr_mask, addr_mask);

	wiphy->पूर्णांकerface_modes = BIT(NL80211_IFTYPE_STATION) |
				 BIT(NL80211_IFTYPE_AP) |
				 BIT(NL80211_IFTYPE_P2P_DEVICE) |
				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
				 BIT(NL80211_IFTYPE_P2P_GO);

	wiphy->संकेत_type = CFG80211_SIGNAL_TYPE_MBM;
	wiphy->retry_लघु = RETRY_SHORT;
	wiphy->retry_दीर्घ  = RETRY_LONG;
	wiphy->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
	wiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
	wiphy->flags = 0;

	wiphy->available_antennas_rx = 1;
	wiphy->available_antennas_tx = 1;

	status = rsi_रेजिस्टर_rates_channels(adapter, NL80211_BAND_2GHZ);
	अगर (status)
		वापस status;
	wiphy->bands[NL80211_BAND_2GHZ] =
		&adapter->sbands[NL80211_BAND_2GHZ];
	अगर (common->num_supp_bands > 1) अणु
		status = rsi_रेजिस्टर_rates_channels(adapter,
						     NL80211_BAND_5GHZ);
		अगर (status)
			वापस status;
		wiphy->bands[NL80211_BAND_5GHZ] =
			&adapter->sbands[NL80211_BAND_5GHZ];
	पूर्ण

	/* AP Parameters */
	wiphy->max_ap_assoc_sta = rsi_max_ap_stas[common->oper_mode - 1];
	common->max_stations = wiphy->max_ap_assoc_sta;
	rsi_dbg(ERR_ZONE, "Max Stations Allowed = %d\n", common->max_stations);
	hw->sta_data_size = माप(काष्ठा rsi_sta);

	wiphy->max_scan_ssids = RSI_MAX_SCAN_SSIDS;
	wiphy->max_scan_ie_len = RSI_MAX_SCAN_IE_LEN;
	wiphy->flags = WIPHY_FLAG_REPORTS_OBSS;
	wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
	wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
	wiphy->reg_notअगरier = rsi_reg_notअगरy;

#अगर_घोषित CONFIG_PM
	wiphy->wowlan = &rsi_wowlan_support;
#पूर्ण_अगर

	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);

	/* Wi-Fi direct parameters */
	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX;
	wiphy->max_reमुख्य_on_channel_duration = 10000;
	hw->max_listen_पूर्णांकerval = 10;
	wiphy->अगरace_combinations = rsi_अगरace_combinations;
	wiphy->n_अगरace_combinations = ARRAY_SIZE(rsi_अगरace_combinations);

	अगर (common->coex_mode > 1)
		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;

	status = ieee80211_रेजिस्टर_hw(hw);
	अगर (status)
		वापस status;

	वापस rsi_init_dbgfs(adapter);
पूर्ण
