<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/*
 * This file contains the handling of command
 * responses as well as events generated by firmware.
 */

#समावेश <linux/hardirq.h>
#समावेश <linux/slab.h>
#समावेश <linux/delay.h>
#समावेश <linux/sched.h>
#समावेश <यंत्र/unaligned.h>
#समावेश <net/cfg80211.h>

#समावेश "cfg.h"
#समावेश "cmd.h"

/**
 * lbs_mac_event_disconnected - handles disconnect event. It
 * reports disconnect to upper layer, clean tx/rx packets,
 * reset link state etc.
 *
 * @priv:	A poपूर्णांकer to काष्ठा lbs_निजी काष्ठाure
 * @locally_generated: indicates disconnect was requested locally
 *		(usually by userspace)
 *
 * वापसs:	n/a
 */
व्योम lbs_mac_event_disconnected(काष्ठा lbs_निजी *priv,
				bool locally_generated)
अणु
	अचिन्हित दीर्घ flags;

	अगर (priv->connect_status != LBS_CONNECTED)
		वापस;

	/*
	 * Cisco AP sends EAP failure and de-auth in less than 0.5 ms.
	 * It causes problem in the Supplicant
	 */
	msleep_पूर्णांकerruptible(1000);

	अगर (priv->wdev->अगरtype == NL80211_IFTYPE_STATION)
		lbs_send_disconnect_notअगरication(priv, locally_generated);

	/* report disconnect to upper layer */
	netअगर_stop_queue(priv->dev);
	netअगर_carrier_off(priv->dev);

	/* Free Tx and Rx packets */
	spin_lock_irqsave(&priv->driver_lock, flags);
	kमुक्त_skb(priv->currenttxskb);
	priv->currenttxskb = शून्य;
	priv->tx_pending_len = 0;
	spin_unlock_irqrestore(&priv->driver_lock, flags);

	priv->connect_status = LBS_DISCONNECTED;

	अगर (priv->psstate != PS_STATE_FULL_POWER) अणु
		/* make firmware to निकास PS mode */
		lbs_deb_cmd("disconnected, so exit PS mode\n");
		lbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS, false);
	पूर्ण
पूर्ण

पूर्णांक lbs_process_command_response(काष्ठा lbs_निजी *priv, u8 *data, u32 len)
अणु
	uपूर्णांक16_t respcmd, curcmd;
	काष्ठा cmd_header *resp;
	पूर्णांक ret = 0;
	अचिन्हित दीर्घ flags;
	uपूर्णांक16_t result;

	mutex_lock(&priv->lock);
	spin_lock_irqsave(&priv->driver_lock, flags);

	अगर (!priv->cur_cmd) अणु
		lbs_deb_host("CMD_RESP: cur_cmd is NULL\n");
		ret = -1;
		spin_unlock_irqrestore(&priv->driver_lock, flags);
		जाओ करोne;
	पूर्ण

	resp = (व्योम *)data;
	curcmd = le16_to_cpu(priv->cur_cmd->cmdbuf->command);
	respcmd = le16_to_cpu(resp->command);
	result = le16_to_cpu(resp->result);

	lbs_deb_cmd("CMD_RESP: response 0x%04x, seq %d, size %d\n",
		     respcmd, le16_to_cpu(resp->seqnum), len);
	lbs_deb_hex(LBS_DEB_CMD, "CMD_RESP", (व्योम *) resp, len);

	अगर (resp->seqnum != priv->cur_cmd->cmdbuf->seqnum) अणु
		netdev_info(priv->dev,
			    "Received CMD_RESP with invalid sequence %d (expected %d)\n",
			    le16_to_cpu(resp->seqnum),
			    le16_to_cpu(priv->cur_cmd->cmdbuf->seqnum));
		spin_unlock_irqrestore(&priv->driver_lock, flags);
		ret = -1;
		जाओ करोne;
	पूर्ण
	अगर (respcmd != CMD_RET(curcmd) &&
	    respcmd != CMD_RET_802_11_ASSOCIATE && curcmd != CMD_802_11_ASSOCIATE) अणु
		netdev_info(priv->dev, "Invalid CMD_RESP %x to command %x!\n",
			    respcmd, curcmd);
		spin_unlock_irqrestore(&priv->driver_lock, flags);
		ret = -1;
		जाओ करोne;
	पूर्ण

	अगर (resp->result == cpu_to_le16(0x0004)) अणु
		/* 0x0004 means -EAGAIN. Drop the response, let it समय out
		   and be resubmitted */
		netdev_info(priv->dev,
			    "Firmware returns DEFER to command %x. Will let it time out...\n",
			    le16_to_cpu(resp->command));
		spin_unlock_irqrestore(&priv->driver_lock, flags);
		ret = -1;
		जाओ करोne;
	पूर्ण

	/* Now we got response from FW, cancel the command समयr */
	del_समयr(&priv->command_समयr);
	priv->cmd_समयd_out = 0;

	अगर (respcmd == CMD_RET(CMD_802_11_PS_MODE)) अणु
		/* काष्ठा cmd_ds_802_11_ps_mode also contains
		 * the header
		 */
		काष्ठा cmd_ds_802_11_ps_mode *psmode = (व्योम *)resp;
		u16 action = le16_to_cpu(psmode->action);

		lbs_deb_host(
		       "CMD_RESP: PS_MODE cmd reply result 0x%x, action 0x%x\n",
		       result, action);

		अगर (result) अणु
			lbs_deb_host("CMD_RESP: PS command failed with 0x%x\n",
				    result);
			/*
			 * We should not re-try enter-ps command in
			 * ad-hoc mode. It takes place in
			 * lbs_execute_next_command().
			 */
			अगर (priv->wdev->अगरtype == NL80211_IFTYPE_MONITOR &&
			    action == PS_MODE_ACTION_ENTER_PS)
				priv->psmode = LBS802_11POWERMODECAM;
		पूर्ण अन्यथा अगर (action == PS_MODE_ACTION_ENTER_PS) अणु
			priv->needtowakeup = 0;
			priv->psstate = PS_STATE_AWAKE;

			lbs_deb_host("CMD_RESP: ENTER_PS command response\n");
			अगर (priv->connect_status != LBS_CONNECTED) अणु
				/*
				 * When Deauth Event received beक्रमe Enter_PS command
				 * response, We need to wake up the firmware.
				 */
				lbs_deb_host(
				       "disconnected, invoking lbs_ps_wakeup\n");

				spin_unlock_irqrestore(&priv->driver_lock, flags);
				mutex_unlock(&priv->lock);
				lbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS,
						false);
				mutex_lock(&priv->lock);
				spin_lock_irqsave(&priv->driver_lock, flags);
			पूर्ण
		पूर्ण अन्यथा अगर (action == PS_MODE_ACTION_EXIT_PS) अणु
			priv->needtowakeup = 0;
			priv->psstate = PS_STATE_FULL_POWER;
			lbs_deb_host("CMD_RESP: EXIT_PS command response\n");
		पूर्ण अन्यथा अणु
			lbs_deb_host("CMD_RESP: PS action 0x%X\n", action);
		पूर्ण

		__lbs_complete_command(priv, priv->cur_cmd, result);
		spin_unlock_irqrestore(&priv->driver_lock, flags);

		ret = 0;
		जाओ करोne;
	पूर्ण

	/* If the command is not successful, cleanup and वापस failure */
	अगर ((result != 0 || !(respcmd & 0x8000))) अणु
		lbs_deb_host("CMD_RESP: error 0x%04x in command reply 0x%04x\n",
		       result, respcmd);
		/*
		 * Handling errors here
		 */
		चयन (respcmd) अणु
		हाल CMD_RET(CMD_GET_HW_SPEC):
		हाल CMD_RET(CMD_802_11_RESET):
			lbs_deb_host("CMD_RESP: reset failed\n");
			अवरोध;

		पूर्ण
		__lbs_complete_command(priv, priv->cur_cmd, result);
		spin_unlock_irqrestore(&priv->driver_lock, flags);

		ret = -1;
		जाओ करोne;
	पूर्ण

	spin_unlock_irqrestore(&priv->driver_lock, flags);

	अगर (priv->cur_cmd && priv->cur_cmd->callback) अणु
		ret = priv->cur_cmd->callback(priv, priv->cur_cmd->callback_arg,
				resp);
	पूर्ण

	spin_lock_irqsave(&priv->driver_lock, flags);

	अगर (priv->cur_cmd) अणु
		/* Clean up and Put current command back to cmdमुक्तq */
		__lbs_complete_command(priv, priv->cur_cmd, result);
	पूर्ण
	spin_unlock_irqrestore(&priv->driver_lock, flags);

करोne:
	mutex_unlock(&priv->lock);
	वापस ret;
पूर्ण

व्योम lbs_process_event(काष्ठा lbs_निजी *priv, u32 event)
अणु
	काष्ठा cmd_header cmd;

	चयन (event) अणु
	हाल MACREG_INT_CODE_LINK_SENSED:
		lbs_deb_cmd("EVENT: link sensed\n");
		अवरोध;

	हाल MACREG_INT_CODE_DEAUTHENTICATED:
		lbs_deb_cmd("EVENT: deauthenticated\n");
		lbs_mac_event_disconnected(priv, false);
		अवरोध;

	हाल MACREG_INT_CODE_DISASSOCIATED:
		lbs_deb_cmd("EVENT: disassociated\n");
		lbs_mac_event_disconnected(priv, false);
		अवरोध;

	हाल MACREG_INT_CODE_LINK_LOST_NO_SCAN:
		lbs_deb_cmd("EVENT: link lost\n");
		lbs_mac_event_disconnected(priv, true);
		अवरोध;

	हाल MACREG_INT_CODE_PS_SLEEP:
		lbs_deb_cmd("EVENT: ps sleep\n");

		/* handle unexpected PS SLEEP event */
		अगर (priv->psstate == PS_STATE_FULL_POWER) अणु
			lbs_deb_cmd(
			       "EVENT: in FULL POWER mode, ignoring PS_SLEEP\n");
			अवरोध;
		पूर्ण
		अगर (!list_empty(&priv->cmdpendingq)) अणु
			lbs_deb_cmd("EVENT: commands in queue, do not sleep\n");
			अवरोध;
		पूर्ण
		priv->psstate = PS_STATE_PRE_SLEEP;

		lbs_ps_confirm_sleep(priv);

		अवरोध;

	हाल MACREG_INT_CODE_HOST_AWAKE:
		lbs_deb_cmd("EVENT: host awake\n");
		अगर (priv->reset_deep_sleep_wakeup)
			priv->reset_deep_sleep_wakeup(priv);
		priv->is_deep_sleep = 0;
		lbs_cmd_async(priv, CMD_802_11_WAKEUP_CONFIRM, &cmd,
				माप(cmd));
		priv->is_host_sleep_activated = 0;
		wake_up_पूर्णांकerruptible(&priv->host_sleep_q);
		अवरोध;

	हाल MACREG_INT_CODE_DEEP_SLEEP_AWAKE:
		अगर (priv->reset_deep_sleep_wakeup)
			priv->reset_deep_sleep_wakeup(priv);
		lbs_deb_cmd("EVENT: ds awake\n");
		priv->is_deep_sleep = 0;
		priv->wakeup_dev_required = 0;
		wake_up_पूर्णांकerruptible(&priv->ds_awake_q);
		अवरोध;

	हाल MACREG_INT_CODE_PS_AWAKE:
		lbs_deb_cmd("EVENT: ps awake\n");
		/* handle unexpected PS AWAKE event */
		अगर (priv->psstate == PS_STATE_FULL_POWER) अणु
			lbs_deb_cmd(
			       "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
			अवरोध;
		पूर्ण

		priv->psstate = PS_STATE_AWAKE;

		अगर (priv->needtowakeup) अणु
			/*
			 * रुको क्रम the command processing to finish
			 * beक्रमe resuming sending
			 * priv->needtowakeup will be set to FALSE
			 * in lbs_ps_wakeup()
			 */
			lbs_deb_cmd("waking up ...\n");
			lbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS, false);
		पूर्ण
		अवरोध;

	हाल MACREG_INT_CODE_MIC_ERR_UNICAST:
		lbs_deb_cmd("EVENT: UNICAST MIC ERROR\n");
		lbs_send_mic_failureevent(priv, event);
		अवरोध;

	हाल MACREG_INT_CODE_MIC_ERR_MULTICAST:
		lbs_deb_cmd("EVENT: MULTICAST MIC ERROR\n");
		lbs_send_mic_failureevent(priv, event);
		अवरोध;

	हाल MACREG_INT_CODE_MIB_CHANGED:
		lbs_deb_cmd("EVENT: MIB CHANGED\n");
		अवरोध;
	हाल MACREG_INT_CODE_INIT_DONE:
		lbs_deb_cmd("EVENT: INIT DONE\n");
		अवरोध;
	हाल MACREG_INT_CODE_ADHOC_BCN_LOST:
		lbs_deb_cmd("EVENT: ADHOC beacon lost\n");
		अवरोध;
	हाल MACREG_INT_CODE_RSSI_LOW:
		netdev_alert(priv->dev, "EVENT: rssi low\n");
		अवरोध;
	हाल MACREG_INT_CODE_SNR_LOW:
		netdev_alert(priv->dev, "EVENT: snr low\n");
		अवरोध;
	हाल MACREG_INT_CODE_MAX_FAIL:
		netdev_alert(priv->dev, "EVENT: max fail\n");
		अवरोध;
	हाल MACREG_INT_CODE_RSSI_HIGH:
		netdev_alert(priv->dev, "EVENT: rssi high\n");
		अवरोध;
	हाल MACREG_INT_CODE_SNR_HIGH:
		netdev_alert(priv->dev, "EVENT: snr high\n");
		अवरोध;

	हाल MACREG_INT_CODE_MESH_AUTO_STARTED:
		/* Ignore spurious स्वतःstart events */
		netdev_info(priv->dev, "EVENT: MESH_AUTO_STARTED (ignoring)\n");
		अवरोध;

	शेष:
		netdev_alert(priv->dev, "EVENT: unknown event id %d\n", event);
		अवरोध;
	पूर्ण
पूर्ण
