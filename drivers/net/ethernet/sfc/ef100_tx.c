<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/****************************************************************************
 * Driver क्रम Solarflare network controllers and boards
 * Copyright 2018 Solarflare Communications Inc.
 * Copyright 2019-2020 Xilinx Inc.
 *
 * This program is मुक्त software; you can redistribute it and/or modअगरy it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation, incorporated herein by reference.
 */

#समावेश <net/ip6_checksum.h>

#समावेश "net_driver.h"
#समावेश "tx_common.h"
#समावेश "nic_common.h"
#समावेश "mcdi_functions.h"
#समावेश "ef100_regs.h"
#समावेश "io.h"
#समावेश "ef100_tx.h"
#समावेश "ef100_nic.h"

पूर्णांक ef100_tx_probe(काष्ठा efx_tx_queue *tx_queue)
अणु
	/* Allocate an extra descriptor क्रम the QMDA status completion entry */
	वापस efx_nic_alloc_buffer(tx_queue->efx, &tx_queue->txd.buf,
				    (tx_queue->ptr_mask + 2) *
				    माप(efx_oword_t),
				    GFP_KERNEL);
पूर्ण

व्योम ef100_tx_init(काष्ठा efx_tx_queue *tx_queue)
अणु
	/* must be the inverse of lookup in efx_get_tx_channel */
	tx_queue->core_txq =
		netdev_get_tx_queue(tx_queue->efx->net_dev,
				    tx_queue->channel->channel -
				    tx_queue->efx->tx_channel_offset);

	/* This value is purely करोcumentational; as EF100 never passes through
	 * the चयन statement in tx.c:__efx_enqueue_skb(), that चयन करोes
	 * not handle हाल 3.  EF100's TSOv3 descriptors are generated by
	 * ef100_make_tso_desc().
	 * Meanजबतक, all efx_mcdi_tx_init() cares about is that it's not 2.
	 */
	tx_queue->tso_version = 3;
	अगर (efx_mcdi_tx_init(tx_queue))
		netdev_WARN(tx_queue->efx->net_dev,
			    "failed to initialise TXQ %d\n", tx_queue->queue);
पूर्ण

अटल bool ef100_tx_can_tso(काष्ठा efx_tx_queue *tx_queue, काष्ठा sk_buff *skb)
अणु
	काष्ठा efx_nic *efx = tx_queue->efx;
	काष्ठा ef100_nic_data *nic_data;
	काष्ठा efx_tx_buffer *buffer;
	माप_प्रकार header_len;
	u32 mss;

	nic_data = efx->nic_data;

	अगर (!skb_is_gso_tcp(skb))
		वापस false;
	अगर (!(efx->net_dev->features & NETIF_F_TSO))
		वापस false;

	mss = skb_shinfo(skb)->gso_size;
	अगर (unlikely(mss < 4)) अणु
		WARN_ONCE(1, "MSS of %u is too small for TSO\n", mss);
		वापस false;
	पूर्ण

	header_len = efx_tx_tso_header_length(skb);
	अगर (header_len > nic_data->tso_max_hdr_len)
		वापस false;

	अगर (skb_shinfo(skb)->gso_segs > nic_data->tso_max_payload_num_segs) अणु
		/* net_dev->gso_max_segs should've caught this */
		WARN_ON_ONCE(1);
		वापस false;
	पूर्ण

	अगर (skb->data_len / mss > nic_data->tso_max_frames)
		वापस false;

	/* net_dev->gso_max_size should've caught this */
	अगर (WARN_ON_ONCE(skb->data_len > nic_data->tso_max_payload_len))
		वापस false;

	/* Reserve an empty buffer क्रम the TSO V3 descriptor.
	 * Convey the length of the header since we alपढ़ोy know it.
	 */
	buffer = efx_tx_queue_get_insert_buffer(tx_queue);
	buffer->flags = EFX_TX_BUF_TSO_V3 | EFX_TX_BUF_CONT;
	buffer->len = header_len;
	buffer->unmap_len = 0;
	buffer->skb = skb;
	++tx_queue->insert_count;
	वापस true;
पूर्ण

अटल efx_oword_t *ef100_tx_desc(काष्ठा efx_tx_queue *tx_queue, अचिन्हित पूर्णांक index)
अणु
	अगर (likely(tx_queue->txd.buf.addr))
		वापस ((efx_oword_t *)tx_queue->txd.buf.addr) + index;
	अन्यथा
		वापस शून्य;
पूर्ण

अटल व्योम ef100_notअगरy_tx_desc(काष्ठा efx_tx_queue *tx_queue)
अणु
	अचिन्हित पूर्णांक ग_लिखो_ptr;
	efx_dword_t reg;

	tx_queue->xmit_pending = false;

	अगर (unlikely(tx_queue->notअगरy_count == tx_queue->ग_लिखो_count))
		वापस;

	ग_लिखो_ptr = tx_queue->ग_लिखो_count & tx_queue->ptr_mask;
	/* The ग_लिखो poपूर्णांकer goes पूर्णांकo the high word */
	EFX_POPULATE_DWORD_1(reg, ERF_GZ_TX_RING_PIDX, ग_लिखो_ptr);
	efx_ग_लिखोd_page(tx_queue->efx, &reg,
			ER_GZ_TX_RING_DOORBELL, tx_queue->queue);
	tx_queue->notअगरy_count = tx_queue->ग_लिखो_count;
पूर्ण

अटल व्योम ef100_tx_push_buffers(काष्ठा efx_tx_queue *tx_queue)
अणु
	ef100_notअगरy_tx_desc(tx_queue);
	++tx_queue->pushes;
पूर्ण

अटल व्योम ef100_set_tx_csum_partial(स्थिर काष्ठा sk_buff *skb,
				      काष्ठा efx_tx_buffer *buffer, efx_oword_t *txd)
अणु
	efx_oword_t csum;
	पूर्णांक csum_start;

	अगर (!skb || skb->ip_summed != CHECKSUM_PARTIAL)
		वापस;

	/* skb->csum_start has the offset from head, but we need the offset
	 * from data.
	 */
	csum_start = skb_checksum_start_offset(skb);
	EFX_POPULATE_OWORD_3(csum,
			     ESF_GZ_TX_SEND_CSO_PARTIAL_EN, 1,
			     ESF_GZ_TX_SEND_CSO_PARTIAL_START_W,
			     csum_start >> 1,
			     ESF_GZ_TX_SEND_CSO_PARTIAL_CSUM_W,
			     skb->csum_offset >> 1);
	EFX_OR_OWORD(*txd, *txd, csum);
पूर्ण

अटल व्योम ef100_set_tx_hw_vlan(स्थिर काष्ठा sk_buff *skb, efx_oword_t *txd)
अणु
	u16 vlan_tci = skb_vlan_tag_get(skb);
	efx_oword_t vlan;

	EFX_POPULATE_OWORD_2(vlan,
			     ESF_GZ_TX_SEND_VLAN_INSERT_EN, 1,
			     ESF_GZ_TX_SEND_VLAN_INSERT_TCI, vlan_tci);
	EFX_OR_OWORD(*txd, *txd, vlan);
पूर्ण

अटल व्योम ef100_make_send_desc(काष्ठा efx_nic *efx,
				 स्थिर काष्ठा sk_buff *skb,
				 काष्ठा efx_tx_buffer *buffer, efx_oword_t *txd,
				 अचिन्हित पूर्णांक segment_count)
अणु
	/* TX send descriptor */
	EFX_POPULATE_OWORD_3(*txd,
			     ESF_GZ_TX_SEND_NUM_SEGS, segment_count,
			     ESF_GZ_TX_SEND_LEN, buffer->len,
			     ESF_GZ_TX_SEND_ADDR, buffer->dma_addr);

	अगर (likely(efx->net_dev->features & NETIF_F_HW_CSUM))
		ef100_set_tx_csum_partial(skb, buffer, txd);
	अगर (efx->net_dev->features & NETIF_F_HW_VLAN_CTAG_TX &&
	    skb && skb_vlan_tag_present(skb))
		ef100_set_tx_hw_vlan(skb, txd);
पूर्ण

अटल व्योम ef100_make_tso_desc(काष्ठा efx_nic *efx,
				स्थिर काष्ठा sk_buff *skb,
				काष्ठा efx_tx_buffer *buffer, efx_oword_t *txd,
				अचिन्हित पूर्णांक segment_count)
अणु
	bool gso_partial = skb_shinfo(skb)->gso_type & SKB_GSO_PARTIAL;
	अचिन्हित पूर्णांक len, ip_offset, tcp_offset, payload_segs;
	u32 mangleid = ESE_GZ_TX_DESC_IP4_ID_INC_MOD16;
	अचिन्हित पूर्णांक outer_ip_offset, outer_l4_offset;
	u16 vlan_tci = skb_vlan_tag_get(skb);
	u32 mss = skb_shinfo(skb)->gso_size;
	bool encap = skb->encapsulation;
	bool udp_encap = false;
	u16 vlan_enable = 0;
	काष्ठा tcphdr *tcp;
	bool outer_csum;
	u32 paylen;

	अगर (skb_shinfo(skb)->gso_type & SKB_GSO_TCP_FIXEDID)
		mangleid = ESE_GZ_TX_DESC_IP4_ID_NO_OP;
	अगर (efx->net_dev->features & NETIF_F_HW_VLAN_CTAG_TX)
		vlan_enable = skb_vlan_tag_present(skb);

	len = skb->len - buffer->len;
	/* We use 1 क्रम the TSO descriptor and 1 क्रम the header */
	payload_segs = segment_count - 2;
	अगर (encap) अणु
		outer_ip_offset = skb_network_offset(skb);
		outer_l4_offset = skb_transport_offset(skb);
		ip_offset = skb_inner_network_offset(skb);
		tcp_offset = skb_inner_transport_offset(skb);
		अगर (skb_shinfo(skb)->gso_type &
		    (SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM))
			udp_encap = true;
	पूर्ण अन्यथा अणु
		ip_offset =  skb_network_offset(skb);
		tcp_offset = skb_transport_offset(skb);
		outer_ip_offset = outer_l4_offset = 0;
	पूर्ण
	outer_csum = skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM;

	/* subtract TCP payload length from inner checksum */
	tcp = (व्योम *)skb->data + tcp_offset;
	paylen = skb->len - tcp_offset;
	csum_replace_by_dअगरf(&tcp->check, (__क्रमce __wsum)htonl(paylen));

	EFX_POPULATE_OWORD_19(*txd,
			      ESF_GZ_TX_DESC_TYPE, ESE_GZ_TX_DESC_TYPE_TSO,
			      ESF_GZ_TX_TSO_MSS, mss,
			      ESF_GZ_TX_TSO_HDR_NUM_SEGS, 1,
			      ESF_GZ_TX_TSO_PAYLOAD_NUM_SEGS, payload_segs,
			      ESF_GZ_TX_TSO_HDR_LEN_W, buffer->len >> 1,
			      ESF_GZ_TX_TSO_PAYLOAD_LEN, len,
			      ESF_GZ_TX_TSO_CSO_OUTER_L4, outer_csum,
			      ESF_GZ_TX_TSO_CSO_INNER_L4, 1,
			      ESF_GZ_TX_TSO_INNER_L3_OFF_W, ip_offset >> 1,
			      ESF_GZ_TX_TSO_INNER_L4_OFF_W, tcp_offset >> 1,
			      ESF_GZ_TX_TSO_ED_INNER_IP4_ID, mangleid,
			      ESF_GZ_TX_TSO_ED_INNER_IP_LEN, 1,
			      ESF_GZ_TX_TSO_OUTER_L3_OFF_W, outer_ip_offset >> 1,
			      ESF_GZ_TX_TSO_OUTER_L4_OFF_W, outer_l4_offset >> 1,
			      ESF_GZ_TX_TSO_ED_OUTER_UDP_LEN, udp_encap && !gso_partial,
			      ESF_GZ_TX_TSO_ED_OUTER_IP_LEN, encap && !gso_partial,
			      ESF_GZ_TX_TSO_ED_OUTER_IP4_ID, encap ? mangleid :
								     ESE_GZ_TX_DESC_IP4_ID_NO_OP,
			      ESF_GZ_TX_TSO_VLAN_INSERT_EN, vlan_enable,
			      ESF_GZ_TX_TSO_VLAN_INSERT_TCI, vlan_tci
		);
पूर्ण

अटल व्योम ef100_tx_make_descriptors(काष्ठा efx_tx_queue *tx_queue,
				      स्थिर काष्ठा sk_buff *skb,
				      अचिन्हित पूर्णांक segment_count)
अणु
	अचिन्हित पूर्णांक old_ग_लिखो_count = tx_queue->ग_लिखो_count;
	अचिन्हित पूर्णांक new_ग_लिखो_count = old_ग_लिखो_count;
	काष्ठा efx_tx_buffer *buffer;
	अचिन्हित पूर्णांक next_desc_type;
	अचिन्हित पूर्णांक ग_लिखो_ptr;
	efx_oword_t *txd;
	अचिन्हित पूर्णांक nr_descs = tx_queue->insert_count - old_ग_लिखो_count;

	अगर (unlikely(nr_descs == 0))
		वापस;

	अगर (segment_count)
		next_desc_type = ESE_GZ_TX_DESC_TYPE_TSO;
	अन्यथा
		next_desc_type = ESE_GZ_TX_DESC_TYPE_SEND;

	/* अगर it's a raw ग_लिखो (such as XDP) then always SEND single frames */
	अगर (!skb)
		nr_descs = 1;

	करो अणु
		ग_लिखो_ptr = new_ग_लिखो_count & tx_queue->ptr_mask;
		buffer = &tx_queue->buffer[ग_लिखो_ptr];
		txd = ef100_tx_desc(tx_queue, ग_लिखो_ptr);
		++new_ग_लिखो_count;

		/* Create TX descriptor ring entry */
		tx_queue->packet_ग_लिखो_count = new_ग_लिखो_count;

		चयन (next_desc_type) अणु
		हाल ESE_GZ_TX_DESC_TYPE_SEND:
			ef100_make_send_desc(tx_queue->efx, skb,
					     buffer, txd, nr_descs);
			अवरोध;
		हाल ESE_GZ_TX_DESC_TYPE_TSO:
			/* TX TSO descriptor */
			WARN_ON_ONCE(!(buffer->flags & EFX_TX_BUF_TSO_V3));
			ef100_make_tso_desc(tx_queue->efx, skb,
					    buffer, txd, nr_descs);
			अवरोध;
		शेष:
			/* TX segment descriptor */
			EFX_POPULATE_OWORD_3(*txd,
					     ESF_GZ_TX_DESC_TYPE, ESE_GZ_TX_DESC_TYPE_SEG,
					     ESF_GZ_TX_SEG_LEN, buffer->len,
					     ESF_GZ_TX_SEG_ADDR, buffer->dma_addr);
		पूर्ण
		/* अगर it's a raw ग_लिखो (such as XDP) then always SEND */
		next_desc_type = skb ? ESE_GZ_TX_DESC_TYPE_SEG :
				       ESE_GZ_TX_DESC_TYPE_SEND;

	पूर्ण जबतक (new_ग_लिखो_count != tx_queue->insert_count);

	wmb(); /* Ensure descriptors are written beक्रमe they are fetched */

	tx_queue->ग_लिखो_count = new_ग_लिखो_count;

	/* The ग_लिखो_count above must be updated beक्रमe पढ़ोing
	 * channel->holकरोff_करोorbell to aव्योम a race with the
	 * completion path, so ensure these operations are not
	 * re-ordered.  This also flushes the update of ग_लिखो_count
	 * back पूर्णांकo the cache.
	 */
	smp_mb();
पूर्ण

व्योम ef100_tx_ग_लिखो(काष्ठा efx_tx_queue *tx_queue)
अणु
	ef100_tx_make_descriptors(tx_queue, शून्य, 0);
	ef100_tx_push_buffers(tx_queue);
पूर्ण

व्योम ef100_ev_tx(काष्ठा efx_channel *channel, स्थिर efx_qword_t *p_event)
अणु
	अचिन्हित पूर्णांक tx_करोne =
		EFX_QWORD_FIELD(*p_event, ESF_GZ_EV_TXCMPL_NUM_DESC);
	अचिन्हित पूर्णांक qlabel =
		EFX_QWORD_FIELD(*p_event, ESF_GZ_EV_TXCMPL_Q_LABEL);
	काष्ठा efx_tx_queue *tx_queue =
		efx_channel_get_tx_queue(channel, qlabel);
	अचिन्हित पूर्णांक tx_index = (tx_queue->पढ़ो_count + tx_करोne - 1) &
				tx_queue->ptr_mask;

	efx_xmit_करोne(tx_queue, tx_index);
पूर्ण

/* Add a socket buffer to a TX queue
 *
 * You must hold netअगर_tx_lock() to call this function.
 *
 * Returns 0 on success, error code otherwise. In हाल of an error this
 * function will मुक्त the SKB.
 */
पूर्णांक ef100_enqueue_skb(काष्ठा efx_tx_queue *tx_queue, काष्ठा sk_buff *skb)
अणु
	अचिन्हित पूर्णांक old_insert_count = tx_queue->insert_count;
	काष्ठा efx_nic *efx = tx_queue->efx;
	bool xmit_more = netdev_xmit_more();
	अचिन्हित पूर्णांक fill_level;
	अचिन्हित पूर्णांक segments;
	पूर्णांक rc;

	अगर (!tx_queue->buffer || !tx_queue->ptr_mask) अणु
		netअगर_stop_queue(efx->net_dev);
		dev_kमुक्त_skb_any(skb);
		वापस -ENODEV;
	पूर्ण

	segments = skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 0;
	अगर (segments == 1)
		segments = 0;	/* Don't use TSO/GSO क्रम a single segment. */
	अगर (segments && !ef100_tx_can_tso(tx_queue, skb)) अणु
		rc = efx_tx_tso_fallback(tx_queue, skb);
		tx_queue->tso_fallbacks++;
		अगर (rc)
			जाओ err;
		अन्यथा
			वापस 0;
	पूर्ण

	/* Map क्रम DMA and create descriptors */
	rc = efx_tx_map_data(tx_queue, skb, segments);
	अगर (rc)
		जाओ err;
	ef100_tx_make_descriptors(tx_queue, skb, segments);

	fill_level = efx_channel_tx_old_fill_level(tx_queue->channel);
	अगर (fill_level > efx->txq_stop_thresh) अणु
		काष्ठा efx_tx_queue *txq2;

		netअगर_tx_stop_queue(tx_queue->core_txq);
		/* Re-पढ़ो after a memory barrier in हाल we've raced with
		 * the completion path. Otherwise there's a danger we'll never
		 * restart the queue अगर all completions have just happened.
		 */
		smp_mb();
		efx_क्रम_each_channel_tx_queue(txq2, tx_queue->channel)
			txq2->old_पढ़ो_count = READ_ONCE(txq2->पढ़ो_count);
		fill_level = efx_channel_tx_old_fill_level(tx_queue->channel);
		अगर (fill_level < efx->txq_stop_thresh)
			netअगर_tx_start_queue(tx_queue->core_txq);
	पूर्ण

	tx_queue->xmit_pending = true;

	/* If xmit_more then we करोn't need to push the करोorbell, unless there
	 * are 256 descriptors alपढ़ोy queued in which हाल we have to push to
	 * ensure we never push more than 256 at once.
	 */
	अगर (__netdev_tx_sent_queue(tx_queue->core_txq, skb->len, xmit_more) ||
	    tx_queue->ग_लिखो_count - tx_queue->notअगरy_count > 255)
		ef100_tx_push_buffers(tx_queue);

	अगर (segments) अणु
		tx_queue->tso_bursts++;
		tx_queue->tso_packets += segments;
		tx_queue->tx_packets  += segments;
	पूर्ण अन्यथा अणु
		tx_queue->tx_packets++;
	पूर्ण
	वापस 0;

err:
	efx_enqueue_unwind(tx_queue, old_insert_count);
	अगर (!IS_ERR_OR_शून्य(skb))
		dev_kमुक्त_skb_any(skb);

	/* If we're not expecting another transmit and we had something to push
	 * on this queue then we need to push here to get the previous packets
	 * out.  We only enter this branch from beक्रमe the xmit_more handling
	 * above, so xmit_pending still refers to the old state.
	 */
	अगर (tx_queue->xmit_pending && !xmit_more)
		ef100_tx_push_buffers(tx_queue);
	वापस rc;
पूर्ण
