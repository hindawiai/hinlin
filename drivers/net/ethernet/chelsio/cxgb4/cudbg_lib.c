<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.
 */

#समावेश <linux/sort.h>
#समावेश <linux/माला.स>

#समावेश "t4_regs.h"
#समावेश "cxgb4.h"
#समावेश "cxgb4_cudbg.h"
#समावेश "cudbg_if.h"
#समावेश "cudbg_lib_common.h"
#समावेश "cudbg_entity.h"
#समावेश "cudbg_lib.h"
#समावेश "cudbg_zlib.h"

अटल स्थिर u32 t6_tp_pio_array[][IREG_NUM_ELEM] = अणु
	अणु0x7e40, 0x7e44, 0x020, 28पूर्ण, /* t6_tp_pio_regs_20_to_3b */
	अणु0x7e40, 0x7e44, 0x040, 10पूर्ण, /* t6_tp_pio_regs_40_to_49 */
	अणु0x7e40, 0x7e44, 0x050, 10पूर्ण, /* t6_tp_pio_regs_50_to_59 */
	अणु0x7e40, 0x7e44, 0x060, 14पूर्ण, /* t6_tp_pio_regs_60_to_6d */
	अणु0x7e40, 0x7e44, 0x06F, 1पूर्ण, /* t6_tp_pio_regs_6f */
	अणु0x7e40, 0x7e44, 0x070, 6पूर्ण, /* t6_tp_pio_regs_70_to_75 */
	अणु0x7e40, 0x7e44, 0x130, 18पूर्ण, /* t6_tp_pio_regs_130_to_141 */
	अणु0x7e40, 0x7e44, 0x145, 19पूर्ण, /* t6_tp_pio_regs_145_to_157 */
	अणु0x7e40, 0x7e44, 0x160, 1पूर्ण, /* t6_tp_pio_regs_160 */
	अणु0x7e40, 0x7e44, 0x230, 25पूर्ण, /* t6_tp_pio_regs_230_to_248 */
	अणु0x7e40, 0x7e44, 0x24a, 3पूर्ण, /* t6_tp_pio_regs_24c */
	अणु0x7e40, 0x7e44, 0x8C0, 1पूर्ण /* t6_tp_pio_regs_8c0 */
पूर्ण;

अटल स्थिर u32 t5_tp_pio_array[][IREG_NUM_ELEM] = अणु
	अणु0x7e40, 0x7e44, 0x020, 28पूर्ण, /* t5_tp_pio_regs_20_to_3b */
	अणु0x7e40, 0x7e44, 0x040, 19पूर्ण, /* t5_tp_pio_regs_40_to_52 */
	अणु0x7e40, 0x7e44, 0x054, 2पूर्ण, /* t5_tp_pio_regs_54_to_55 */
	अणु0x7e40, 0x7e44, 0x060, 13पूर्ण, /* t5_tp_pio_regs_60_to_6c */
	अणु0x7e40, 0x7e44, 0x06F, 1पूर्ण, /* t5_tp_pio_regs_6f */
	अणु0x7e40, 0x7e44, 0x120, 4पूर्ण, /* t5_tp_pio_regs_120_to_123 */
	अणु0x7e40, 0x7e44, 0x12b, 2पूर्ण, /* t5_tp_pio_regs_12b_to_12c */
	अणु0x7e40, 0x7e44, 0x12f, 21पूर्ण, /* t5_tp_pio_regs_12f_to_143 */
	अणु0x7e40, 0x7e44, 0x145, 19पूर्ण, /* t5_tp_pio_regs_145_to_157 */
	अणु0x7e40, 0x7e44, 0x230, 25पूर्ण, /* t5_tp_pio_regs_230_to_248 */
	अणु0x7e40, 0x7e44, 0x8C0, 1पूर्ण /* t5_tp_pio_regs_8c0 */
पूर्ण;

अटल स्थिर u32 t6_tp_पंचांग_pio_array[][IREG_NUM_ELEM] = अणु
	अणु0x7e18, 0x7e1c, 0x0, 12पूर्ण
पूर्ण;

अटल स्थिर u32 t5_tp_पंचांग_pio_array[][IREG_NUM_ELEM] = अणु
	अणु0x7e18, 0x7e1c, 0x0, 12पूर्ण
पूर्ण;

अटल स्थिर u32 t6_tp_mib_index_array[6][IREG_NUM_ELEM] = अणु
	अणु0x7e50, 0x7e54, 0x0, 13पूर्ण,
	अणु0x7e50, 0x7e54, 0x10, 6पूर्ण,
	अणु0x7e50, 0x7e54, 0x18, 21पूर्ण,
	अणु0x7e50, 0x7e54, 0x30, 32पूर्ण,
	अणु0x7e50, 0x7e54, 0x50, 22पूर्ण,
	अणु0x7e50, 0x7e54, 0x68, 12पूर्ण
पूर्ण;

अटल स्थिर u32 t5_tp_mib_index_array[9][IREG_NUM_ELEM] = अणु
	अणु0x7e50, 0x7e54, 0x0, 13पूर्ण,
	अणु0x7e50, 0x7e54, 0x10, 6पूर्ण,
	अणु0x7e50, 0x7e54, 0x18, 8पूर्ण,
	अणु0x7e50, 0x7e54, 0x20, 13पूर्ण,
	अणु0x7e50, 0x7e54, 0x30, 16पूर्ण,
	अणु0x7e50, 0x7e54, 0x40, 16पूर्ण,
	अणु0x7e50, 0x7e54, 0x50, 16पूर्ण,
	अणु0x7e50, 0x7e54, 0x60, 6पूर्ण,
	अणु0x7e50, 0x7e54, 0x68, 4पूर्ण
पूर्ण;

अटल स्थिर u32 t5_sge_dbg_index_array[2][IREG_NUM_ELEM] = अणु
	अणु0x10cc, 0x10d0, 0x0, 16पूर्ण,
	अणु0x10cc, 0x10d4, 0x0, 16पूर्ण,
पूर्ण;

अटल स्थिर u32 t6_sge_qbase_index_array[] = अणु
	/* 1 addr reg SGE_QBASE_INDEX and 4 data reg SGE_QBASE_MAP[0-3] */
	0x1250, 0x1240, 0x1244, 0x1248, 0x124c,
पूर्ण;

अटल स्थिर u32 t5_pcie_pdbg_array[][IREG_NUM_ELEM] = अणु
	अणु0x5a04, 0x5a0c, 0x00, 0x20पूर्ण, /* t5_pcie_pdbg_regs_00_to_20 */
	अणु0x5a04, 0x5a0c, 0x21, 0x20पूर्ण, /* t5_pcie_pdbg_regs_21_to_40 */
	अणु0x5a04, 0x5a0c, 0x41, 0x10पूर्ण, /* t5_pcie_pdbg_regs_41_to_50 */
पूर्ण;

अटल स्थिर u32 t5_pcie_cdbg_array[][IREG_NUM_ELEM] = अणु
	अणु0x5a10, 0x5a18, 0x00, 0x20पूर्ण, /* t5_pcie_cdbg_regs_00_to_20 */
	अणु0x5a10, 0x5a18, 0x21, 0x18पूर्ण, /* t5_pcie_cdbg_regs_21_to_37 */
पूर्ण;

अटल स्थिर u32 t5_pm_rx_array[][IREG_NUM_ELEM] = अणु
	अणु0x8FD0, 0x8FD4, 0x10000, 0x20पूर्ण, /* t5_pm_rx_regs_10000_to_10020 */
	अणु0x8FD0, 0x8FD4, 0x10021, 0x0Dपूर्ण, /* t5_pm_rx_regs_10021_to_1002c */
पूर्ण;

अटल स्थिर u32 t5_pm_tx_array[][IREG_NUM_ELEM] = अणु
	अणु0x8FF0, 0x8FF4, 0x10000, 0x20पूर्ण, /* t5_pm_tx_regs_10000_to_10020 */
	अणु0x8FF0, 0x8FF4, 0x10021, 0x1Dपूर्ण, /* t5_pm_tx_regs_10021_to_1003c */
पूर्ण;

अटल स्थिर u32 t5_pcie_config_array[][2] = अणु
	अणु0x0, 0x34पूर्ण,
	अणु0x3c, 0x40पूर्ण,
	अणु0x50, 0x64पूर्ण,
	अणु0x70, 0x80पूर्ण,
	अणु0x94, 0xa0पूर्ण,
	अणु0xb0, 0xb8पूर्ण,
	अणु0xd0, 0xd4पूर्ण,
	अणु0x100, 0x128पूर्ण,
	अणु0x140, 0x148पूर्ण,
	अणु0x150, 0x164पूर्ण,
	अणु0x170, 0x178पूर्ण,
	अणु0x180, 0x194पूर्ण,
	अणु0x1a0, 0x1b8पूर्ण,
	अणु0x1c0, 0x208पूर्ण,
पूर्ण;

अटल स्थिर u32 t6_ma_ireg_array[][IREG_NUM_ELEM] = अणु
	अणु0x78f8, 0x78fc, 0xa000, 23पूर्ण, /* t6_ma_regs_a000_to_a016 */
	अणु0x78f8, 0x78fc, 0xa400, 30पूर्ण, /* t6_ma_regs_a400_to_a41e */
	अणु0x78f8, 0x78fc, 0xa800, 20पूर्ण /* t6_ma_regs_a800_to_a813 */
पूर्ण;

अटल स्थिर u32 t6_ma_ireg_array2[][IREG_NUM_ELEM] = अणु
	अणु0x78f8, 0x78fc, 0xe400, 17पूर्ण, /* t6_ma_regs_e400_to_e600 */
	अणु0x78f8, 0x78fc, 0xe640, 13पूर्ण /* t6_ma_regs_e640_to_e7c0 */
पूर्ण;

अटल स्थिर u32 t6_up_cim_reg_array[][IREG_NUM_ELEM + 1] = अणु
	अणु0x7b50, 0x7b54, 0x2000, 0x20, 0पूर्ण, /* up_cim_2000_to_207c */
	अणु0x7b50, 0x7b54, 0x2080, 0x1d, 0पूर्ण, /* up_cim_2080_to_20fc */
	अणु0x7b50, 0x7b54, 0x00, 0x20, 0पूर्ण, /* up_cim_00_to_7c */
	अणु0x7b50, 0x7b54, 0x80, 0x20, 0पूर्ण, /* up_cim_80_to_fc */
	अणु0x7b50, 0x7b54, 0x100, 0x11, 0पूर्ण, /* up_cim_100_to_14c */
	अणु0x7b50, 0x7b54, 0x200, 0x10, 0पूर्ण, /* up_cim_200_to_23c */
	अणु0x7b50, 0x7b54, 0x240, 0x2, 0पूर्ण, /* up_cim_240_to_244 */
	अणु0x7b50, 0x7b54, 0x250, 0x2, 0पूर्ण, /* up_cim_250_to_254 */
	अणु0x7b50, 0x7b54, 0x260, 0x2, 0पूर्ण, /* up_cim_260_to_264 */
	अणु0x7b50, 0x7b54, 0x270, 0x2, 0पूर्ण, /* up_cim_270_to_274 */
	अणु0x7b50, 0x7b54, 0x280, 0x20, 0पूर्ण, /* up_cim_280_to_2fc */
	अणु0x7b50, 0x7b54, 0x300, 0x20, 0पूर्ण, /* up_cim_300_to_37c */
	अणु0x7b50, 0x7b54, 0x380, 0x14, 0पूर्ण, /* up_cim_380_to_3cc */
	अणु0x7b50, 0x7b54, 0x4900, 0x4, 0x4पूर्ण, /* up_cim_4900_to_4c60 */
	अणु0x7b50, 0x7b54, 0x4904, 0x4, 0x4पूर्ण, /* up_cim_4904_to_4c64 */
	अणु0x7b50, 0x7b54, 0x4908, 0x4, 0x4पूर्ण, /* up_cim_4908_to_4c68 */
	अणु0x7b50, 0x7b54, 0x4910, 0x4, 0x4पूर्ण, /* up_cim_4910_to_4c70 */
	अणु0x7b50, 0x7b54, 0x4914, 0x4, 0x4पूर्ण, /* up_cim_4914_to_4c74 */
	अणु0x7b50, 0x7b54, 0x4920, 0x10, 0x10पूर्ण, /* up_cim_4920_to_4a10 */
	अणु0x7b50, 0x7b54, 0x4924, 0x10, 0x10पूर्ण, /* up_cim_4924_to_4a14 */
	अणु0x7b50, 0x7b54, 0x4928, 0x10, 0x10पूर्ण, /* up_cim_4928_to_4a18 */
	अणु0x7b50, 0x7b54, 0x492c, 0x10, 0x10पूर्ण, /* up_cim_492c_to_4a1c */
पूर्ण;

अटल स्थिर u32 t5_up_cim_reg_array[][IREG_NUM_ELEM + 1] = अणु
	अणु0x7b50, 0x7b54, 0x2000, 0x20, 0पूर्ण, /* up_cim_2000_to_207c */
	अणु0x7b50, 0x7b54, 0x2080, 0x19, 0पूर्ण, /* up_cim_2080_to_20ec */
	अणु0x7b50, 0x7b54, 0x00, 0x20, 0पूर्ण, /* up_cim_00_to_7c */
	अणु0x7b50, 0x7b54, 0x80, 0x20, 0पूर्ण, /* up_cim_80_to_fc */
	अणु0x7b50, 0x7b54, 0x100, 0x11, 0पूर्ण, /* up_cim_100_to_14c */
	अणु0x7b50, 0x7b54, 0x200, 0x10, 0पूर्ण, /* up_cim_200_to_23c */
	अणु0x7b50, 0x7b54, 0x240, 0x2, 0पूर्ण, /* up_cim_240_to_244 */
	अणु0x7b50, 0x7b54, 0x250, 0x2, 0पूर्ण, /* up_cim_250_to_254 */
	अणु0x7b50, 0x7b54, 0x260, 0x2, 0पूर्ण, /* up_cim_260_to_264 */
	अणु0x7b50, 0x7b54, 0x270, 0x2, 0पूर्ण, /* up_cim_270_to_274 */
	अणु0x7b50, 0x7b54, 0x280, 0x20, 0पूर्ण, /* up_cim_280_to_2fc */
	अणु0x7b50, 0x7b54, 0x300, 0x20, 0पूर्ण, /* up_cim_300_to_37c */
	अणु0x7b50, 0x7b54, 0x380, 0x14, 0पूर्ण, /* up_cim_380_to_3cc */
पूर्ण;

अटल स्थिर u32 t6_hma_ireg_array[][IREG_NUM_ELEM] = अणु
	अणु0x51320, 0x51324, 0xa000, 32पूर्ण /* t6_hma_regs_a000_to_a01f */
पूर्ण;

u32 cudbg_get_entity_length(काष्ठा adapter *adap, u32 entity)
अणु
	काष्ठा cudbg_tcam tcam_region = अणु 0 पूर्ण;
	u32 value, n = 0, len = 0;

	चयन (entity) अणु
	हाल CUDBG_REG_DUMP:
		चयन (CHELSIO_CHIP_VERSION(adap->params.chip)) अणु
		हाल CHELSIO_T4:
			len = T4_REGMAP_SIZE;
			अवरोध;
		हाल CHELSIO_T5:
		हाल CHELSIO_T6:
			len = T5_REGMAP_SIZE;
			अवरोध;
		शेष:
			अवरोध;
		पूर्ण
		अवरोध;
	हाल CUDBG_DEV_LOG:
		len = adap->params.devlog.size;
		अवरोध;
	हाल CUDBG_CIM_LA:
		अगर (is_t6(adap->params.chip)) अणु
			len = adap->params.cim_la_size / 10 + 1;
			len *= 10 * माप(u32);
		पूर्ण अन्यथा अणु
			len = adap->params.cim_la_size / 8;
			len *= 8 * माप(u32);
		पूर्ण
		len += माप(u32); /* क्रम पढ़ोing CIM LA configuration */
		अवरोध;
	हाल CUDBG_CIM_MA_LA:
		len = 2 * CIM_MALA_SIZE * 5 * माप(u32);
		अवरोध;
	हाल CUDBG_CIM_QCFG:
		len = माप(काष्ठा cudbg_cim_qcfg);
		अवरोध;
	हाल CUDBG_CIM_IBQ_TP0:
	हाल CUDBG_CIM_IBQ_TP1:
	हाल CUDBG_CIM_IBQ_ULP:
	हाल CUDBG_CIM_IBQ_SGE0:
	हाल CUDBG_CIM_IBQ_SGE1:
	हाल CUDBG_CIM_IBQ_NCSI:
		len = CIM_IBQ_SIZE * 4 * माप(u32);
		अवरोध;
	हाल CUDBG_CIM_OBQ_ULP0:
		len = cudbg_cim_obq_size(adap, 0);
		अवरोध;
	हाल CUDBG_CIM_OBQ_ULP1:
		len = cudbg_cim_obq_size(adap, 1);
		अवरोध;
	हाल CUDBG_CIM_OBQ_ULP2:
		len = cudbg_cim_obq_size(adap, 2);
		अवरोध;
	हाल CUDBG_CIM_OBQ_ULP3:
		len = cudbg_cim_obq_size(adap, 3);
		अवरोध;
	हाल CUDBG_CIM_OBQ_SGE:
		len = cudbg_cim_obq_size(adap, 4);
		अवरोध;
	हाल CUDBG_CIM_OBQ_NCSI:
		len = cudbg_cim_obq_size(adap, 5);
		अवरोध;
	हाल CUDBG_CIM_OBQ_RXQ0:
		len = cudbg_cim_obq_size(adap, 6);
		अवरोध;
	हाल CUDBG_CIM_OBQ_RXQ1:
		len = cudbg_cim_obq_size(adap, 7);
		अवरोध;
	हाल CUDBG_EDC0:
		value = t4_पढ़ो_reg(adap, MA_TARGET_MEM_ENABLE_A);
		अगर (value & EDRAM0_ENABLE_F) अणु
			value = t4_पढ़ो_reg(adap, MA_EDRAM0_BAR_A);
			len = EDRAM0_SIZE_G(value);
		पूर्ण
		len = cudbg_mbytes_to_bytes(len);
		अवरोध;
	हाल CUDBG_EDC1:
		value = t4_पढ़ो_reg(adap, MA_TARGET_MEM_ENABLE_A);
		अगर (value & EDRAM1_ENABLE_F) अणु
			value = t4_पढ़ो_reg(adap, MA_EDRAM1_BAR_A);
			len = EDRAM1_SIZE_G(value);
		पूर्ण
		len = cudbg_mbytes_to_bytes(len);
		अवरोध;
	हाल CUDBG_MC0:
		value = t4_पढ़ो_reg(adap, MA_TARGET_MEM_ENABLE_A);
		अगर (value & EXT_MEM0_ENABLE_F) अणु
			value = t4_पढ़ो_reg(adap, MA_EXT_MEMORY0_BAR_A);
			len = EXT_MEM0_SIZE_G(value);
		पूर्ण
		len = cudbg_mbytes_to_bytes(len);
		अवरोध;
	हाल CUDBG_MC1:
		value = t4_पढ़ो_reg(adap, MA_TARGET_MEM_ENABLE_A);
		अगर (value & EXT_MEM1_ENABLE_F) अणु
			value = t4_पढ़ो_reg(adap, MA_EXT_MEMORY1_BAR_A);
			len = EXT_MEM1_SIZE_G(value);
		पूर्ण
		len = cudbg_mbytes_to_bytes(len);
		अवरोध;
	हाल CUDBG_RSS:
		len = t4_chip_rss_size(adap) * माप(u16);
		अवरोध;
	हाल CUDBG_RSS_VF_CONF:
		len = adap->params.arch.vfcount *
		      माप(काष्ठा cudbg_rss_vf_conf);
		अवरोध;
	हाल CUDBG_PATH_MTU:
		len = NMTUS * माप(u16);
		अवरोध;
	हाल CUDBG_PM_STATS:
		len = माप(काष्ठा cudbg_pm_stats);
		अवरोध;
	हाल CUDBG_HW_SCHED:
		len = माप(काष्ठा cudbg_hw_sched);
		अवरोध;
	हाल CUDBG_TP_INसूचीECT:
		चयन (CHELSIO_CHIP_VERSION(adap->params.chip)) अणु
		हाल CHELSIO_T5:
			n = माप(t5_tp_pio_array) +
			    माप(t5_tp_पंचांग_pio_array) +
			    माप(t5_tp_mib_index_array);
			अवरोध;
		हाल CHELSIO_T6:
			n = माप(t6_tp_pio_array) +
			    माप(t6_tp_पंचांग_pio_array) +
			    माप(t6_tp_mib_index_array);
			अवरोध;
		शेष:
			अवरोध;
		पूर्ण
		n = n / (IREG_NUM_ELEM * माप(u32));
		len = माप(काष्ठा ireg_buf) * n;
		अवरोध;
	हाल CUDBG_SGE_INसूचीECT:
		len = माप(काष्ठा ireg_buf) * 2 +
		      माप(काष्ठा sge_qbase_reg_field);
		अवरोध;
	हाल CUDBG_ULPRX_LA:
		len = माप(काष्ठा cudbg_ulprx_la);
		अवरोध;
	हाल CUDBG_TP_LA:
		len = माप(काष्ठा cudbg_tp_la) + TPLA_SIZE * माप(u64);
		अवरोध;
	हाल CUDBG_MEMINFO:
		len = माप(काष्ठा cudbg_ver_hdr) +
		      माप(काष्ठा cudbg_meminfo);
		अवरोध;
	हाल CUDBG_CIM_PIF_LA:
		len = माप(काष्ठा cudbg_cim_pअगर_la);
		len += 2 * CIM_PIFLA_SIZE * 6 * माप(u32);
		अवरोध;
	हाल CUDBG_CLK:
		len = माप(काष्ठा cudbg_clk_info);
		अवरोध;
	हाल CUDBG_PCIE_INसूचीECT:
		n = माप(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * माप(u32));
		len = माप(काष्ठा ireg_buf) * n * 2;
		अवरोध;
	हाल CUDBG_PM_INसूचीECT:
		n = माप(t5_pm_rx_array) / (IREG_NUM_ELEM * माप(u32));
		len = माप(काष्ठा ireg_buf) * n * 2;
		अवरोध;
	हाल CUDBG_TID_INFO:
		len = माप(काष्ठा cudbg_tid_info_region_rev1);
		अवरोध;
	हाल CUDBG_PCIE_CONFIG:
		len = माप(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;
		अवरोध;
	हाल CUDBG_DUMP_CONTEXT:
		len = cudbg_dump_context_size(adap);
		अवरोध;
	हाल CUDBG_MPS_TCAM:
		len = माप(काष्ठा cudbg_mps_tcam) *
		      adap->params.arch.mps_tcam_size;
		अवरोध;
	हाल CUDBG_VPD_DATA:
		len = माप(काष्ठा cudbg_vpd_data);
		अवरोध;
	हाल CUDBG_LE_TCAM:
		cudbg_fill_le_tcam_info(adap, &tcam_region);
		len = माप(काष्ठा cudbg_tcam) +
		      माप(काष्ठा cudbg_tid_data) * tcam_region.max_tid;
		अवरोध;
	हाल CUDBG_CCTRL:
		len = माप(u16) * NMTUS * NCCTRL_WIN;
		अवरोध;
	हाल CUDBG_MA_INसूचीECT:
		अगर (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) अणु
			n = माप(t6_ma_ireg_array) /
			    (IREG_NUM_ELEM * माप(u32));
			len = माप(काष्ठा ireg_buf) * n * 2;
		पूर्ण
		अवरोध;
	हाल CUDBG_ULPTX_LA:
		len = माप(काष्ठा cudbg_ver_hdr) +
		      माप(काष्ठा cudbg_ulptx_la);
		अवरोध;
	हाल CUDBG_UP_CIM_INसूचीECT:
		n = 0;
		अगर (is_t5(adap->params.chip))
			n = माप(t5_up_cim_reg_array) /
			    ((IREG_NUM_ELEM + 1) * माप(u32));
		अन्यथा अगर (is_t6(adap->params.chip))
			n = माप(t6_up_cim_reg_array) /
			    ((IREG_NUM_ELEM + 1) * माप(u32));
		len = माप(काष्ठा ireg_buf) * n;
		अवरोध;
	हाल CUDBG_PBT_TABLE:
		len = माप(काष्ठा cudbg_pbt_tables);
		अवरोध;
	हाल CUDBG_MBOX_LOG:
		len = माप(काष्ठा cudbg_mbox_log) * adap->mbox_log->size;
		अवरोध;
	हाल CUDBG_HMA_INसूचीECT:
		अगर (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) अणु
			n = माप(t6_hma_ireg_array) /
			    (IREG_NUM_ELEM * माप(u32));
			len = माप(काष्ठा ireg_buf) * n;
		पूर्ण
		अवरोध;
	हाल CUDBG_HMA:
		value = t4_पढ़ो_reg(adap, MA_TARGET_MEM_ENABLE_A);
		अगर (value & HMA_MUX_F) अणु
			/* In T6, there's no MC1.  So, HMA shares MC1
			 * address space.
			 */
			value = t4_पढ़ो_reg(adap, MA_EXT_MEMORY1_BAR_A);
			len = EXT_MEM1_SIZE_G(value);
		पूर्ण
		len = cudbg_mbytes_to_bytes(len);
		अवरोध;
	हाल CUDBG_QDESC:
		cudbg_fill_qdesc_num_and_size(adap, शून्य, &len);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	वापस len;
पूर्ण

अटल पूर्णांक cudbg_करो_compression(काष्ठा cudbg_init *pdbg_init,
				काष्ठा cudbg_buffer *pin_buff,
				काष्ठा cudbg_buffer *dbg_buff)
अणु
	काष्ठा cudbg_buffer temp_in_buff = अणु 0 पूर्ण;
	पूर्णांक bytes_left, bytes_पढ़ो, bytes;
	u32 offset = dbg_buff->offset;
	पूर्णांक rc;

	temp_in_buff.offset = pin_buff->offset;
	temp_in_buff.data = pin_buff->data;
	temp_in_buff.size = pin_buff->size;

	bytes_left = pin_buff->size;
	bytes_पढ़ो = 0;
	जबतक (bytes_left > 0) अणु
		/* Do compression in smaller chunks */
		bytes = min_t(अचिन्हित दीर्घ, bytes_left,
			      (अचिन्हित दीर्घ)CUDBG_CHUNK_SIZE);
		temp_in_buff.data = (अक्षर *)pin_buff->data + bytes_पढ़ो;
		temp_in_buff.size = bytes;
		rc = cudbg_compress_buff(pdbg_init, &temp_in_buff, dbg_buff);
		अगर (rc)
			वापस rc;
		bytes_left -= bytes;
		bytes_पढ़ो += bytes;
	पूर्ण

	pin_buff->size = dbg_buff->offset - offset;
	वापस 0;
पूर्ण

अटल पूर्णांक cudbg_ग_लिखो_and_release_buff(काष्ठा cudbg_init *pdbg_init,
					काष्ठा cudbg_buffer *pin_buff,
					काष्ठा cudbg_buffer *dbg_buff)
अणु
	पूर्णांक rc = 0;

	अगर (pdbg_init->compress_type == CUDBG_COMPRESSION_NONE) अणु
		cudbg_update_buff(pin_buff, dbg_buff);
	पूर्ण अन्यथा अणु
		rc = cudbg_करो_compression(pdbg_init, pin_buff, dbg_buff);
		अगर (rc)
			जाओ out;
	पूर्ण

out:
	cudbg_put_buff(pdbg_init, pin_buff);
	वापस rc;
पूर्ण

अटल पूर्णांक is_fw_attached(काष्ठा cudbg_init *pdbg_init)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;

	अगर (!(padap->flags & CXGB4_FW_OK) || padap->use_bd)
		वापस 0;

	वापस 1;
पूर्ण

/* This function will add additional padding bytes पूर्णांकo debug_buffer to make it
 * 4 byte aligned.
 */
व्योम cudbg_align_debug_buffer(काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_entity_hdr *entity_hdr)
अणु
	u8 zero_buf[4] = अणु0पूर्ण;
	u8 padding, reमुख्य;

	reमुख्य = (dbg_buff->offset - entity_hdr->start_offset) % 4;
	padding = 4 - reमुख्य;
	अगर (reमुख्य) अणु
		स_नकल(((u8 *)dbg_buff->data) + dbg_buff->offset, &zero_buf,
		       padding);
		dbg_buff->offset += padding;
		entity_hdr->num_pad = padding;
	पूर्ण
	entity_hdr->size = dbg_buff->offset - entity_hdr->start_offset;
पूर्ण

काष्ठा cudbg_entity_hdr *cudbg_get_entity_hdr(व्योम *outbuf, पूर्णांक i)
अणु
	काष्ठा cudbg_hdr *cudbg_hdr = (काष्ठा cudbg_hdr *)outbuf;

	वापस (काष्ठा cudbg_entity_hdr *)
	       ((अक्षर *)outbuf + cudbg_hdr->hdr_len +
		(माप(काष्ठा cudbg_entity_hdr) * (i - 1)));
पूर्ण

अटल पूर्णांक cudbg_पढ़ो_vpd_reg(काष्ठा adapter *padap, u32 addr, u32 len,
			      व्योम *dest)
अणु
	पूर्णांक vaddr, rc;

	vaddr = t4_eeprom_ptov(addr, padap->pf, EEPROMPFSIZE);
	अगर (vaddr < 0)
		वापस vaddr;

	rc = pci_पढ़ो_vpd(padap->pdev, vaddr, len, dest);
	अगर (rc < 0)
		वापस rc;

	वापस 0;
पूर्ण

अटल पूर्णांक cudbg_mem_desc_cmp(स्थिर व्योम *a, स्थिर व्योम *b)
अणु
	वापस ((स्थिर काष्ठा cudbg_mem_desc *)a)->base -
	       ((स्थिर काष्ठा cudbg_mem_desc *)b)->base;
पूर्ण

पूर्णांक cudbg_fill_meminfo(काष्ठा adapter *padap,
		       काष्ठा cudbg_meminfo *meminfo_buff)
अणु
	काष्ठा cudbg_mem_desc *md;
	u32 lo, hi, used, alloc;
	पूर्णांक n, i;

	स_रखो(meminfo_buff->avail, 0,
	       ARRAY_SIZE(meminfo_buff->avail) *
	       माप(काष्ठा cudbg_mem_desc));
	स_रखो(meminfo_buff->mem, 0,
	       (ARRAY_SIZE(cudbg_region) + 3) * माप(काष्ठा cudbg_mem_desc));
	md  = meminfo_buff->mem;

	क्रम (i = 0; i < ARRAY_SIZE(meminfo_buff->mem); i++) अणु
		meminfo_buff->mem[i].limit = 0;
		meminfo_buff->mem[i].idx = i;
	पूर्ण

	/* Find and sort the populated memory ranges */
	i = 0;
	lo = t4_पढ़ो_reg(padap, MA_TARGET_MEM_ENABLE_A);
	अगर (lo & EDRAM0_ENABLE_F) अणु
		hi = t4_पढ़ो_reg(padap, MA_EDRAM0_BAR_A);
		meminfo_buff->avail[i].base =
			cudbg_mbytes_to_bytes(EDRAM0_BASE_G(hi));
		meminfo_buff->avail[i].limit =
			meminfo_buff->avail[i].base +
			cudbg_mbytes_to_bytes(EDRAM0_SIZE_G(hi));
		meminfo_buff->avail[i].idx = 0;
		i++;
	पूर्ण

	अगर (lo & EDRAM1_ENABLE_F) अणु
		hi =  t4_पढ़ो_reg(padap, MA_EDRAM1_BAR_A);
		meminfo_buff->avail[i].base =
			cudbg_mbytes_to_bytes(EDRAM1_BASE_G(hi));
		meminfo_buff->avail[i].limit =
			meminfo_buff->avail[i].base +
			cudbg_mbytes_to_bytes(EDRAM1_SIZE_G(hi));
		meminfo_buff->avail[i].idx = 1;
		i++;
	पूर्ण

	अगर (is_t5(padap->params.chip)) अणु
		अगर (lo & EXT_MEM0_ENABLE_F) अणु
			hi = t4_पढ़ो_reg(padap, MA_EXT_MEMORY0_BAR_A);
			meminfo_buff->avail[i].base =
				cudbg_mbytes_to_bytes(EXT_MEM_BASE_G(hi));
			meminfo_buff->avail[i].limit =
				meminfo_buff->avail[i].base +
				cudbg_mbytes_to_bytes(EXT_MEM_SIZE_G(hi));
			meminfo_buff->avail[i].idx = 3;
			i++;
		पूर्ण

		अगर (lo & EXT_MEM1_ENABLE_F) अणु
			hi = t4_पढ़ो_reg(padap, MA_EXT_MEMORY1_BAR_A);
			meminfo_buff->avail[i].base =
				cudbg_mbytes_to_bytes(EXT_MEM1_BASE_G(hi));
			meminfo_buff->avail[i].limit =
				meminfo_buff->avail[i].base +
				cudbg_mbytes_to_bytes(EXT_MEM1_SIZE_G(hi));
			meminfo_buff->avail[i].idx = 4;
			i++;
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (lo & EXT_MEM_ENABLE_F) अणु
			hi = t4_पढ़ो_reg(padap, MA_EXT_MEMORY_BAR_A);
			meminfo_buff->avail[i].base =
				cudbg_mbytes_to_bytes(EXT_MEM_BASE_G(hi));
			meminfo_buff->avail[i].limit =
				meminfo_buff->avail[i].base +
				cudbg_mbytes_to_bytes(EXT_MEM_SIZE_G(hi));
			meminfo_buff->avail[i].idx = 2;
			i++;
		पूर्ण

		अगर (lo & HMA_MUX_F) अणु
			hi = t4_पढ़ो_reg(padap, MA_EXT_MEMORY1_BAR_A);
			meminfo_buff->avail[i].base =
				cudbg_mbytes_to_bytes(EXT_MEM1_BASE_G(hi));
			meminfo_buff->avail[i].limit =
				meminfo_buff->avail[i].base +
				cudbg_mbytes_to_bytes(EXT_MEM1_SIZE_G(hi));
			meminfo_buff->avail[i].idx = 5;
			i++;
		पूर्ण
	पूर्ण

	अगर (!i) /* no memory available */
		वापस CUDBG_STATUS_ENTITY_NOT_FOUND;

	meminfo_buff->avail_c = i;
	sort(meminfo_buff->avail, i, माप(काष्ठा cudbg_mem_desc),
	     cudbg_mem_desc_cmp, शून्य);
	(md++)->base = t4_पढ़ो_reg(padap, SGE_DBQ_CTXT_BADDR_A);
	(md++)->base = t4_पढ़ो_reg(padap, SGE_IMSG_CTXT_BADDR_A);
	(md++)->base = t4_पढ़ो_reg(padap, SGE_FLM_CACHE_BADDR_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_TCB_BASE_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_MM_BASE_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_TIMER_BASE_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_MM_RX_FLST_BASE_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_MM_TX_FLST_BASE_A);
	(md++)->base = t4_पढ़ो_reg(padap, TP_CMM_MM_PS_FLST_BASE_A);

	/* the next few have explicit upper bounds */
	md->base = t4_पढ़ो_reg(padap, TP_PMM_TX_BASE_A);
	md->limit = md->base - 1 +
		    t4_पढ़ो_reg(padap, TP_PMM_TX_PAGE_SIZE_A) *
		    PMTXMAXPAGE_G(t4_पढ़ो_reg(padap, TP_PMM_TX_MAX_PAGE_A));
	md++;

	md->base = t4_पढ़ो_reg(padap, TP_PMM_RX_BASE_A);
	md->limit = md->base - 1 +
		    t4_पढ़ो_reg(padap, TP_PMM_RX_PAGE_SIZE_A) *
		    PMRXMAXPAGE_G(t4_पढ़ो_reg(padap, TP_PMM_RX_MAX_PAGE_A));
	md++;

	अगर (t4_पढ़ो_reg(padap, LE_DB_CONFIG_A) & HASHEN_F) अणु
		अगर (CHELSIO_CHIP_VERSION(padap->params.chip) <= CHELSIO_T5) अणु
			hi = t4_पढ़ो_reg(padap, LE_DB_TID_HASHBASE_A) / 4;
			md->base = t4_पढ़ो_reg(padap, LE_DB_HASH_TID_BASE_A);
		पूर्ण अन्यथा अणु
			hi = t4_पढ़ो_reg(padap, LE_DB_HASH_TID_BASE_A);
			md->base = t4_पढ़ो_reg(padap,
					       LE_DB_HASH_TBL_BASE_ADDR_A);
		पूर्ण
		md->limit = 0;
	पूर्ण अन्यथा अणु
		md->base = 0;
		md->idx = ARRAY_SIZE(cudbg_region);  /* hide it */
	पूर्ण
	md++;

#घोषणा ulp_region(reg) करो अणु \
	md->base = t4_पढ़ो_reg(padap, ULP_ ## reg ## _LLIMIT_A);\
	(md++)->limit = t4_पढ़ो_reg(padap, ULP_ ## reg ## _ULIMIT_A);\
पूर्ण जबतक (0)

	ulp_region(RX_ISCSI);
	ulp_region(RX_TDDP);
	ulp_region(TX_TPT);
	ulp_region(RX_STAG);
	ulp_region(RX_RQ);
	ulp_region(RX_RQUDP);
	ulp_region(RX_PBL);
	ulp_region(TX_PBL);
#अघोषित ulp_region
	md->base = 0;
	md->idx = ARRAY_SIZE(cudbg_region);
	अगर (!is_t4(padap->params.chip)) अणु
		u32 fअगरo_size = t4_पढ़ो_reg(padap, SGE_DBVFIFO_SIZE_A);
		u32 sge_ctrl = t4_पढ़ो_reg(padap, SGE_CONTROL2_A);
		u32 size = 0;

		अगर (is_t5(padap->params.chip)) अणु
			अगर (sge_ctrl & VFIFO_ENABLE_F)
				size = DBVFIFO_SIZE_G(fअगरo_size);
		पूर्ण अन्यथा अणु
			size = T6_DBVFIFO_SIZE_G(fअगरo_size);
		पूर्ण

		अगर (size) अणु
			md->base = BASEADDR_G(t4_पढ़ो_reg(padap,
							  SGE_DBVFIFO_BADDR_A));
			md->limit = md->base + (size << 2) - 1;
		पूर्ण
	पूर्ण

	md++;

	md->base = t4_पढ़ो_reg(padap, ULP_RX_CTX_BASE_A);
	md->limit = 0;
	md++;
	md->base = t4_पढ़ो_reg(padap, ULP_TX_ERR_TABLE_BASE_A);
	md->limit = 0;
	md++;

	md->base = padap->vres.ocq.start;
	अगर (padap->vres.ocq.size)
		md->limit = md->base + padap->vres.ocq.size - 1;
	अन्यथा
		md->idx = ARRAY_SIZE(cudbg_region);  /* hide it */
	md++;

	/* add any address-space holes, there can be up to 3 */
	क्रम (n = 0; n < i - 1; n++)
		अगर (meminfo_buff->avail[n].limit <
		    meminfo_buff->avail[n + 1].base)
			(md++)->base = meminfo_buff->avail[n].limit;

	अगर (meminfo_buff->avail[n].limit)
		(md++)->base = meminfo_buff->avail[n].limit;

	n = md - meminfo_buff->mem;
	meminfo_buff->mem_c = n;

	sort(meminfo_buff->mem, n, माप(काष्ठा cudbg_mem_desc),
	     cudbg_mem_desc_cmp, शून्य);

	lo = t4_पढ़ो_reg(padap, CIM_SDRAM_BASE_ADDR_A);
	hi = t4_पढ़ो_reg(padap, CIM_SDRAM_ADDR_SIZE_A) + lo - 1;
	meminfo_buff->up_ram_lo = lo;
	meminfo_buff->up_ram_hi = hi;

	lo = t4_पढ़ो_reg(padap, CIM_EXTMEM2_BASE_ADDR_A);
	hi = t4_पढ़ो_reg(padap, CIM_EXTMEM2_ADDR_SIZE_A) + lo - 1;
	meminfo_buff->up_exपंचांगem2_lo = lo;
	meminfo_buff->up_exपंचांगem2_hi = hi;

	lo = t4_पढ़ो_reg(padap, TP_PMM_RX_MAX_PAGE_A);
	क्रम (i = 0, meminfo_buff->मुक्त_rx_cnt = 0; i < 2; i++)
		meminfo_buff->मुक्त_rx_cnt +=
			FREERXPAGECOUNT_G(t4_पढ़ो_reg(padap,
						      TP_FLM_FREE_RX_CNT_A));

	meminfo_buff->rx_pages_data[0] =  PMRXMAXPAGE_G(lo);
	meminfo_buff->rx_pages_data[1] =
		t4_पढ़ो_reg(padap, TP_PMM_RX_PAGE_SIZE_A) >> 10;
	meminfo_buff->rx_pages_data[2] = (lo & PMRXNUMCHN_F) ? 2 : 1;

	lo = t4_पढ़ो_reg(padap, TP_PMM_TX_MAX_PAGE_A);
	hi = t4_पढ़ो_reg(padap, TP_PMM_TX_PAGE_SIZE_A);
	क्रम (i = 0, meminfo_buff->मुक्त_tx_cnt = 0; i < 4; i++)
		meminfo_buff->मुक्त_tx_cnt +=
			FREETXPAGECOUNT_G(t4_पढ़ो_reg(padap,
						      TP_FLM_FREE_TX_CNT_A));

	meminfo_buff->tx_pages_data[0] = PMTXMAXPAGE_G(lo);
	meminfo_buff->tx_pages_data[1] =
		hi >= (1 << 20) ? (hi >> 20) : (hi >> 10);
	meminfo_buff->tx_pages_data[2] =
		hi >= (1 << 20) ? 'M' : 'K';
	meminfo_buff->tx_pages_data[3] = 1 << PMTXNUMCHN_G(lo);

	meminfo_buff->p_काष्ठाs = t4_पढ़ो_reg(padap, TP_CMM_MM_MAX_PSTRUCT_A);
	meminfo_buff->p_काष्ठाs_मुक्त_cnt =
		FREEPSTRUCTCOUNT_G(t4_पढ़ो_reg(padap, TP_FLM_FREE_PS_CNT_A));

	क्रम (i = 0; i < 4; i++) अणु
		अगर (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5)
			lo = t4_पढ़ो_reg(padap,
					 MPS_RX_MAC_BG_PG_CNT0_A + i * 4);
		अन्यथा
			lo = t4_पढ़ो_reg(padap, MPS_RX_PG_RSV0_A + i * 4);
		अगर (is_t5(padap->params.chip)) अणु
			used = T5_USED_G(lo);
			alloc = T5_ALLOC_G(lo);
		पूर्ण अन्यथा अणु
			used = USED_G(lo);
			alloc = ALLOC_G(lo);
		पूर्ण
		meminfo_buff->port_used[i] = used;
		meminfo_buff->port_alloc[i] = alloc;
	पूर्ण

	क्रम (i = 0; i < padap->params.arch.nchan; i++) अणु
		अगर (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5)
			lo = t4_पढ़ो_reg(padap,
					 MPS_RX_LPBK_BG_PG_CNT0_A + i * 4);
		अन्यथा
			lo = t4_पढ़ो_reg(padap, MPS_RX_PG_RSV4_A + i * 4);
		अगर (is_t5(padap->params.chip)) अणु
			used = T5_USED_G(lo);
			alloc = T5_ALLOC_G(lo);
		पूर्ण अन्यथा अणु
			used = USED_G(lo);
			alloc = ALLOC_G(lo);
		पूर्ण
		meminfo_buff->loopback_used[i] = used;
		meminfo_buff->loopback_alloc[i] = alloc;
	पूर्ण

	वापस 0;
पूर्ण

पूर्णांक cudbg_collect_reg_dump(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	u32 buf_size = 0;
	पूर्णांक rc = 0;

	अगर (is_t4(padap->params.chip))
		buf_size = T4_REGMAP_SIZE;
	अन्यथा अगर (is_t5(padap->params.chip) || is_t6(padap->params.chip))
		buf_size = T5_REGMAP_SIZE;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, buf_size, &temp_buff);
	अगर (rc)
		वापस rc;
	t4_get_regs(padap, (व्योम *)temp_buff.data, temp_buff.size);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_fw_devlog(काष्ठा cudbg_init *pdbg_init,
			    काष्ठा cudbg_buffer *dbg_buff,
			    काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा devlog_params *dparams;
	पूर्णांक rc = 0;

	rc = t4_init_devlog_params(padap);
	अगर (rc < 0) अणु
		cudbg_err->sys_err = rc;
		वापस rc;
	पूर्ण

	dparams = &padap->params.devlog;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, dparams->size, &temp_buff);
	अगर (rc)
		वापस rc;

	/* Collect FW devlog */
	अगर (dparams->start != 0) अणु
		spin_lock(&padap->win0_lock);
		rc = t4_memory_rw(padap, padap->params.drv_memwin,
				  dparams->memtype, dparams->start,
				  dparams->size,
				  (__be32 *)(अक्षर *)temp_buff.data,
				  1);
		spin_unlock(&padap->win0_lock);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_la(काष्ठा cudbg_init *pdbg_init,
			 काष्ठा cudbg_buffer *dbg_buff,
			 काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक size, rc;
	u32 cfg = 0;

	अगर (is_t6(padap->params.chip)) अणु
		size = padap->params.cim_la_size / 10 + 1;
		size *= 10 * माप(u32);
	पूर्ण अन्यथा अणु
		size = padap->params.cim_la_size / 8;
		size *= 8 * माप(u32);
	पूर्ण

	size += माप(cfg);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	rc = t4_cim_पढ़ो(padap, UP_UP_DBG_LA_CFG_A, 1, &cfg);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण

	स_नकल((अक्षर *)temp_buff.data, &cfg, माप(cfg));
	rc = t4_cim_पढ़ो_la(padap,
			    (u32 *)((अक्षर *)temp_buff.data + माप(cfg)),
			    शून्य);
	अगर (rc < 0) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_ma_la(काष्ठा cudbg_init *pdbg_init,
			    काष्ठा cudbg_buffer *dbg_buff,
			    काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक size, rc;

	size = 2 * CIM_MALA_SIZE * 5 * माप(u32);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	t4_cim_पढ़ो_ma_la(padap,
			  (u32 *)temp_buff.data,
			  (u32 *)((अक्षर *)temp_buff.data +
				  5 * CIM_MALA_SIZE));
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_qcfg(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_cim_qcfg *cim_qcfg_data;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_cim_qcfg),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	cim_qcfg_data = (काष्ठा cudbg_cim_qcfg *)temp_buff.data;
	cim_qcfg_data->chip = padap->params.chip;
	rc = t4_cim_पढ़ो(padap, UP_IBQ_0_RDADDR_A,
			 ARRAY_SIZE(cim_qcfg_data->stat), cim_qcfg_data->stat);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण

	rc = t4_cim_पढ़ो(padap, UP_OBQ_0_REALADDR_A,
			 ARRAY_SIZE(cim_qcfg_data->obq_wr),
			 cim_qcfg_data->obq_wr);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण

	t4_पढ़ो_cimq_cfg(padap, cim_qcfg_data->base, cim_qcfg_data->size,
			 cim_qcfg_data->thres);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

अटल पूर्णांक cudbg_पढ़ो_cim_ibq(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err, पूर्णांक qid)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक no_of_पढ़ो_words, rc = 0;
	u32 qsize;

	/* collect CIM IBQ */
	qsize = CIM_IBQ_SIZE * 4 * माप(u32);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
	अगर (rc)
		वापस rc;

	/* t4_पढ़ो_cim_ibq will वापस no. of पढ़ो words or error */
	no_of_पढ़ो_words = t4_पढ़ो_cim_ibq(padap, qid,
					   (u32 *)temp_buff.data, qsize);
	/* no_of_पढ़ो_words is less than or equal to 0 means error */
	अगर (no_of_पढ़ो_words <= 0) अणु
		अगर (!no_of_पढ़ो_words)
			rc = CUDBG_SYSTEM_ERROR;
		अन्यथा
			rc = no_of_पढ़ो_words;
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_tp0(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 0);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_tp1(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 1);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_ulp(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 2);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_sge0(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 3);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_sge1(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 4);
पूर्ण

पूर्णांक cudbg_collect_cim_ibq_ncsi(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 5);
पूर्ण

u32 cudbg_cim_obq_size(काष्ठा adapter *padap, पूर्णांक qid)
अणु
	u32 value;

	t4_ग_लिखो_reg(padap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |
		     QUENUMSELECT_V(qid));
	value = t4_पढ़ो_reg(padap, CIM_QUEUE_CONFIG_CTRL_A);
	value = CIMQSIZE_G(value) * 64; /* size in number of words */
	वापस value * माप(u32);
पूर्ण

अटल पूर्णांक cudbg_पढ़ो_cim_obq(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err, पूर्णांक qid)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक no_of_पढ़ो_words, rc = 0;
	u32 qsize;

	/* collect CIM OBQ */
	qsize =  cudbg_cim_obq_size(padap, qid);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
	अगर (rc)
		वापस rc;

	/* t4_पढ़ो_cim_obq will वापस no. of पढ़ो words or error */
	no_of_पढ़ो_words = t4_पढ़ो_cim_obq(padap, qid,
					   (u32 *)temp_buff.data, qsize);
	/* no_of_पढ़ो_words is less than or equal to 0 means error */
	अगर (no_of_पढ़ो_words <= 0) अणु
		अगर (!no_of_पढ़ो_words)
			rc = CUDBG_SYSTEM_ERROR;
		अन्यथा
			rc = no_of_पढ़ो_words;
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_ulp0(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 0);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_ulp1(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 1);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_ulp2(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 2);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_ulp3(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 3);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_sge(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 4);
पूर्ण

पूर्णांक cudbg_collect_cim_obq_ncsi(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 5);
पूर्ण

पूर्णांक cudbg_collect_obq_sge_rx_q0(काष्ठा cudbg_init *pdbg_init,
				काष्ठा cudbg_buffer *dbg_buff,
				काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 6);
पूर्ण

पूर्णांक cudbg_collect_obq_sge_rx_q1(काष्ठा cudbg_init *pdbg_init,
				काष्ठा cudbg_buffer *dbg_buff,
				काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_पढ़ो_cim_obq(pdbg_init, dbg_buff, cudbg_err, 7);
पूर्ण

अटल पूर्णांक cudbg_meminfo_get_mem_index(काष्ठा adapter *padap,
				       काष्ठा cudbg_meminfo *mem_info,
				       u8 mem_type, u8 *idx)
अणु
	u8 i, flag;

	चयन (mem_type) अणु
	हाल MEM_EDC0:
		flag = EDC0_FLAG;
		अवरोध;
	हाल MEM_EDC1:
		flag = EDC1_FLAG;
		अवरोध;
	हाल MEM_MC0:
		/* Some T5 cards have both MC0 and MC1. */
		flag = is_t5(padap->params.chip) ? MC0_FLAG : MC_FLAG;
		अवरोध;
	हाल MEM_MC1:
		flag = MC1_FLAG;
		अवरोध;
	हाल MEM_HMA:
		flag = HMA_FLAG;
		अवरोध;
	शेष:
		वापस CUDBG_STATUS_ENTITY_NOT_FOUND;
	पूर्ण

	क्रम (i = 0; i < mem_info->avail_c; i++) अणु
		अगर (mem_info->avail[i].idx == flag) अणु
			*idx = i;
			वापस 0;
		पूर्ण
	पूर्ण

	वापस CUDBG_STATUS_ENTITY_NOT_FOUND;
पूर्ण

/* Fetch the @region_name's start and end from @meminfo. */
अटल पूर्णांक cudbg_get_mem_region(काष्ठा adapter *padap,
				काष्ठा cudbg_meminfo *meminfo,
				u8 mem_type, स्थिर अक्षर *region_name,
				काष्ठा cudbg_mem_desc *mem_desc)
अणु
	u8 mc, found = 0;
	u32 idx = 0;
	पूर्णांक rc, i;

	rc = cudbg_meminfo_get_mem_index(padap, meminfo, mem_type, &mc);
	अगर (rc)
		वापस rc;

	i = match_string(cudbg_region, ARRAY_SIZE(cudbg_region), region_name);
	अगर (i < 0)
		वापस -EINVAL;

	idx = i;
	क्रम (i = 0; i < meminfo->mem_c; i++) अणु
		अगर (meminfo->mem[i].idx >= ARRAY_SIZE(cudbg_region))
			जारी; /* Skip holes */

		अगर (!(meminfo->mem[i].limit))
			meminfo->mem[i].limit =
				i < meminfo->mem_c - 1 ?
				meminfo->mem[i + 1].base - 1 : ~0;

		अगर (meminfo->mem[i].idx == idx) अणु
			/* Check अगर the region exists in @mem_type memory */
			अगर (meminfo->mem[i].base < meminfo->avail[mc].base &&
			    meminfo->mem[i].limit < meminfo->avail[mc].base)
				वापस -EINVAL;

			अगर (meminfo->mem[i].base > meminfo->avail[mc].limit)
				वापस -EINVAL;

			स_नकल(mem_desc, &meminfo->mem[i],
			       माप(काष्ठा cudbg_mem_desc));
			found = 1;
			अवरोध;
		पूर्ण
	पूर्ण
	अगर (!found)
		वापस -EINVAL;

	वापस 0;
पूर्ण

/* Fetch and update the start and end of the requested memory region w.r.t 0
 * in the corresponding EDC/MC/HMA.
 */
अटल पूर्णांक cudbg_get_mem_relative(काष्ठा adapter *padap,
				  काष्ठा cudbg_meminfo *meminfo,
				  u8 mem_type, u32 *out_base, u32 *out_end)
अणु
	u8 mc_idx;
	पूर्णांक rc;

	rc = cudbg_meminfo_get_mem_index(padap, meminfo, mem_type, &mc_idx);
	अगर (rc)
		वापस rc;

	अगर (*out_base < meminfo->avail[mc_idx].base)
		*out_base = 0;
	अन्यथा
		*out_base -= meminfo->avail[mc_idx].base;

	अगर (*out_end > meminfo->avail[mc_idx].limit)
		*out_end = meminfo->avail[mc_idx].limit;
	अन्यथा
		*out_end -= meminfo->avail[mc_idx].base;

	वापस 0;
पूर्ण

/* Get TX and RX Payload region */
अटल पूर्णांक cudbg_get_payload_range(काष्ठा adapter *padap, u8 mem_type,
				   स्थिर अक्षर *region_name,
				   काष्ठा cudbg_region_info *payload)
अणु
	काष्ठा cudbg_mem_desc mem_desc = अणु 0 पूर्ण;
	काष्ठा cudbg_meminfo meminfo;
	पूर्णांक rc;

	rc = cudbg_fill_meminfo(padap, &meminfo);
	अगर (rc)
		वापस rc;

	rc = cudbg_get_mem_region(padap, &meminfo, mem_type, region_name,
				  &mem_desc);
	अगर (rc) अणु
		payload->exist = false;
		वापस 0;
	पूर्ण

	payload->exist = true;
	payload->start = mem_desc.base;
	payload->end = mem_desc.limit;

	वापस cudbg_get_mem_relative(padap, &meminfo, mem_type,
				      &payload->start, &payload->end);
पूर्ण

अटल पूर्णांक cudbg_memory_पढ़ो(काष्ठा cudbg_init *pdbg_init, पूर्णांक win,
			     पूर्णांक mtype, u32 addr, u32 len, व्योम *hbuf)
अणु
	u32 win_pf, memoffset, mem_aperture, mem_base;
	काष्ठा adapter *adap = pdbg_init->adap;
	u32 pos, offset, resid;
	u32 *res_buf;
	u64 *buf;
	पूर्णांक ret;

	/* Argument sanity checks ...
	 */
	अगर (addr & 0x3 || (uपूर्णांकptr_t)hbuf & 0x3)
		वापस -EINVAL;

	buf = (u64 *)hbuf;

	/* Try to करो 64-bit पढ़ोs.  Residual will be handled later. */
	resid = len & 0x7;
	len -= resid;

	ret = t4_memory_rw_init(adap, win, mtype, &memoffset, &mem_base,
				&mem_aperture);
	अगर (ret)
		वापस ret;

	addr = addr + memoffset;
	win_pf = is_t4(adap->params.chip) ? 0 : PFNUM_V(adap->pf);

	pos = addr & ~(mem_aperture - 1);
	offset = addr - pos;

	/* Set up initial PCI-E Memory Winकरोw to cover the start of our
	 * transfer.
	 */
	t4_memory_update_win(adap, win, pos | win_pf);

	/* Transfer data from the adapter */
	जबतक (len > 0) अणु
		*buf++ = le64_to_cpu((__क्रमce __le64)
				     t4_पढ़ो_reg64(adap, mem_base + offset));
		offset += माप(u64);
		len -= माप(u64);

		/* If we've reached the end of our current winकरोw aperture,
		 * move the PCI-E Memory Winकरोw on to the next.
		 */
		अगर (offset == mem_aperture) अणु
			pos += mem_aperture;
			offset = 0;
			t4_memory_update_win(adap, win, pos | win_pf);
		पूर्ण
	पूर्ण

	res_buf = (u32 *)buf;
	/* Read residual in 32-bit multiples */
	जबतक (resid > माप(u32)) अणु
		*res_buf++ = le32_to_cpu((__क्रमce __le32)
					 t4_पढ़ो_reg(adap, mem_base + offset));
		offset += माप(u32);
		resid -= माप(u32);

		/* If we've reached the end of our current winकरोw aperture,
		 * move the PCI-E Memory Winकरोw on to the next.
		 */
		अगर (offset == mem_aperture) अणु
			pos += mem_aperture;
			offset = 0;
			t4_memory_update_win(adap, win, pos | win_pf);
		पूर्ण
	पूर्ण

	/* Transfer residual < 32-bits */
	अगर (resid)
		t4_memory_rw_residual(adap, resid, mem_base + offset,
				      (u8 *)res_buf, T4_MEMORY_READ);

	वापस 0;
पूर्ण

#घोषणा CUDBG_YIELD_ITERATION 256

अटल पूर्णांक cudbg_पढ़ो_fw_mem(काष्ठा cudbg_init *pdbg_init,
			     काष्ठा cudbg_buffer *dbg_buff, u8 mem_type,
			     अचिन्हित दीर्घ tot_len,
			     काष्ठा cudbg_error *cudbg_err)
अणु
	अटल स्थिर अक्षर * स्थिर region_name[] = अणु "Tx payload:",
						    "Rx payload:" पूर्ण;
	अचिन्हित दीर्घ bytes, bytes_left, bytes_पढ़ो = 0;
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_region_info payload[2];
	u32 yield_count = 0;
	पूर्णांक rc = 0;
	u8 i;

	/* Get TX/RX Payload region range अगर they exist */
	स_रखो(payload, 0, माप(payload));
	क्रम (i = 0; i < ARRAY_SIZE(region_name); i++) अणु
		rc = cudbg_get_payload_range(padap, mem_type, region_name[i],
					     &payload[i]);
		अगर (rc)
			वापस rc;

		अगर (payload[i].exist) अणु
			/* Align start and end to aव्योम wrap around */
			payload[i].start = roundup(payload[i].start,
						   CUDBG_CHUNK_SIZE);
			payload[i].end = roundकरोwn(payload[i].end,
						   CUDBG_CHUNK_SIZE);
		पूर्ण
	पूर्ण

	bytes_left = tot_len;
	जबतक (bytes_left > 0) अणु
		/* As MC size is huge and पढ़ो through PIO access, this
		 * loop will hold cpu क्रम a दीर्घer समय. OS may think that
		 * the process is hanged and will generate CPU stall traces.
		 * So yield the cpu regularly.
		 */
		yield_count++;
		अगर (!(yield_count % CUDBG_YIELD_ITERATION))
			schedule();

		bytes = min_t(अचिन्हित दीर्घ, bytes_left,
			      (अचिन्हित दीर्घ)CUDBG_CHUNK_SIZE);
		rc = cudbg_get_buff(pdbg_init, dbg_buff, bytes, &temp_buff);
		अगर (rc)
			वापस rc;

		क्रम (i = 0; i < ARRAY_SIZE(payload); i++)
			अगर (payload[i].exist &&
			    bytes_पढ़ो >= payload[i].start &&
			    bytes_पढ़ो + bytes <= payload[i].end)
				/* TX and RX Payload regions can't overlap */
				जाओ skip_पढ़ो;

		spin_lock(&padap->win0_lock);
		rc = cudbg_memory_पढ़ो(pdbg_init, MEMWIN_NIC, mem_type,
				       bytes_पढ़ो, bytes, temp_buff.data);
		spin_unlock(&padap->win0_lock);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण

skip_पढ़ो:
		bytes_left -= bytes;
		bytes_पढ़ो += bytes;
		rc = cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff,
						  dbg_buff);
		अगर (rc) अणु
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण
	वापस rc;
पूर्ण

अटल व्योम cudbg_t4_fwcache(काष्ठा cudbg_init *pdbg_init,
			     काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	पूर्णांक rc;

	अगर (is_fw_attached(pdbg_init)) अणु
		/* Flush uP dcache beक्रमe पढ़ोing edcX/mcX  */
		rc = t4_fwcache(padap, FW_PARAM_DEV_FWCACHE_FLUSH);
		अगर (rc)
			cudbg_err->sys_warn = rc;
	पूर्ण
पूर्ण

अटल पूर्णांक cudbg_mem_region_size(काष्ठा cudbg_init *pdbg_init,
				 काष्ठा cudbg_error *cudbg_err,
				 u8 mem_type, अचिन्हित दीर्घ *region_size)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_meminfo mem_info;
	u8 mc_idx;
	पूर्णांक rc;

	स_रखो(&mem_info, 0, माप(काष्ठा cudbg_meminfo));
	rc = cudbg_fill_meminfo(padap, &mem_info);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		वापस rc;
	पूर्ण

	cudbg_t4_fwcache(pdbg_init, cudbg_err);
	rc = cudbg_meminfo_get_mem_index(padap, &mem_info, mem_type, &mc_idx);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		वापस rc;
	पूर्ण

	अगर (region_size)
		*region_size = mem_info.avail[mc_idx].limit -
			       mem_info.avail[mc_idx].base;

	वापस 0;
पूर्ण

अटल पूर्णांक cudbg_collect_mem_region(काष्ठा cudbg_init *pdbg_init,
				    काष्ठा cudbg_buffer *dbg_buff,
				    काष्ठा cudbg_error *cudbg_err,
				    u8 mem_type)
अणु
	अचिन्हित दीर्घ size = 0;
	पूर्णांक rc;

	rc = cudbg_mem_region_size(pdbg_init, cudbg_err, mem_type, &size);
	अगर (rc)
		वापस rc;

	वापस cudbg_पढ़ो_fw_mem(pdbg_init, dbg_buff, mem_type, size,
				 cudbg_err);
पूर्ण

पूर्णांक cudbg_collect_edc0_meminfo(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,
					MEM_EDC0);
पूर्ण

पूर्णांक cudbg_collect_edc1_meminfo(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,
					MEM_EDC1);
पूर्ण

पूर्णांक cudbg_collect_mc0_meminfo(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,
					MEM_MC0);
पूर्ण

पूर्णांक cudbg_collect_mc1_meminfo(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,
					MEM_MC1);
पूर्ण

पूर्णांक cudbg_collect_hma_meminfo(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	वापस cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,
					MEM_HMA);
पूर्ण

पूर्णांक cudbg_collect_rss(काष्ठा cudbg_init *pdbg_init,
		      काष्ठा cudbg_buffer *dbg_buff,
		      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक rc, nentries;

	nentries = t4_chip_rss_size(padap);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, nentries * माप(u16),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	rc = t4_पढ़ो_rss(padap, (u16 *)temp_buff.data);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_rss_vf_config(काष्ठा cudbg_init *pdbg_init,
				काष्ठा cudbg_buffer *dbg_buff,
				काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_rss_vf_conf *vfconf;
	पूर्णांक vf, rc, vf_count;

	vf_count = padap->params.arch.vfcount;
	rc = cudbg_get_buff(pdbg_init, dbg_buff,
			    vf_count * माप(काष्ठा cudbg_rss_vf_conf),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	vfconf = (काष्ठा cudbg_rss_vf_conf *)temp_buff.data;
	क्रम (vf = 0; vf < vf_count; vf++)
		t4_पढ़ो_rss_vf_config(padap, vf, &vfconf[vf].rss_vf_vfl,
				      &vfconf[vf].rss_vf_vfh, true);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_path_mtu(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, NMTUS * माप(u16),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	t4_पढ़ो_mtu_tbl(padap, (u16 *)temp_buff.data, शून्य);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_pm_stats(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_pm_stats *pm_stats_buff;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_pm_stats),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	pm_stats_buff = (काष्ठा cudbg_pm_stats *)temp_buff.data;
	t4_pmtx_get_stats(padap, pm_stats_buff->tx_cnt, pm_stats_buff->tx_cyc);
	t4_pmrx_get_stats(padap, pm_stats_buff->rx_cnt, pm_stats_buff->rx_cyc);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_hw_sched(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_hw_sched *hw_sched_buff;
	पूर्णांक i, rc = 0;

	अगर (!padap->params.vpd.cclk)
		वापस CUDBG_STATUS_CCLK_NOT_DEFINED;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_hw_sched),
			    &temp_buff);

	अगर (rc)
		वापस rc;

	hw_sched_buff = (काष्ठा cudbg_hw_sched *)temp_buff.data;
	hw_sched_buff->map = t4_पढ़ो_reg(padap, TP_TX_MOD_QUEUE_REQ_MAP_A);
	hw_sched_buff->mode = TIMERMODE_G(t4_पढ़ो_reg(padap, TP_MOD_CONFIG_A));
	t4_पढ़ो_pace_tbl(padap, hw_sched_buff->pace_tab);
	क्रम (i = 0; i < NTX_SCHED; ++i)
		t4_get_tx_sched(padap, i, &hw_sched_buff->kbps[i],
				&hw_sched_buff->ipg[i], true);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_tp_indirect(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा ireg_buf *ch_tp_pio;
	पूर्णांक i, rc, n = 0;
	u32 size;

	अगर (is_t5(padap->params.chip))
		n = माप(t5_tp_pio_array) +
		    माप(t5_tp_पंचांग_pio_array) +
		    माप(t5_tp_mib_index_array);
	अन्यथा
		n = माप(t6_tp_pio_array) +
		    माप(t6_tp_पंचांग_pio_array) +
		    माप(t6_tp_mib_index_array);

	n = n / (IREG_NUM_ELEM * माप(u32));
	size = माप(काष्ठा ireg_buf) * n;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	ch_tp_pio = (काष्ठा ireg_buf *)temp_buff.data;

	/* TP_PIO */
	अगर (is_t5(padap->params.chip))
		n = माप(t5_tp_pio_array) / (IREG_NUM_ELEM * माप(u32));
	अन्यथा अगर (is_t6(padap->params.chip))
		n = माप(t6_tp_pio_array) / (IREG_NUM_ELEM * माप(u32));

	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *tp_pio = &ch_tp_pio->tp_pio;
		u32 *buff = ch_tp_pio->outbuf;

		अगर (is_t5(padap->params.chip)) अणु
			tp_pio->ireg_addr = t5_tp_pio_array[i][0];
			tp_pio->ireg_data = t5_tp_pio_array[i][1];
			tp_pio->ireg_local_offset = t5_tp_pio_array[i][2];
			tp_pio->ireg_offset_range = t5_tp_pio_array[i][3];
		पूर्ण अन्यथा अगर (is_t6(padap->params.chip)) अणु
			tp_pio->ireg_addr = t6_tp_pio_array[i][0];
			tp_pio->ireg_data = t6_tp_pio_array[i][1];
			tp_pio->ireg_local_offset = t6_tp_pio_array[i][2];
			tp_pio->ireg_offset_range = t6_tp_pio_array[i][3];
		पूर्ण
		t4_tp_pio_पढ़ो(padap, buff, tp_pio->ireg_offset_range,
			       tp_pio->ireg_local_offset, true);
		ch_tp_pio++;
	पूर्ण

	/* TP_TM_PIO */
	अगर (is_t5(padap->params.chip))
		n = माप(t5_tp_पंचांग_pio_array) / (IREG_NUM_ELEM * माप(u32));
	अन्यथा अगर (is_t6(padap->params.chip))
		n = माप(t6_tp_पंचांग_pio_array) / (IREG_NUM_ELEM * माप(u32));

	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *tp_pio = &ch_tp_pio->tp_pio;
		u32 *buff = ch_tp_pio->outbuf;

		अगर (is_t5(padap->params.chip)) अणु
			tp_pio->ireg_addr = t5_tp_पंचांग_pio_array[i][0];
			tp_pio->ireg_data = t5_tp_पंचांग_pio_array[i][1];
			tp_pio->ireg_local_offset = t5_tp_पंचांग_pio_array[i][2];
			tp_pio->ireg_offset_range = t5_tp_पंचांग_pio_array[i][3];
		पूर्ण अन्यथा अगर (is_t6(padap->params.chip)) अणु
			tp_pio->ireg_addr = t6_tp_पंचांग_pio_array[i][0];
			tp_pio->ireg_data = t6_tp_पंचांग_pio_array[i][1];
			tp_pio->ireg_local_offset = t6_tp_पंचांग_pio_array[i][2];
			tp_pio->ireg_offset_range = t6_tp_पंचांग_pio_array[i][3];
		पूर्ण
		t4_tp_पंचांग_pio_पढ़ो(padap, buff, tp_pio->ireg_offset_range,
				  tp_pio->ireg_local_offset, true);
		ch_tp_pio++;
	पूर्ण

	/* TP_MIB_INDEX */
	अगर (is_t5(padap->params.chip))
		n = माप(t5_tp_mib_index_array) /
		    (IREG_NUM_ELEM * माप(u32));
	अन्यथा अगर (is_t6(padap->params.chip))
		n = माप(t6_tp_mib_index_array) /
		    (IREG_NUM_ELEM * माप(u32));

	क्रम (i = 0; i < n ; i++) अणु
		काष्ठा ireg_field *tp_pio = &ch_tp_pio->tp_pio;
		u32 *buff = ch_tp_pio->outbuf;

		अगर (is_t5(padap->params.chip)) अणु
			tp_pio->ireg_addr = t5_tp_mib_index_array[i][0];
			tp_pio->ireg_data = t5_tp_mib_index_array[i][1];
			tp_pio->ireg_local_offset =
				t5_tp_mib_index_array[i][2];
			tp_pio->ireg_offset_range =
				t5_tp_mib_index_array[i][3];
		पूर्ण अन्यथा अगर (is_t6(padap->params.chip)) अणु
			tp_pio->ireg_addr = t6_tp_mib_index_array[i][0];
			tp_pio->ireg_data = t6_tp_mib_index_array[i][1];
			tp_pio->ireg_local_offset =
				t6_tp_mib_index_array[i][2];
			tp_pio->ireg_offset_range =
				t6_tp_mib_index_array[i][3];
		पूर्ण
		t4_tp_mib_पढ़ो(padap, buff, tp_pio->ireg_offset_range,
			       tp_pio->ireg_local_offset, true);
		ch_tp_pio++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

अटल व्योम cudbg_पढ़ो_sge_qbase_indirect_reg(काष्ठा adapter *padap,
					      काष्ठा sge_qbase_reg_field *qbase,
					      u32 func, bool is_pf)
अणु
	u32 *buff, i;

	अगर (is_pf) अणु
		buff = qbase->pf_data_value[func];
	पूर्ण अन्यथा अणु
		buff = qbase->vf_data_value[func];
		/* In SGE_QBASE_INDEX,
		 * Entries 0->7 are PF0->7, Entries 8->263 are VFID0->256.
		 */
		func += 8;
	पूर्ण

	t4_ग_लिखो_reg(padap, qbase->reg_addr, func);
	क्रम (i = 0; i < SGE_QBASE_DATA_REG_NUM; i++, buff++)
		*buff = t4_पढ़ो_reg(padap, qbase->reg_data[i]);
पूर्ण

पूर्णांक cudbg_collect_sge_indirect(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा sge_qbase_reg_field *sge_qbase;
	काष्ठा ireg_buf *ch_sge_dbg;
	u8 padap_running = 0;
	पूर्णांक i, rc;
	u32 size;

	/* Accessing SGE_QBASE_MAP[0-3] and SGE_QBASE_INDEX regs can
	 * lead to SGE missing करोorbells under heavy traffic. So, only
	 * collect them when adapter is idle.
	 */
	क्रम_each_port(padap, i) अणु
		padap_running = netअगर_running(padap->port[i]);
		अगर (padap_running)
			अवरोध;
	पूर्ण

	size = माप(*ch_sge_dbg) * 2;
	अगर (!padap_running)
		size += माप(*sge_qbase);

	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	ch_sge_dbg = (काष्ठा ireg_buf *)temp_buff.data;
	क्रम (i = 0; i < 2; i++) अणु
		काष्ठा ireg_field *sge_pio = &ch_sge_dbg->tp_pio;
		u32 *buff = ch_sge_dbg->outbuf;

		sge_pio->ireg_addr = t5_sge_dbg_index_array[i][0];
		sge_pio->ireg_data = t5_sge_dbg_index_array[i][1];
		sge_pio->ireg_local_offset = t5_sge_dbg_index_array[i][2];
		sge_pio->ireg_offset_range = t5_sge_dbg_index_array[i][3];
		t4_पढ़ो_indirect(padap,
				 sge_pio->ireg_addr,
				 sge_pio->ireg_data,
				 buff,
				 sge_pio->ireg_offset_range,
				 sge_pio->ireg_local_offset);
		ch_sge_dbg++;
	पूर्ण

	अगर (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5 &&
	    !padap_running) अणु
		sge_qbase = (काष्ठा sge_qbase_reg_field *)ch_sge_dbg;
		/* 1 addr reg SGE_QBASE_INDEX and 4 data reg
		 * SGE_QBASE_MAP[0-3]
		 */
		sge_qbase->reg_addr = t6_sge_qbase_index_array[0];
		क्रम (i = 0; i < SGE_QBASE_DATA_REG_NUM; i++)
			sge_qbase->reg_data[i] =
				t6_sge_qbase_index_array[i + 1];

		क्रम (i = 0; i <= PCIE_FW_MASTER_M; i++)
			cudbg_पढ़ो_sge_qbase_indirect_reg(padap, sge_qbase,
							  i, true);

		क्रम (i = 0; i < padap->params.arch.vfcount; i++)
			cudbg_पढ़ो_sge_qbase_indirect_reg(padap, sge_qbase,
							  i, false);

		sge_qbase->vfcount = padap->params.arch.vfcount;
	पूर्ण

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_ulprx_la(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_ulprx_la *ulprx_la_buff;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_ulprx_la),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	ulprx_la_buff = (काष्ठा cudbg_ulprx_la *)temp_buff.data;
	t4_ulprx_पढ़ो_la(padap, (u32 *)ulprx_la_buff->data);
	ulprx_la_buff->size = ULPRX_LA_SIZE;
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_tp_la(काष्ठा cudbg_init *pdbg_init,
			काष्ठा cudbg_buffer *dbg_buff,
			काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_tp_la *tp_la_buff;
	पूर्णांक size, rc;

	size = माप(काष्ठा cudbg_tp_la) + TPLA_SIZE *  माप(u64);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	tp_la_buff = (काष्ठा cudbg_tp_la *)temp_buff.data;
	tp_la_buff->mode = DBGLAMODE_G(t4_पढ़ो_reg(padap, TP_DBG_LA_CONFIG_A));
	t4_tp_पढ़ो_la(padap, (u64 *)tp_la_buff->data, शून्य);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_meminfo(काष्ठा cudbg_init *pdbg_init,
			  काष्ठा cudbg_buffer *dbg_buff,
			  काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_meminfo *meminfo_buff;
	काष्ठा cudbg_ver_hdr *ver_hdr;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff,
			    माप(काष्ठा cudbg_ver_hdr) +
			    माप(काष्ठा cudbg_meminfo),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	ver_hdr = (काष्ठा cudbg_ver_hdr *)temp_buff.data;
	ver_hdr->signature = CUDBG_ENTITY_SIGNATURE;
	ver_hdr->revision = CUDBG_MEMINFO_REV;
	ver_hdr->size = माप(काष्ठा cudbg_meminfo);

	meminfo_buff = (काष्ठा cudbg_meminfo *)(temp_buff.data +
						माप(*ver_hdr));
	rc = cudbg_fill_meminfo(padap, meminfo_buff);
	अगर (rc) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cim_pअगर_la(काष्ठा cudbg_init *pdbg_init,
			     काष्ठा cudbg_buffer *dbg_buff,
			     काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा cudbg_cim_pअगर_la *cim_pअगर_la_buff;
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	पूर्णांक size, rc;

	size = माप(काष्ठा cudbg_cim_pअगर_la) +
	       2 * CIM_PIFLA_SIZE * 6 * माप(u32);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	cim_pअगर_la_buff = (काष्ठा cudbg_cim_pअगर_la *)temp_buff.data;
	cim_pअगर_la_buff->size = CIM_PIFLA_SIZE;
	t4_cim_पढ़ो_pअगर_la(padap, (u32 *)cim_pअगर_la_buff->data,
			   (u32 *)cim_pअगर_la_buff->data + 6 * CIM_PIFLA_SIZE,
			   शून्य, शून्य);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_clk_info(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_clk_info *clk_info_buff;
	u64 tp_tick_us;
	पूर्णांक rc;

	अगर (!padap->params.vpd.cclk)
		वापस CUDBG_STATUS_CCLK_NOT_DEFINED;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_clk_info),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	clk_info_buff = (काष्ठा cudbg_clk_info *)temp_buff.data;
	clk_info_buff->cclk_ps = 1000000000 / padap->params.vpd.cclk; /* psec */
	clk_info_buff->res = t4_पढ़ो_reg(padap, TP_TIMER_RESOLUTION_A);
	clk_info_buff->tre = TIMERRESOLUTION_G(clk_info_buff->res);
	clk_info_buff->dack_re = DELAYEDACKRESOLUTION_G(clk_info_buff->res);
	tp_tick_us = (clk_info_buff->cclk_ps << clk_info_buff->tre) / 1000000;

	clk_info_buff->dack_समयr =
		(clk_info_buff->cclk_ps << clk_info_buff->dack_re) / 1000000 *
		t4_पढ़ो_reg(padap, TP_DACK_TIMER_A);
	clk_info_buff->retransmit_min =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_RXT_MIN_A);
	clk_info_buff->retransmit_max =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_RXT_MAX_A);
	clk_info_buff->persist_समयr_min =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_PERS_MIN_A);
	clk_info_buff->persist_समयr_max =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_PERS_MAX_A);
	clk_info_buff->keepalive_idle_समयr =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_KEEP_IDLE_A);
	clk_info_buff->keepalive_पूर्णांकerval =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_KEEP_INTVL_A);
	clk_info_buff->initial_srtt =
		tp_tick_us * INITSRTT_G(t4_पढ़ो_reg(padap, TP_INIT_SRTT_A));
	clk_info_buff->finरुको2_समयr =
		tp_tick_us * t4_पढ़ो_reg(padap, TP_FINWAIT2_TIMER_A);

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_pcie_indirect(काष्ठा cudbg_init *pdbg_init,
				काष्ठा cudbg_buffer *dbg_buff,
				काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा ireg_buf *ch_pcie;
	पूर्णांक i, rc, n;
	u32 size;

	n = माप(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * माप(u32));
	size = माप(काष्ठा ireg_buf) * n * 2;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	ch_pcie = (काष्ठा ireg_buf *)temp_buff.data;
	/* PCIE_PDBG */
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *pcie_pio = &ch_pcie->tp_pio;
		u32 *buff = ch_pcie->outbuf;

		pcie_pio->ireg_addr = t5_pcie_pdbg_array[i][0];
		pcie_pio->ireg_data = t5_pcie_pdbg_array[i][1];
		pcie_pio->ireg_local_offset = t5_pcie_pdbg_array[i][2];
		pcie_pio->ireg_offset_range = t5_pcie_pdbg_array[i][3];
		t4_पढ़ो_indirect(padap,
				 pcie_pio->ireg_addr,
				 pcie_pio->ireg_data,
				 buff,
				 pcie_pio->ireg_offset_range,
				 pcie_pio->ireg_local_offset);
		ch_pcie++;
	पूर्ण

	/* PCIE_CDBG */
	n = माप(t5_pcie_cdbg_array) / (IREG_NUM_ELEM * माप(u32));
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *pcie_pio = &ch_pcie->tp_pio;
		u32 *buff = ch_pcie->outbuf;

		pcie_pio->ireg_addr = t5_pcie_cdbg_array[i][0];
		pcie_pio->ireg_data = t5_pcie_cdbg_array[i][1];
		pcie_pio->ireg_local_offset = t5_pcie_cdbg_array[i][2];
		pcie_pio->ireg_offset_range = t5_pcie_cdbg_array[i][3];
		t4_पढ़ो_indirect(padap,
				 pcie_pio->ireg_addr,
				 pcie_pio->ireg_data,
				 buff,
				 pcie_pio->ireg_offset_range,
				 pcie_pio->ireg_local_offset);
		ch_pcie++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_pm_indirect(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा ireg_buf *ch_pm;
	पूर्णांक i, rc, n;
	u32 size;

	n = माप(t5_pm_rx_array) / (IREG_NUM_ELEM * माप(u32));
	size = माप(काष्ठा ireg_buf) * n * 2;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	ch_pm = (काष्ठा ireg_buf *)temp_buff.data;
	/* PM_RX */
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *pm_pio = &ch_pm->tp_pio;
		u32 *buff = ch_pm->outbuf;

		pm_pio->ireg_addr = t5_pm_rx_array[i][0];
		pm_pio->ireg_data = t5_pm_rx_array[i][1];
		pm_pio->ireg_local_offset = t5_pm_rx_array[i][2];
		pm_pio->ireg_offset_range = t5_pm_rx_array[i][3];
		t4_पढ़ो_indirect(padap,
				 pm_pio->ireg_addr,
				 pm_pio->ireg_data,
				 buff,
				 pm_pio->ireg_offset_range,
				 pm_pio->ireg_local_offset);
		ch_pm++;
	पूर्ण

	/* PM_TX */
	n = माप(t5_pm_tx_array) / (IREG_NUM_ELEM * माप(u32));
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *pm_pio = &ch_pm->tp_pio;
		u32 *buff = ch_pm->outbuf;

		pm_pio->ireg_addr = t5_pm_tx_array[i][0];
		pm_pio->ireg_data = t5_pm_tx_array[i][1];
		pm_pio->ireg_local_offset = t5_pm_tx_array[i][2];
		pm_pio->ireg_offset_range = t5_pm_tx_array[i][3];
		t4_पढ़ो_indirect(padap,
				 pm_pio->ireg_addr,
				 pm_pio->ireg_data,
				 buff,
				 pm_pio->ireg_offset_range,
				 pm_pio->ireg_local_offset);
		ch_pm++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_tid(काष्ठा cudbg_init *pdbg_init,
		      काष्ठा cudbg_buffer *dbg_buff,
		      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_tid_info_region_rev1 *tid1;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_tid_info_region *tid;
	u32 para[2], val[2];
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff,
			    माप(काष्ठा cudbg_tid_info_region_rev1),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	tid1 = (काष्ठा cudbg_tid_info_region_rev1 *)temp_buff.data;
	tid = &tid1->tid;
	tid1->ver_hdr.signature = CUDBG_ENTITY_SIGNATURE;
	tid1->ver_hdr.revision = CUDBG_TID_INFO_REV;
	tid1->ver_hdr.size = माप(काष्ठा cudbg_tid_info_region_rev1) -
			     माप(काष्ठा cudbg_ver_hdr);

	/* If firmware is not attached/alive, use backकरोor रेजिस्टर
	 * access to collect dump.
	 */
	अगर (!is_fw_attached(pdbg_init))
		जाओ fill_tid;

#घोषणा FW_PARAM_PFVF_A(param) \
	(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) | \
	 FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_##param) | \
	 FW_PARAMS_PARAM_Y_V(0) | \
	 FW_PARAMS_PARAM_Z_V(0))

	para[0] = FW_PARAM_PFVF_A(ETHOFLD_START);
	para[1] = FW_PARAM_PFVF_A(ETHOFLD_END);
	rc = t4_query_params(padap, padap->mbox, padap->pf, 0, 2, para, val);
	अगर (rc <  0) अणु
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	tid->uotid_base = val[0];
	tid->nuotids = val[1] - val[0] + 1;

	अगर (is_t5(padap->params.chip)) अणु
		tid->sb = t4_पढ़ो_reg(padap, LE_DB_SERVER_INDEX_A) / 4;
	पूर्ण अन्यथा अगर (is_t6(padap->params.chip)) अणु
		tid1->tid_start =
			t4_पढ़ो_reg(padap, LE_DB_ACTIVE_TABLE_START_INDEX_A);
		tid->sb = t4_पढ़ो_reg(padap, LE_DB_SRVR_START_INDEX_A);

		para[0] = FW_PARAM_PFVF_A(HPFILTER_START);
		para[1] = FW_PARAM_PFVF_A(HPFILTER_END);
		rc = t4_query_params(padap, padap->mbox, padap->pf, 0, 2,
				     para, val);
		अगर (rc < 0) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
		tid->hpftid_base = val[0];
		tid->nhpftids = val[1] - val[0] + 1;
	पूर्ण

#अघोषित FW_PARAM_PFVF_A

fill_tid:
	tid->ntids = padap->tids.ntids;
	tid->nstids = padap->tids.nstids;
	tid->stid_base = padap->tids.stid_base;
	tid->hash_base = padap->tids.hash_base;

	tid->natids = padap->tids.natids;
	tid->nftids = padap->tids.nftids;
	tid->ftid_base = padap->tids.ftid_base;
	tid->aftid_base = padap->tids.aftid_base;
	tid->aftid_end = padap->tids.aftid_end;

	tid->sftid_base = padap->tids.sftid_base;
	tid->nsftids = padap->tids.nsftids;

	tid->flags = padap->flags;
	tid->le_db_conf = t4_पढ़ो_reg(padap, LE_DB_CONFIG_A);
	tid->ip_users = t4_पढ़ो_reg(padap, LE_DB_ACT_CNT_IPV4_A);
	tid->ipv6_users = t4_पढ़ो_reg(padap, LE_DB_ACT_CNT_IPV6_A);

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_pcie_config(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	u32 size, *value, j;
	पूर्णांक i, rc, n;

	size = माप(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;
	n = माप(t5_pcie_config_array) / (2 * माप(u32));
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	value = (u32 *)temp_buff.data;
	क्रम (i = 0; i < n; i++) अणु
		क्रम (j = t5_pcie_config_array[i][0];
		     j <= t5_pcie_config_array[i][1]; j += 4) अणु
			t4_hw_pci_पढ़ो_cfg4(padap, j, value);
			value++;
		पूर्ण
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

अटल पूर्णांक cudbg_sge_ctxt_check_valid(u32 *buf, पूर्णांक type)
अणु
	पूर्णांक index, bit, bit_pos = 0;

	चयन (type) अणु
	हाल CTXT_EGRESS:
		bit_pos = 176;
		अवरोध;
	हाल CTXT_INGRESS:
		bit_pos = 141;
		अवरोध;
	हाल CTXT_FLM:
		bit_pos = 89;
		अवरोध;
	पूर्ण
	index = bit_pos / 32;
	bit =  bit_pos % 32;
	वापस buf[index] & (1U << bit);
पूर्ण

अटल पूर्णांक cudbg_get_ctxt_region_info(काष्ठा adapter *padap,
				      काष्ठा cudbg_region_info *ctx_info,
				      u8 *mem_type)
अणु
	काष्ठा cudbg_mem_desc mem_desc;
	काष्ठा cudbg_meminfo meminfo;
	u32 i, j, value, found;
	u8 flq;
	पूर्णांक rc;

	rc = cudbg_fill_meminfo(padap, &meminfo);
	अगर (rc)
		वापस rc;

	/* Get EGRESS and INGRESS context region size */
	क्रम (i = CTXT_EGRESS; i <= CTXT_INGRESS; i++) अणु
		found = 0;
		स_रखो(&mem_desc, 0, माप(काष्ठा cudbg_mem_desc));
		क्रम (j = 0; j < ARRAY_SIZE(meminfo.avail); j++) अणु
			rc = cudbg_get_mem_region(padap, &meminfo, j,
						  cudbg_region[i],
						  &mem_desc);
			अगर (!rc) अणु
				found = 1;
				rc = cudbg_get_mem_relative(padap, &meminfo, j,
							    &mem_desc.base,
							    &mem_desc.limit);
				अगर (rc) अणु
					ctx_info[i].exist = false;
					अवरोध;
				पूर्ण
				ctx_info[i].exist = true;
				ctx_info[i].start = mem_desc.base;
				ctx_info[i].end = mem_desc.limit;
				mem_type[i] = j;
				अवरोध;
			पूर्ण
		पूर्ण
		अगर (!found)
			ctx_info[i].exist = false;
	पूर्ण

	/* Get FLM and CNM max qid. */
	value = t4_पढ़ो_reg(padap, SGE_FLM_CFG_A);

	/* Get number of data मुक्तlist queues */
	flq = HDRSTARTFLQ_G(value);
	ctx_info[CTXT_FLM].exist = true;
	ctx_info[CTXT_FLM].end = (CUDBG_MAX_FL_QIDS >> flq) * SGE_CTXT_SIZE;

	/* The number of CONM contexts are same as number of मुक्तlist
	 * queues.
	 */
	ctx_info[CTXT_CNM].exist = true;
	ctx_info[CTXT_CNM].end = ctx_info[CTXT_FLM].end;

	वापस 0;
पूर्ण

पूर्णांक cudbg_dump_context_size(काष्ठा adapter *padap)
अणु
	काष्ठा cudbg_region_info region_info[CTXT_CNM + 1] = अणु अणु0पूर्ण पूर्ण;
	u8 mem_type[CTXT_INGRESS + 1] = अणु 0 पूर्ण;
	u32 i, size = 0;
	पूर्णांक rc;

	/* Get max valid qid क्रम each type of queue */
	rc = cudbg_get_ctxt_region_info(padap, region_info, mem_type);
	अगर (rc)
		वापस rc;

	क्रम (i = 0; i < CTXT_CNM; i++) अणु
		अगर (!region_info[i].exist) अणु
			अगर (i == CTXT_EGRESS || i == CTXT_INGRESS)
				size += CUDBG_LOWMEM_MAX_CTXT_QIDS *
					SGE_CTXT_SIZE;
			जारी;
		पूर्ण

		size += (region_info[i].end - region_info[i].start + 1) /
			SGE_CTXT_SIZE;
	पूर्ण
	वापस size * माप(काष्ठा cudbg_ch_cntxt);
पूर्ण

अटल व्योम cudbg_पढ़ो_sge_ctxt(काष्ठा cudbg_init *pdbg_init, u32 cid,
				क्रमागत ctxt_type ctype, u32 *data)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	पूर्णांक rc = -1;

	/* Under heavy traffic, the SGE Queue contexts रेजिस्टरs will be
	 * frequently accessed by firmware.
	 *
	 * To aव्योम conflicts with firmware, always ask firmware to fetch
	 * the SGE Queue contexts via mailbox. On failure, fallback to
	 * accessing hardware रेजिस्टरs directly.
	 */
	अगर (is_fw_attached(pdbg_init))
		rc = t4_sge_ctxt_rd(padap, padap->mbox, cid, ctype, data);
	अगर (rc)
		t4_sge_ctxt_rd_bd(padap, cid, ctype, data);
पूर्ण

अटल व्योम cudbg_get_sge_ctxt_fw(काष्ठा cudbg_init *pdbg_init, u32 max_qid,
				  u8 ctxt_type,
				  काष्ठा cudbg_ch_cntxt **out_buff)
अणु
	काष्ठा cudbg_ch_cntxt *buff = *out_buff;
	पूर्णांक rc;
	u32 j;

	क्रम (j = 0; j < max_qid; j++) अणु
		cudbg_पढ़ो_sge_ctxt(pdbg_init, j, ctxt_type, buff->data);
		rc = cudbg_sge_ctxt_check_valid(buff->data, ctxt_type);
		अगर (!rc)
			जारी;

		buff->cntxt_type = ctxt_type;
		buff->cntxt_id = j;
		buff++;
		अगर (ctxt_type == CTXT_FLM) अणु
			cudbg_पढ़ो_sge_ctxt(pdbg_init, j, CTXT_CNM, buff->data);
			buff->cntxt_type = CTXT_CNM;
			buff->cntxt_id = j;
			buff++;
		पूर्ण
	पूर्ण

	*out_buff = buff;
पूर्ण

पूर्णांक cudbg_collect_dump_context(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा cudbg_region_info region_info[CTXT_CNM + 1] = अणु अणु0पूर्ण पूर्ण;
	काष्ठा adapter *padap = pdbg_init->adap;
	u32 j, size, max_ctx_size, max_ctx_qid;
	u8 mem_type[CTXT_INGRESS + 1] = अणु 0 पूर्ण;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_ch_cntxt *buff;
	u8 *ctx_buf;
	u8 i, k;
	पूर्णांक rc;

	/* Get max valid qid क्रम each type of queue */
	rc = cudbg_get_ctxt_region_info(padap, region_info, mem_type);
	अगर (rc)
		वापस rc;

	rc = cudbg_dump_context_size(padap);
	अगर (rc <= 0)
		वापस CUDBG_STATUS_ENTITY_NOT_FOUND;

	size = rc;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	/* Get buffer with enough space to पढ़ो the biggest context
	 * region in memory.
	 */
	max_ctx_size = max(region_info[CTXT_EGRESS].end -
			   region_info[CTXT_EGRESS].start + 1,
			   region_info[CTXT_INGRESS].end -
			   region_info[CTXT_INGRESS].start + 1);

	ctx_buf = kvzalloc(max_ctx_size, GFP_KERNEL);
	अगर (!ctx_buf) अणु
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस -ENOMEM;
	पूर्ण

	buff = (काष्ठा cudbg_ch_cntxt *)temp_buff.data;

	/* Collect EGRESS and INGRESS context data.
	 * In हाल of failures, fallback to collecting via FW or
	 * backकरोor access.
	 */
	क्रम (i = CTXT_EGRESS; i <= CTXT_INGRESS; i++) अणु
		अगर (!region_info[i].exist) अणु
			max_ctx_qid = CUDBG_LOWMEM_MAX_CTXT_QIDS;
			cudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, i,
					      &buff);
			जारी;
		पूर्ण

		max_ctx_size = region_info[i].end - region_info[i].start + 1;
		max_ctx_qid = max_ctx_size / SGE_CTXT_SIZE;

		/* If firmware is not attached/alive, use backकरोor रेजिस्टर
		 * access to collect dump.
		 */
		अगर (is_fw_attached(pdbg_init)) अणु
			t4_sge_ctxt_flush(padap, padap->mbox, i);

			rc = t4_memory_rw(padap, MEMWIN_NIC, mem_type[i],
					  region_info[i].start, max_ctx_size,
					  (__be32 *)ctx_buf, 1);
		पूर्ण

		अगर (rc || !is_fw_attached(pdbg_init)) अणु
			max_ctx_qid = CUDBG_LOWMEM_MAX_CTXT_QIDS;
			cudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, i,
					      &buff);
			जारी;
		पूर्ण

		क्रम (j = 0; j < max_ctx_qid; j++) अणु
			__be64 *dst_off;
			u64 *src_off;

			src_off = (u64 *)(ctx_buf + j * SGE_CTXT_SIZE);
			dst_off = (__be64 *)buff->data;

			/* The data is stored in 64-bit cpu order.  Convert it
			 * to big endian beक्रमe parsing.
			 */
			क्रम (k = 0; k < SGE_CTXT_SIZE / माप(u64); k++)
				dst_off[k] = cpu_to_be64(src_off[k]);

			rc = cudbg_sge_ctxt_check_valid(buff->data, i);
			अगर (!rc)
				जारी;

			buff->cntxt_type = i;
			buff->cntxt_id = j;
			buff++;
		पूर्ण
	पूर्ण

	kvमुक्त(ctx_buf);

	/* Collect FREELIST and CONGESTION MANAGER contexts */
	max_ctx_size = region_info[CTXT_FLM].end -
		       region_info[CTXT_FLM].start + 1;
	max_ctx_qid = max_ctx_size / SGE_CTXT_SIZE;
	/* Since FLM and CONM are 1-to-1 mapped, the below function
	 * will fetch both FLM and CONM contexts.
	 */
	cudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, CTXT_FLM, &buff);

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

अटल अंतरभूत व्योम cudbg_tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)
अणु
	*mask = x | y;
	y = (__क्रमce u64)cpu_to_be64(y);
	स_नकल(addr, (अक्षर *)&y + 2, ETH_ALEN);
पूर्ण

अटल व्योम cudbg_mps_rpl_backकरोor(काष्ठा adapter *padap,
				   काष्ठा fw_ldst_mps_rplc *mps_rplc)
अणु
	अगर (is_t5(padap->params.chip)) अणु
		mps_rplc->rplc255_224 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP3_A));
		mps_rplc->rplc223_192 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP2_A));
		mps_rplc->rplc191_160 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP1_A));
		mps_rplc->rplc159_128 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP0_A));
	पूर्ण अन्यथा अणु
		mps_rplc->rplc255_224 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP7_A));
		mps_rplc->rplc223_192 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP6_A));
		mps_rplc->rplc191_160 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP5_A));
		mps_rplc->rplc159_128 = htonl(t4_पढ़ो_reg(padap,
							  MPS_VF_RPLCT_MAP4_A));
	पूर्ण
	mps_rplc->rplc127_96 = htonl(t4_पढ़ो_reg(padap, MPS_VF_RPLCT_MAP3_A));
	mps_rplc->rplc95_64 = htonl(t4_पढ़ो_reg(padap, MPS_VF_RPLCT_MAP2_A));
	mps_rplc->rplc63_32 = htonl(t4_पढ़ो_reg(padap, MPS_VF_RPLCT_MAP1_A));
	mps_rplc->rplc31_0 = htonl(t4_पढ़ो_reg(padap, MPS_VF_RPLCT_MAP0_A));
पूर्ण

अटल पूर्णांक cudbg_collect_tcam_index(काष्ठा cudbg_init *pdbg_init,
				    काष्ठा cudbg_mps_tcam *tcam, u32 idx)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	u64 tcamy, tcamx, val;
	u32 ctl, data2;
	पूर्णांक rc = 0;

	अगर (CHELSIO_CHIP_VERSION(padap->params.chip) >= CHELSIO_T6) अणु
		/* CtlReqID   - 1: use Host Driver Requester ID
		 * CtlCmdType - 0: Read, 1: Write
		 * CtlTcamSel - 0: TCAM0, 1: TCAM1
		 * CtlXYBitSel- 0: Y bit, 1: X bit
		 */

		/* Read tcamy */
		ctl = CTLREQID_V(1) | CTLCMDTYPE_V(0) | CTLXYBITSEL_V(0);
		अगर (idx < 256)
			ctl |= CTLTCAMINDEX_V(idx) | CTLTCAMSEL_V(0);
		अन्यथा
			ctl |= CTLTCAMINDEX_V(idx - 256) | CTLTCAMSEL_V(1);

		t4_ग_लिखो_reg(padap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);
		val = t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA1_REQ_ID1_A);
		tcamy = DMACH_G(val) << 32;
		tcamy |= t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA0_REQ_ID1_A);
		data2 = t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA2_REQ_ID1_A);
		tcam->lookup_type = DATALKPTYPE_G(data2);

		/* 0 - Outer header, 1 - Inner header
		 * [71:48] bit locations are overloaded क्रम
		 * outer vs. inner lookup types.
		 */
		अगर (tcam->lookup_type && tcam->lookup_type != DATALKPTYPE_M) अणु
			/* Inner header VNI */
			tcam->vniy = (data2 & DATAVIDH2_F) | DATAVIDH1_G(data2);
			tcam->vniy = (tcam->vniy << 16) | VIDL_G(val);
			tcam->dip_hit = data2 & DATADIPHIT_F;
		पूर्ण अन्यथा अणु
			tcam->vlan_vld = data2 & DATAVIDH2_F;
			tcam->ivlan = VIDL_G(val);
		पूर्ण

		tcam->port_num = DATAPORTNUM_G(data2);

		/* Read tcamx. Change the control param */
		ctl |= CTLXYBITSEL_V(1);
		t4_ग_लिखो_reg(padap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);
		val = t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA1_REQ_ID1_A);
		tcamx = DMACH_G(val) << 32;
		tcamx |= t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA0_REQ_ID1_A);
		data2 = t4_पढ़ो_reg(padap, MPS_CLS_TCAM_RDATA2_REQ_ID1_A);
		अगर (tcam->lookup_type && tcam->lookup_type != DATALKPTYPE_M) अणु
			/* Inner header VNI mask */
			tcam->vnix = (data2 & DATAVIDH2_F) | DATAVIDH1_G(data2);
			tcam->vnix = (tcam->vnix << 16) | VIDL_G(val);
		पूर्ण
	पूर्ण अन्यथा अणु
		tcamy = t4_पढ़ो_reg64(padap, MPS_CLS_TCAM_Y_L(idx));
		tcamx = t4_पढ़ो_reg64(padap, MPS_CLS_TCAM_X_L(idx));
	पूर्ण

	/* If no entry, वापस */
	अगर (tcamx & tcamy)
		वापस rc;

	tcam->cls_lo = t4_पढ़ो_reg(padap, MPS_CLS_SRAM_L(idx));
	tcam->cls_hi = t4_पढ़ो_reg(padap, MPS_CLS_SRAM_H(idx));

	अगर (is_t5(padap->params.chip))
		tcam->repli = (tcam->cls_lo & REPLICATE_F);
	अन्यथा अगर (is_t6(padap->params.chip))
		tcam->repli = (tcam->cls_lo & T6_REPLICATE_F);

	अगर (tcam->repli) अणु
		काष्ठा fw_ldst_cmd ldst_cmd;
		काष्ठा fw_ldst_mps_rplc mps_rplc;

		स_रखो(&ldst_cmd, 0, माप(ldst_cmd));
		ldst_cmd.op_to_addrspace =
			htonl(FW_CMD_OP_V(FW_LDST_CMD) |
			      FW_CMD_REQUEST_F | FW_CMD_READ_F |
			      FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MPS));
		ldst_cmd.cycles_to_len16 = htonl(FW_LEN16(ldst_cmd));
		ldst_cmd.u.mps.rplc.fid_idx =
			htons(FW_LDST_CMD_FID_V(FW_LDST_MPS_RPLC) |
			      FW_LDST_CMD_IDX_V(idx));

		/* If firmware is not attached/alive, use backकरोor रेजिस्टर
		 * access to collect dump.
		 */
		अगर (is_fw_attached(pdbg_init))
			rc = t4_wr_mbox(padap, padap->mbox, &ldst_cmd,
					माप(ldst_cmd), &ldst_cmd);

		अगर (rc || !is_fw_attached(pdbg_init)) अणु
			cudbg_mps_rpl_backकरोor(padap, &mps_rplc);
			/* Ignore error since we collected directly from
			 * पढ़ोing रेजिस्टरs.
			 */
			rc = 0;
		पूर्ण अन्यथा अणु
			mps_rplc = ldst_cmd.u.mps.rplc;
		पूर्ण

		tcam->rplc[0] = ntohl(mps_rplc.rplc31_0);
		tcam->rplc[1] = ntohl(mps_rplc.rplc63_32);
		tcam->rplc[2] = ntohl(mps_rplc.rplc95_64);
		tcam->rplc[3] = ntohl(mps_rplc.rplc127_96);
		अगर (padap->params.arch.mps_rplc_size > CUDBG_MAX_RPLC_SIZE) अणु
			tcam->rplc[4] = ntohl(mps_rplc.rplc159_128);
			tcam->rplc[5] = ntohl(mps_rplc.rplc191_160);
			tcam->rplc[6] = ntohl(mps_rplc.rplc223_192);
			tcam->rplc[7] = ntohl(mps_rplc.rplc255_224);
		पूर्ण
	पूर्ण
	cudbg_tcamxy2valmask(tcamx, tcamy, tcam->addr, &tcam->mask);
	tcam->idx = idx;
	tcam->rplc_size = padap->params.arch.mps_rplc_size;
	वापस rc;
पूर्ण

पूर्णांक cudbg_collect_mps_tcam(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	u32 size = 0, i, n, total_size = 0;
	काष्ठा cudbg_mps_tcam *tcam;
	पूर्णांक rc;

	n = padap->params.arch.mps_tcam_size;
	size = माप(काष्ठा cudbg_mps_tcam) * n;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	tcam = (काष्ठा cudbg_mps_tcam *)temp_buff.data;
	क्रम (i = 0; i < n; i++) अणु
		rc = cudbg_collect_tcam_index(pdbg_init, tcam, i);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
		total_size += माप(काष्ठा cudbg_mps_tcam);
		tcam++;
	पूर्ण

	अगर (!total_size) अणु
		rc = CUDBG_SYSTEM_ERROR;
		cudbg_err->sys_err = rc;
		cudbg_put_buff(pdbg_init, &temp_buff);
		वापस rc;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_vpd_data(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	अक्षर vpd_str[CUDBG_VPD_VER_LEN + 1];
	काष्ठा cudbg_vpd_data *vpd_data;
	काष्ठा vpd_params vpd = अणु 0 पूर्ण;
	u32 vpd_vers, fw_vers;
	पूर्णांक rc;

	rc = t4_get_raw_vpd_params(padap, &vpd);
	अगर (rc)
		वापस rc;

	rc = t4_get_fw_version(padap, &fw_vers);
	अगर (rc)
		वापस rc;

	rc = cudbg_पढ़ो_vpd_reg(padap, CUDBG_VPD_VER_ADDR, CUDBG_VPD_VER_LEN,
				vpd_str);
	अगर (rc)
		वापस rc;

	vpd_str[CUDBG_VPD_VER_LEN] = '\0';
	rc = kstrtouपूर्णांक(vpd_str, 0, &vpd_vers);
	अगर (rc)
		वापस rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff, माप(काष्ठा cudbg_vpd_data),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	vpd_data = (काष्ठा cudbg_vpd_data *)temp_buff.data;
	स_नकल(vpd_data->sn, vpd.sn, SERNUM_LEN + 1);
	स_नकल(vpd_data->bn, vpd.pn, PN_LEN + 1);
	स_नकल(vpd_data->na, vpd.na, MACADDR_LEN + 1);
	स_नकल(vpd_data->mn, vpd.id, ID_LEN + 1);
	vpd_data->scfg_vers = t4_पढ़ो_reg(padap, PCIE_STATIC_SPARE2_A);
	vpd_data->vpd_vers = vpd_vers;
	vpd_data->fw_major = FW_HDR_FW_VER_MAJOR_G(fw_vers);
	vpd_data->fw_minor = FW_HDR_FW_VER_MINOR_G(fw_vers);
	vpd_data->fw_micro = FW_HDR_FW_VER_MICRO_G(fw_vers);
	vpd_data->fw_build = FW_HDR_FW_VER_BUILD_G(fw_vers);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

अटल पूर्णांक cudbg_पढ़ो_tid(काष्ठा cudbg_init *pdbg_init, u32 tid,
			  काष्ठा cudbg_tid_data *tid_data)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	पूर्णांक i, cmd_retry = 8;
	u32 val;

	/* Fill REQ_DATA regs with 0's */
	क्रम (i = 0; i < NUM_LE_DB_DBGI_REQ_DATA_INSTANCES; i++)
		t4_ग_लिखो_reg(padap, LE_DB_DBGI_REQ_DATA_A + (i << 2), 0);

	/* Write DBIG command */
	val = DBGICMD_V(4) | DBGITID_V(tid);
	t4_ग_लिखो_reg(padap, LE_DB_DBGI_REQ_TCAM_CMD_A, val);
	tid_data->dbig_cmd = val;

	val = DBGICMDSTRT_F | DBGICMDMODE_V(1); /* LE mode */
	t4_ग_लिखो_reg(padap, LE_DB_DBGI_CONFIG_A, val);
	tid_data->dbig_conf = val;

	/* Poll the DBGICMDBUSY bit */
	val = 1;
	जबतक (val) अणु
		val = t4_पढ़ो_reg(padap, LE_DB_DBGI_CONFIG_A);
		val = val & DBGICMDBUSY_F;
		cmd_retry--;
		अगर (!cmd_retry)
			वापस CUDBG_SYSTEM_ERROR;
	पूर्ण

	/* Check RESP status */
	val = t4_पढ़ो_reg(padap, LE_DB_DBGI_RSP_STATUS_A);
	tid_data->dbig_rsp_stat = val;
	अगर (!(val & 1))
		वापस CUDBG_SYSTEM_ERROR;

	/* Read RESP data */
	क्रम (i = 0; i < NUM_LE_DB_DBGI_RSP_DATA_INSTANCES; i++)
		tid_data->data[i] = t4_पढ़ो_reg(padap,
						LE_DB_DBGI_RSP_DATA_A +
						(i << 2));
	tid_data->tid = tid;
	वापस 0;
पूर्ण

अटल पूर्णांक cudbg_get_le_type(u32 tid, काष्ठा cudbg_tcam tcam_region)
अणु
	पूर्णांक type = LE_ET_UNKNOWN;

	अगर (tid < tcam_region.server_start)
		type = LE_ET_TCAM_CON;
	अन्यथा अगर (tid < tcam_region.filter_start)
		type = LE_ET_TCAM_SERVER;
	अन्यथा अगर (tid < tcam_region.clip_start)
		type = LE_ET_TCAM_FILTER;
	अन्यथा अगर (tid < tcam_region.routing_start)
		type = LE_ET_TCAM_CLIP;
	अन्यथा अगर (tid < tcam_region.tid_hash_base)
		type = LE_ET_TCAM_ROUTING;
	अन्यथा अगर (tid < tcam_region.max_tid)
		type = LE_ET_HASH_CON;
	अन्यथा
		type = LE_ET_INVALID_TID;

	वापस type;
पूर्ण

अटल पूर्णांक cudbg_is_ipv6_entry(काष्ठा cudbg_tid_data *tid_data,
			       काष्ठा cudbg_tcam tcam_region)
अणु
	पूर्णांक ipv6 = 0;
	पूर्णांक le_type;

	le_type = cudbg_get_le_type(tid_data->tid, tcam_region);
	अगर (tid_data->tid & 1)
		वापस 0;

	अगर (le_type == LE_ET_HASH_CON) अणु
		ipv6 = tid_data->data[16] & 0x8000;
	पूर्ण अन्यथा अगर (le_type == LE_ET_TCAM_CON) अणु
		ipv6 = tid_data->data[16] & 0x8000;
		अगर (ipv6)
			ipv6 = tid_data->data[9] == 0x00C00000;
	पूर्ण अन्यथा अणु
		ipv6 = 0;
	पूर्ण
	वापस ipv6;
पूर्ण

व्योम cudbg_fill_le_tcam_info(काष्ठा adapter *padap,
			     काष्ठा cudbg_tcam *tcam_region)
अणु
	u32 value;

	/* Get the LE regions */
	value = t4_पढ़ो_reg(padap, LE_DB_TID_HASHBASE_A); /* hash base index */
	tcam_region->tid_hash_base = value;

	/* Get routing table index */
	value = t4_पढ़ो_reg(padap, LE_DB_ROUTING_TABLE_INDEX_A);
	tcam_region->routing_start = value;

	/* Get clip table index. For T6 there is separate CLIP TCAM */
	अगर (is_t6(padap->params.chip))
		value = t4_पढ़ो_reg(padap, LE_DB_CLCAM_TID_BASE_A);
	अन्यथा
		value = t4_पढ़ो_reg(padap, LE_DB_CLIP_TABLE_INDEX_A);
	tcam_region->clip_start = value;

	/* Get filter table index */
	value = t4_पढ़ो_reg(padap, LE_DB_FILTER_TABLE_INDEX_A);
	tcam_region->filter_start = value;

	/* Get server table index */
	value = t4_पढ़ो_reg(padap, LE_DB_SERVER_INDEX_A);
	tcam_region->server_start = value;

	/* Check whether hash is enabled and calculate the max tids */
	value = t4_पढ़ो_reg(padap, LE_DB_CONFIG_A);
	अगर ((value >> HASHEN_S) & 1) अणु
		value = t4_पढ़ो_reg(padap, LE_DB_HASH_CONFIG_A);
		अगर (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5) अणु
			tcam_region->max_tid = (value & 0xFFFFF) +
					       tcam_region->tid_hash_base;
		पूर्ण अन्यथा अणु
			value = HASHTIDSIZE_G(value);
			value = 1 << value;
			tcam_region->max_tid = value +
					       tcam_region->tid_hash_base;
		पूर्ण
	पूर्ण अन्यथा अणु /* hash not enabled */
		अगर (is_t6(padap->params.chip))
			tcam_region->max_tid = (value & ASLIPCOMPEN_F) ?
					       CUDBG_MAX_TID_COMP_EN :
					       CUDBG_MAX_TID_COMP_DIS;
		अन्यथा
			tcam_region->max_tid = CUDBG_MAX_TCAM_TID;
	पूर्ण

	अगर (is_t6(padap->params.chip))
		tcam_region->max_tid += CUDBG_T6_CLIP;
पूर्ण

पूर्णांक cudbg_collect_le_tcam(काष्ठा cudbg_init *pdbg_init,
			  काष्ठा cudbg_buffer *dbg_buff,
			  काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_tcam tcam_region = अणु 0 पूर्ण;
	काष्ठा cudbg_tid_data *tid_data;
	u32 bytes = 0;
	पूर्णांक rc, size;
	u32 i;

	cudbg_fill_le_tcam_info(padap, &tcam_region);

	size = माप(काष्ठा cudbg_tid_data) * tcam_region.max_tid;
	size += माप(काष्ठा cudbg_tcam);
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	स_नकल(temp_buff.data, &tcam_region, माप(काष्ठा cudbg_tcam));
	bytes = माप(काष्ठा cudbg_tcam);
	tid_data = (काष्ठा cudbg_tid_data *)(temp_buff.data + bytes);
	/* पढ़ो all tid */
	क्रम (i = 0; i < tcam_region.max_tid; ) अणु
		rc = cudbg_पढ़ो_tid(pdbg_init, i, tid_data);
		अगर (rc) अणु
			cudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;
			/* Update tcam header and निकास */
			tcam_region.max_tid = i;
			स_नकल(temp_buff.data, &tcam_region,
			       माप(काष्ठा cudbg_tcam));
			जाओ out;
		पूर्ण

		अगर (cudbg_is_ipv6_entry(tid_data, tcam_region)) अणु
			/* T6 CLIP TCAM: ipv6 takes 4 entries */
			अगर (is_t6(padap->params.chip) &&
			    i >= tcam_region.clip_start &&
			    i < tcam_region.clip_start + CUDBG_T6_CLIP)
				i += 4;
			अन्यथा /* Main TCAM: ipv6 takes two tids */
				i += 2;
		पूर्ण अन्यथा अणु
			i++;
		पूर्ण

		tid_data++;
		bytes += माप(काष्ठा cudbg_tid_data);
	पूर्ण

out:
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_cctrl(काष्ठा cudbg_init *pdbg_init,
			काष्ठा cudbg_buffer *dbg_buff,
			काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	u32 size;
	पूर्णांक rc;

	size = माप(u16) * NMTUS * NCCTRL_WIN;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	t4_पढ़ो_cong_tbl(padap, (व्योम *)temp_buff.data);
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_ma_indirect(काष्ठा cudbg_init *pdbg_init,
			      काष्ठा cudbg_buffer *dbg_buff,
			      काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा ireg_buf *ma_indr;
	पूर्णांक i, rc, n;
	u32 size, j;

	अगर (CHELSIO_CHIP_VERSION(padap->params.chip) < CHELSIO_T6)
		वापस CUDBG_STATUS_ENTITY_NOT_FOUND;

	n = माप(t6_ma_ireg_array) / (IREG_NUM_ELEM * माप(u32));
	size = माप(काष्ठा ireg_buf) * n * 2;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	ma_indr = (काष्ठा ireg_buf *)temp_buff.data;
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *ma_fli = &ma_indr->tp_pio;
		u32 *buff = ma_indr->outbuf;

		ma_fli->ireg_addr = t6_ma_ireg_array[i][0];
		ma_fli->ireg_data = t6_ma_ireg_array[i][1];
		ma_fli->ireg_local_offset = t6_ma_ireg_array[i][2];
		ma_fli->ireg_offset_range = t6_ma_ireg_array[i][3];
		t4_पढ़ो_indirect(padap, ma_fli->ireg_addr, ma_fli->ireg_data,
				 buff, ma_fli->ireg_offset_range,
				 ma_fli->ireg_local_offset);
		ma_indr++;
	पूर्ण

	n = माप(t6_ma_ireg_array2) / (IREG_NUM_ELEM * माप(u32));
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *ma_fli = &ma_indr->tp_pio;
		u32 *buff = ma_indr->outbuf;

		ma_fli->ireg_addr = t6_ma_ireg_array2[i][0];
		ma_fli->ireg_data = t6_ma_ireg_array2[i][1];
		ma_fli->ireg_local_offset = t6_ma_ireg_array2[i][2];
		क्रम (j = 0; j < t6_ma_ireg_array2[i][3]; j++) अणु
			t4_पढ़ो_indirect(padap, ma_fli->ireg_addr,
					 ma_fli->ireg_data, buff, 1,
					 ma_fli->ireg_local_offset);
			buff++;
			ma_fli->ireg_local_offset += 0x20;
		पूर्ण
		ma_indr++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_ulptx_la(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_ulptx_la *ulptx_la_buff;
	काष्ठा cudbg_ver_hdr *ver_hdr;
	u32 i, j;
	पूर्णांक rc;

	rc = cudbg_get_buff(pdbg_init, dbg_buff,
			    माप(काष्ठा cudbg_ver_hdr) +
			    माप(काष्ठा cudbg_ulptx_la),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	ver_hdr = (काष्ठा cudbg_ver_hdr *)temp_buff.data;
	ver_hdr->signature = CUDBG_ENTITY_SIGNATURE;
	ver_hdr->revision = CUDBG_ULPTX_LA_REV;
	ver_hdr->size = माप(काष्ठा cudbg_ulptx_la);

	ulptx_la_buff = (काष्ठा cudbg_ulptx_la *)(temp_buff.data +
						  माप(*ver_hdr));
	क्रम (i = 0; i < CUDBG_NUM_ULPTX; i++) अणु
		ulptx_la_buff->rdptr[i] = t4_पढ़ो_reg(padap,
						      ULP_TX_LA_RDPTR_0_A +
						      0x10 * i);
		ulptx_la_buff->wrptr[i] = t4_पढ़ो_reg(padap,
						      ULP_TX_LA_WRPTR_0_A +
						      0x10 * i);
		ulptx_la_buff->rddata[i] = t4_पढ़ो_reg(padap,
						       ULP_TX_LA_RDDATA_0_A +
						       0x10 * i);
		क्रम (j = 0; j < CUDBG_NUM_ULPTX_READ; j++)
			ulptx_la_buff->rd_data[i][j] =
				t4_पढ़ो_reg(padap,
					    ULP_TX_LA_RDDATA_0_A + 0x10 * i);
	पूर्ण

	क्रम (i = 0; i < CUDBG_NUM_ULPTX_ASIC_READ; i++) अणु
		t4_ग_लिखो_reg(padap, ULP_TX_ASIC_DEBUG_CTRL_A, 0x1);
		ulptx_la_buff->rdptr_asic[i] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_CTRL_A);
		ulptx_la_buff->rddata_asic[i][0] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_0_A);
		ulptx_la_buff->rddata_asic[i][1] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_1_A);
		ulptx_la_buff->rddata_asic[i][2] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_2_A);
		ulptx_la_buff->rddata_asic[i][3] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_3_A);
		ulptx_la_buff->rddata_asic[i][4] =
				t4_पढ़ो_reg(padap, ULP_TX_ASIC_DEBUG_4_A);
		ulptx_la_buff->rddata_asic[i][5] =
				t4_पढ़ो_reg(padap, PM_RX_BASE_ADDR);
	पूर्ण

	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_up_cim_indirect(काष्ठा cudbg_init *pdbg_init,
				  काष्ठा cudbg_buffer *dbg_buff,
				  काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	u32 local_offset, local_range;
	काष्ठा ireg_buf *up_cim;
	u32 size, j, iter;
	u32 instance = 0;
	पूर्णांक i, rc, n;

	अगर (is_t5(padap->params.chip))
		n = माप(t5_up_cim_reg_array) /
		    ((IREG_NUM_ELEM + 1) * माप(u32));
	अन्यथा अगर (is_t6(padap->params.chip))
		n = माप(t6_up_cim_reg_array) /
		    ((IREG_NUM_ELEM + 1) * माप(u32));
	अन्यथा
		वापस CUDBG_STATUS_NOT_IMPLEMENTED;

	size = माप(काष्ठा ireg_buf) * n;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	up_cim = (काष्ठा ireg_buf *)temp_buff.data;
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *up_cim_reg = &up_cim->tp_pio;
		u32 *buff = up_cim->outbuf;

		अगर (is_t5(padap->params.chip)) अणु
			up_cim_reg->ireg_addr = t5_up_cim_reg_array[i][0];
			up_cim_reg->ireg_data = t5_up_cim_reg_array[i][1];
			up_cim_reg->ireg_local_offset =
						t5_up_cim_reg_array[i][2];
			up_cim_reg->ireg_offset_range =
						t5_up_cim_reg_array[i][3];
			instance = t5_up_cim_reg_array[i][4];
		पूर्ण अन्यथा अगर (is_t6(padap->params.chip)) अणु
			up_cim_reg->ireg_addr = t6_up_cim_reg_array[i][0];
			up_cim_reg->ireg_data = t6_up_cim_reg_array[i][1];
			up_cim_reg->ireg_local_offset =
						t6_up_cim_reg_array[i][2];
			up_cim_reg->ireg_offset_range =
						t6_up_cim_reg_array[i][3];
			instance = t6_up_cim_reg_array[i][4];
		पूर्ण

		चयन (instance) अणु
		हाल NUM_CIM_CTL_TSCH_CHANNEL_INSTANCES:
			iter = up_cim_reg->ireg_offset_range;
			local_offset = 0x120;
			local_range = 1;
			अवरोध;
		हाल NUM_CIM_CTL_TSCH_CHANNEL_TSCH_CLASS_INSTANCES:
			iter = up_cim_reg->ireg_offset_range;
			local_offset = 0x10;
			local_range = 1;
			अवरोध;
		शेष:
			iter = 1;
			local_offset = 0;
			local_range = up_cim_reg->ireg_offset_range;
			अवरोध;
		पूर्ण

		क्रम (j = 0; j < iter; j++, buff++) अणु
			rc = t4_cim_पढ़ो(padap,
					 up_cim_reg->ireg_local_offset +
					 (j * local_offset), local_range, buff);
			अगर (rc) अणु
				cudbg_put_buff(pdbg_init, &temp_buff);
				वापस rc;
			पूर्ण
		पूर्ण
		up_cim++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_pbt_tables(काष्ठा cudbg_init *pdbg_init,
			     काष्ठा cudbg_buffer *dbg_buff,
			     काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_pbt_tables *pbt;
	पूर्णांक i, rc;
	u32 addr;

	rc = cudbg_get_buff(pdbg_init, dbg_buff,
			    माप(काष्ठा cudbg_pbt_tables),
			    &temp_buff);
	अगर (rc)
		वापस rc;

	pbt = (काष्ठा cudbg_pbt_tables *)temp_buff.data;
	/* PBT dynamic entries */
	addr = CUDBG_CHAC_PBT_ADDR;
	क्रम (i = 0; i < CUDBG_PBT_DYNAMIC_ENTRIES; i++) अणु
		rc = t4_cim_पढ़ो(padap, addr + (i * 4), 1,
				 &pbt->pbt_dynamic[i]);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण

	/* PBT अटल entries */
	/* अटल entries start when bit 6 is set */
	addr = CUDBG_CHAC_PBT_ADDR + (1 << 6);
	क्रम (i = 0; i < CUDBG_PBT_STATIC_ENTRIES; i++) अणु
		rc = t4_cim_पढ़ो(padap, addr + (i * 4), 1,
				 &pbt->pbt_अटल[i]);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण

	/* LRF entries */
	addr = CUDBG_CHAC_PBT_LRF;
	क्रम (i = 0; i < CUDBG_LRF_ENTRIES; i++) अणु
		rc = t4_cim_पढ़ो(padap, addr + (i * 4), 1,
				 &pbt->lrf_table[i]);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण

	/* PBT data entries */
	addr = CUDBG_CHAC_PBT_DATA;
	क्रम (i = 0; i < CUDBG_PBT_DATA_ENTRIES; i++) अणु
		rc = t4_cim_पढ़ो(padap, addr + (i * 4), 1,
				 &pbt->pbt_data[i]);
		अगर (rc) अणु
			cudbg_err->sys_err = rc;
			cudbg_put_buff(pdbg_init, &temp_buff);
			वापस rc;
		पूर्ण
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_mbox_log(काष्ठा cudbg_init *pdbg_init,
			   काष्ठा cudbg_buffer *dbg_buff,
			   काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_mbox_log *mboxlog = शून्य;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा mbox_cmd_log *log = शून्य;
	काष्ठा mbox_cmd *entry;
	अचिन्हित पूर्णांक entry_idx;
	u16 mbox_cmds;
	पूर्णांक i, k, rc;
	u64 flit;
	u32 size;

	log = padap->mbox_log;
	mbox_cmds = padap->mbox_log->size;
	size = माप(काष्ठा cudbg_mbox_log) * mbox_cmds;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	mboxlog = (काष्ठा cudbg_mbox_log *)temp_buff.data;
	क्रम (k = 0; k < mbox_cmds; k++) अणु
		entry_idx = log->cursor + k;
		अगर (entry_idx >= log->size)
			entry_idx -= log->size;

		entry = mbox_cmd_log_entry(log, entry_idx);
		/* skip over unused entries */
		अगर (entry->बारtamp == 0)
			जारी;

		स_नकल(&mboxlog->entry, entry, माप(काष्ठा mbox_cmd));
		क्रम (i = 0; i < MBOX_LEN / 8; i++) अणु
			flit = entry->cmd[i];
			mboxlog->hi[i] = (u32)(flit >> 32);
			mboxlog->lo[i] = (u32)flit;
		पूर्ण
		mboxlog++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

पूर्णांक cudbg_collect_hma_indirect(काष्ठा cudbg_init *pdbg_init,
			       काष्ठा cudbg_buffer *dbg_buff,
			       काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा ireg_buf *hma_indr;
	पूर्णांक i, rc, n;
	u32 size;

	अगर (CHELSIO_CHIP_VERSION(padap->params.chip) < CHELSIO_T6)
		वापस CUDBG_STATUS_ENTITY_NOT_FOUND;

	n = माप(t6_hma_ireg_array) / (IREG_NUM_ELEM * माप(u32));
	size = माप(काष्ठा ireg_buf) * n;
	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
	अगर (rc)
		वापस rc;

	hma_indr = (काष्ठा ireg_buf *)temp_buff.data;
	क्रम (i = 0; i < n; i++) अणु
		काष्ठा ireg_field *hma_fli = &hma_indr->tp_pio;
		u32 *buff = hma_indr->outbuf;

		hma_fli->ireg_addr = t6_hma_ireg_array[i][0];
		hma_fli->ireg_data = t6_hma_ireg_array[i][1];
		hma_fli->ireg_local_offset = t6_hma_ireg_array[i][2];
		hma_fli->ireg_offset_range = t6_hma_ireg_array[i][3];
		t4_पढ़ो_indirect(padap, hma_fli->ireg_addr, hma_fli->ireg_data,
				 buff, hma_fli->ireg_offset_range,
				 hma_fli->ireg_local_offset);
		hma_indr++;
	पूर्ण
	वापस cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
पूर्ण

व्योम cudbg_fill_qdesc_num_and_size(स्थिर काष्ठा adapter *padap,
				   u32 *num, u32 *size)
अणु
	u32 tot_entries = 0, tot_size = 0;

	/* NIC TXQ, RXQ, FLQ, and CTRLQ */
	tot_entries += MAX_ETH_QSETS * 3;
	tot_entries += MAX_CTRL_QUEUES;

	tot_size += MAX_ETH_QSETS * MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;
	tot_size += MAX_ETH_QSETS * MAX_RSPQ_ENTRIES * MAX_RXQ_DESC_SIZE;
	tot_size += MAX_ETH_QSETS * MAX_RX_BUFFERS * MAX_FL_DESC_SIZE;
	tot_size += MAX_CTRL_QUEUES * MAX_CTRL_TXQ_ENTRIES *
		    MAX_CTRL_TXQ_DESC_SIZE;

	/* FW_EVTQ and INTRQ */
	tot_entries += INGQ_EXTRAS;
	tot_size += INGQ_EXTRAS * MAX_RSPQ_ENTRIES * MAX_RXQ_DESC_SIZE;

	/* PTP_TXQ */
	tot_entries += 1;
	tot_size += MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;

	/* ULD TXQ, RXQ, and FLQ */
	tot_entries += CXGB4_TX_MAX * MAX_OFLD_QSETS;
	tot_entries += CXGB4_ULD_MAX * MAX_ULD_QSETS * 2;

	tot_size += CXGB4_TX_MAX * MAX_OFLD_QSETS * MAX_TXQ_ENTRIES *
		    MAX_TXQ_DESC_SIZE;
	tot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * MAX_RSPQ_ENTRIES *
		    MAX_RXQ_DESC_SIZE;
	tot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * MAX_RX_BUFFERS *
		    MAX_FL_DESC_SIZE;

	/* ULD CIQ */
	tot_entries += CXGB4_ULD_MAX * MAX_ULD_QSETS;
	tot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * SGE_MAX_IQ_SIZE *
		    MAX_RXQ_DESC_SIZE;

	/* ETHOFLD TXQ, RXQ, and FLQ */
	tot_entries += MAX_OFLD_QSETS * 3;
	tot_size += MAX_OFLD_QSETS * MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;

	tot_size += माप(काष्ठा cudbg_ver_hdr) +
		    माप(काष्ठा cudbg_qdesc_info) +
		    माप(काष्ठा cudbg_qdesc_entry) * tot_entries;

	अगर (num)
		*num = tot_entries;

	अगर (size)
		*size = tot_size;
पूर्ण

पूर्णांक cudbg_collect_qdesc(काष्ठा cudbg_init *pdbg_init,
			काष्ठा cudbg_buffer *dbg_buff,
			काष्ठा cudbg_error *cudbg_err)
अणु
	u32 num_queues = 0, tot_entries = 0, size = 0;
	काष्ठा adapter *padap = pdbg_init->adap;
	काष्ठा cudbg_buffer temp_buff = अणु 0 पूर्ण;
	काष्ठा cudbg_qdesc_entry *qdesc_entry;
	काष्ठा cudbg_qdesc_info *qdesc_info;
	काष्ठा cudbg_ver_hdr *ver_hdr;
	काष्ठा sge *s = &padap->sge;
	u32 i, j, cur_off, tot_len;
	u8 *data;
	पूर्णांक rc;

	cudbg_fill_qdesc_num_and_size(padap, &tot_entries, &size);
	size = min_t(u32, size, CUDBG_DUMP_BUFF_SIZE);
	tot_len = size;
	data = kvzalloc(size, GFP_KERNEL);
	अगर (!data)
		वापस -ENOMEM;

	ver_hdr = (काष्ठा cudbg_ver_hdr *)data;
	ver_hdr->signature = CUDBG_ENTITY_SIGNATURE;
	ver_hdr->revision = CUDBG_QDESC_REV;
	ver_hdr->size = माप(काष्ठा cudbg_qdesc_info);
	size -= माप(*ver_hdr);

	qdesc_info = (काष्ठा cudbg_qdesc_info *)(data +
						 माप(*ver_hdr));
	size -= माप(*qdesc_info);
	qdesc_entry = (काष्ठा cudbg_qdesc_entry *)qdesc_info->data;

#घोषणा QDESC_GET(q, desc, type, label) करो अणु \
	अगर (size <= 0) अणु \
		जाओ label; \
	पूर्ण \
	अगर (desc) अणु \
		cudbg_fill_qdesc_##q(q, type, qdesc_entry); \
		size -= माप(*qdesc_entry) + qdesc_entry->data_size; \
		num_queues++; \
		qdesc_entry = cudbg_next_qdesc(qdesc_entry); \
	पूर्ण \
पूर्ण जबतक (0)

#घोषणा QDESC_GET_TXQ(q, type, label) करो अणु \
	काष्ठा sge_txq *txq = (काष्ठा sge_txq *)q; \
	QDESC_GET(txq, txq->desc, type, label); \
पूर्ण जबतक (0)

#घोषणा QDESC_GET_RXQ(q, type, label) करो अणु \
	काष्ठा sge_rspq *rxq = (काष्ठा sge_rspq *)q; \
	QDESC_GET(rxq, rxq->desc, type, label); \
पूर्ण जबतक (0)

#घोषणा QDESC_GET_FLQ(q, type, label) करो अणु \
	काष्ठा sge_fl *flq = (काष्ठा sge_fl *)q; \
	QDESC_GET(flq, flq->desc, type, label); \
पूर्ण जबतक (0)

	/* NIC TXQ */
	क्रम (i = 0; i < s->ethqsets; i++)
		QDESC_GET_TXQ(&s->ethtxq[i].q, CUDBG_QTYPE_NIC_TXQ, out);

	/* NIC RXQ */
	क्रम (i = 0; i < s->ethqsets; i++)
		QDESC_GET_RXQ(&s->ethrxq[i].rspq, CUDBG_QTYPE_NIC_RXQ, out);

	/* NIC FLQ */
	क्रम (i = 0; i < s->ethqsets; i++)
		QDESC_GET_FLQ(&s->ethrxq[i].fl, CUDBG_QTYPE_NIC_FLQ, out);

	/* NIC CTRLQ */
	क्रम (i = 0; i < padap->params.nports; i++)
		QDESC_GET_TXQ(&s->ctrlq[i].q, CUDBG_QTYPE_CTRLQ, out);

	/* FW_EVTQ */
	QDESC_GET_RXQ(&s->fw_evtq, CUDBG_QTYPE_FWEVTQ, out);

	/* INTRQ */
	QDESC_GET_RXQ(&s->पूर्णांकrq, CUDBG_QTYPE_INTRQ, out);

	/* PTP_TXQ */
	QDESC_GET_TXQ(&s->ptptxq.q, CUDBG_QTYPE_PTP_TXQ, out);

	/* ULD Queues */
	mutex_lock(&uld_mutex);

	अगर (s->uld_txq_info) अणु
		काष्ठा sge_uld_txq_info *utxq;

		/* ULD TXQ */
		क्रम (j = 0; j < CXGB4_TX_MAX; j++) अणु
			अगर (!s->uld_txq_info[j])
				जारी;

			utxq = s->uld_txq_info[j];
			क्रम (i = 0; i < utxq->ntxq; i++)
				QDESC_GET_TXQ(&utxq->uldtxq[i].q,
					      cudbg_uld_txq_to_qtype(j),
					      out_unlock);
		पूर्ण
	पूर्ण

	अगर (s->uld_rxq_info) अणु
		काष्ठा sge_uld_rxq_info *urxq;
		u32 base;

		/* ULD RXQ */
		क्रम (j = 0; j < CXGB4_ULD_MAX; j++) अणु
			अगर (!s->uld_rxq_info[j])
				जारी;

			urxq = s->uld_rxq_info[j];
			क्रम (i = 0; i < urxq->nrxq; i++)
				QDESC_GET_RXQ(&urxq->uldrxq[i].rspq,
					      cudbg_uld_rxq_to_qtype(j),
					      out_unlock);
		पूर्ण

		/* ULD FLQ */
		क्रम (j = 0; j < CXGB4_ULD_MAX; j++) अणु
			अगर (!s->uld_rxq_info[j])
				जारी;

			urxq = s->uld_rxq_info[j];
			क्रम (i = 0; i < urxq->nrxq; i++)
				QDESC_GET_FLQ(&urxq->uldrxq[i].fl,
					      cudbg_uld_flq_to_qtype(j),
					      out_unlock);
		पूर्ण

		/* ULD CIQ */
		क्रम (j = 0; j < CXGB4_ULD_MAX; j++) अणु
			अगर (!s->uld_rxq_info[j])
				जारी;

			urxq = s->uld_rxq_info[j];
			base = urxq->nrxq;
			क्रम (i = 0; i < urxq->nciq; i++)
				QDESC_GET_RXQ(&urxq->uldrxq[base + i].rspq,
					      cudbg_uld_ciq_to_qtype(j),
					      out_unlock);
		पूर्ण
	पूर्ण

	/* ETHOFLD TXQ */
	अगर (s->eohw_txq)
		क्रम (i = 0; i < s->eoqsets; i++)
			QDESC_GET_TXQ(&s->eohw_txq[i].q,
				      CUDBG_QTYPE_ETHOFLD_TXQ, out);

	/* ETHOFLD RXQ and FLQ */
	अगर (s->eohw_rxq) अणु
		क्रम (i = 0; i < s->eoqsets; i++)
			QDESC_GET_RXQ(&s->eohw_rxq[i].rspq,
				      CUDBG_QTYPE_ETHOFLD_RXQ, out);

		क्रम (i = 0; i < s->eoqsets; i++)
			QDESC_GET_FLQ(&s->eohw_rxq[i].fl,
				      CUDBG_QTYPE_ETHOFLD_FLQ, out);
	पूर्ण

out_unlock:
	mutex_unlock(&uld_mutex);

out:
	qdesc_info->qdesc_entry_size = माप(*qdesc_entry);
	qdesc_info->num_queues = num_queues;
	cur_off = 0;
	जबतक (tot_len) अणु
		u32 chunk_size = min_t(u32, tot_len, CUDBG_CHUNK_SIZE);

		rc = cudbg_get_buff(pdbg_init, dbg_buff, chunk_size,
				    &temp_buff);
		अगर (rc) अणु
			cudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;
			जाओ out_मुक्त;
		पूर्ण

		स_नकल(temp_buff.data, data + cur_off, chunk_size);
		tot_len -= chunk_size;
		cur_off += chunk_size;
		rc = cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff,
						  dbg_buff);
		अगर (rc) अणु
			cudbg_put_buff(pdbg_init, &temp_buff);
			cudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;
			जाओ out_मुक्त;
		पूर्ण
	पूर्ण

out_मुक्त:
	kvमुक्त(data);

#अघोषित QDESC_GET_FLQ
#अघोषित QDESC_GET_RXQ
#अघोषित QDESC_GET_TXQ
#अघोषित QDESC_GET

	वापस rc;
पूर्ण

पूर्णांक cudbg_collect_flash(काष्ठा cudbg_init *pdbg_init,
			काष्ठा cudbg_buffer *dbg_buff,
			काष्ठा cudbg_error *cudbg_err)
अणु
	काष्ठा adapter *padap = pdbg_init->adap;
	u32 count = padap->params.sf_size, n;
	काष्ठा cudbg_buffer temp_buff = अणु0पूर्ण;
	u32 addr, i;
	पूर्णांक rc;

	addr = FLASH_EXP_ROM_START;

	क्रम (i = 0; i < count; i += SF_PAGE_SIZE) अणु
		n = min_t(u32, count - i, SF_PAGE_SIZE);

		rc = cudbg_get_buff(pdbg_init, dbg_buff, n, &temp_buff);
		अगर (rc) अणु
			cudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;
			जाओ out;
		पूर्ण
		rc = t4_पढ़ो_flash(padap, addr, n, (u32 *)temp_buff.data, 0);
		अगर (rc)
			जाओ out;

		addr += (n * 4);
		rc = cudbg_ग_लिखो_and_release_buff(pdbg_init, &temp_buff,
						  dbg_buff);
		अगर (rc) अणु
			cudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;
			जाओ out;
		पूर्ण
	पूर्ण

out:
	वापस rc;
पूर्ण
