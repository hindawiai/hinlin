<शैली गुरु>
/*
 * Audio crossconnecting/conferrencing (hardware level).
 *
 * Copyright 2002 by Andreas Eversberg (jolly@eversberg.eu)
 *
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 */

/*
 * The process of adding and removing parties to/from a conference:
 *
 * There is a chain of काष्ठा dsp_conf which has one or more members in a chain
 * of काष्ठा dsp_conf_member.
 *
 * After a party is added, the conference is checked क्रम hardware capability.
 * Also अगर a party is हटाओd, the conference is checked again.
 *
 * There are 3 dअगरferent solutions: -1 = software, 0 = hardware-crossconnect
 * 1-n = hardware-conference. The n will give the conference number.
 *
 * Depending on the change after removal or insertion of a party, hardware
 * commands are given.
 *
 * The current solution is stored within the काष्ठा dsp_conf entry.
 */

/*
 * HOW THE CMX WORKS:
 *
 * There are 3 types of पूर्णांकeraction: One member is alone, in this हाल only
 * data flow from upper to lower layer is करोne.
 * Two members will also exchange their data so they are crossconnected.
 * Three or more members will be added in a conference and will hear each
 * other but will not receive their own speech (echo) अगर not enabled.
 *
 * Features of CMX are:
 *  - Crossconnecting or even conference, अगर more than two members are together.
 *  - Force mixing of transmit data with other crossconnect/conference members.
 *  - Echo generation to benchmark the delay of audio processing.
 *  - Use hardware to minimize cpu load, disable FIFO load and minimize delay.
 *  - Dejittering and घड़ी generation.
 *
 * There are 2 buffers:
 *
 *
 * RX-Buffer
 *                 R             W
 *                 |             |
 * ----------------+-------------+-------------------
 *
 * The rx-buffer is a ring buffer used to store the received data क्रम each
 * inभागidual member. This is only the हाल अगर data needs to be dejittered
 * or in हाल of a conference where dअगरferent घड़ीs require reघड़ीing.
 * The transmit-घड़ी (R) will पढ़ो the buffer.
 * If the घड़ी overruns the ग_लिखो-poपूर्णांकer, we will have a buffer underrun.
 * If the ग_लिखो poपूर्णांकer always has a certain distance from the transmit-
 * घड़ी, we will have a delay. The delay will dynamically be increased and
 * reduced.
 *
 *
 * TX-Buffer
 *                  R        W
 *                  |        |
 * -----------------+--------+-----------------------
 *
 * The tx-buffer is a ring buffer to queue the transmit data from user space
 * until it will be mixed or sent. There are two poपूर्णांकers, R and W. If the ग_लिखो
 * poपूर्णांकer W would reach or overrun R, the buffer would overrun. In this हाल
 * (some) data is dropped so that it will not overrun.
 * Additionally a dynamic dejittering can be enabled. this allows data from
 * user space that have jitter and dअगरferent घड़ी source.
 *
 *
 * Clock:
 *
 * A Clock is not required, अगर the data source has exactly one घड़ी. In this
 * हाल the data source is क्रमwarded to the destination.
 *
 * A Clock is required, because the data source
 *  - has multiple घड़ीs.
 *  - has no usable घड़ी due to jitter or packet loss (VoIP).
 * In this हाल the प्रणाली's घड़ी is used. The घड़ी resolution depends on
 * the jअगरfie resolution.
 *
 * If a member joins a conference:
 *
 * - If a member joins, its rx_buff is set to silence and change पढ़ो poपूर्णांकer
 *   to transmit घड़ी.
 *
 * The procedure of received data from card is explained in cmx_receive.
 * The procedure of received data from user space is explained in cmx_transmit.
 * The procedure of transmit data to card is cmx_send.
 *
 *
 * Interaction with other features:
 *
 * DTMF:
 * DTMF decoding is करोne beक्रमe the data is crossconnected.
 *
 * Volume change:
 * Changing rx-volume is करोne beक्रमe the data is crossconnected. The tx-volume
 * must be changed whenever data is transmitted to the card by the cmx.
 *
 * Tones:
 * If a tone is enabled, it will be processed whenever data is transmitted to
 * the card. It will replace the tx-data from the user space.
 * If tones are generated by hardware, this conference member is हटाओd क्रम
 * this समय.
 *
 * Disable rx-data:
 * If cmx is realized in hardware, rx data will be disabled अगर requested by
 * the upper layer. If dपंचांगf decoding is करोne by software and enabled, rx data
 * will not be disabled but blocked to the upper layer.
 *
 * HFC conference engine:
 * If it is possible to realize all features using hardware, hardware will be
 * used अगर not क्रमbidden by control command. Disabling rx-data provides
 * असलolutely traffic मुक्त audio processing. (except क्रम the quick 1-frame
 * upload of a tone loop, only once क्रम a new tone)
 *
 */

/* delay.h is required क्रम hw_lock.h */

#समावेश <linux/slab.h>
#समावेश <linux/delay.h>
#समावेश <linux/mISDNअगर.h>
#समावेश <linux/mISDNdsp.h>
#समावेश "core.h"
#समावेश "dsp.h"
/*
 * debugging of multi party conference,
 * by using conference even with two members
 */

/* #घोषणा CMX_CONF_DEBUG */

/*#घोषणा CMX_DEBUG * massive पढ़ो/ग_लिखो poपूर्णांकer output */
/*#घोषणा CMX_DELAY_DEBUG * gives rx-buffer delay overview */
/*#घोषणा CMX_TX_DEBUG * massive पढ़ो/ग_लिखो on tx-buffer with content */

अटल अंतरभूत पूर्णांक
count_list_member(काष्ठा list_head *head)
अणु
	पूर्णांक			cnt = 0;
	काष्ठा list_head	*m;

	list_क्रम_each(m, head)
		cnt++;
	वापस cnt;
पूर्ण

/*
 * debug cmx memory काष्ठाure
 */
व्योम
dsp_cmx_debug(काष्ठा dsp *dsp)
अणु
	काष्ठा dsp_conf	*conf;
	काष्ठा dsp_conf_member	*member;
	काष्ठा dsp		*odsp;

	prपूर्णांकk(KERN_DEBUG "-----Current DSP\n");
	list_क्रम_each_entry(odsp, &dsp_ilist, list) अणु
		prपूर्णांकk(KERN_DEBUG "* %s hardecho=%d softecho=%d txmix=%d",
		       odsp->name, odsp->echo.hardware, odsp->echo.software,
		       odsp->tx_mix);
		अगर (odsp->conf)
			prपूर्णांकk(" (Conf %d)", odsp->conf->id);
		अगर (dsp == odsp)
			prपूर्णांकk(" *this*");
		prपूर्णांकk("\n");
	पूर्ण
	prपूर्णांकk(KERN_DEBUG "-----Current Conf:\n");
	list_क्रम_each_entry(conf, &conf_ilist, list) अणु
		prपूर्णांकk(KERN_DEBUG "* Conf %d (%p)\n", conf->id, conf);
		list_क्रम_each_entry(member, &conf->mlist, list) अणु
			prपूर्णांकk(KERN_DEBUG
			       "  - member = %s (slot_tx %d, bank_tx %d, "
			       "slot_rx %d, bank_rx %d hfc_conf %d "
			       "tx_data %d rx_is_off %d)%s\n",
			       member->dsp->name, member->dsp->pcm_slot_tx,
			       member->dsp->pcm_bank_tx, member->dsp->pcm_slot_rx,
			       member->dsp->pcm_bank_rx, member->dsp->hfc_conf,
			       member->dsp->tx_data, member->dsp->rx_is_off,
			       (member->dsp == dsp) ? " *this*" : "");
		पूर्ण
	पूर्ण
	prपूर्णांकk(KERN_DEBUG "-----end\n");
पूर्ण

/*
 * search conference
 */
अटल काष्ठा dsp_conf *
dsp_cmx_search_conf(u32 id)
अणु
	काष्ठा dsp_conf *conf;

	अगर (!id) अणु
		prपूर्णांकk(KERN_WARNING "%s: conference ID is 0.\n", __func__);
		वापस शून्य;
	पूर्ण

	/* search conference */
	list_क्रम_each_entry(conf, &conf_ilist, list)
		अगर (conf->id == id)
			वापस conf;

	वापस शून्य;
पूर्ण


/*
 * add member to conference
 */
अटल पूर्णांक
dsp_cmx_add_conf_member(काष्ठा dsp *dsp, काष्ठा dsp_conf *conf)
अणु
	काष्ठा dsp_conf_member *member;

	अगर (!conf || !dsp) अणु
		prपूर्णांकk(KERN_WARNING "%s: conf or dsp is 0.\n", __func__);
		वापस -EINVAL;
	पूर्ण
	अगर (dsp->member) अणु
		prपूर्णांकk(KERN_WARNING "%s: dsp is already member in a conf.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	अगर (dsp->conf) अणु
		prपूर्णांकk(KERN_WARNING "%s: dsp is already in a conf.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	member = kzalloc(माप(काष्ठा dsp_conf_member), GFP_ATOMIC);
	अगर (!member) अणु
		prपूर्णांकk(KERN_ERR "kzalloc struct dsp_conf_member failed\n");
		वापस -ENOMEM;
	पूर्ण
	member->dsp = dsp;
	/* clear rx buffer */
	स_रखो(dsp->rx_buff, dsp_silence, माप(dsp->rx_buff));
	dsp->rx_init = 1; /* rx_W and rx_R will be adjusted on first frame */
	dsp->rx_W = 0;
	dsp->rx_R = 0;

	list_add_tail(&member->list, &conf->mlist);

	dsp->conf = conf;
	dsp->member = member;

	वापस 0;
पूर्ण


/*
 * del member from conference
 */
पूर्णांक
dsp_cmx_del_conf_member(काष्ठा dsp *dsp)
अणु
	काष्ठा dsp_conf_member *member;

	अगर (!dsp) अणु
		prपूर्णांकk(KERN_WARNING "%s: dsp is 0.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	अगर (!dsp->conf) अणु
		prपूर्णांकk(KERN_WARNING "%s: dsp is not in a conf.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	अगर (list_empty(&dsp->conf->mlist)) अणु
		prपूर्णांकk(KERN_WARNING "%s: dsp has linked an empty conf.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	/* find us in conf */
	list_क्रम_each_entry(member, &dsp->conf->mlist, list) अणु
		अगर (member->dsp == dsp) अणु
			list_del(&member->list);
			dsp->conf = शून्य;
			dsp->member = शून्य;
			kमुक्त(member);
			वापस 0;
		पूर्ण
	पूर्ण
	prपूर्णांकk(KERN_WARNING
	       "%s: dsp is not present in its own conf_member list.\n",
	       __func__);

	वापस -EINVAL;
पूर्ण


/*
 * new conference
 */
अटल काष्ठा dsp_conf
*dsp_cmx_new_conf(u32 id)
अणु
	काष्ठा dsp_conf *conf;

	अगर (!id) अणु
		prपूर्णांकk(KERN_WARNING "%s: id is 0.\n",
		       __func__);
		वापस शून्य;
	पूर्ण

	conf = kzalloc(माप(काष्ठा dsp_conf), GFP_ATOMIC);
	अगर (!conf) अणु
		prपूर्णांकk(KERN_ERR "kzalloc struct dsp_conf failed\n");
		वापस शून्य;
	पूर्ण
	INIT_LIST_HEAD(&conf->mlist);
	conf->id = id;

	list_add_tail(&conf->list, &conf_ilist);

	वापस conf;
पूर्ण


/*
 * del conference
 */
पूर्णांक
dsp_cmx_del_conf(काष्ठा dsp_conf *conf)
अणु
	अगर (!conf) अणु
		prपूर्णांकk(KERN_WARNING "%s: conf is null.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण

	अगर (!list_empty(&conf->mlist)) अणु
		prपूर्णांकk(KERN_WARNING "%s: conf not empty.\n",
		       __func__);
		वापस -EINVAL;
	पूर्ण
	list_del(&conf->list);
	kमुक्त(conf);

	वापस 0;
पूर्ण


/*
 * send HW message to hfc card
 */
अटल व्योम
dsp_cmx_hw_message(काष्ठा dsp *dsp, u32 message, u32 param1, u32 param2,
		   u32 param3, u32 param4)
अणु
	काष्ठा mISDN_ctrl_req cq;

	स_रखो(&cq, 0, माप(cq));
	cq.op = message;
	cq.p1 = param1 | (param2 << 8);
	cq.p2 = param3 | (param4 << 8);
	अगर (dsp->ch.peer)
		dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq);
पूर्ण


/*
 * करो hardware update and set the software/hardware flag
 *
 * either a conference or a dsp instance can be given
 * अगर only dsp instance is given, the instance is not associated with a conf
 * and thereक्रमe हटाओd. अगर a conference is given, the dsp is expected to
 * be member of that conference.
 */
व्योम
dsp_cmx_hardware(काष्ठा dsp_conf *conf, काष्ठा dsp *dsp)
अणु
	काष्ठा dsp_conf_member	*member, *nexपंचांग;
	काष्ठा dsp		*finddsp;
	पूर्णांक		memb = 0, i, ii, i1, i2;
	पूर्णांक		मुक्तunits[8];
	u_अक्षर		मुक्तslots[256];
	पूर्णांक		same_hfc = -1, same_pcm = -1, current_conf = -1,
		all_conf = 1, tx_data = 0;

	/* dsp माला_लो updated (no conf) */
	अगर (!conf) अणु
		अगर (!dsp)
			वापस;
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG "%s checking dsp %s\n",
			       __func__, dsp->name);
	one_member:
		/* हटाओ HFC conference अगर enabled */
		अगर (dsp->hfc_conf >= 0) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s removing %s from HFC conf %d "
				       "because dsp is split\n", __func__,
				       dsp->name, dsp->hfc_conf);
			dsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_CONF_SPLIT,
					   0, 0, 0, 0);
			dsp->hfc_conf = -1;
		पूर्ण
		/* process hw echo */
		अगर (dsp->features.pcm_banks < 1)
			वापस;
		अगर (!dsp->echo.software && !dsp->echo.hardware) अणु
			/* NO ECHO: हटाओ PCM slot अगर asचिन्हित */
			अगर (dsp->pcm_slot_tx >= 0 || dsp->pcm_slot_rx >= 0) अणु
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG "%s removing %s from"
					       " PCM slot %d (TX) %d (RX) because"
					       " dsp is split (no echo)\n",
					       __func__, dsp->name,
					       dsp->pcm_slot_tx, dsp->pcm_slot_rx);
				dsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_DISC,
						   0, 0, 0, 0);
				dsp->pcm_slot_tx = -1;
				dsp->pcm_bank_tx = -1;
				dsp->pcm_slot_rx = -1;
				dsp->pcm_bank_rx = -1;
			पूर्ण
			वापस;
		पूर्ण
		/* echo is enabled, find out अगर we use soft or hardware */
		dsp->echo.software = dsp->tx_data;
		dsp->echo.hardware = 0;
		/* ECHO: alपढ़ोy echo */
		अगर (dsp->pcm_slot_tx >= 0 && dsp->pcm_slot_rx < 0 &&
		    dsp->pcm_bank_tx == 2 && dsp->pcm_bank_rx == 2) अणु
			dsp->echo.hardware = 1;
			वापस;
		पूर्ण
		/* ECHO: अगर slot alपढ़ोy asचिन्हित */
		अगर (dsp->pcm_slot_tx >= 0) अणु
			dsp->pcm_slot_rx = dsp->pcm_slot_tx;
			dsp->pcm_bank_tx = 2; /* 2 means loop */
			dsp->pcm_bank_rx = 2;
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s refresh %s for echo using slot %d\n",
				       __func__, dsp->name,
				       dsp->pcm_slot_tx);
			dsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,
					   dsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);
			dsp->echo.hardware = 1;
			वापस;
		पूर्ण
		/* ECHO: find slot */
		dsp->pcm_slot_tx = -1;
		dsp->pcm_slot_rx = -1;
		स_रखो(मुक्तslots, 1, माप(मुक्तslots));
		list_क्रम_each_entry(finddsp, &dsp_ilist, list) अणु
			अगर (finddsp->features.pcm_id == dsp->features.pcm_id) अणु
				अगर (finddsp->pcm_slot_rx >= 0 &&
				    finddsp->pcm_slot_rx < माप(मुक्तslots))
					मुक्तslots[finddsp->pcm_slot_rx] = 0;
				अगर (finddsp->pcm_slot_tx >= 0 &&
				    finddsp->pcm_slot_tx < माप(मुक्तslots))
					मुक्तslots[finddsp->pcm_slot_tx] = 0;
			पूर्ण
		पूर्ण
		i = 0;
		ii = dsp->features.pcm_slots;
		जबतक (i < ii) अणु
			अगर (मुक्तslots[i])
				अवरोध;
			i++;
		पूर्ण
		अगर (i == ii) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s no slot available for echo\n",
				       __func__);
			/* no more slots available */
			dsp->echo.software = 1;
			वापस;
		पूर्ण
		/* assign मुक्त slot */
		dsp->pcm_slot_tx = i;
		dsp->pcm_slot_rx = i;
		dsp->pcm_bank_tx = 2; /* loop */
		dsp->pcm_bank_rx = 2;
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "%s assign echo for %s using slot %d\n",
			       __func__, dsp->name, dsp->pcm_slot_tx);
		dsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,
				   dsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);
		dsp->echo.hardware = 1;
		वापस;
	पूर्ण

	/* conf माला_लो updated (all members) */
	अगर (dsp_debug & DEBUG_DSP_CMX)
		prपूर्णांकk(KERN_DEBUG "%s checking conference %d\n",
		       __func__, conf->id);

	अगर (list_empty(&conf->mlist)) अणु
		prपूर्णांकk(KERN_ERR "%s: conference without members\n",
		       __func__);
		वापस;
	पूर्ण
	member = list_entry(conf->mlist.next, काष्ठा dsp_conf_member, list);
	same_hfc = member->dsp->features.hfc_id;
	same_pcm = member->dsp->features.pcm_id;
	/* check all members in our conference */
	list_क्रम_each_entry(member, &conf->mlist, list) अणु
		/* check अगर member uses mixing */
		अगर (member->dsp->tx_mix) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "tx_mix is turned on\n", __func__,
				       member->dsp->name);
		conf_software:
			list_क्रम_each_entry(member, &conf->mlist, list) अणु
				dsp = member->dsp;
				/* हटाओ HFC conference अगर enabled */
				अगर (dsp->hfc_conf >= 0) अणु
					अगर (dsp_debug & DEBUG_DSP_CMX)
						prपूर्णांकk(KERN_DEBUG
						       "%s removing %s from HFC "
						       "conf %d because not "
						       "possible with hardware\n",
						       __func__,
						       dsp->name,
						       dsp->hfc_conf);
					dsp_cmx_hw_message(dsp,
							   MISDN_CTRL_HFC_CONF_SPLIT,
							   0, 0, 0, 0);
					dsp->hfc_conf = -1;
				पूर्ण
				/* हटाओ PCM slot अगर asचिन्हित */
				अगर (dsp->pcm_slot_tx >= 0 ||
				    dsp->pcm_slot_rx >= 0) अणु
					अगर (dsp_debug & DEBUG_DSP_CMX)
						prपूर्णांकk(KERN_DEBUG "%s removing "
						       "%s from PCM slot %d (TX)"
						       " slot %d (RX) because not"
						       " possible with hardware\n",
						       __func__,
						       dsp->name,
						       dsp->pcm_slot_tx,
						       dsp->pcm_slot_rx);
					dsp_cmx_hw_message(dsp,
							   MISDN_CTRL_HFC_PCM_DISC,
							   0, 0, 0, 0);
					dsp->pcm_slot_tx = -1;
					dsp->pcm_bank_tx = -1;
					dsp->pcm_slot_rx = -1;
					dsp->pcm_bank_rx = -1;
				पूर्ण
			पूर्ण
			conf->hardware = 0;
			conf->software = 1;
			वापस;
		पूर्ण
		/* check अगर member has echo turned on */
		अगर (member->dsp->echo.hardware || member->dsp->echo.software) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "echo is turned on\n", __func__,
				       member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर member has tx_mix turned on */
		अगर (member->dsp->tx_mix) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "tx_mix is turned on\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर member changes volume at an not suppoted level */
		अगर (member->dsp->tx_volume) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "tx_volume is changed\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		अगर (member->dsp->rx_volume) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "rx_volume is changed\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर tx-data turned on */
		अगर (member->dsp->tx_data) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s tx_data is turned on\n",
				       __func__, member->dsp->name);
			tx_data = 1;
		पूर्ण
		/* check अगर pipeline exists */
		अगर (member->dsp->pipeline.inuse) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "pipeline exists\n", __func__,
				       member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर encryption is enabled */
		अगर (member->dsp->bf_enable) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG "%s dsp %s cannot form a "
				       "conf, because encryption is enabled\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर member is on a card with PCM support */
		अगर (member->dsp->features.pcm_id < 0) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "dsp has no PCM bus\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* check अगर relations are on the same PCM bus */
		अगर (member->dsp->features.pcm_id != same_pcm) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s dsp %s cannot form a conf, because "
				       "dsp is on a different PCM bus than the "
				       "first dsp\n",
				       __func__, member->dsp->name);
			जाओ conf_software;
		पूर्ण
		/* determine अगर members are on the same hfc chip */
		अगर (same_hfc != member->dsp->features.hfc_id)
			same_hfc = -1;
		/* अगर there are members alपढ़ोy in a conference */
		अगर (current_conf < 0 && member->dsp->hfc_conf >= 0)
			current_conf = member->dsp->hfc_conf;
		/* अगर any member is not in a conference */
		अगर (member->dsp->hfc_conf < 0)
			all_conf = 0;

		memb++;
	पूर्ण

	/* अगर no member, this is an error */
	अगर (memb < 1)
		वापस;

	/* one member */
	अगर (memb == 1) अणु
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "%s conf %d cannot form a HW conference, "
			       "because dsp is alone\n", __func__, conf->id);
		conf->hardware = 0;
		conf->software = 0;
		member = list_entry(conf->mlist.next, काष्ठा dsp_conf_member,
				    list);
		dsp = member->dsp;
		जाओ one_member;
	पूर्ण

	/*
	 * ok, now we are sure that all members are on the same pcm.
	 * now we will see अगर we have only two members, so we can करो
	 * crossconnections, which करोn't have any limitations.
	 */

	/* अगर we have only two members */
	अगर (memb == 2) अणु
		member = list_entry(conf->mlist.next, काष्ठा dsp_conf_member,
				    list);
		nexपंचांग = list_entry(member->list.next, काष्ठा dsp_conf_member,
				   list);
		/* हटाओ HFC conference अगर enabled */
		अगर (member->dsp->hfc_conf >= 0) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s removing %s from HFC conf %d because "
				       "two parties require only a PCM slot\n",
				       __func__, member->dsp->name,
				       member->dsp->hfc_conf);
			dsp_cmx_hw_message(member->dsp,
					   MISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);
			member->dsp->hfc_conf = -1;
		पूर्ण
		अगर (nexपंचांग->dsp->hfc_conf >= 0) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s removing %s from HFC conf %d because "
				       "two parties require only a PCM slot\n",
				       __func__, nexपंचांग->dsp->name,
				       nexपंचांग->dsp->hfc_conf);
			dsp_cmx_hw_message(nexपंचांग->dsp,
					   MISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);
			nexपंचांग->dsp->hfc_conf = -1;
		पूर्ण
		/* अगर members have two banks (and not on the same chip) */
		अगर (member->dsp->features.pcm_banks > 1 &&
		    nexपंचांग->dsp->features.pcm_banks > 1 &&
		    member->dsp->features.hfc_id !=
		    nexपंचांग->dsp->features.hfc_id) अणु
			/* अगर both members have same slots with crossed banks */
			अगर (member->dsp->pcm_slot_tx >= 0 &&
			    member->dsp->pcm_slot_rx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_tx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_rx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_tx ==
			    member->dsp->pcm_slot_rx &&
			    nexपंचांग->dsp->pcm_slot_rx ==
			    member->dsp->pcm_slot_tx &&
			    nexपंचांग->dsp->pcm_slot_tx ==
			    member->dsp->pcm_slot_tx &&
			    member->dsp->pcm_bank_tx !=
			    member->dsp->pcm_bank_rx &&
			    nexपंचांग->dsp->pcm_bank_tx !=
			    nexपंचांग->dsp->pcm_bank_rx) अणु
				/* all members have same slot */
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s dsp %s & %s stay joined on "
					       "PCM slot %d bank %d (TX) bank %d "
					       "(RX) (on different chips)\n",
					       __func__,
					       member->dsp->name,
					       nexपंचांग->dsp->name,
					       member->dsp->pcm_slot_tx,
					       member->dsp->pcm_bank_tx,
					       member->dsp->pcm_bank_rx);
				conf->hardware = 1;
				conf->software = tx_data;
				वापस;
			पूर्ण
			/* find a new slot */
			स_रखो(मुक्तslots, 1, माप(मुक्तslots));
			list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
				अगर (dsp != member->dsp &&
				    dsp != nexपंचांग->dsp &&
				    member->dsp->features.pcm_id ==
				    dsp->features.pcm_id) अणु
					अगर (dsp->pcm_slot_rx >= 0 &&
					    dsp->pcm_slot_rx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_rx] = 0;
					अगर (dsp->pcm_slot_tx >= 0 &&
					    dsp->pcm_slot_tx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_tx] = 0;
				पूर्ण
			पूर्ण
			i = 0;
			ii = member->dsp->features.pcm_slots;
			जबतक (i < ii) अणु
				अगर (मुक्तslots[i])
					अवरोध;
				i++;
			पूर्ण
			अगर (i == ii) अणु
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s no slot available for "
					       "%s & %s\n", __func__,
					       member->dsp->name,
					       nexपंचांग->dsp->name);
				/* no more slots available */
				जाओ conf_software;
			पूर्ण
			/* assign मुक्त slot */
			member->dsp->pcm_slot_tx = i;
			member->dsp->pcm_slot_rx = i;
			nexपंचांग->dsp->pcm_slot_tx = i;
			nexपंचांग->dsp->pcm_slot_rx = i;
			member->dsp->pcm_bank_rx = 0;
			member->dsp->pcm_bank_tx = 1;
			nexपंचांग->dsp->pcm_bank_rx = 1;
			nexपंचांग->dsp->pcm_bank_tx = 0;
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s adding %s & %s to new PCM slot %d "
				       "(TX and RX on different chips) because "
				       "both members have not same slots\n",
				       __func__,
				       member->dsp->name,
				       nexपंचांग->dsp->name,
				       member->dsp->pcm_slot_tx);
			dsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,
					   member->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,
					   member->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);
			dsp_cmx_hw_message(nexपंचांग->dsp, MISDN_CTRL_HFC_PCM_CONN,
					   nexपंचांग->dsp->pcm_slot_tx, nexपंचांग->dsp->pcm_bank_tx,
					   nexपंचांग->dsp->pcm_slot_rx, nexपंचांग->dsp->pcm_bank_rx);
			conf->hardware = 1;
			conf->software = tx_data;
			वापस;
			/* अगर members have one bank (or on the same chip) */
		पूर्ण अन्यथा अणु
			/* अगर both members have dअगरferent crossed slots */
			अगर (member->dsp->pcm_slot_tx >= 0 &&
			    member->dsp->pcm_slot_rx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_tx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_rx >= 0 &&
			    nexपंचांग->dsp->pcm_slot_tx ==
			    member->dsp->pcm_slot_rx &&
			    nexपंचांग->dsp->pcm_slot_rx ==
			    member->dsp->pcm_slot_tx &&
			    member->dsp->pcm_slot_tx !=
			    member->dsp->pcm_slot_rx &&
			    member->dsp->pcm_bank_tx == 0 &&
			    member->dsp->pcm_bank_rx == 0 &&
			    nexपंचांग->dsp->pcm_bank_tx == 0 &&
			    nexपंचांग->dsp->pcm_bank_rx == 0) अणु
				/* all members have same slot */
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s dsp %s & %s stay joined on PCM "
					       "slot %d (TX) %d (RX) on same chip "
					       "or one bank PCM)\n", __func__,
					       member->dsp->name,
					       nexपंचांग->dsp->name,
					       member->dsp->pcm_slot_tx,
					       member->dsp->pcm_slot_rx);
				conf->hardware = 1;
				conf->software = tx_data;
				वापस;
			पूर्ण
			/* find two new slot */
			स_रखो(मुक्तslots, 1, माप(मुक्तslots));
			list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
				अगर (dsp != member->dsp &&
				    dsp != nexपंचांग->dsp &&
				    member->dsp->features.pcm_id ==
				    dsp->features.pcm_id) अणु
					अगर (dsp->pcm_slot_rx >= 0 &&
					    dsp->pcm_slot_rx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_rx] = 0;
					अगर (dsp->pcm_slot_tx >= 0 &&
					    dsp->pcm_slot_tx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_tx] = 0;
				पूर्ण
			पूर्ण
			i1 = 0;
			ii = member->dsp->features.pcm_slots;
			जबतक (i1 < ii) अणु
				अगर (मुक्तslots[i1])
					अवरोध;
				i1++;
			पूर्ण
			अगर (i1 == ii) अणु
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s no slot available "
					       "for %s & %s\n", __func__,
					       member->dsp->name,
					       nexपंचांग->dsp->name);
				/* no more slots available */
				जाओ conf_software;
			पूर्ण
			i2 = i1 + 1;
			जबतक (i2 < ii) अणु
				अगर (मुक्तslots[i2])
					अवरोध;
				i2++;
			पूर्ण
			अगर (i2 == ii) अणु
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s no slot available "
					       "for %s & %s\n",
					       __func__,
					       member->dsp->name,
					       nexपंचांग->dsp->name);
				/* no more slots available */
				जाओ conf_software;
			पूर्ण
			/* assign मुक्त slots */
			member->dsp->pcm_slot_tx = i1;
			member->dsp->pcm_slot_rx = i2;
			nexपंचांग->dsp->pcm_slot_tx = i2;
			nexपंचांग->dsp->pcm_slot_rx = i1;
			member->dsp->pcm_bank_rx = 0;
			member->dsp->pcm_bank_tx = 0;
			nexपंचांग->dsp->pcm_bank_rx = 0;
			nexपंचांग->dsp->pcm_bank_tx = 0;
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s adding %s & %s to new PCM slot %d "
				       "(TX) %d (RX) on same chip or one bank "
				       "PCM, because both members have not "
				       "crossed slots\n", __func__,
				       member->dsp->name,
				       nexपंचांग->dsp->name,
				       member->dsp->pcm_slot_tx,
				       member->dsp->pcm_slot_rx);
			dsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,
					   member->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,
					   member->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);
			dsp_cmx_hw_message(nexपंचांग->dsp, MISDN_CTRL_HFC_PCM_CONN,
					   nexपंचांग->dsp->pcm_slot_tx, nexपंचांग->dsp->pcm_bank_tx,
					   nexपंचांग->dsp->pcm_slot_rx, nexपंचांग->dsp->pcm_bank_rx);
			conf->hardware = 1;
			conf->software = tx_data;
			वापस;
		पूर्ण
	पूर्ण

	/*
	 * अगर we have more than two, we may check अगर we have a conference
	 * unit available on the chip. also all members must be on the same
	 */

	/* अगर not the same HFC chip */
	अगर (same_hfc < 0) अणु
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "%s conference %d cannot be formed, because "
			       "members are on different chips or not "
			       "on HFC chip\n",
			       __func__, conf->id);
		जाओ conf_software;
	पूर्ण

	/* क्रम more than two members.. */

	/* अगर all members alपढ़ोy have the same conference */
	अगर (all_conf) अणु
		conf->hardware = 1;
		conf->software = tx_data;
		वापस;
	पूर्ण

	/*
	 * अगर there is an existing conference, but not all members have joined
	 */
	अगर (current_conf >= 0) अणु
	join_members:
		list_क्रम_each_entry(member, &conf->mlist, list) अणु
			/* अगर no conference engine on our chip, change to
			 * software */
			अगर (!member->dsp->features.hfc_conf)
				जाओ conf_software;
			/* in हाल of hdlc, change to software */
			अगर (member->dsp->hdlc)
				जाओ conf_software;
			/* join to current conference */
			अगर (member->dsp->hfc_conf == current_conf)
				जारी;
			/* get a मुक्त बारlot first */
			स_रखो(मुक्तslots, 1, माप(मुक्तslots));
			list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
				/*
				 * not checking current member, because
				 * slot will be overwritten.
				 */
				अगर (
					dsp != member->dsp &&
					/* dsp must be on the same PCM */
					member->dsp->features.pcm_id ==
					dsp->features.pcm_id) अणु
					/* dsp must be on a slot */
					अगर (dsp->pcm_slot_tx >= 0 &&
					    dsp->pcm_slot_tx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_tx] = 0;
					अगर (dsp->pcm_slot_rx >= 0 &&
					    dsp->pcm_slot_rx <
					    माप(मुक्तslots))
						मुक्तslots[dsp->pcm_slot_rx] = 0;
				पूर्ण
			पूर्ण
			i = 0;
			ii = member->dsp->features.pcm_slots;
			जबतक (i < ii) अणु
				अगर (मुक्तslots[i])
					अवरोध;
				i++;
			पूर्ण
			अगर (i == ii) अणु
				/* no more slots available */
				अगर (dsp_debug & DEBUG_DSP_CMX)
					prपूर्णांकk(KERN_DEBUG
					       "%s conference %d cannot be formed,"
					       " because no slot free\n",
					       __func__, conf->id);
				जाओ conf_software;
			पूर्ण
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "%s changing dsp %s to HW conference "
				       "%d slot %d\n", __func__,
				       member->dsp->name, current_conf, i);
			/* assign मुक्त slot & set PCM & join conf */
			member->dsp->pcm_slot_tx = i;
			member->dsp->pcm_slot_rx = i;
			member->dsp->pcm_bank_tx = 2; /* loop */
			member->dsp->pcm_bank_rx = 2;
			member->dsp->hfc_conf = current_conf;
			dsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,
					   i, 2, i, 2);
			dsp_cmx_hw_message(member->dsp,
					   MISDN_CTRL_HFC_CONF_JOIN, current_conf, 0, 0, 0);
		पूर्ण
		conf->hardware = 1;
		conf->software = tx_data;
		वापस;
	पूर्ण

	/*
	 * no member is in a conference yet, so we find a मुक्त one
	 */
	स_रखो(मुक्तunits, 1, माप(मुक्तunits));
	list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
		/* dsp must be on the same chip */
		अगर (dsp->features.hfc_id == same_hfc &&
		    /* dsp must have joined a HW conference */
		    dsp->hfc_conf >= 0 &&
		    /* slot must be within range */
		    dsp->hfc_conf < 8)
			मुक्तunits[dsp->hfc_conf] = 0;
	पूर्ण
	i = 0;
	ii = 8;
	जबतक (i < ii) अणु
		अगर (मुक्तunits[i])
			अवरोध;
		i++;
	पूर्ण
	अगर (i == ii) अणु
		/* no more conferences available */
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "%s conference %d cannot be formed, because "
			       "no conference number free\n",
			       __func__, conf->id);
		जाओ conf_software;
	पूर्ण
	/* join all members */
	current_conf = i;
	जाओ join_members;
पूर्ण


/*
 * conf_id != 0: join or change conference
 * conf_id == 0: split from conference अगर not alपढ़ोy
 */
पूर्णांक
dsp_cmx_conf(काष्ठा dsp *dsp, u32 conf_id)
अणु
	पूर्णांक err;
	काष्ठा dsp_conf *conf;
	काष्ठा dsp_conf_member	*member;

	/* अगर conference करोesn't change */
	अगर (dsp->conf_id == conf_id)
		वापस 0;

	/* first हटाओ us from current conf */
	अगर (dsp->conf_id) अणु
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG "removing us from conference %d\n",
			       dsp->conf->id);
		/* हटाओ us from conf */
		conf = dsp->conf;
		err = dsp_cmx_del_conf_member(dsp);
		अगर (err)
			वापस err;
		dsp->conf_id = 0;

		/* update hardware */
		dsp_cmx_hardware(शून्य, dsp);

		/* conf now empty? */
		अगर (list_empty(&conf->mlist)) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "conference is empty, so we remove it.\n");
			err = dsp_cmx_del_conf(conf);
			अगर (err)
				वापस err;
		पूर्ण अन्यथा अणु
			/* update members left on conf */
			dsp_cmx_hardware(conf, शून्य);
		पूर्ण
	पूर्ण

	/* अगर split */
	अगर (!conf_id)
		वापस 0;

	/* now add us to conf */
	अगर (dsp_debug & DEBUG_DSP_CMX)
		prपूर्णांकk(KERN_DEBUG "searching conference %d\n",
		       conf_id);
	conf = dsp_cmx_search_conf(conf_id);
	अगर (!conf) अणु
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "conference doesn't exist yet, creating.\n");
		/* the conference करोesn't exist, so we create */
		conf = dsp_cmx_new_conf(conf_id);
		अगर (!conf)
			वापस -EINVAL;
	पूर्ण अन्यथा अगर (!list_empty(&conf->mlist)) अणु
		member = list_entry(conf->mlist.next, काष्ठा dsp_conf_member,
				    list);
		अगर (dsp->hdlc && !member->dsp->hdlc) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "cannot join transparent conference.\n");
			वापस -EINVAL;
		पूर्ण
		अगर (!dsp->hdlc && member->dsp->hdlc) अणु
			अगर (dsp_debug & DEBUG_DSP_CMX)
				prपूर्णांकk(KERN_DEBUG
				       "cannot join hdlc conference.\n");
			वापस -EINVAL;
		पूर्ण
	पूर्ण
	/* add conference member */
	err = dsp_cmx_add_conf_member(dsp, conf);
	अगर (err)
		वापस err;
	dsp->conf_id = conf_id;

	/* अगर we are alone, we करो nothing! */
	अगर (list_empty(&conf->mlist)) अणु
		अगर (dsp_debug & DEBUG_DSP_CMX)
			prपूर्णांकk(KERN_DEBUG
			       "we are alone in this conference, so exit.\n");
		/* update hardware */
		dsp_cmx_hardware(शून्य, dsp);
		वापस 0;
	पूर्ण

	/* update members on conf */
	dsp_cmx_hardware(conf, शून्य);

	वापस 0;
पूर्ण

#अगर_घोषित CMX_DELAY_DEBUG
पूर्णांक delaycount;
अटल व्योम
showdelay(काष्ठा dsp *dsp, पूर्णांक samples, पूर्णांक delay)
अणु
	अक्षर bar[] = "--------------------------------------------------|";
	पूर्णांक sdelay;

	delaycount += samples;
	अगर (delaycount < 8000)
		वापस;
	delaycount = 0;

	sdelay = delay * 50 / (dsp_poll << 2);

	prपूर्णांकk(KERN_DEBUG "DELAY (%s) %3d >%s\n", dsp->name, delay,
	       sdelay > 50 ? "..." : bar + 50 - sdelay);
पूर्ण
#पूर्ण_अगर

/*
 * audio data is received from card
 */
व्योम
dsp_cmx_receive(काष्ठा dsp *dsp, काष्ठा sk_buff *skb)
अणु
	u8 *d, *p;
	पूर्णांक len = skb->len;
	काष्ठा mISDNhead *hh = mISDN_HEAD_P(skb);
	पूर्णांक w, i, ii;

	/* check अगर we have sompen */
	अगर (len < 1)
		वापस;

	/* half of the buffer should be larger than maximum packet size */
	अगर (len >= CMX_BUFF_HALF) अणु
		prपूर्णांकk(KERN_ERR
		       "%s line %d: packet from card is too large (%d bytes). "
		       "please make card send smaller packets OR increase "
		       "CMX_BUFF_SIZE\n", __खाता__, __LINE__, len);
		वापस;
	पूर्ण

	/*
	 * initialize poपूर्णांकers अगर not alपढ़ोy -
	 * also add delay अगर requested by PH_SIGNAL
	 */
	अगर (dsp->rx_init) अणु
		dsp->rx_init = 0;
		अगर (dsp->features.unordered) अणु
			dsp->rx_R = (hh->id & CMX_BUFF_MASK);
			अगर (dsp->cmx_delay)
				dsp->rx_W = (dsp->rx_R + dsp->cmx_delay)
					& CMX_BUFF_MASK;
			अन्यथा
				dsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))
					& CMX_BUFF_MASK;
		पूर्ण अन्यथा अणु
			dsp->rx_R = 0;
			अगर (dsp->cmx_delay)
				dsp->rx_W = dsp->cmx_delay;
			अन्यथा
				dsp->rx_W = dsp_poll >> 1;
		पूर्ण
	पूर्ण
	/* अगर frame contains समय code, ग_लिखो directly */
	अगर (dsp->features.unordered) अणु
		dsp->rx_W = (hh->id & CMX_BUFF_MASK);
		/* prपूर्णांकk(KERN_DEBUG "%s %08x\n", dsp->name, hh->id); */
	पूर्ण
	/*
	 * अगर we underrun (or maybe overrun),
	 * we set our new पढ़ो poपूर्णांकer, and ग_लिखो silence to buffer
	 */
	अगर (((dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK) >= CMX_BUFF_HALF) अणु
		अगर (dsp_debug & DEBUG_DSP_CLOCK)
			prपूर्णांकk(KERN_DEBUG
			       "cmx_receive(dsp=%lx): UNDERRUN (or overrun the "
			       "maximum delay), adjusting read pointer! "
			       "(inst %s)\n", (u_दीर्घ)dsp, dsp->name);
		/* flush rx buffer and set delay to dsp_poll / 2 */
		अगर (dsp->features.unordered) अणु
			dsp->rx_R = (hh->id & CMX_BUFF_MASK);
			अगर (dsp->cmx_delay)
				dsp->rx_W = (dsp->rx_R + dsp->cmx_delay)
					& CMX_BUFF_MASK;
			अन्यथा
				dsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))
					& CMX_BUFF_MASK;
		पूर्ण अन्यथा अणु
			dsp->rx_R = 0;
			अगर (dsp->cmx_delay)
				dsp->rx_W = dsp->cmx_delay;
			अन्यथा
				dsp->rx_W = dsp_poll >> 1;
		पूर्ण
		स_रखो(dsp->rx_buff, dsp_silence, माप(dsp->rx_buff));
	पूर्ण
	/* अगर we have reached द्विगुन delay, jump back to middle */
	अगर (dsp->cmx_delay)
		अगर (((dsp->rx_W - dsp->rx_R) & CMX_BUFF_MASK) >=
		    (dsp->cmx_delay << 1)) अणु
			अगर (dsp_debug & DEBUG_DSP_CLOCK)
				prपूर्णांकk(KERN_DEBUG
				       "cmx_receive(dsp=%lx): OVERRUN (because "
				       "twice the delay is reached), adjusting "
				       "read pointer! (inst %s)\n",
				       (u_दीर्घ)dsp, dsp->name);
			/* flush buffer */
			अगर (dsp->features.unordered) अणु
				dsp->rx_R = (hh->id & CMX_BUFF_MASK);
				dsp->rx_W = (dsp->rx_R + dsp->cmx_delay)
					& CMX_BUFF_MASK;
			पूर्ण अन्यथा अणु
				dsp->rx_R = 0;
				dsp->rx_W = dsp->cmx_delay;
			पूर्ण
			स_रखो(dsp->rx_buff, dsp_silence, माप(dsp->rx_buff));
		पूर्ण

	/* show where to ग_लिखो */
#अगर_घोषित CMX_DEBUG
	prपूर्णांकk(KERN_DEBUG
	       "cmx_receive(dsp=%lx): rx_R(dsp)=%05x rx_W(dsp)=%05x len=%d %s\n",
	       (u_दीर्घ)dsp, dsp->rx_R, dsp->rx_W, len, dsp->name);
#पूर्ण_अगर

	/* ग_लिखो data पूर्णांकo rx_buffer */
	p = skb->data;
	d = dsp->rx_buff;
	w = dsp->rx_W;
	i = 0;
	ii = len;
	जबतक (i < ii) अणु
		d[w++ & CMX_BUFF_MASK] = *p++;
		i++;
	पूर्ण

	/* increase ग_लिखो-poपूर्णांकer */
	dsp->rx_W = ((dsp->rx_W + len) & CMX_BUFF_MASK);
#अगर_घोषित CMX_DELAY_DEBUG
	showdelay(dsp, len, (dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK);
#पूर्ण_अगर
पूर्ण


/*
 * send (mixed) audio data to card and control jitter
 */
अटल व्योम
dsp_cmx_send_member(काष्ठा dsp *dsp, पूर्णांक len, s32 *c, पूर्णांक members)
अणु
	काष्ठा dsp_conf *conf = dsp->conf;
	काष्ठा dsp *member, *other;
	रेजिस्टर s32 sample;
	u8 *d, *p, *q, *o_q;
	काष्ठा sk_buff *nskb, *txskb;
	पूर्णांक r, rr, t, tt, o_r, o_rr;
	पूर्णांक preload = 0;
	काष्ठा mISDNhead *hh, *thh;
	पूर्णांक tx_data_only = 0;

	/* करोn't process अगर: */
	अगर (!dsp->b_active) अणु /* अगर not active */
		dsp->last_tx = 0;
		वापस;
	पूर्ण
	अगर (((dsp->conf && dsp->conf->hardware) || /* hardware conf */
	     dsp->echo.hardware) && /* OR hardware echo */
	    dsp->tx_R == dsp->tx_W && /* AND no tx-data */
	    !(dsp->tone.tone && dsp->tone.software)) अणु /* AND not soft tones */
		अगर (!dsp->tx_data) अणु /* no tx_data क्रम user space required */
			dsp->last_tx = 0;
			वापस;
		पूर्ण
		अगर (dsp->conf && dsp->conf->software && dsp->conf->hardware)
			tx_data_only = 1;
		अगर (dsp->echo.software && dsp->echo.hardware)
			tx_data_only = 1;
	पूर्ण

#अगर_घोषित CMX_DEBUG
	prपूर्णांकk(KERN_DEBUG
	       "SEND members=%d dsp=%s, conf=%p, rx_R=%05x rx_W=%05x\n",
	       members, dsp->name, conf, dsp->rx_R, dsp->rx_W);
#पूर्ण_अगर

	/* preload अगर we have delay set */
	अगर (dsp->cmx_delay && !dsp->last_tx) अणु
		preload = len;
		अगर (preload < 128)
			preload = 128;
	पूर्ण

	/* PREPARE RESULT */
	nskb = mI_alloc_skb(len + preload, GFP_ATOMIC);
	अगर (!nskb) अणु
		prपूर्णांकk(KERN_ERR
		       "FATAL ERROR in mISDN_dsp.o: cannot alloc %d bytes\n",
		       len + preload);
		वापस;
	पूर्ण
	hh = mISDN_HEAD_P(nskb);
	hh->prim = PH_DATA_REQ;
	hh->id = 0;
	dsp->last_tx = 1;

	/* set poपूर्णांकers, indexes and stuff */
	member = dsp;
	p = dsp->tx_buff; /* transmit data */
	q = dsp->rx_buff; /* received data */
	d = skb_put(nskb, preload + len); /* result */
	t = dsp->tx_R; /* tx-poपूर्णांकers */
	tt = dsp->tx_W;
	r = dsp->rx_R; /* rx-poपूर्णांकers */
	rr = (r + len) & CMX_BUFF_MASK;

	/* preload with silence, अगर required */
	अगर (preload) अणु
		स_रखो(d, dsp_silence, preload);
		d += preload;
	पूर्ण

	/* PROCESS TONES/TX-DATA ONLY */
	अगर (dsp->tone.tone && dsp->tone.software) अणु
		/* -> copy tone */
		dsp_tone_copy(dsp, d, len);
		dsp->tx_R = 0; /* clear tx buffer */
		dsp->tx_W = 0;
		जाओ send_packet;
	पूर्ण
	/* अगर we have tx-data but करो not use mixing */
	अगर (!dsp->tx_mix && t != tt) अणु
		/* -> send tx-data and जारी when not enough */
#अगर_घोषित CMX_TX_DEBUG
		प्र_लिखो(debugbuf, "TX sending (%04x-%04x)%p: ", t, tt, p);
#पूर्ण_अगर
		जबतक (r != rr && t != tt) अणु
#अगर_घोषित CMX_TX_DEBUG
			अगर (म_माप(debugbuf) < 48)
				प्र_लिखो(debugbuf + म_माप(debugbuf), " %02x",
					p[t]);
#पूर्ण_अगर
			*d++ = p[t]; /* ग_लिखो tx_buff */
			t = (t + 1) & CMX_BUFF_MASK;
			r = (r + 1) & CMX_BUFF_MASK;
		पूर्ण
		अगर (r == rr) अणु
			dsp->tx_R = t;
#अगर_घोषित CMX_TX_DEBUG
			prपूर्णांकk(KERN_DEBUG "%s\n", debugbuf);
#पूर्ण_अगर
			जाओ send_packet;
		पूर्ण
	पूर्ण
#अगर_घोषित CMX_TX_DEBUG
	prपूर्णांकk(KERN_DEBUG "%s\n", debugbuf);
#पूर्ण_अगर

	/* PROCESS DATA (one member / no conf) */
	अगर (!conf || members <= 1) अणु
		/* -> अगर echo is NOT enabled */
		अगर (!dsp->echo.software) अणु
			/* -> send tx-data अगर available or use 0-volume */
			जबतक (r != rr && t != tt) अणु
				*d++ = p[t]; /* ग_लिखो tx_buff */
				t = (t + 1) & CMX_BUFF_MASK;
				r = (r + 1) & CMX_BUFF_MASK;
			पूर्ण
			अगर (r != rr) अणु
				अगर (dsp_debug & DEBUG_DSP_CLOCK)
					prपूर्णांकk(KERN_DEBUG "%s: RX empty\n",
					       __func__);
				स_रखो(d, dsp_silence, (rr - r) & CMX_BUFF_MASK);
			पूर्ण
			/* -> अगर echo is enabled */
		पूर्ण अन्यथा अणु
			/*
			 * -> mix tx-data with echo अगर available,
			 * or use echo only
			 */
			जबतक (r != rr && t != tt) अणु
				*d++ = dsp_audio_mix_law[(p[t] << 8) | q[r]];
				t = (t + 1) & CMX_BUFF_MASK;
				r = (r + 1) & CMX_BUFF_MASK;
			पूर्ण
			जबतक (r != rr) अणु
				*d++ = q[r]; /* echo */
				r = (r + 1) & CMX_BUFF_MASK;
			पूर्ण
		पूर्ण
		dsp->tx_R = t;
		जाओ send_packet;
	पूर्ण
	/* PROCESS DATA (two members) */
#अगर_घोषित CMX_CONF_DEBUG
	अगर (0) अणु
#अन्यथा
	अगर (members == 2) अणु
#पूर्ण_अगर
		/* "other" becomes other party */
		other = (list_entry(conf->mlist.next,
				    काष्ठा dsp_conf_member, list))->dsp;
		अगर (other == member)
			other = (list_entry(conf->mlist.prev,
				    काष्ठा dsp_conf_member, list))->dsp;
		o_q = other->rx_buff; /* received data */
		o_rr = (other->rx_R + len) & CMX_BUFF_MASK;
		/* end of rx-poपूर्णांकer */
		o_r = (o_rr - rr + r) & CMX_BUFF_MASK;
		/* start rx-poपूर्णांकer at current पढ़ो position*/
		/* -> अगर echo is NOT enabled */
		अगर (!dsp->echo.software) अणु
			/*
			 * -> copy other member's rx-data,
			 * अगर tx-data is available, mix
			 */
			जबतक (o_r != o_rr && t != tt) अणु
				*d++ = dsp_audio_mix_law[(p[t] << 8) | o_q[o_r]];
				t = (t + 1) & CMX_BUFF_MASK;
				o_r = (o_r + 1) & CMX_BUFF_MASK;
			पूर्ण
			जबतक (o_r != o_rr) अणु
				*d++ = o_q[o_r];
				o_r = (o_r + 1) & CMX_BUFF_MASK;
			पूर्ण
			/* -> अगर echo is enabled */
		पूर्ण अन्यथा अणु
			/*
			 * -> mix other member's rx-data with echo,
			 * अगर tx-data is available, mix
			 */
			जबतक (r != rr && t != tt) अणु
				sample = dsp_audio_law_to_s32[p[t]] +
					dsp_audio_law_to_s32[q[r]] +
					dsp_audio_law_to_s32[o_q[o_r]];
				अगर (sample < -32768)
					sample = -32768;
				अन्यथा अगर (sample > 32767)
					sample = 32767;
				*d++ = dsp_audio_s16_to_law[sample & 0xffff];
				/* tx-data + rx_data + echo */
				t = (t + 1) & CMX_BUFF_MASK;
				r = (r + 1) & CMX_BUFF_MASK;
				o_r = (o_r + 1) & CMX_BUFF_MASK;
			पूर्ण
			जबतक (r != rr) अणु
				*d++ = dsp_audio_mix_law[(q[r] << 8) | o_q[o_r]];
				r = (r + 1) & CMX_BUFF_MASK;
				o_r = (o_r + 1) & CMX_BUFF_MASK;
			पूर्ण
		पूर्ण
		dsp->tx_R = t;
		जाओ send_packet;
	पूर्ण
	/* PROCESS DATA (three or more members) */
	/* -> अगर echo is NOT enabled */
	अगर (!dsp->echo.software) अणु
		/*
		 * -> subtract rx-data from conf-data,
		 * अगर tx-data is available, mix
		 */
		जबतक (r != rr && t != tt) अणु
			sample = dsp_audio_law_to_s32[p[t]] + *c++ -
				dsp_audio_law_to_s32[q[r]];
			अगर (sample < -32768)
				sample = -32768;
			अन्यथा अगर (sample > 32767)
				sample = 32767;
			*d++ = dsp_audio_s16_to_law[sample & 0xffff];
			/* conf-rx+tx */
			r = (r + 1) & CMX_BUFF_MASK;
			t = (t + 1) & CMX_BUFF_MASK;
		पूर्ण
		जबतक (r != rr) अणु
			sample = *c++ - dsp_audio_law_to_s32[q[r]];
			अगर (sample < -32768)
				sample = -32768;
			अन्यथा अगर (sample > 32767)
				sample = 32767;
			*d++ = dsp_audio_s16_to_law[sample & 0xffff];
			/* conf-rx */
			r = (r + 1) & CMX_BUFF_MASK;
		पूर्ण
		/* -> अगर echo is enabled */
	पूर्ण अन्यथा अणु
		/*
		 * -> encode conf-data, अगर tx-data
		 * is available, mix
		 */
		जबतक (r != rr && t != tt) अणु
			sample = dsp_audio_law_to_s32[p[t]] + *c++;
			अगर (sample < -32768)
				sample = -32768;
			अन्यथा अगर (sample > 32767)
				sample = 32767;
			*d++ = dsp_audio_s16_to_law[sample & 0xffff];
			/* conf(echo)+tx */
			t = (t + 1) & CMX_BUFF_MASK;
			r = (r + 1) & CMX_BUFF_MASK;
		पूर्ण
		जबतक (r != rr) अणु
			sample = *c++;
			अगर (sample < -32768)
				sample = -32768;
			अन्यथा अगर (sample > 32767)
				sample = 32767;
			*d++ = dsp_audio_s16_to_law[sample & 0xffff];
			/* conf(echo) */
			r = (r + 1) & CMX_BUFF_MASK;
		पूर्ण
	पूर्ण
	dsp->tx_R = t;
	जाओ send_packet;

send_packet:
	/*
	 * send tx-data अगर enabled - करोn't filter,
	 * because we want what we send, not what we filtered
	 */
	अगर (dsp->tx_data) अणु
		अगर (tx_data_only) अणु
			hh->prim = DL_DATA_REQ;
			hh->id = 0;
			/* queue and trigger */
			skb_queue_tail(&dsp->sendq, nskb);
			schedule_work(&dsp->workq);
			/* निकास because only tx_data is used */
			वापस;
		पूर्ण अन्यथा अणु
			txskb = mI_alloc_skb(len, GFP_ATOMIC);
			अगर (!txskb) अणु
				prपूर्णांकk(KERN_ERR
				       "FATAL ERROR in mISDN_dsp.o: "
				       "cannot alloc %d bytes\n", len);
			पूर्ण अन्यथा अणु
				thh = mISDN_HEAD_P(txskb);
				thh->prim = DL_DATA_REQ;
				thh->id = 0;
				skb_put_data(txskb, nskb->data + preload, len);
				/* queue (trigger later) */
				skb_queue_tail(&dsp->sendq, txskb);
			पूर्ण
		पूर्ण
	पूर्ण

	/* send data only to card, अगर we करोn't just calculated tx_data */
	/* adjust volume */
	अगर (dsp->tx_volume)
		dsp_change_volume(nskb, dsp->tx_volume);
	/* pipeline */
	अगर (dsp->pipeline.inuse)
		dsp_pipeline_process_tx(&dsp->pipeline, nskb->data,
					nskb->len);
	/* crypt */
	अगर (dsp->bf_enable)
		dsp_bf_encrypt(dsp, nskb->data, nskb->len);
	/* queue and trigger */
	skb_queue_tail(&dsp->sendq, nskb);
	schedule_work(&dsp->workq);
पूर्ण

अटल u32	jittercount; /* counter क्रम jitter check */
काष्ठा समयr_list dsp_spl_tl;
अचिन्हित दीर्घ	dsp_spl_jअगरfies; /* calculate the next समय to fire */
अटल u16	dsp_count; /* last sample count */
अटल पूर्णांक	dsp_count_valid; /* अगर we have last sample count */

व्योम
dsp_cmx_send(व्योम *arg)
अणु
	काष्ठा dsp_conf *conf;
	काष्ठा dsp_conf_member *member;
	काष्ठा dsp *dsp;
	पूर्णांक musपंचांगix, members;
	अटल s32 mixbuffer[MAX_POLL + 100];
	s32 *c;
	u8 *p, *q;
	पूर्णांक r, rr;
	पूर्णांक jittercheck = 0, delay, i;
	u_दीर्घ flags;
	u16 length, count;

	/* lock */
	spin_lock_irqsave(&dsp_lock, flags);

	अगर (!dsp_count_valid) अणु
		dsp_count = mISDN_घड़ी_get();
		length = dsp_poll;
		dsp_count_valid = 1;
	पूर्ण अन्यथा अणु
		count = mISDN_घड़ी_get();
		length = count - dsp_count;
		dsp_count = count;
	पूर्ण
	अगर (length > MAX_POLL + 100)
		length = MAX_POLL + 100;
	/* prपूर्णांकk(KERN_DEBUG "len=%d dsp_count=0x%x\n", length, dsp_count); */

	/*
	 * check अगर jitter needs to be checked (this is every second)
	 */
	jittercount += length;
	अगर (jittercount >= 8000) अणु
		jittercount -= 8000;
		jittercheck = 1;
	पूर्ण

	/* loop all members that करो not require conference mixing */
	list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
		अगर (dsp->hdlc)
			जारी;
		conf = dsp->conf;
		musपंचांगix = 0;
		members = 0;
		अगर (conf) अणु
			members = count_list_member(&conf->mlist);
#अगर_घोषित CMX_CONF_DEBUG
			अगर (conf->software && members > 1)
#अन्यथा
			अगर (conf->software && members > 2)
#पूर्ण_अगर
				musपंचांगix = 1;
		पूर्ण

		/* transmission required */
		अगर (!musपंचांगix) अणु
			dsp_cmx_send_member(dsp, length, mixbuffer, members);

			/*
			 * unused mixbuffer is given to prevent a
			 * potential null-poपूर्णांकer-bug
			 */
		पूर्ण
	पूर्ण

	/* loop all members that require conference mixing */
	list_क्रम_each_entry(conf, &conf_ilist, list) अणु
		/* count members and check hardware */
		members = count_list_member(&conf->mlist);
#अगर_घोषित CMX_CONF_DEBUG
		अगर (conf->software && members > 1) अणु
#अन्यथा
		अगर (conf->software && members > 2) अणु
#पूर्ण_अगर
			/* check क्रम hdlc conf */
			member = list_entry(conf->mlist.next,
					    काष्ठा dsp_conf_member, list);
			अगर (member->dsp->hdlc)
				जारी;
			/* mix all data */
			स_रखो(mixbuffer, 0, length * माप(s32));
			list_क्रम_each_entry(member, &conf->mlist, list) अणु
				dsp = member->dsp;
				/* get range of data to mix */
				c = mixbuffer;
				q = dsp->rx_buff;
				r = dsp->rx_R;
				rr = (r + length) & CMX_BUFF_MASK;
				/* add member's data */
				जबतक (r != rr) अणु
					*c++ += dsp_audio_law_to_s32[q[r]];
					r = (r + 1) & CMX_BUFF_MASK;
				पूर्ण
			पूर्ण

			/* process each member */
			list_क्रम_each_entry(member, &conf->mlist, list) अणु
				/* transmission */
				dsp_cmx_send_member(member->dsp, length,
						    mixbuffer, members);
			पूर्ण
		पूर्ण
	पूर्ण

	/* delete rx-data, increment buffers, change poपूर्णांकers */
	list_क्रम_each_entry(dsp, &dsp_ilist, list) अणु
		अगर (dsp->hdlc)
			जारी;
		p = dsp->rx_buff;
		q = dsp->tx_buff;
		r = dsp->rx_R;
		/* move receive poपूर्णांकer when receiving */
		अगर (!dsp->rx_is_off) अणु
			rr = (r + length) & CMX_BUFF_MASK;
			/* delete rx-data */
			जबतक (r != rr) अणु
				p[r] = dsp_silence;
				r = (r + 1) & CMX_BUFF_MASK;
			पूर्ण
			/* increment rx-buffer poपूर्णांकer */
			dsp->rx_R = r; /* ग_लिखो incremented पढ़ो poपूर्णांकer */
		पूर्ण

		/* check current rx_delay */
		delay = (dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK;
		अगर (delay >= CMX_BUFF_HALF)
			delay = 0; /* will be the delay beक्रमe next ग_लिखो */
		/* check क्रम lower delay */
		अगर (delay < dsp->rx_delay[0])
			dsp->rx_delay[0] = delay;
		/* check current tx_delay */
		delay = (dsp->tx_W-dsp->tx_R) & CMX_BUFF_MASK;
		अगर (delay >= CMX_BUFF_HALF)
			delay = 0; /* will be the delay beक्रमe next ग_लिखो */
		/* check क्रम lower delay */
		अगर (delay < dsp->tx_delay[0])
			dsp->tx_delay[0] = delay;
		अगर (jittercheck) अणु
			/* find the lowest of all rx_delays */
			delay = dsp->rx_delay[0];
			i = 1;
			जबतक (i < MAX_SECONDS_JITTER_CHECK) अणु
				अगर (delay > dsp->rx_delay[i])
					delay = dsp->rx_delay[i];
				i++;
			पूर्ण
			/*
			 * हटाओ rx_delay only अगर we have delay AND we
			 * have not preset cmx_delay AND
			 * the delay is greater dsp_poll
			 */
			अगर (delay > dsp_poll && !dsp->cmx_delay) अणु
				अगर (dsp_debug & DEBUG_DSP_CLOCK)
					prपूर्णांकk(KERN_DEBUG
					       "%s lowest rx_delay of %d bytes for"
					       " dsp %s are now removed.\n",
					       __func__, delay,
					       dsp->name);
				r = dsp->rx_R;
				rr = (r + delay - (dsp_poll >> 1))
					& CMX_BUFF_MASK;
				/* delete rx-data */
				जबतक (r != rr) अणु
					p[r] = dsp_silence;
					r = (r + 1) & CMX_BUFF_MASK;
				पूर्ण
				/* increment rx-buffer poपूर्णांकer */
				dsp->rx_R = r;
				/* ग_लिखो incremented पढ़ो poपूर्णांकer */
			पूर्ण
			/* find the lowest of all tx_delays */
			delay = dsp->tx_delay[0];
			i = 1;
			जबतक (i < MAX_SECONDS_JITTER_CHECK) अणु
				अगर (delay > dsp->tx_delay[i])
					delay = dsp->tx_delay[i];
				i++;
			पूर्ण
			/*
			 * हटाओ delay only अगर we have delay AND we
			 * have enabled tx_dejitter
			 */
			अगर (delay > dsp_poll && dsp->tx_dejitter) अणु
				अगर (dsp_debug & DEBUG_DSP_CLOCK)
					prपूर्णांकk(KERN_DEBUG
					       "%s lowest tx_delay of %d bytes for"
					       " dsp %s are now removed.\n",
					       __func__, delay,
					       dsp->name);
				r = dsp->tx_R;
				rr = (r + delay - (dsp_poll >> 1))
					& CMX_BUFF_MASK;
				/* delete tx-data */
				जबतक (r != rr) अणु
					q[r] = dsp_silence;
					r = (r + 1) & CMX_BUFF_MASK;
				पूर्ण
				/* increment rx-buffer poपूर्णांकer */
				dsp->tx_R = r;
				/* ग_लिखो incremented पढ़ो poपूर्णांकer */
			पूर्ण
			/* scroll up delays */
			i = MAX_SECONDS_JITTER_CHECK - 1;
			जबतक (i) अणु
				dsp->rx_delay[i] = dsp->rx_delay[i - 1];
				dsp->tx_delay[i] = dsp->tx_delay[i - 1];
				i--;
			पूर्ण
			dsp->tx_delay[0] = CMX_BUFF_HALF; /* (infinite) delay */
			dsp->rx_delay[0] = CMX_BUFF_HALF; /* (infinite) delay */
		पूर्ण
	पूर्ण

	/* अगर next event would be in the past ... */
	अगर ((s32)(dsp_spl_jअगरfies + dsp_tics-jअगरfies) <= 0)
		dsp_spl_jअगरfies = jअगरfies + 1;
	अन्यथा
		dsp_spl_jअगरfies += dsp_tics;

	dsp_spl_tl.expires = dsp_spl_jअगरfies;
	add_समयr(&dsp_spl_tl);

	/* unlock */
	spin_unlock_irqrestore(&dsp_lock, flags);
पूर्ण

/*
 * audio data is transmitted from upper layer to the dsp
 */
व्योम
dsp_cmx_transmit(काष्ठा dsp *dsp, काष्ठा sk_buff *skb)
अणु
	u_पूर्णांक w, ww;
	u8 *d, *p;
	पूर्णांक space; /* toकरो: , l = skb->len; */
#अगर_घोषित CMX_TX_DEBUG
	अक्षर debugbuf[256] = "";
#पूर्ण_अगर

	/* check अगर there is enough space, and then copy */
	w = dsp->tx_W;
	ww = dsp->tx_R;
	p = dsp->tx_buff;
	d = skb->data;
	space = (ww - w - 1) & CMX_BUFF_MASK;
	/* ग_लिखो-poपूर्णांकer should not overrun nor reach पढ़ो poपूर्णांकer */
	अगर (space < skb->len) अणु
		/* ग_लिखो to the space we have left */
		ww = (ww - 1) & CMX_BUFF_MASK; /* end one byte prior tx_R */
		अगर (dsp_debug & DEBUG_DSP_CLOCK)
			prपूर्णांकk(KERN_DEBUG "%s: TX overflow space=%d skb->len="
			       "%d, w=0x%04x, ww=0x%04x\n", __func__, space,
			       skb->len, w, ww);
	पूर्ण अन्यथा
		/* ग_लिखो until all byte are copied */
		ww = (w + skb->len) & CMX_BUFF_MASK;
	dsp->tx_W = ww;
		/* show current buffer */
#अगर_घोषित CMX_DEBUG
	prपूर्णांकk(KERN_DEBUG
	       "cmx_transmit(dsp=%lx) %d bytes to 0x%x-0x%x. %s\n",
	       (u_दीर्घ)dsp, (ww - w) & CMX_BUFF_MASK, w, ww, dsp->name);
#पूर्ण_अगर

	/* copy transmit data to tx-buffer */
#अगर_घोषित CMX_TX_DEBUG
	प्र_लिखो(debugbuf, "TX getting (%04x-%04x)%p: ", w, ww, p);
#पूर्ण_अगर
	जबतक (w != ww) अणु
#अगर_घोषित CMX_TX_DEBUG
		अगर (म_माप(debugbuf) < 48)
			प्र_लिखो(debugbuf + म_माप(debugbuf), " %02x", *d);
#पूर्ण_अगर
		p[w] = *d++;
		w = (w + 1) & CMX_BUFF_MASK;
	पूर्ण
#अगर_घोषित CMX_TX_DEBUG
	prपूर्णांकk(KERN_DEBUG "%s\n", debugbuf);
#पूर्ण_अगर

पूर्ण

/*
 * hdlc data is received from card and sent to all members.
 */
व्योम
dsp_cmx_hdlc(काष्ठा dsp *dsp, काष्ठा sk_buff *skb)
अणु
	काष्ठा sk_buff *nskb = शून्य;
	काष्ठा dsp_conf_member *member;
	काष्ठा mISDNhead *hh;

	/* not अगर not active */
	अगर (!dsp->b_active)
		वापस;

	/* check अगर we have sompen */
	अगर (skb->len < 1)
		वापस;

	/* no conf */
	अगर (!dsp->conf) अणु
		/* in हाल of software echo */
		अगर (dsp->echo.software) अणु
			nskb = skb_clone(skb, GFP_ATOMIC);
			अगर (nskb) अणु
				hh = mISDN_HEAD_P(nskb);
				hh->prim = PH_DATA_REQ;
				hh->id = 0;
				skb_queue_tail(&dsp->sendq, nskb);
				schedule_work(&dsp->workq);
			पूर्ण
		पूर्ण
		वापस;
	पूर्ण
	/* in हाल of hardware conference */
	अगर (dsp->conf->hardware)
		वापस;
	list_क्रम_each_entry(member, &dsp->conf->mlist, list) अणु
		अगर (dsp->echo.software || member->dsp != dsp) अणु
			nskb = skb_clone(skb, GFP_ATOMIC);
			अगर (nskb) अणु
				hh = mISDN_HEAD_P(nskb);
				hh->prim = PH_DATA_REQ;
				hh->id = 0;
				skb_queue_tail(&member->dsp->sendq, nskb);
				schedule_work(&member->dsp->workq);
			पूर्ण
		पूर्ण
	पूर्ण
पूर्ण
