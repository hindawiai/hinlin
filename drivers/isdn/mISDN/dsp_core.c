<शैली गुरु>
/*
 * Author       Andreas Eversberg (jolly@eversberg.eu)
 * Based on source code काष्ठाure by
 *		Karsten Keil (keil@isdn4linux.de)
 *
 *		This file is (c) under GNU PUBLIC LICENSE
 *
 * Thanks to    Karsten Keil (great drivers)
 *              Cologne Chip (great chips)
 *
 * This module करोes:
 *		Real-समय tone generation
 *		DTMF detection
 *		Real-समय cross-connection and conferrence
 *		Compensate jitter due to प्रणाली load and hardware fault.
 *		All features are करोne in kernel space and will be realized
 *		using hardware, अगर available and supported by chip set.
 *		Blowfish encryption/decryption
 */

/* STRUCTURE:
 *
 * The dsp module provides layer 2 क्रम b-channels (64kbit). It provides
 * transparent audio क्रमwarding with special digital संकेत processing:
 *
 * - (1) generation of tones
 * - (2) detection of dपंचांगf tones
 * - (3) crossconnecting and conferences (घड़ीing)
 * - (4) echo generation क्रम delay test
 * - (5) volume control
 * - (6) disable receive data
 * - (7) pipeline
 * - (8) encryption/decryption
 *
 * Look:
 *             TX            RX
 *         ------upper layer------
 *             |             ^
 *             |             |(6)
 *             v             |
 *       +-----+-------------+-----+
 *       |(3)(4)                   |
 *       |           CMX           |
 *       |                         |
 *       |           +-------------+
 *       |           |       ^
 *       |           |       |
 *       |+---------+|  +----+----+
 *       ||(1)      ||  |(2)      |
 *       ||         ||  |         |
 *       ||  Tones  ||  |  DTMF   |
 *       ||         ||  |         |
 *       ||         ||  |         |
 *       |+----+----+|  +----+----+
 *       +-----+-----+       ^
 *             |             |
 *             v             |
 *        +----+----+   +----+----+
 *        |(5)      |   |(5)      |
 *        |         |   |         |
 *        |TX Volume|   |RX Volume|
 *        |         |   |         |
 *        |         |   |         |
 *        +----+----+   +----+----+
 *             |             ^
 *             |             |
 *             v             |
 *        +----+-------------+----+
 *        |(7)                    |
 *        |                       |
 *        |  Pipeline Processing  |
 *        |                       |
 *        |                       |
 *        +----+-------------+----+
 *             |             ^
 *             |             |
 *             v             |
 *        +----+----+   +----+----+
 *        |(8)      |   |(8)      |
 *        |         |   |         |
 *        | Encrypt |   | Decrypt |
 *        |         |   |         |
 *        |         |   |         |
 *        +----+----+   +----+----+
 *             |             ^
 *             |             |
 *             v             |
 *         ------card  layer------
 *             TX            RX
 *
 * Above you can see the logical data flow. If software is used to करो the
 * process, it is actually the real data flow. If hardware is used, data
 * may not flow, but hardware commands to the card, to provide the data flow
 * as shown.
 *
 * NOTE: The channel must be activated in order to make dsp work, even अगर
 * no data flow to the upper layer is पूर्णांकended. Activation can be करोne
 * after and beक्रमe controlling the setting using PH_CONTROL requests.
 *
 * DTMF: Will be detected by hardware अगर possible. It is करोne beक्रमe CMX
 * processing.
 *
 * Tones: Will be generated via software अगर endless looped audio fअगरos are
 * not supported by hardware. Tones will override all data from CMX.
 * It is not required to join a conference to use tones at any समय.
 *
 * CMX: Is transparent when not used. When it is used, it will करो
 * crossconnections and conferences via software अगर not possible through
 * hardware. If hardware capability is available, hardware is used.
 *
 * Echo: Is generated by CMX and is used to check perक्रमmance of hard and
 * software CMX.
 *
 * The CMX has special functions क्रम conferences with one, two and more
 * members. It will allow dअगरferent types of data flow. Receive and transmit
 * data to/क्रमm upper layer may be चयनed on/off inभागidually without losing
 * features of CMX, Tones and DTMF.
 *
 * Echo Cancellation: Someबार we like to cancel echo from the पूर्णांकerface.
 * Note that a VoIP call may not have echo caused by the IP phone. The echo
 * is generated by the telephone line connected to it. Because the delay
 * is high, it becomes an echo. RESULT: Echo Cachelation is required अगर
 * both echo AND delay is applied to an पूर्णांकerface.
 * Remember that software CMX always generates a more or less delay.
 *
 * If all used features can be realized in hardware, and अगर transmit and/or
 * receive data ist disabled, the card may not send/receive any data at all.
 * Not receiving is useful अगर only announcements are played. Not sending is
 * useful अगर an answering machine records audio. Not sending and receiving is
 * useful during most states of the call. If supported by hardware, tones
 * will be played without cpu load. Small PBXs and NT-Mode applications will
 * not need expensive hardware when processing calls.
 *
 *
 * LOCKING:
 *
 * When data is received from upper or lower layer (card), the complete dsp
 * module is locked by a global lock.  This lock MUST lock irq, because it
 * must lock समयr events by DSP poll समयr.
 * When data is पढ़ोy to be transmitted करोwn, the data is queued and sent
 * outside lock and समयr event.
 * PH_CONTROL must not change any settings, join or split conference members
 * during process of data.
 *
 * HDLC:
 *
 * It works quite the same as transparent, except that HDLC data is क्रमwarded
 * to all other conference members अगर no hardware bridging is possible.
 * Send data will be writte to sendq. Sendq will be sent अगर confirm is received.
 * Conference cannot join, अगर one member is not hdlc.
 *
 */

#समावेश <linux/delay.h>
#समावेश <linux/gfp.h>
#समावेश <linux/mISDNअगर.h>
#समावेश <linux/mISDNdsp.h>
#समावेश <linux/module.h>
#समावेश <linux/vदो_स्मृति.h>
#समावेश "core.h"
#समावेश "dsp.h"

अटल स्थिर अक्षर *mISDN_dsp_revision = "2.0";

अटल पूर्णांक debug;
अटल पूर्णांक options;
अटल पूर्णांक poll;
अटल पूर्णांक dपंचांगfthreshold = 100;

MODULE_AUTHOR("Andreas Eversberg");
module_param(debug, uपूर्णांक, S_IRUGO | S_IWUSR);
module_param(options, uपूर्णांक, S_IRUGO | S_IWUSR);
module_param(poll, uपूर्णांक, S_IRUGO | S_IWUSR);
module_param(dपंचांगfthreshold, uपूर्णांक, S_IRUGO | S_IWUSR);
MODULE_LICENSE("GPL");

/*पूर्णांक spinnest = 0;*/

DEFINE_SPINLOCK(dsp_lock); /* global dsp lock */
LIST_HEAD(dsp_ilist);
LIST_HEAD(conf_ilist);
पूर्णांक dsp_debug;
पूर्णांक dsp_options;
पूर्णांक dsp_poll, dsp_tics;

/* check अगर rx may be turned off or must be turned on */
अटल व्योम
dsp_rx_off_member(काष्ठा dsp *dsp)
अणु
	काष्ठा mISDN_ctrl_req	cq;
	पूर्णांक rx_off = 1;

	स_रखो(&cq, 0, माप(cq));

	अगर (!dsp->features_rx_off)
		वापस;

	/* not disabled */
	अगर (!dsp->rx_disabled)
		rx_off = 0;
	/* software dपंचांगf */
	अन्यथा अगर (dsp->dपंचांगf.software)
		rx_off = 0;
	/* echo in software */
	अन्यथा अगर (dsp->echo.software)
		rx_off = 0;
	/* bridge in software */
	अन्यथा अगर (dsp->conf && dsp->conf->software)
		rx_off = 0;
	/* data is not required by user space and not required
	 * क्रम echo dपंचांगf detection, soft-echo, soft-bridging */

	अगर (rx_off == dsp->rx_is_off)
		वापस;

	अगर (!dsp->ch.peer) अणु
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: no peer, no rx_off\n",
			       __func__);
		वापस;
	पूर्ण
	cq.op = MISDN_CTRL_RX_OFF;
	cq.p1 = rx_off;
	अगर (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) अणु
		prपूर्णांकk(KERN_DEBUG "%s: 2nd CONTROL_CHANNEL failed\n",
		       __func__);
		वापस;
	पूर्ण
	dsp->rx_is_off = rx_off;
	अगर (dsp_debug & DEBUG_DSP_CORE)
		prपूर्णांकk(KERN_DEBUG "%s: %s set rx_off = %d\n",
		       __func__, dsp->name, rx_off);
पूर्ण
अटल व्योम
dsp_rx_off(काष्ठा dsp *dsp)
अणु
	काष्ठा dsp_conf_member	*member;

	अगर (dsp_options & DSP_OPT_NOHARDWARE)
		वापस;

	/* no conf */
	अगर (!dsp->conf) अणु
		dsp_rx_off_member(dsp);
		वापस;
	पूर्ण
	/* check all members in conf */
	list_क्रम_each_entry(member, &dsp->conf->mlist, list) अणु
		dsp_rx_off_member(member->dsp);
	पूर्ण
पूर्ण

/* enable "fill empty" feature */
अटल व्योम
dsp_fill_empty(काष्ठा dsp *dsp)
अणु
	काष्ठा mISDN_ctrl_req	cq;

	स_रखो(&cq, 0, माप(cq));

	अगर (!dsp->ch.peer) अणु
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: no peer, no fill_empty\n",
			       __func__);
		वापस;
	पूर्ण
	cq.op = MISDN_CTRL_FILL_EMPTY;
	cq.p1 = 1;
	cq.p2 = dsp_silence;
	अगर (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) अणु
		prपूर्णांकk(KERN_DEBUG "%s: CONTROL_CHANNEL failed\n",
		       __func__);
		वापस;
	पूर्ण
	अगर (dsp_debug & DEBUG_DSP_CORE)
		prपूर्णांकk(KERN_DEBUG "%s: %s set fill_empty = 1\n",
		       __func__, dsp->name);
पूर्ण

अटल पूर्णांक
dsp_control_req(काष्ठा dsp *dsp, काष्ठा mISDNhead *hh, काष्ठा sk_buff *skb)
अणु
	काष्ठा sk_buff	*nskb;
	पूर्णांक ret = 0;
	पूर्णांक cont;
	u8 *data;
	पूर्णांक len;

	अगर (skb->len < माप(पूर्णांक)) अणु
		prपूर्णांकk(KERN_ERR "%s: PH_CONTROL message too short\n", __func__);
		वापस -EINVAL;
	पूर्ण
	cont = *((पूर्णांक *)skb->data);
	len = skb->len - माप(पूर्णांक);
	data = skb->data + माप(पूर्णांक);

	चयन (cont) अणु
	हाल DTMF_TONE_START: /* turn on DTMF */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: start dtmf\n", __func__);
		अगर (len == माप(पूर्णांक)) अणु
			अगर (dsp_debug & DEBUG_DSP_CORE)
				prपूर्णांकk(KERN_NOTICE "changing DTMF Threshold "
				       "to %d\n", *((पूर्णांक *)data));
			dsp->dपंचांगf.treshold = (*(पूर्णांक *)data) * 10000;
		पूर्ण
		dsp->dपंचांगf.enable = 1;
		/* init goertzel */
		dsp_dपंचांगf_goertzel_init(dsp);

		/* check dपंचांगf hardware */
		dsp_dपंचांगf_hardware(dsp);
		dsp_rx_off(dsp);
		अवरोध;
	हाल DTMF_TONE_STOP: /* turn off DTMF */
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: stop dtmf\n", __func__);
		dsp->dपंचांगf.enable = 0;
		dsp->dपंचांगf.hardware = 0;
		dsp->dपंचांगf.software = 0;
		अवरोध;
	हाल DSP_CONF_JOIN: /* join / update conference */
		अगर (len < माप(पूर्णांक)) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (*((u32 *)data) == 0)
			जाओ conf_split;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: join conference %d\n",
			       __func__, *((u32 *)data));
		ret = dsp_cmx_conf(dsp, *((u32 *)data));
		/* dsp_cmx_hardware will also be called here */
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_CONF_SPLIT: /* हटाओ from conference */
	conf_split:
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: release conference\n", __func__);
		ret = dsp_cmx_conf(dsp, 0);
		/* dsp_cmx_hardware will also be called here */
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		dsp_rx_off(dsp);
		अवरोध;
	हाल DSP_TONE_PATT_ON: /* play tone */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len < माप(पूर्णांक)) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: turn tone 0x%x on\n",
			       __func__, *((पूर्णांक *)skb->data));
		ret = dsp_tone(dsp, *((पूर्णांक *)data));
		अगर (!ret) अणु
			dsp_cmx_hardware(dsp->conf, dsp);
			dsp_rx_off(dsp);
		पूर्ण
		अगर (!dsp->tone.tone)
			जाओ tone_off;
		अवरोध;
	हाल DSP_TONE_PATT_OFF: /* stop tone */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: turn tone off\n", __func__);
		dsp_tone(dsp, 0);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		/* reset tx buffers (user space data) */
	tone_off:
		dsp->rx_W = 0;
		dsp->rx_R = 0;
		अवरोध;
	हाल DSP_VOL_CHANGE_TX: /* change volume */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len < माप(पूर्णांक)) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->tx_volume = *((पूर्णांक *)data);
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: change tx vol to %d\n",
			       __func__, dsp->tx_volume);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_dपंचांगf_hardware(dsp);
		dsp_rx_off(dsp);
		अवरोध;
	हाल DSP_VOL_CHANGE_RX: /* change volume */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len < माप(पूर्णांक)) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->rx_volume = *((पूर्णांक *)data);
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: change rx vol to %d\n",
			       __func__, dsp->tx_volume);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_dपंचांगf_hardware(dsp);
		dsp_rx_off(dsp);
		अवरोध;
	हाल DSP_ECHO_ON: /* enable echo */
		dsp->echo.software = 1; /* soft echo */
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: enable cmx-echo\n", __func__);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_ECHO_OFF: /* disable echo */
		dsp->echo.software = 0;
		dsp->echo.hardware = 0;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: disable cmx-echo\n", __func__);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_RECEIVE_ON: /* enable receive to user space */
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: enable receive to user "
			       "space\n", __func__);
		dsp->rx_disabled = 0;
		dsp_rx_off(dsp);
		अवरोध;
	हाल DSP_RECEIVE_OFF: /* disable receive to user space */
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: disable receive to "
			       "user space\n", __func__);
		dsp->rx_disabled = 1;
		dsp_rx_off(dsp);
		अवरोध;
	हाल DSP_MIX_ON: /* enable mixing of tx data */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: enable mixing of "
			       "tx-data with conf members\n", __func__);
		dsp->tx_mix = 1;
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_MIX_OFF: /* disable mixing of tx data */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: disable mixing of "
			       "tx-data with conf members\n", __func__);
		dsp->tx_mix = 0;
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_TXDATA_ON: /* enable txdata */
		dsp->tx_data = 1;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: enable tx-data\n", __func__);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_TXDATA_OFF: /* disable txdata */
		dsp->tx_data = 0;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: disable tx-data\n", __func__);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		अगर (dsp_debug & DEBUG_DSP_CMX)
			dsp_cmx_debug(dsp);
		अवरोध;
	हाल DSP_DELAY: /* use delay algorithm instead of dynamic
			   jitter algorithm */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len < माप(पूर्णांक)) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->cmx_delay = (*((पूर्णांक *)data)) << 3;
		/* milliseconds to samples */
		अगर (dsp->cmx_delay >= (CMX_BUFF_HALF >> 1))
			/* clip to half of maximum usable buffer
			   (half of half buffer) */
			dsp->cmx_delay = (CMX_BUFF_HALF >> 1) - 1;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: use delay algorithm to "
			       "compensate jitter (%d samples)\n",
			       __func__, dsp->cmx_delay);
		अवरोध;
	हाल DSP_JITTER: /* use dynamic jitter algorithm instead of
			    delay algorithm */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->cmx_delay = 0;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: use jitter algorithm to "
			       "compensate jitter\n", __func__);
		अवरोध;
	हाल DSP_TX_DEJITTER: /* use dynamic jitter algorithm क्रम tx-buffer */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->tx_dejitter = 1;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: use dejitter on TX "
			       "buffer\n", __func__);
		अवरोध;
	हाल DSP_TX_DEJ_OFF: /* use tx-buffer without dejittering*/
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		dsp->tx_dejitter = 0;
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: use TX buffer without "
			       "dejittering\n", __func__);
		अवरोध;
	हाल DSP_PIPELINE_CFG:
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len > 0 && ((अक्षर *)data)[len - 1]) अणु
			prपूर्णांकk(KERN_DEBUG "%s: pipeline config string "
			       "is not NULL terminated!\n", __func__);
			ret = -EINVAL;
		पूर्ण अन्यथा अणु
			dsp->pipeline.inuse = 1;
			dsp_cmx_hardware(dsp->conf, dsp);
			ret = dsp_pipeline_build(&dsp->pipeline,
						 len > 0 ? data : शून्य);
			dsp_cmx_hardware(dsp->conf, dsp);
			dsp_rx_off(dsp);
		पूर्ण
		अवरोध;
	हाल DSP_BF_ENABLE_KEY: /* turn blowfish on */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (len < 4 || len > 56) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: turn blowfish on (key "
			       "not shown)\n", __func__);
		ret = dsp_bf_init(dsp, (u8 *)data, len);
		/* set new cont */
		अगर (!ret)
			cont = DSP_BF_ACCEPT;
		अन्यथा
			cont = DSP_BF_REJECT;
		/* send indication अगर it worked to set it */
		nskb = _alloc_mISDN_skb(PH_CONTROL_IND, MISDN_ID_ANY,
					माप(पूर्णांक), &cont, GFP_ATOMIC);
		अगर (nskb) अणु
			अगर (dsp->up) अणु
				अगर (dsp->up->send(dsp->up, nskb))
					dev_kमुक्त_skb(nskb);
			पूर्ण अन्यथा
				dev_kमुक्त_skb(nskb);
		पूर्ण
		अगर (!ret) अणु
			dsp_cmx_hardware(dsp->conf, dsp);
			dsp_dपंचांगf_hardware(dsp);
			dsp_rx_off(dsp);
		पूर्ण
		अवरोध;
	हाल DSP_BF_DISABLE: /* turn blowfish off */
		अगर (dsp->hdlc) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: turn blowfish off\n", __func__);
		dsp_bf_cleanup(dsp);
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_dपंचांगf_hardware(dsp);
		dsp_rx_off(dsp);
		अवरोध;
	शेष:
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: ctrl req %x unhandled\n",
			       __func__, cont);
		ret = -EINVAL;
	पूर्ण
	वापस ret;
पूर्ण

अटल व्योम
get_features(काष्ठा mISDNchannel *ch)
अणु
	काष्ठा dsp		*dsp = container_of(ch, काष्ठा dsp, ch);
	काष्ठा mISDN_ctrl_req	cq;

	अगर (!ch->peer) अणु
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: no peer, no features\n",
			       __func__);
		वापस;
	पूर्ण
	स_रखो(&cq, 0, माप(cq));
	cq.op = MISDN_CTRL_GETOP;
	अगर (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq) < 0) अणु
		prपूर्णांकk(KERN_DEBUG "%s: CONTROL_CHANNEL failed\n",
		       __func__);
		वापस;
	पूर्ण
	अगर (cq.op & MISDN_CTRL_RX_OFF)
		dsp->features_rx_off = 1;
	अगर (cq.op & MISDN_CTRL_FILL_EMPTY)
		dsp->features_fill_empty = 1;
	अगर (dsp_options & DSP_OPT_NOHARDWARE)
		वापस;
	अगर ((cq.op & MISDN_CTRL_HW_FEATURES_OP)) अणु
		cq.op = MISDN_CTRL_HW_FEATURES;
		*((u_दीर्घ *)&cq.p1) = (u_दीर्घ)&dsp->features;
		अगर (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq)) अणु
			prपूर्णांकk(KERN_DEBUG "%s: 2nd CONTROL_CHANNEL failed\n",
			       __func__);
		पूर्ण
	पूर्ण अन्यथा
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: features not supported for %s\n",
			       __func__, dsp->name);
पूर्ण

अटल पूर्णांक
dsp_function(काष्ठा mISDNchannel *ch,  काष्ठा sk_buff *skb)
अणु
	काष्ठा dsp		*dsp = container_of(ch, काष्ठा dsp, ch);
	काष्ठा mISDNhead	*hh;
	पूर्णांक			ret = 0;
	u8			*digits = शून्य;
	u_दीर्घ			flags;

	hh = mISDN_HEAD_P(skb);
	चयन (hh->prim) अणु
		/* FROM DOWN */
	हाल (PH_DATA_CNF):
		dsp->data_pending = 0;
		/* trigger next hdlc frame, अगर any */
		अगर (dsp->hdlc) अणु
			spin_lock_irqsave(&dsp_lock, flags);
			अगर (dsp->b_active)
				schedule_work(&dsp->workq);
			spin_unlock_irqrestore(&dsp_lock, flags);
		पूर्ण
		अवरोध;
	हाल (PH_DATA_IND):
	हाल (DL_DATA_IND):
		अगर (skb->len < 1) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp->rx_is_off) अणु
			अगर (dsp_debug & DEBUG_DSP_CORE)
				prपूर्णांकk(KERN_DEBUG "%s: rx-data during rx_off"
				       " for %s\n",
				       __func__, dsp->name);
		पूर्ण
		अगर (dsp->hdlc) अणु
			/* hdlc */
			spin_lock_irqsave(&dsp_lock, flags);
			dsp_cmx_hdlc(dsp, skb);
			spin_unlock_irqrestore(&dsp_lock, flags);
			अगर (dsp->rx_disabled) अणु
				/* अगर receive is not allowed */
				अवरोध;
			पूर्ण
			hh->prim = DL_DATA_IND;
			अगर (dsp->up)
				वापस dsp->up->send(dsp->up, skb);
			अवरोध;
		पूर्ण

		spin_lock_irqsave(&dsp_lock, flags);

		/* decrypt अगर enabled */
		अगर (dsp->bf_enable)
			dsp_bf_decrypt(dsp, skb->data, skb->len);
		/* pipeline */
		अगर (dsp->pipeline.inuse)
			dsp_pipeline_process_rx(&dsp->pipeline, skb->data,
						skb->len, hh->id);
		/* change volume अगर requested */
		अगर (dsp->rx_volume)
			dsp_change_volume(skb, dsp->rx_volume);
		/* check अगर dपंचांगf soft decoding is turned on */
		अगर (dsp->dपंचांगf.software) अणु
			digits = dsp_dपंचांगf_goertzel_decode(dsp, skb->data,
							  skb->len, (dsp_options & DSP_OPT_ULAW) ? 1 : 0);
		पूर्ण
		/* we need to process receive data अगर software */
		अगर (dsp->conf && dsp->conf->software) अणु
			/* process data from card at cmx */
			dsp_cmx_receive(dsp, skb);
		पूर्ण

		spin_unlock_irqrestore(&dsp_lock, flags);

		/* send dपंचांगf result, अगर any */
		अगर (digits) अणु
			जबतक (*digits) अणु
				पूर्णांक k;
				काष्ठा sk_buff *nskb;
				अगर (dsp_debug & DEBUG_DSP_DTMF)
					prपूर्णांकk(KERN_DEBUG "%s: digit"
					       "(%c) to layer %s\n",
					       __func__, *digits, dsp->name);
				k = *digits | DTMF_TONE_VAL;
				nskb = _alloc_mISDN_skb(PH_CONTROL_IND,
							MISDN_ID_ANY, माप(पूर्णांक), &k,
							GFP_ATOMIC);
				अगर (nskb) अणु
					अगर (dsp->up) अणु
						अगर (dsp->up->send(
							    dsp->up, nskb))
							dev_kमुक्त_skb(nskb);
					पूर्ण अन्यथा
						dev_kमुक्त_skb(nskb);
				पूर्ण
				digits++;
			पूर्ण
		पूर्ण
		अगर (dsp->rx_disabled) अणु
			/* अगर receive is not allowed */
			अवरोध;
		पूर्ण
		hh->prim = DL_DATA_IND;
		अगर (dsp->up)
			वापस dsp->up->send(dsp->up, skb);
		अवरोध;
	हाल (PH_CONTROL_IND):
		अगर (dsp_debug & DEBUG_DSP_DTMFCOEFF)
			prपूर्णांकk(KERN_DEBUG "%s: PH_CONTROL INDICATION "
			       "received: %x (len %d) %s\n", __func__,
			       hh->id, skb->len, dsp->name);
		चयन (hh->id) अणु
		हाल (DTMF_HFC_COEF): /* getting coefficients */
			अगर (!dsp->dपंचांगf.hardware) अणु
				अगर (dsp_debug & DEBUG_DSP_DTMFCOEFF)
					prपूर्णांकk(KERN_DEBUG "%s: ignoring DTMF "
					       "coefficients from HFC\n",
					       __func__);
				अवरोध;
			पूर्ण
			digits = dsp_dपंचांगf_goertzel_decode(dsp, skb->data,
							  skb->len, 2);
			जबतक (*digits) अणु
				पूर्णांक k;
				काष्ठा sk_buff *nskb;
				अगर (dsp_debug & DEBUG_DSP_DTMF)
					prपूर्णांकk(KERN_DEBUG "%s: digit"
					       "(%c) to layer %s\n",
					       __func__, *digits, dsp->name);
				k = *digits | DTMF_TONE_VAL;
				nskb = _alloc_mISDN_skb(PH_CONTROL_IND,
							MISDN_ID_ANY, माप(पूर्णांक), &k,
							GFP_ATOMIC);
				अगर (nskb) अणु
					अगर (dsp->up) अणु
						अगर (dsp->up->send(
							    dsp->up, nskb))
							dev_kमुक्त_skb(nskb);
					पूर्ण अन्यथा
						dev_kमुक्त_skb(nskb);
				पूर्ण
				digits++;
			पूर्ण
			अवरोध;
		हाल (HFC_VOL_CHANGE_TX): /* change volume */
			अगर (skb->len != माप(पूर्णांक)) अणु
				ret = -EINVAL;
				अवरोध;
			पूर्ण
			spin_lock_irqsave(&dsp_lock, flags);
			dsp->tx_volume = *((पूर्णांक *)skb->data);
			अगर (dsp_debug & DEBUG_DSP_CORE)
				prपूर्णांकk(KERN_DEBUG "%s: change tx volume to "
				       "%d\n", __func__, dsp->tx_volume);
			dsp_cmx_hardware(dsp->conf, dsp);
			dsp_dपंचांगf_hardware(dsp);
			dsp_rx_off(dsp);
			spin_unlock_irqrestore(&dsp_lock, flags);
			अवरोध;
		शेष:
			अगर (dsp_debug & DEBUG_DSP_CORE)
				prपूर्णांकk(KERN_DEBUG "%s: ctrl ind %x unhandled "
				       "%s\n", __func__, hh->id, dsp->name);
			ret = -EINVAL;
		पूर्ण
		अवरोध;
	हाल (PH_ACTIVATE_IND):
	हाल (PH_ACTIVATE_CNF):
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: b_channel is now active %s\n",
			       __func__, dsp->name);
		/* bchannel now active */
		spin_lock_irqsave(&dsp_lock, flags);
		dsp->b_active = 1;
		dsp->data_pending = 0;
		dsp->rx_init = 1;
		/* rx_W and rx_R will be adjusted on first frame */
		dsp->rx_W = 0;
		dsp->rx_R = 0;
		स_रखो(dsp->rx_buff, 0, माप(dsp->rx_buff));
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_dपंचांगf_hardware(dsp);
		dsp_rx_off(dsp);
		spin_unlock_irqrestore(&dsp_lock, flags);
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: done with activation, sending "
			       "confirm to user space. %s\n", __func__,
			       dsp->name);
		/* send activation to upper layer */
		hh->prim = DL_ESTABLISH_CNF;
		अगर (dsp->up)
			वापस dsp->up->send(dsp->up, skb);
		अवरोध;
	हाल (PH_DEACTIVATE_IND):
	हाल (PH_DEACTIVATE_CNF):
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: b_channel is now inactive %s\n",
			       __func__, dsp->name);
		/* bchannel now inactive */
		spin_lock_irqsave(&dsp_lock, flags);
		dsp->b_active = 0;
		dsp->data_pending = 0;
		dsp_cmx_hardware(dsp->conf, dsp);
		dsp_rx_off(dsp);
		spin_unlock_irqrestore(&dsp_lock, flags);
		hh->prim = DL_RELEASE_CNF;
		अगर (dsp->up)
			वापस dsp->up->send(dsp->up, skb);
		अवरोध;
		/* FROM UP */
	हाल (DL_DATA_REQ):
	हाल (PH_DATA_REQ):
		अगर (skb->len < 1) अणु
			ret = -EINVAL;
			अवरोध;
		पूर्ण
		अगर (dsp->hdlc) अणु
			/* hdlc */
			अगर (!dsp->b_active) अणु
				ret = -EIO;
				अवरोध;
			पूर्ण
			hh->prim = PH_DATA_REQ;
			spin_lock_irqsave(&dsp_lock, flags);
			skb_queue_tail(&dsp->sendq, skb);
			schedule_work(&dsp->workq);
			spin_unlock_irqrestore(&dsp_lock, flags);
			वापस 0;
		पूर्ण
		/* send data to tx-buffer (अगर no tone is played) */
		अगर (!dsp->tone.tone) अणु
			spin_lock_irqsave(&dsp_lock, flags);
			dsp_cmx_transmit(dsp, skb);
			spin_unlock_irqrestore(&dsp_lock, flags);
		पूर्ण
		अवरोध;
	हाल (PH_CONTROL_REQ):
		spin_lock_irqsave(&dsp_lock, flags);
		ret = dsp_control_req(dsp, hh, skb);
		spin_unlock_irqrestore(&dsp_lock, flags);
		अवरोध;
	हाल (DL_ESTABLISH_REQ):
	हाल (PH_ACTIVATE_REQ):
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: activating b_channel %s\n",
			       __func__, dsp->name);
		अगर (dsp->dपंचांगf.hardware || dsp->dपंचांगf.software)
			dsp_dपंचांगf_goertzel_init(dsp);
		get_features(ch);
		/* enable fill_empty feature */
		अगर (dsp->features_fill_empty)
			dsp_fill_empty(dsp);
		/* send ph_activate */
		hh->prim = PH_ACTIVATE_REQ;
		अगर (ch->peer)
			वापस ch->recv(ch->peer, skb);
		अवरोध;
	हाल (DL_RELEASE_REQ):
	हाल (PH_DEACTIVATE_REQ):
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: releasing b_channel %s\n",
			       __func__, dsp->name);
		spin_lock_irqsave(&dsp_lock, flags);
		dsp->tone.tone = 0;
		dsp->tone.hardware = 0;
		dsp->tone.software = 0;
		अगर (समयr_pending(&dsp->tone.tl))
			del_समयr(&dsp->tone.tl);
		अगर (dsp->conf)
			dsp_cmx_conf(dsp, 0); /* dsp_cmx_hardware will also be
						 called here */
		skb_queue_purge(&dsp->sendq);
		spin_unlock_irqrestore(&dsp_lock, flags);
		hh->prim = PH_DEACTIVATE_REQ;
		अगर (ch->peer)
			वापस ch->recv(ch->peer, skb);
		अवरोध;
	शेष:
		अगर (dsp_debug & DEBUG_DSP_CORE)
			prपूर्णांकk(KERN_DEBUG "%s: msg %x unhandled %s\n",
			       __func__, hh->prim, dsp->name);
		ret = -EINVAL;
	पूर्ण
	अगर (!ret)
		dev_kमुक्त_skb(skb);
	वापस ret;
पूर्ण

अटल पूर्णांक
dsp_ctrl(काष्ठा mISDNchannel *ch, u_पूर्णांक cmd, व्योम *arg)
अणु
	काष्ठा dsp		*dsp = container_of(ch, काष्ठा dsp, ch);
	u_दीर्घ		flags;

	अगर (debug & DEBUG_DSP_CTRL)
		prपूर्णांकk(KERN_DEBUG "%s:(%x)\n", __func__, cmd);

	चयन (cmd) अणु
	हाल OPEN_CHANNEL:
		अवरोध;
	हाल CLOSE_CHANNEL:
		अगर (dsp->ch.peer)
			dsp->ch.peer->ctrl(dsp->ch.peer, CLOSE_CHANNEL, शून्य);

		/* रुको until workqueue has finished,
		 * must lock here, or we may hit send-process currently
		 * queueing. */
		spin_lock_irqsave(&dsp_lock, flags);
		dsp->b_active = 0;
		spin_unlock_irqrestore(&dsp_lock, flags);
		/* MUST not be locked, because it रुकोs until queue is करोne. */
		cancel_work_sync(&dsp->workq);
		spin_lock_irqsave(&dsp_lock, flags);
		अगर (समयr_pending(&dsp->tone.tl))
			del_समयr(&dsp->tone.tl);
		skb_queue_purge(&dsp->sendq);
		अगर (dsp_debug & DEBUG_DSP_CTRL)
			prपूर्णांकk(KERN_DEBUG "%s: releasing member %s\n",
			       __func__, dsp->name);
		dsp->b_active = 0;
		dsp_cmx_conf(dsp, 0); /* dsp_cmx_hardware will also be called
					 here */
		dsp_pipeline_destroy(&dsp->pipeline);

		अगर (dsp_debug & DEBUG_DSP_CTRL)
			prपूर्णांकk(KERN_DEBUG "%s: remove & destroy object %s\n",
			       __func__, dsp->name);
		list_del(&dsp->list);
		spin_unlock_irqrestore(&dsp_lock, flags);

		अगर (dsp_debug & DEBUG_DSP_CTRL)
			prपूर्णांकk(KERN_DEBUG "%s: dsp instance released\n",
			       __func__);
		vमुक्त(dsp);
		module_put(THIS_MODULE);
		अवरोध;
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम
dsp_send_bh(काष्ठा work_काष्ठा *work)
अणु
	काष्ठा dsp *dsp = container_of(work, काष्ठा dsp, workq);
	काष्ठा sk_buff *skb;
	काष्ठा mISDNhead	*hh;

	अगर (dsp->hdlc && dsp->data_pending)
		वापस; /* रुको until data has been acknowledged */

	/* send queued data */
	जबतक ((skb = skb_dequeue(&dsp->sendq))) अणु
		/* in locked date, we must have still data in queue */
		अगर (dsp->data_pending) अणु
			अगर (dsp_debug & DEBUG_DSP_CORE)
				prपूर्णांकk(KERN_DEBUG "%s: fifo full %s, this is "
				       "no bug!\n", __func__, dsp->name);
			/* flush transparent data, अगर not acked */
			dev_kमुक्त_skb(skb);
			जारी;
		पूर्ण
		hh = mISDN_HEAD_P(skb);
		अगर (hh->prim == DL_DATA_REQ) अणु
			/* send packet up */
			अगर (dsp->up) अणु
				अगर (dsp->up->send(dsp->up, skb))
					dev_kमुक्त_skb(skb);
			पूर्ण अन्यथा
				dev_kमुक्त_skb(skb);
		पूर्ण अन्यथा अणु
			/* send packet करोwn */
			अगर (dsp->ch.peer) अणु
				dsp->data_pending = 1;
				अगर (dsp->ch.recv(dsp->ch.peer, skb)) अणु
					dev_kमुक्त_skb(skb);
					dsp->data_pending = 0;
				पूर्ण
			पूर्ण अन्यथा
				dev_kमुक्त_skb(skb);
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक
dspcreate(काष्ठा channel_req *crq)
अणु
	काष्ठा dsp		*ndsp;
	u_दीर्घ		flags;

	अगर (crq->protocol != ISDN_P_B_L2DSP
	    && crq->protocol != ISDN_P_B_L2DSPHDLC)
		वापस -EPROTONOSUPPORT;
	ndsp = vzalloc(माप(काष्ठा dsp));
	अगर (!ndsp) अणु
		prपूर्णांकk(KERN_ERR "%s: vmalloc struct dsp failed\n", __func__);
		वापस -ENOMEM;
	पूर्ण
	अगर (dsp_debug & DEBUG_DSP_CTRL)
		prपूर्णांकk(KERN_DEBUG "%s: creating new dsp instance\n", __func__);

	/* शेष enabled */
	INIT_WORK(&ndsp->workq, (व्योम *)dsp_send_bh);
	skb_queue_head_init(&ndsp->sendq);
	ndsp->ch.send = dsp_function;
	ndsp->ch.ctrl = dsp_ctrl;
	ndsp->up = crq->ch;
	crq->ch = &ndsp->ch;
	अगर (crq->protocol == ISDN_P_B_L2DSP) अणु
		crq->protocol = ISDN_P_B_RAW;
		ndsp->hdlc = 0;
	पूर्ण अन्यथा अणु
		crq->protocol = ISDN_P_B_HDLC;
		ndsp->hdlc = 1;
	पूर्ण
	अगर (!try_module_get(THIS_MODULE))
		prपूर्णांकk(KERN_WARNING "%s:cannot get module\n",
		       __func__);

	प्र_लिखो(ndsp->name, "DSP_C%x(0x%p)",
		ndsp->up->st->dev->id + 1, ndsp);
	/* set frame size to start */
	ndsp->features.hfc_id = -1; /* current PCM id */
	ndsp->features.pcm_id = -1; /* current PCM id */
	ndsp->pcm_slot_rx = -1; /* current CPM slot */
	ndsp->pcm_slot_tx = -1;
	ndsp->pcm_bank_rx = -1;
	ndsp->pcm_bank_tx = -1;
	ndsp->hfc_conf = -1; /* current conference number */
	/* set tone समयr */
	समयr_setup(&ndsp->tone.tl, dsp_tone_समयout, 0);

	अगर (dपंचांगfthreshold < 20 || dपंचांगfthreshold > 500)
		dपंचांगfthreshold = 200;
	ndsp->dपंचांगf.treshold = dपंचांगfthreshold * 10000;

	/* init pipeline append to list */
	spin_lock_irqsave(&dsp_lock, flags);
	dsp_pipeline_init(&ndsp->pipeline);
	list_add_tail(&ndsp->list, &dsp_ilist);
	spin_unlock_irqrestore(&dsp_lock, flags);

	वापस 0;
पूर्ण


अटल काष्ठा Bprotocol DSP = अणु
	.Bprotocols = (1 << (ISDN_P_B_L2DSP & ISDN_P_B_MASK))
	| (1 << (ISDN_P_B_L2DSPHDLC & ISDN_P_B_MASK)),
	.name = "dsp",
	.create = dspcreate
पूर्ण;

अटल पूर्णांक __init dsp_init(व्योम)
अणु
	पूर्णांक err;
	पूर्णांक tics;

	prपूर्णांकk(KERN_INFO "DSP module %s\n", mISDN_dsp_revision);

	dsp_options = options;
	dsp_debug = debug;

	/* set packet size */
	dsp_poll = poll;
	अगर (dsp_poll) अणु
		अगर (dsp_poll > MAX_POLL) अणु
			prपूर्णांकk(KERN_ERR "%s: Wrong poll value (%d), use %d "
			       "maximum.\n", __func__, poll, MAX_POLL);
			err = -EINVAL;
			वापस err;
		पूर्ण
		अगर (dsp_poll < 8) अणु
			prपूर्णांकk(KERN_ERR "%s: Wrong poll value (%d), use 8 "
			       "minimum.\n", __func__, dsp_poll);
			err = -EINVAL;
			वापस err;
		पूर्ण
		dsp_tics = poll * HZ / 8000;
		अगर (dsp_tics * 8000 != poll * HZ) अणु
			prपूर्णांकk(KERN_INFO "mISDN_dsp: Cannot clock every %d "
			       "samples (0,125 ms). It is not a multiple of "
			       "%d HZ.\n", poll, HZ);
			err = -EINVAL;
			वापस err;
		पूर्ण
	पूर्ण अन्यथा अणु
		poll = 8;
		जबतक (poll <= MAX_POLL) अणु
			tics = (poll * HZ) / 8000;
			अगर (tics * 8000 == poll * HZ) अणु
				dsp_tics = tics;
				dsp_poll = poll;
				अगर (poll >= 64)
					अवरोध;
			पूर्ण
			poll++;
		पूर्ण
	पूर्ण
	अगर (dsp_poll == 0) अणु
		prपूर्णांकk(KERN_INFO "mISDN_dsp: There is no multiple of kernel "
		       "clock that equals exactly the duration of 8-256 "
		       "samples. (Choose kernel clock speed like 100, 250, "
		       "300, 1000)\n");
		err = -EINVAL;
		वापस err;
	पूर्ण
	prपूर्णांकk(KERN_INFO "mISDN_dsp: DSP clocks every %d samples. This equals "
	       "%d jiffies.\n", dsp_poll, dsp_tics);

	/* init conversion tables */
	dsp_audio_generate_law_tables();
	dsp_silence = (dsp_options & DSP_OPT_ULAW) ? 0xff : 0x2a;
	dsp_audio_law_to_s32 = (dsp_options & DSP_OPT_ULAW) ?
		dsp_audio_ulaw_to_s32 : dsp_audio_alaw_to_s32;
	dsp_audio_generate_s2law_table();
	dsp_audio_generate_seven();
	dsp_audio_generate_mix_table();
	अगर (dsp_options & DSP_OPT_ULAW)
		dsp_audio_generate_ulaw_samples();
	dsp_audio_generate_volume_changes();

	err = dsp_pipeline_module_init();
	अगर (err) अणु
		prपूर्णांकk(KERN_ERR "mISDN_dsp: Can't initialize pipeline, "
		       "error(%d)\n", err);
		वापस err;
	पूर्ण

	err = mISDN_रेजिस्टर_Bprotocol(&DSP);
	अगर (err) अणु
		prपूर्णांकk(KERN_ERR "Can't register %s error(%d)\n", DSP.name, err);
		वापस err;
	पूर्ण

	/* set sample समयr */
	समयr_setup(&dsp_spl_tl, (व्योम *)dsp_cmx_send, 0);
	dsp_spl_tl.expires = jअगरfies + dsp_tics;
	dsp_spl_jअगरfies = dsp_spl_tl.expires;
	add_समयr(&dsp_spl_tl);

	वापस 0;
पूर्ण


अटल व्योम __निकास dsp_cleanup(व्योम)
अणु
	mISDN_unरेजिस्टर_Bprotocol(&DSP);

	del_समयr_sync(&dsp_spl_tl);

	अगर (!list_empty(&dsp_ilist)) अणु
		prपूर्णांकk(KERN_ERR "mISDN_dsp: Audio DSP object inst list not "
		       "empty.\n");
	पूर्ण
	अगर (!list_empty(&conf_ilist)) अणु
		prपूर्णांकk(KERN_ERR "mISDN_dsp: Conference list not empty. Not "
		       "all memory freed.\n");
	पूर्ण

	dsp_pipeline_module_निकास();
पूर्ण

module_init(dsp_init);
module_निकास(dsp_cleanup);
