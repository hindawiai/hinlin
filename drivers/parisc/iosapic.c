<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*
** I/O Sapic Driver - PCI पूर्णांकerrupt line support
**
**      (c) Copyright 1999 Grant Grundler
**      (c) Copyright 1999 Hewlett-Packard Company
**
**
** The I/O sapic driver manages the Interrupt Redirection Table which is
** the control logic to convert PCI line based पूर्णांकerrupts पूर्णांकo a Message
** Signaled Interrupt (aka Transaction Based Interrupt, TBI).
**
** Acronyms
** --------
** HPA  Hard Physical Address (aka MMIO address)
** IRQ  Interrupt ReQuest. Implies Line based पूर्णांकerrupt.
** IRT	Interrupt Routing Table (provided by PAT firmware)
** IRdT Interrupt Redirection Table. IRQ line to TXN ADDR/DATA
**      table which is implemented in I/O SAPIC.
** ISR  Interrupt Service Routine. aka Interrupt handler.
** MSI	Message Signaled Interrupt. PCI 2.2 functionality.
**      aka Transaction Based Interrupt (or TBI).
** PA   Precision Architecture. HP's RISC architecture.
** RISC Reduced Inकाष्ठाion Set Computer.
**
**
** What's a Message Signalled Interrupt?
** -------------------------------------
** MSI is a ग_लिखो transaction which tarमाला_लो a processor and is similar
** to a processor ग_लिखो to memory or MMIO. MSIs can be generated by I/O
** devices as well as processors and require *architecture* to work.
**
** PA only supports MSI. So I/O subप्रणालीs must either natively generate
** MSIs (e.g. GSC or HP-PB) or convert line based पूर्णांकerrupts पूर्णांकo MSIs
** (e.g. PCI and EISA).  IA64 supports MSIs via a "local SAPIC" which
** acts on behalf of a processor.
**
** MSI allows any I/O device to पूर्णांकerrupt any processor. This makes
** load balancing of the पूर्णांकerrupt processing possible on an SMP platक्रमm.
** Interrupts are also ordered WRT to DMA data.  It's possible on I/O
** coherent प्रणालीs to completely eliminate PIO पढ़ोs from the पूर्णांकerrupt
** path. The device and driver must be deचिन्हित and implemented to
** guarantee all DMA has been issued (issues about atomicity here)
** beक्रमe the MSI is issued. I/O status can then safely be पढ़ो from
** DMA'd data by the ISR.
**
**
** PA Firmware
** -----------
** PA-RISC platक्रमms have two fundamentally dअगरferent types of firmware.
** For PCI devices, "Legacy" PDC initializes the "INTERRUPT_LINE" रेजिस्टर
** and BARs similar to a traditional PC BIOS.
** The newer "PAT" firmware supports PDC calls which वापस tables.
** PAT firmware only initializes the PCI Console and Boot पूर्णांकerface.
** With these tables, the OS can program all other PCI devices.
**
** One such PAT PDC call वापसs the "Interrupt Routing Table" (IRT).
** The IRT maps each PCI slot's INTA-D "output" line to an I/O SAPIC
** input line.  If the IRT is not available, this driver assumes
** INTERRUPT_LINE रेजिस्टर has been programmed by firmware. The latter
** हाल also means online addition of PCI cards can NOT be supported
** even अगर HW support is present.
**
** All platक्रमms with PAT firmware to date (Oct 1999) use one Interrupt
** Routing Table क्रम the entire platक्रमm.
**
** Where's the iosapic?
** --------------------
** I/O sapic is part of the "Core Electronics Complex". And on HP platक्रमms
** it's पूर्णांकegrated as part of the PCI bus adapter, "lba".  So no bus walk
** will discover I/O Sapic. I/O Sapic driver learns about each device
** when lba driver advertises the presence of the I/O sapic by calling
** iosapic_रेजिस्टर().
**
**
** IRQ handling notes
** ------------------
** The IO-SAPIC can indicate to the CPU which पूर्णांकerrupt was निश्चितed.
** So, unlike the GSC-ASIC and Dino, we allocate one CPU पूर्णांकerrupt per
** IO-SAPIC पूर्णांकerrupt and call the device driver's handler directly.
** The IO-SAPIC driver hijacks the CPU पूर्णांकerrupt handler so it can
** issue the End Of Interrupt command to the IO-SAPIC.
**
** Overview of exported iosapic functions
** --------------------------------------
** (caveat: code isn't finished yet - this is just the plan)
**
** iosapic_init:
**   o initialize globals (lock, etc)
**   o try to पढ़ो IRT. Presence of IRT determines अगर this is
**     a PAT platक्रमm or not.
**
** iosapic_रेजिस्टर():
**   o create iosapic_info instance data काष्ठाure
**   o allocate vector_info array क्रम this iosapic
**   o initialize vector_info - पढ़ो corresponding IRdT?
**
** iosapic_xlate_pin: (only called by fixup_irq क्रम PAT platक्रमm)
**   o पूर्णांकr_pin = पढ़ो cfg (INTERRUPT_PIN);
**   o अगर (device under PCI-PCI bridge)
**               translate slot/pin
**
** iosapic_fixup_irq:
**   o अगर PAT platक्रमm (IRT present)
**	   पूर्णांकr_pin = iosapic_xlate_pin(isi,pcidev):
**         पूर्णांकr_line = find IRT entry(isi, PCI_SLOT(pcidev), पूर्णांकr_pin)
**         save IRT entry पूर्णांकo vector_info later
**         ग_लिखो cfg INTERRUPT_LINE (with पूर्णांकr_line)?
**     अन्यथा
**         पूर्णांकr_line = pcidev->irq
**         IRT poपूर्णांकer = शून्य
**     endअगर
**   o locate vector_info (needs: isi, पूर्णांकr_line)
**   o allocate processor "irq" and get txn_addr/data
**   o request_irq(processor_irq,  iosapic_पूर्णांकerrupt, vector_info,...)
**
** iosapic_enable_irq:
**   o clear any pending IRQ on that line
**   o enable IRdT - call enable_irq(vector[line]->processor_irq)
**   o ग_लिखो EOI in हाल line is alपढ़ोy निश्चितed.
**
** iosapic_disable_irq:
**   o disable IRdT - call disable_irq(vector[line]->processor_irq)
*/

#समावेश <linux/pci.h>

#समावेश <यंत्र/pdc.h>
#समावेश <यंत्र/pdcpat.h>
#अगर_घोषित CONFIG_SUPERIO
#समावेश <यंत्र/superपन.स>
#पूर्ण_अगर

#समावेश <यंत्र/ropes.h>
#समावेश "iosapic_private.h"

#घोषणा MODULE_NAME "iosapic"

/* "local" compile flags */
#अघोषित PCI_BRIDGE_FUNCS
#अघोषित DEBUG_IOSAPIC
#अघोषित DEBUG_IOSAPIC_IRT


#अगर_घोषित DEBUG_IOSAPIC
#घोषणा DBG(x...) prपूर्णांकk(x)
#अन्यथा /* DEBUG_IOSAPIC */
#घोषणा DBG(x...)
#पूर्ण_अगर /* DEBUG_IOSAPIC */

#अगर_घोषित DEBUG_IOSAPIC_IRT
#घोषणा DBG_IRT(x...) prपूर्णांकk(x)
#अन्यथा
#घोषणा DBG_IRT(x...)
#पूर्ण_अगर

#अगर_घोषित CONFIG_64BIT
#घोषणा COMPARE_IRTE_ADDR(irte, hpa)	((irte)->dest_iosapic_addr == (hpa))
#अन्यथा
#घोषणा COMPARE_IRTE_ADDR(irte, hpa)	\
		((irte)->dest_iosapic_addr == ((hpa) | 0xffffffff00000000ULL))
#पूर्ण_अगर

#घोषणा IOSAPIC_REG_SELECT              0x00
#घोषणा IOSAPIC_REG_WINDOW              0x10
#घोषणा IOSAPIC_REG_EOI                 0x40

#घोषणा IOSAPIC_REG_VERSION		0x1

#घोषणा IOSAPIC_IRDT_ENTRY(idx)		(0x10+(idx)*2)
#घोषणा IOSAPIC_IRDT_ENTRY_HI(idx)	(0x11+(idx)*2)

अटल अंतरभूत अचिन्हित पूर्णांक iosapic_पढ़ो(व्योम __iomem *iosapic, अचिन्हित पूर्णांक reg)
अणु
	ग_लिखोl(reg, iosapic + IOSAPIC_REG_SELECT);
	वापस पढ़ोl(iosapic + IOSAPIC_REG_WINDOW);
पूर्ण

अटल अंतरभूत व्योम iosapic_ग_लिखो(व्योम __iomem *iosapic, अचिन्हित पूर्णांक reg, u32 val)
अणु
	ग_लिखोl(reg, iosapic + IOSAPIC_REG_SELECT);
	ग_लिखोl(val, iosapic + IOSAPIC_REG_WINDOW);
पूर्ण

#घोषणा IOSAPIC_VERSION_MASK	0x000000ff
#घोषणा	IOSAPIC_VERSION(ver)	((पूर्णांक) (ver & IOSAPIC_VERSION_MASK))

#घोषणा IOSAPIC_MAX_ENTRY_MASK          0x00ff0000
#घोषणा IOSAPIC_MAX_ENTRY_SHIFT         0x10
#घोषणा	IOSAPIC_IRDT_MAX_ENTRY(ver)	\
	(पूर्णांक) (((ver) & IOSAPIC_MAX_ENTRY_MASK) >> IOSAPIC_MAX_ENTRY_SHIFT)

/* bits in the "low" I/O Sapic IRdT entry */
#घोषणा IOSAPIC_IRDT_ENABLE       0x10000
#घोषणा IOSAPIC_IRDT_PO_LOW       0x02000
#घोषणा IOSAPIC_IRDT_LEVEL_TRIG   0x08000
#घोषणा IOSAPIC_IRDT_MODE_LPRI    0x00100

/* bits in the "high" I/O Sapic IRdT entry */
#घोषणा IOSAPIC_IRDT_ID_EID_SHIFT              0x10


अटल DEFINE_SPINLOCK(iosapic_lock);

अटल अंतरभूत व्योम iosapic_eoi(व्योम __iomem *addr, अचिन्हित पूर्णांक data)
अणु
	__raw_ग_लिखोl(data, addr);
पूर्ण

/*
** REVISIT: future platक्रमms may have more than one IRT.
** If so, the following three fields क्रमm a काष्ठाure which
** then be linked पूर्णांकo a list. Names are chosen to make searching
** क्रम them easy - not necessarily accurate (eg "cell").
**
** Alternative: iosapic_info could poपूर्णांक to the IRT it's in.
** iosapic_रेजिस्टर() could search a list of IRT's.
*/
अटल काष्ठा irt_entry *irt_cell;
अटल माप_प्रकार irt_num_entry;

अटल काष्ठा irt_entry *iosapic_alloc_irt(पूर्णांक num_entries)
अणु
	अचिन्हित दीर्घ a;

	/* The IRT needs to be 8-byte aligned क्रम the PDC call. 
	 * Normally kदो_स्मृति would guarantee larger alignment, but
	 * अगर CONFIG_DEBUG_SLAB is enabled, then we can get only
	 * 4-byte alignment on 32-bit kernels
	 */
	a = (अचिन्हित दीर्घ)kदो_स्मृति(माप(काष्ठा irt_entry) * num_entries + 8, GFP_KERNEL);
	a = (a + 7UL) & ~7UL;
	वापस (काष्ठा irt_entry *)a;
पूर्ण

/**
 * iosapic_load_irt - Fill in the पूर्णांकerrupt routing table
 * @cell_num: The cell number of the CPU we're currently executing on
 * @irt: The address to place the new IRT at
 * @वापस The number of entries found
 *
 * The "Get PCI INT Routing Table Size" option वापसs the number of 
 * entries in the PCI पूर्णांकerrupt routing table क्रम the cell specअगरied 
 * in the cell_number argument.  The cell number must be क्रम a cell 
 * within the caller's protection करोमुख्य.
 *
 * The "Get PCI INT Routing Table" option वापसs, क्रम the cell 
 * specअगरied in the cell_number argument, the PCI पूर्णांकerrupt routing 
 * table in the caller allocated memory poपूर्णांकed to by mem_addr.
 * We assume the IRT only contains entries क्रम I/O SAPIC and
 * calculate the size based on the size of I/O sapic entries.
 *
 * The PCI पूर्णांकerrupt routing table entry क्रमmat is derived from the
 * IA64 SAL Specअगरication 2.4.   The PCI पूर्णांकerrupt routing table defines
 * the routing of PCI पूर्णांकerrupt संकेतs between the PCI device output
 * "pins" and the IO SAPICs' input "lines" (including core I/O PCI
 * devices).  This table करोes NOT include inक्रमmation क्रम devices/slots
 * behind PCI to PCI bridges. See PCI to PCI Bridge Architecture Spec.
 * क्रम the architected method of routing of IRQ's behind PPB's.
 */


अटल पूर्णांक __init
iosapic_load_irt(अचिन्हित दीर्घ cell_num, काष्ठा irt_entry **irt)
अणु
	दीर्घ status;              /* PDC वापस value status */
	काष्ठा irt_entry *table;  /* start of पूर्णांकerrupt routing tbl */
	अचिन्हित दीर्घ num_entries = 0UL;

	BUG_ON(!irt);

	अगर (is_pdc_pat()) अणु
		/* Use pat pdc routine to get पूर्णांकerrupt routing table size */
		DBG("calling get_irt_size (cell %ld)\n", cell_num);
		status = pdc_pat_get_irt_size(&num_entries, cell_num);
		DBG("get_irt_size: %ld\n", status);

		BUG_ON(status != PDC_OK);
		BUG_ON(num_entries == 0);

		/*
		** allocate memory क्रम पूर्णांकerrupt routing table
		** This पूर्णांकerface isn't really right. We are assuming
		** the contents of the table are exclusively
		** क्रम I/O sapic devices.
		*/
		table = iosapic_alloc_irt(num_entries);
		अगर (table == शून्य) अणु
			prपूर्णांकk(KERN_WARNING MODULE_NAME ": read_irt : can "
					"not alloc mem for IRT\n");
			वापस 0;
		पूर्ण

		/* get PCI INT routing table */
		status = pdc_pat_get_irt(table, cell_num);
		DBG("pdc_pat_get_irt: %ld\n", status);
		WARN_ON(status != PDC_OK);
	पूर्ण अन्यथा अणु
		/*
		** C3000/J5000 (and similar) platक्रमms with Sprockets PDC
		** will वापस exactly one IRT क्रम all iosapics.
		** So अगर we have one, करोn't need to get it again.
		*/
		अगर (irt_cell)
			वापस 0;

		/* Should be using the Elroy's HPA, but it's ignored anyway */
		status = pdc_pci_irt_size(&num_entries, 0);
		DBG("pdc_pci_irt_size: %ld\n", status);

		अगर (status != PDC_OK) अणु
			/* Not a "legacy" प्रणाली with I/O SAPIC either */
			वापस 0;
		पूर्ण

		BUG_ON(num_entries == 0);

		table = iosapic_alloc_irt(num_entries);
		अगर (!table) अणु
			prपूर्णांकk(KERN_WARNING MODULE_NAME ": read_irt : can "
					"not alloc mem for IRT\n");
			वापस 0;
		पूर्ण

		/* HPA ignored by this call too. */
		status = pdc_pci_irt(num_entries, 0, table);
		BUG_ON(status != PDC_OK);
	पूर्ण

	/* वापस पूर्णांकerrupt table address */
	*irt = table;

#अगर_घोषित DEBUG_IOSAPIC_IRT
अणु
	काष्ठा irt_entry *p = table;
	पूर्णांक i;

	prपूर्णांकk(MODULE_NAME " Interrupt Routing Table (cell %ld)\n", cell_num);
	prपूर्णांकk(MODULE_NAME " start = 0x%p num_entries %ld entry_size %d\n",
		table,
		num_entries,
		(पूर्णांक) माप(काष्ठा irt_entry));

	क्रम (i = 0 ; i < num_entries ; i++, p++) अणु
		prपूर्णांकk(MODULE_NAME " %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x\n",
		p->entry_type, p->entry_length, p->पूर्णांकerrupt_type,
		p->polarity_trigger, p->src_bus_irq_devno, p->src_bus_id,
		p->src_seg_id, p->dest_iosapic_पूर्णांकin,
		((u32 *) p)[2],
		((u32 *) p)[3]
		);
	पूर्ण
पूर्ण
#पूर्ण_अगर /* DEBUG_IOSAPIC_IRT */

	वापस num_entries;
पूर्ण



व्योम __init iosapic_init(व्योम)
अणु
	अचिन्हित दीर्घ cell = 0;

	DBG("iosapic_init()\n");

#अगर_घोषित __LP64__
	अगर (is_pdc_pat()) अणु
		पूर्णांक status;
		काष्ठा pdc_pat_cell_num cell_info;

		status = pdc_pat_cell_get_number(&cell_info);
		अगर (status == PDC_OK) अणु
			cell = cell_info.cell_num;
		पूर्ण
	पूर्ण
#पूर्ण_अगर

	/* get पूर्णांकerrupt routing table क्रम this cell */
	irt_num_entry = iosapic_load_irt(cell, &irt_cell);
	अगर (irt_num_entry == 0)
		irt_cell = शून्य;	/* old PDC w/o iosapic */
पूर्ण


/*
** Return the IRT entry in हाल we need to look something अन्यथा up.
*/
अटल काष्ठा irt_entry *
irt_find_irqline(काष्ठा iosapic_info *isi, u8 slot, u8 पूर्णांकr_pin)
अणु
	काष्ठा irt_entry *i = irt_cell;
	पूर्णांक cnt;	/* track how many entries we've looked at */
	u8 irq_devno = (slot << IRT_DEV_SHIFT) | (पूर्णांकr_pin-1);

	DBG_IRT("irt_find_irqline() SLOT %d pin %d\n", slot, पूर्णांकr_pin);

	क्रम (cnt=0; cnt < irt_num_entry; cnt++, i++) अणु

		/*
		** Validate: entry_type, entry_length, पूर्णांकerrupt_type
		**
		** Dअगरference between validate vs compare is the क्रमmer
		** should prपूर्णांक debug info and is not expected to "fail"
		** on current platक्रमms.
		*/
		अगर (i->entry_type != IRT_IOSAPIC_TYPE) अणु
			DBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry %d type %d\n", i, cnt, i->entry_type);
			जारी;
		पूर्ण
		
		अगर (i->entry_length != IRT_IOSAPIC_LENGTH) अणु
			DBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry %d  length %d\n", i, cnt, i->entry_length);
			जारी;
		पूर्ण

		अगर (i->पूर्णांकerrupt_type != IRT_VECTORED_INTR) अणु
			DBG_IRT(KERN_WARNING MODULE_NAME ":find_irqline(0x%p): skipping entry  %d interrupt_type %d\n", i, cnt, i->पूर्णांकerrupt_type);
			जारी;
		पूर्ण

		अगर (!COMPARE_IRTE_ADDR(i, isi->isi_hpa))
			जारी;

		अगर ((i->src_bus_irq_devno & IRT_IRQ_DEVNO_MASK) != irq_devno)
			जारी;

		/*
		** Ignore: src_bus_id and rc_seg_id correlate with
		**         iosapic_info->isi_hpa on HP platक्रमms.
		**         If needed, pass in "PFA" (aka config space addr)
		**         instead of slot.
		*/

		/* Found it! */
		वापस i;
	पूर्ण

	prपूर्णांकk(KERN_WARNING MODULE_NAME ": 0x%lx : no IRT entry for slot %d, pin %d\n",
			isi->isi_hpa, slot, पूर्णांकr_pin);
	वापस शून्य;
पूर्ण


/*
** xlate_pin() supports the skewing of IRQ lines करोne by subsidiary bridges.
** Legacy PDC alपढ़ोy करोes this translation क्रम us and stores it in INTR_LINE.
**
** PAT PDC needs to basically करो what legacy PDC करोes:
** o पढ़ो PIN
** o adjust PIN in हाल device is "behind" a PPB
**     (eg 4-port 100BT and SCSI/LAN "Combo Card")
** o convert slot/pin to I/O SAPIC input line.
**
** HP platक्रमms only support:
** o one level of skewing क्रम any number of PPBs
** o only support PCI-PCI Bridges.
*/
अटल काष्ठा irt_entry *
iosapic_xlate_pin(काष्ठा iosapic_info *isi, काष्ठा pci_dev *pcidev)
अणु
	u8 पूर्णांकr_pin, पूर्णांकr_slot;

	pci_पढ़ो_config_byte(pcidev, PCI_INTERRUPT_PIN, &पूर्णांकr_pin);

	DBG_IRT("iosapic_xlate_pin(%s) SLOT %d pin %d\n",
		pcidev->slot_name, PCI_SLOT(pcidev->devfn), पूर्णांकr_pin);

	अगर (पूर्णांकr_pin == 0) अणु
		/* The device करोes NOT support/use IRQ lines.  */
		वापस शून्य;
	पूर्ण

	/* Check अगर pcidev behind a PPB */
	अगर (pcidev->bus->parent) अणु
		/* Convert pcidev INTR_PIN पूर्णांकo something we
		** can lookup in the IRT.
		*/
#अगर_घोषित PCI_BRIDGE_FUNCS
		/*
		** Proposal #1:
		**
		** call implementation specअगरic translation function
		** This is architecturally "cleaner". HP-UX करोesn't
		** support other secondary bus types (eg. E/ISA) directly.
		** May be needed क्रम other processor (eg IA64) architectures
		** or by some ambitous soul who wants to watch TV.
		*/
		अगर (pci_bridge_funcs->xlate_पूर्णांकr_line) अणु
			पूर्णांकr_pin = pci_bridge_funcs->xlate_पूर्णांकr_line(pcidev);
		पूर्ण
#अन्यथा	/* PCI_BRIDGE_FUNCS */
		काष्ठा pci_bus *p = pcidev->bus;
		/*
		** Proposal #2:
		** The "pin" is skewed ((pin + dev - 1) % 4).
		**
		** This isn't very clean since I/O SAPIC must assume:
		**   - all platक्रमms only have PCI busses.
		**   - only PCI-PCI bridge (eg not PCI-EISA, PCI-PCMCIA)
		**   - IRQ routing is only skewed once regardless of
		**     the number of PPB's between iosapic and device.
		**     (Bit3 expansion chassis follows this rule)
		**
		** Advantage is it's really easy to implement.
		*/
		पूर्णांकr_pin = pci_swizzle_पूर्णांकerrupt_pin(pcidev, पूर्णांकr_pin);
#पूर्ण_अगर /* PCI_BRIDGE_FUNCS */

		/*
		 * Locate the host slot of the PPB.
		 */
		जबतक (p->parent->parent)
			p = p->parent;

		पूर्णांकr_slot = PCI_SLOT(p->self->devfn);
	पूर्ण अन्यथा अणु
		पूर्णांकr_slot = PCI_SLOT(pcidev->devfn);
	पूर्ण
	DBG_IRT("iosapic_xlate_pin:  bus %d slot %d pin %d\n",
			pcidev->bus->busn_res.start, पूर्णांकr_slot, पूर्णांकr_pin);

	वापस irt_find_irqline(isi, पूर्णांकr_slot, पूर्णांकr_pin);
पूर्ण

अटल व्योम iosapic_rd_irt_entry(काष्ठा vector_info *vi , u32 *dp0, u32 *dp1)
अणु
	काष्ठा iosapic_info *isp = vi->iosapic;
	u8 idx = vi->irqline;

	*dp0 = iosapic_पढ़ो(isp->addr, IOSAPIC_IRDT_ENTRY(idx));
	*dp1 = iosapic_पढ़ो(isp->addr, IOSAPIC_IRDT_ENTRY_HI(idx));
पूर्ण


अटल व्योम iosapic_wr_irt_entry(काष्ठा vector_info *vi, u32 dp0, u32 dp1)
अणु
	काष्ठा iosapic_info *isp = vi->iosapic;

	DBG_IRT("iosapic_wr_irt_entry(): irq %d hpa %lx 0x%x 0x%x\n",
		vi->irqline, isp->isi_hpa, dp0, dp1);

	iosapic_ग_लिखो(isp->addr, IOSAPIC_IRDT_ENTRY(vi->irqline), dp0);

	/* Read the winकरोw रेजिस्टर to flush the ग_लिखोs करोwn to HW  */
	dp0 = पढ़ोl(isp->addr+IOSAPIC_REG_WINDOW);

	iosapic_ग_लिखो(isp->addr, IOSAPIC_IRDT_ENTRY_HI(vi->irqline), dp1);

	/* Read the winकरोw रेजिस्टर to flush the ग_लिखोs करोwn to HW  */
	dp1 = पढ़ोl(isp->addr+IOSAPIC_REG_WINDOW);
पूर्ण

/*
** set_irt prepares the data (dp0, dp1) according to the vector_info
** and target cpu (id_eid).  dp0/dp1 are then used to program I/O SAPIC
** IRdT क्रम the given "vector" (aka IRQ line).
*/
अटल व्योम
iosapic_set_irt_data( काष्ठा vector_info *vi, u32 *dp0, u32 *dp1)
अणु
	u32 mode = 0;
	काष्ठा irt_entry *p = vi->irte;

	अगर ((p->polarity_trigger & IRT_PO_MASK) == IRT_ACTIVE_LO)
		mode |= IOSAPIC_IRDT_PO_LOW;

	अगर (((p->polarity_trigger >> IRT_EL_SHIFT) & IRT_EL_MASK) == IRT_LEVEL_TRIG)
		mode |= IOSAPIC_IRDT_LEVEL_TRIG;

	/*
	** IA64 REVISIT
	** PA करोesn't support EXTINT or LPRIO bits.
	*/

	*dp0 = mode | (u32) vi->txn_data;

	/*
	** Extracting id_eid isn't a real clean way of getting it.
	** But the encoding is the same क्रम both PA and IA64 platक्रमms.
	*/
	अगर (is_pdc_pat()) अणु
		/*
		** PAT PDC just hands it to us "right".
		** txn_addr comes from cpu_data[x].txn_addr.
		*/
		*dp1 = (u32) (vi->txn_addr);
	पूर्ण अन्यथा अणु
		/* 
		** eg अगर base_addr == 0xfffa0000),
		**    we want to get 0xa0ff0000.
		**
		** eid	0x0ff00000 -> 0x00ff0000
		** id	0x000ff000 -> 0xff000000
		*/
		*dp1 = (((u32)vi->txn_addr & 0x0ff00000) >> 4) |
			(((u32)vi->txn_addr & 0x000ff000) << 12);
	पूर्ण
	DBG_IRT("iosapic_set_irt_data(): 0x%x 0x%x\n", *dp0, *dp1);
पूर्ण


अटल व्योम iosapic_mask_irq(काष्ठा irq_data *d)
अणु
	अचिन्हित दीर्घ flags;
	काष्ठा vector_info *vi = irq_data_get_irq_chip_data(d);
	u32 d0, d1;

	spin_lock_irqsave(&iosapic_lock, flags);
	iosapic_rd_irt_entry(vi, &d0, &d1);
	d0 |= IOSAPIC_IRDT_ENABLE;
	iosapic_wr_irt_entry(vi, d0, d1);
	spin_unlock_irqrestore(&iosapic_lock, flags);
पूर्ण

अटल व्योम iosapic_unmask_irq(काष्ठा irq_data *d)
अणु
	काष्ठा vector_info *vi = irq_data_get_irq_chip_data(d);
	u32 d0, d1;

	/* data is initialized by fixup_irq */
	WARN_ON(vi->txn_irq  == 0);

	iosapic_set_irt_data(vi, &d0, &d1);
	iosapic_wr_irt_entry(vi, d0, d1);

#अगर_घोषित DEBUG_IOSAPIC_IRT
अणु
	u32 *t = (u32 *) ((uदीर्घ) vi->eoi_addr & ~0xffUL);
	prपूर्णांकk("iosapic_enable_irq(): regs %p", vi->eoi_addr);
	क्रम ( ; t < vi->eoi_addr; t++)
		prपूर्णांकk(" %x", पढ़ोl(t));
	prपूर्णांकk("\n");
पूर्ण

prपूर्णांकk("iosapic_enable_irq(): sel ");
अणु
	काष्ठा iosapic_info *isp = vi->iosapic;

	क्रम (d0=0x10; d0<0x1e; d0++) अणु
		d1 = iosapic_पढ़ो(isp->addr, d0);
		prपूर्णांकk(" %x", d1);
	पूर्ण
पूर्ण
prपूर्णांकk("\n");
#पूर्ण_अगर

	/*
	 * Issuing I/O SAPIC an EOI causes an पूर्णांकerrupt IFF IRQ line is
	 * निश्चितed.  IRQ generally should not be निश्चितed when a driver
	 * enables their IRQ. It can lead to "interesting" race conditions
	 * in the driver initialization sequence.
	 */
	DBG(KERN_DEBUG "enable_irq(%d): eoi(%p, 0x%x)\n", d->irq,
			vi->eoi_addr, vi->eoi_data);
	iosapic_eoi(vi->eoi_addr, vi->eoi_data);
पूर्ण

अटल व्योम iosapic_eoi_irq(काष्ठा irq_data *d)
अणु
	काष्ठा vector_info *vi = irq_data_get_irq_chip_data(d);

	iosapic_eoi(vi->eoi_addr, vi->eoi_data);
	cpu_eoi_irq(d);
पूर्ण

#अगर_घोषित CONFIG_SMP
अटल पूर्णांक iosapic_set_affinity_irq(काष्ठा irq_data *d,
				    स्थिर काष्ठा cpumask *dest, bool क्रमce)
अणु
	काष्ठा vector_info *vi = irq_data_get_irq_chip_data(d);
	u32 d0, d1, dummy_d0;
	अचिन्हित दीर्घ flags;
	पूर्णांक dest_cpu;

	dest_cpu = cpu_check_affinity(d, dest);
	अगर (dest_cpu < 0)
		वापस -1;

	cpumask_copy(irq_data_get_affinity_mask(d), cpumask_of(dest_cpu));
	vi->txn_addr = txn_affinity_addr(d->irq, dest_cpu);

	spin_lock_irqsave(&iosapic_lock, flags);
	/* d1 contains the destination CPU, so only want to set that
	 * entry */
	iosapic_rd_irt_entry(vi, &d0, &d1);
	iosapic_set_irt_data(vi, &dummy_d0, &d1);
	iosapic_wr_irt_entry(vi, d0, d1);
	spin_unlock_irqrestore(&iosapic_lock, flags);

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल काष्ठा irq_chip iosapic_पूर्णांकerrupt_type = अणु
	.name		=	"IO-SAPIC-level",
	.irq_unmask	=	iosapic_unmask_irq,
	.irq_mask	=	iosapic_mask_irq,
	.irq_ack	=	cpu_ack_irq,
	.irq_eoi	=	iosapic_eoi_irq,
#अगर_घोषित CONFIG_SMP
	.irq_set_affinity =	iosapic_set_affinity_irq,
#पूर्ण_अगर
पूर्ण;

पूर्णांक iosapic_fixup_irq(व्योम *isi_obj, काष्ठा pci_dev *pcidev)
अणु
	काष्ठा iosapic_info *isi = isi_obj;
	काष्ठा irt_entry *irte = शून्य;  /* only used अगर PAT PDC */
	काष्ठा vector_info *vi;
	पूर्णांक isi_line;	/* line used by device */

	अगर (!isi) अणु
		prपूर्णांकk(KERN_WARNING MODULE_NAME ": hpa not registered for %s\n",
			pci_name(pcidev));
		वापस -1;
	पूर्ण

#अगर_घोषित CONFIG_SUPERIO
	/*
	 * HACK ALERT! (non-compliant PCI device support)
	 *
	 * All SuckyIO पूर्णांकerrupts are routed through the PIC's on function 1.
	 * But SuckyIO OHCI USB controller माला_लो an IRT entry anyway because
	 * it advertises INT D क्रम INT_PIN.  Use that IRT entry to get the
	 * SuckyIO पूर्णांकerrupt routing क्रम PICs on function 1 (*BLEECCHH*).
	 */
	अगर (is_superio_device(pcidev)) अणु
		/* We must call superio_fixup_irq() to रेजिस्टर the pdev */
		pcidev->irq = superio_fixup_irq(pcidev);

		/* Don't return if need to program the IOSAPIC's IRT... */
		अगर (PCI_FUNC(pcidev->devfn) != SUPERIO_USB_FN)
			वापस pcidev->irq;
	पूर्ण
#पूर्ण_अगर /* CONFIG_SUPERIO */

	/* lookup IRT entry क्रम isi/slot/pin set */
	irte = iosapic_xlate_pin(isi, pcidev);
	अगर (!irte) अणु
		prपूर्णांकk("iosapic: no IRTE for %s (IRQ not connected?)\n",
				pci_name(pcidev));
		वापस -1;
	पूर्ण
	DBG_IRT("iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x\n",
		irte,
		irte->entry_type,
		irte->entry_length,
		irte->polarity_trigger,
		irte->src_bus_irq_devno,
		irte->src_bus_id,
		irte->src_seg_id,
		irte->dest_iosapic_पूर्णांकin,
		(u32) irte->dest_iosapic_addr);
	isi_line = irte->dest_iosapic_पूर्णांकin;

	/* get vector info क्रम this input line */
	vi = isi->isi_vector + isi_line;
	DBG_IRT("iosapic_fixup_irq:  line %d vi 0x%p\n", isi_line, vi);

	/* If this IRQ line has alपढ़ोy been setup, skip it */
	अगर (vi->irte)
		जाओ out;

	vi->irte = irte;

	/*
	 * Allocate processor IRQ
	 *
	 * XXX/FIXME The txn_alloc_irq() code and related code should be
	 * moved to enable_irq(). That way we only allocate processor IRQ
	 * bits क्रम devices that actually have drivers claiming them.
	 * Right now we assign an IRQ to every PCI device present,
	 * regardless of whether it's used or not.
	 */
	vi->txn_irq = txn_alloc_irq(8);

	अगर (vi->txn_irq < 0)
		panic("I/O sapic: couldn't get TXN IRQ\n");

	/* enable_irq() will use txn_* to program IRdT */
	vi->txn_addr = txn_alloc_addr(vi->txn_irq);
	vi->txn_data = txn_alloc_data(vi->txn_irq);

	vi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;
	vi->eoi_data = cpu_to_le32(vi->txn_data);

	cpu_claim_irq(vi->txn_irq, &iosapic_पूर्णांकerrupt_type, vi);

 out:
	pcidev->irq = vi->txn_irq;

	DBG_IRT("iosapic_fixup_irq() %d:%d %x %x line %d irq %d\n",
		PCI_SLOT(pcidev->devfn), PCI_FUNC(pcidev->devfn),
		pcidev->venकरोr, pcidev->device, isi_line, pcidev->irq);

	वापस pcidev->irq;
पूर्ण

अटल काष्ठा iosapic_info *iosapic_list;

#अगर_घोषित CONFIG_64BIT
पूर्णांक iosapic_serial_irq(काष्ठा parisc_device *dev)
अणु
	काष्ठा iosapic_info *isi;
	काष्ठा irt_entry *irte;
	काष्ठा vector_info *vi;
	पूर्णांक cnt;
	पूर्णांक पूर्णांकin;

	पूर्णांकin = (dev->mod_info >> 24) & 15;

	/* lookup IRT entry क्रम isi/slot/pin set */
	क्रम (cnt = 0; cnt < irt_num_entry; cnt++) अणु
		irte = &irt_cell[cnt];
		अगर (COMPARE_IRTE_ADDR(irte, dev->mod0) &&
		    irte->dest_iosapic_पूर्णांकin == पूर्णांकin)
			अवरोध;
	पूर्ण
	अगर (cnt >= irt_num_entry)
		वापस 0; /* no irq found, क्रमce polling */

	DBG_IRT("iosapic_serial_irq(): irte %p %x %x %x %x %x %x %x %x\n",
		irte,
		irte->entry_type,
		irte->entry_length,
		irte->polarity_trigger,
		irte->src_bus_irq_devno,
		irte->src_bus_id,
		irte->src_seg_id,
		irte->dest_iosapic_पूर्णांकin,
		(u32) irte->dest_iosapic_addr);

	/* search क्रम iosapic */
	क्रम (isi = iosapic_list; isi; isi = isi->isi_next)
		अगर (isi->isi_hpa == dev->mod0)
			अवरोध;
	अगर (!isi)
		वापस 0; /* no iosapic found, क्रमce polling */

	/* get vector info क्रम this input line */
	vi = isi->isi_vector + पूर्णांकin;
	DBG_IRT("iosapic_serial_irq:  line %d vi 0x%p\n", iosapic_पूर्णांकin, vi);

	/* If this IRQ line has alपढ़ोy been setup, skip it */
	अगर (vi->irte)
		जाओ out;

	vi->irte = irte;

	/*
	 * Allocate processor IRQ
	 *
	 * XXX/FIXME The txn_alloc_irq() code and related code should be
	 * moved to enable_irq(). That way we only allocate processor IRQ
	 * bits क्रम devices that actually have drivers claiming them.
	 * Right now we assign an IRQ to every PCI device present,
	 * regardless of whether it's used or not.
	 */
	vi->txn_irq = txn_alloc_irq(8);

	अगर (vi->txn_irq < 0)
		panic("I/O sapic: couldn't get TXN IRQ\n");

	/* enable_irq() will use txn_* to program IRdT */
	vi->txn_addr = txn_alloc_addr(vi->txn_irq);
	vi->txn_data = txn_alloc_data(vi->txn_irq);

	vi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;
	vi->eoi_data = cpu_to_le32(vi->txn_data);

	cpu_claim_irq(vi->txn_irq, &iosapic_पूर्णांकerrupt_type, vi);

 out:

	वापस vi->txn_irq;
पूर्ण
#पूर्ण_अगर


/*
** squirrel away the I/O Sapic Version
*/
अटल अचिन्हित पूर्णांक
iosapic_rd_version(काष्ठा iosapic_info *isi)
अणु
	वापस iosapic_पढ़ो(isi->addr, IOSAPIC_REG_VERSION);
पूर्ण


/*
** iosapic_रेजिस्टर() is called by "drivers" with an पूर्णांकegrated I/O SAPIC.
** Caller must be certain they have an I/O SAPIC and know its MMIO address.
**
**	o allocate iosapic_info and add it to the list
**	o पढ़ो iosapic version and squirrel that away
**	o पढ़ो size of IRdT.
**	o allocate and initialize isi_vector[]
**	o allocate irq region
*/
व्योम *iosapic_रेजिस्टर(अचिन्हित दीर्घ hpa)
अणु
	काष्ठा iosapic_info *isi = शून्य;
	काष्ठा irt_entry *irte = irt_cell;
	काष्ठा vector_info *vip;
	पूर्णांक cnt;	/* track how many entries we've looked at */

	/*
	 * Astro based platक्रमms can only support PCI OLARD अगर they implement
	 * PAT PDC.  Legacy PDC omits LBAs with no PCI devices from the IRT.
	 * Search the IRT and ignore iosapic's which aren't in the IRT.
	 */
	क्रम (cnt=0; cnt < irt_num_entry; cnt++, irte++) अणु
		WARN_ON(IRT_IOSAPIC_TYPE != irte->entry_type);
		अगर (COMPARE_IRTE_ADDR(irte, hpa))
			अवरोध;
	पूर्ण

	अगर (cnt >= irt_num_entry) अणु
		DBG("iosapic_register() ignoring 0x%lx (NOT FOUND)\n", hpa);
		वापस शून्य;
	पूर्ण

	isi = kzalloc(माप(काष्ठा iosapic_info), GFP_KERNEL);
	अगर (!isi) अणु
		BUG();
		वापस शून्य;
	पूर्ण

	isi->addr = ioremap(hpa, 4096);
	isi->isi_hpa = hpa;
	isi->isi_version = iosapic_rd_version(isi);
	isi->isi_num_vectors = IOSAPIC_IRDT_MAX_ENTRY(isi->isi_version) + 1;

	vip = isi->isi_vector = kसुस्मृति(isi->isi_num_vectors,
					माप(काष्ठा vector_info), GFP_KERNEL);
	अगर (vip == शून्य) अणु
		kमुक्त(isi);
		वापस शून्य;
	पूर्ण

	क्रम (cnt=0; cnt < isi->isi_num_vectors; cnt++, vip++) अणु
		vip->irqline = (अचिन्हित अक्षर) cnt;
		vip->iosapic = isi;
	पूर्ण
	isi->isi_next = iosapic_list;
	iosapic_list = isi;
	वापस isi;
पूर्ण


#अगर_घोषित DEBUG_IOSAPIC

अटल व्योम
iosapic_prt_irt(व्योम *irt, दीर्घ num_entry)
अणु
	अचिन्हित पूर्णांक i, *irp = (अचिन्हित पूर्णांक *) irt;


	prपूर्णांकk(KERN_DEBUG MODULE_NAME ": Interrupt Routing Table (%lx entries)\n", num_entry);

	क्रम (i=0; i<num_entry; i++, irp += 4) अणु
		prपूर्णांकk(KERN_DEBUG "%p : %2d %.8x %.8x %.8x %.8x\n",
					irp, i, irp[0], irp[1], irp[2], irp[3]);
	पूर्ण
पूर्ण


अटल व्योम
iosapic_prt_vi(काष्ठा vector_info *vi)
अणु
	prपूर्णांकk(KERN_DEBUG MODULE_NAME ": vector_info[%d] is at %p\n", vi->irqline, vi);
	prपूर्णांकk(KERN_DEBUG "\t\tstatus:	 %.4x\n", vi->status);
	prपूर्णांकk(KERN_DEBUG "\t\ttxn_irq:  %d\n",  vi->txn_irq);
	prपूर्णांकk(KERN_DEBUG "\t\ttxn_addr: %lx\n", vi->txn_addr);
	prपूर्णांकk(KERN_DEBUG "\t\ttxn_data: %lx\n", vi->txn_data);
	prपूर्णांकk(KERN_DEBUG "\t\teoi_addr: %p\n",  vi->eoi_addr);
	prपूर्णांकk(KERN_DEBUG "\t\teoi_data: %x\n",  vi->eoi_data);
पूर्ण


अटल व्योम
iosapic_prt_isi(काष्ठा iosapic_info *isi)
अणु
	prपूर्णांकk(KERN_DEBUG MODULE_NAME ": io_sapic_info at %p\n", isi);
	prपूर्णांकk(KERN_DEBUG "\t\tisi_hpa:       %lx\n", isi->isi_hpa);
	prपूर्णांकk(KERN_DEBUG "\t\tisi_status:    %x\n", isi->isi_status);
	prपूर्णांकk(KERN_DEBUG "\t\tisi_version:   %x\n", isi->isi_version);
	prपूर्णांकk(KERN_DEBUG "\t\tisi_vector:    %p\n", isi->isi_vector);
पूर्ण
#पूर्ण_अगर /* DEBUG_IOSAPIC */
