<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0+
/*
 * Copyright (C) 2019 BayLibre, SAS
 * Author: Neil Armstrong <narmstrong@baylibre.com>
 */

#समावेश <linux/bitfield.h>

#समावेश <drm/drm_prपूर्णांक.h>
#समावेश <drm/drm_fourcc.h>

#समावेश "meson_drv.h"
#समावेश "meson_registers.h"
#समावेश "meson_viu.h"
#समावेश "meson_rdma.h"
#समावेश "meson_osd_afbcd.h"

/*
 * DOC: Driver क्रम the ARM FrameBuffer Compression Decoders
 *
 * The Amlogic GXM and G12A SoC families embeds an AFBC Decoder,
 * to decode compressed buffers generated by the ARM Mali GPU.
 *
 * For the GXM Family, Amlogic deचिन्हित their own Decoder, named in
 * the venकरोr source as "MESON_AFBC", and a single decoder is available
 * क्रम the 2 OSD planes.
 * This decoder is compatible with the AFBC 1.0 specअगरications and the
 * Mali T820 GPU capabilities.
 * It supports :
 * - basic AFBC buffer क्रम RGB32 only, thus YTR feature is mandatory
 * - SPARSE layout and SPLIT layout
 * - only 16x16 superblock
 *
 * The decoder पढ़ोs the data from the SDRAM, decodes and sends the
 * decoded pixel stream to the OSD1 Plane pixel composer.
 *
 * For the G12A Family, Amlogic पूर्णांकegrated an ARM AFBC Decoder, named
 * in the venकरोr source as "MALI_AFBC", and the decoder can decode up
 * to 4 surfaces, one क्रम each of the 4 available OSDs.
 * This decoder is compatible with the AFBC 1.2 specअगरications क्रम the
 * Mali G31 and G52 GPUs.
 * Is supports :
 * - basic AFBC buffer क्रम multiple RGB and YUV pixel क्रमmats
 * - SPARSE layout and SPLIT layout
 * - 16x16 and 32x8 "wideblk" superblocks
 * - Tiled header
 *
 * The ARM AFBC Decoder independent from the VPU Pixel Pipeline, so
 * the ARM AFBC Decoder पढ़ोs the data from the SDRAM then decodes
 * पूर्णांकo a निजी पूर्णांकernal physical address where the OSD1 Plane pixel
 * composer unpacks the decoded data.
 */

/* Amlogic AFBC Decoder क्रम GXM Family */

#घोषणा OSD1_AFBCD_RGB32	0x15

अटल पूर्णांक meson_gxm_afbcd_pixel_fmt(u64 modअगरier, uपूर्णांक32_t क्रमmat)
अणु
	चयन (क्रमmat) अणु
	हाल DRM_FORMAT_XBGR8888:
	हाल DRM_FORMAT_ABGR8888:
		वापस OSD1_AFBCD_RGB32;
	/* TOFIX support mode क्रमmats */
	शेष:
		DRM_DEBUG("unsupported afbc format[%08x]\n", क्रमmat);
		वापस -EINVAL;
	पूर्ण
पूर्ण

अटल bool meson_gxm_afbcd_supported_fmt(u64 modअगरier, uपूर्णांक32_t क्रमmat)
अणु
	अगर (modअगरier & AFBC_FORMAT_MOD_BLOCK_SIZE_32x8)
		वापस false;

	अगर (!(modअगरier & AFBC_FORMAT_MOD_YTR))
		वापस false;

	वापस meson_gxm_afbcd_pixel_fmt(modअगरier, क्रमmat) >= 0;
पूर्ण

अटल पूर्णांक meson_gxm_afbcd_init(काष्ठा meson_drm *priv)
अणु
	वापस 0;
पूर्ण

अटल पूर्णांक meson_gxm_afbcd_reset(काष्ठा meson_drm *priv)
अणु
	ग_लिखोl_relaxed(VIU_SW_RESET_OSD1_AFBCD,
		       priv->io_base + _REG(VIU_SW_RESET));
	ग_लिखोl_relaxed(0, priv->io_base + _REG(VIU_SW_RESET));

	वापस 0;
पूर्ण

अटल पूर्णांक meson_gxm_afbcd_enable(काष्ठा meson_drm *priv)
अणु
	ग_लिखोl_relaxed(FIELD_PREP(OSD1_AFBCD_ID_FIFO_THRD, 0x40) |
		       OSD1_AFBCD_DEC_ENABLE,
		       priv->io_base + _REG(OSD1_AFBCD_ENABLE));

	वापस 0;
पूर्ण

अटल पूर्णांक meson_gxm_afbcd_disable(काष्ठा meson_drm *priv)
अणु
	ग_लिखोl_bits_relaxed(OSD1_AFBCD_DEC_ENABLE, 0,
			    priv->io_base + _REG(OSD1_AFBCD_ENABLE));

	वापस 0;
पूर्ण

अटल पूर्णांक meson_gxm_afbcd_setup(काष्ठा meson_drm *priv)
अणु
	u32 conv_lbuf_len;
	u32 mode = FIELD_PREP(OSD1_AFBCD_MIF_URGENT, 3) |
		   FIELD_PREP(OSD1_AFBCD_HOLD_LINE_NUM, 4) |
		   FIELD_PREP(OSD1_AFBCD_RGBA_EXCHAN_CTRL, 0x34) |
		   meson_gxm_afbcd_pixel_fmt(priv->afbcd.modअगरier,
					     priv->afbcd.क्रमmat);

	अगर (priv->afbcd.modअगरier & AFBC_FORMAT_MOD_SPARSE)
		mode |= OSD1_AFBCD_HREG_HALF_BLOCK;

	अगर (priv->afbcd.modअगरier & AFBC_FORMAT_MOD_SPLIT)
		mode |= OSD1_AFBCD_HREG_BLOCK_SPLIT;

	ग_लिखोl_relaxed(mode, priv->io_base + _REG(OSD1_AFBCD_MODE));

	ग_लिखोl_relaxed(FIELD_PREP(OSD1_AFBCD_HREG_VSIZE_IN,
				  priv->viu.osd1_width) |
		       FIELD_PREP(OSD1_AFBCD_HREG_HSIZE_IN,
				  priv->viu.osd1_height),
		       priv->io_base + _REG(OSD1_AFBCD_SIZE_IN));

	ग_लिखोl_relaxed(priv->viu.osd1_addr >> 4,
		       priv->io_base + _REG(OSD1_AFBCD_HDR_PTR));
	ग_लिखोl_relaxed(priv->viu.osd1_addr >> 4,
		       priv->io_base + _REG(OSD1_AFBCD_FRAME_PTR));
	/* TOFIX: bits 31:24 are not करोcumented, nor the meaning of 0xe4 */
	ग_लिखोl_relaxed((0xe4 << 24) | (priv->viu.osd1_addr & 0xffffff),
		       priv->io_base + _REG(OSD1_AFBCD_CHROMA_PTR));

	अगर (priv->viu.osd1_width <= 128)
		conv_lbuf_len = 32;
	अन्यथा अगर (priv->viu.osd1_width <= 256)
		conv_lbuf_len = 64;
	अन्यथा अगर (priv->viu.osd1_width <= 512)
		conv_lbuf_len = 128;
	अन्यथा अगर (priv->viu.osd1_width <= 1024)
		conv_lbuf_len = 256;
	अन्यथा अगर (priv->viu.osd1_width <= 2048)
		conv_lbuf_len = 512;
	अन्यथा
		conv_lbuf_len = 1024;

	ग_लिखोl_relaxed(conv_lbuf_len,
		       priv->io_base + _REG(OSD1_AFBCD_CONV_CTRL));

	ग_लिखोl_relaxed(FIELD_PREP(OSD1_AFBCD_DEC_PIXEL_BGN_H, 0) |
		       FIELD_PREP(OSD1_AFBCD_DEC_PIXEL_END_H,
				  priv->viu.osd1_width - 1),
		       priv->io_base + _REG(OSD1_AFBCD_PIXEL_HSCOPE));

	ग_लिखोl_relaxed(FIELD_PREP(OSD1_AFBCD_DEC_PIXEL_BGN_V, 0) |
		       FIELD_PREP(OSD1_AFBCD_DEC_PIXEL_END_V,
				  priv->viu.osd1_height - 1),
		       priv->io_base + _REG(OSD1_AFBCD_PIXEL_VSCOPE));

	वापस 0;
पूर्ण

काष्ठा meson_afbcd_ops meson_afbcd_gxm_ops = अणु
	.init = meson_gxm_afbcd_init,
	.reset = meson_gxm_afbcd_reset,
	.enable = meson_gxm_afbcd_enable,
	.disable = meson_gxm_afbcd_disable,
	.setup = meson_gxm_afbcd_setup,
	.supported_fmt = meson_gxm_afbcd_supported_fmt,
पूर्ण;

/* ARM AFBC Decoder क्रम G12A Family */

/* Amlogic G12A Mali AFBC Decoder supported क्रमmats */
क्रमागत अणु
	MAFBC_FMT_RGB565 = 0,
	MAFBC_FMT_RGBA5551,
	MAFBC_FMT_RGBA1010102,
	MAFBC_FMT_YUV420_10B,
	MAFBC_FMT_RGB888,
	MAFBC_FMT_RGBA8888,
	MAFBC_FMT_RGBA4444,
	MAFBC_FMT_R8,
	MAFBC_FMT_RG88,
	MAFBC_FMT_YUV420_8B,
	MAFBC_FMT_YUV422_8B = 11,
	MAFBC_FMT_YUV422_10B = 14,
पूर्ण;

अटल पूर्णांक meson_g12a_afbcd_pixel_fmt(u64 modअगरier, uपूर्णांक32_t क्रमmat)
अणु
	चयन (क्रमmat) अणु
	हाल DRM_FORMAT_XRGB8888:
	हाल DRM_FORMAT_ARGB8888:
		/* YTR is क्रमbidden क्रम non XBGR क्रमmats */
		अगर (modअगरier & AFBC_FORMAT_MOD_YTR)
			वापस -EINVAL;
		fallthrough;
	हाल DRM_FORMAT_XBGR8888:
	हाल DRM_FORMAT_ABGR8888:
		वापस MAFBC_FMT_RGBA8888;
	हाल DRM_FORMAT_RGB888:
		/* YTR is क्रमbidden क्रम non XBGR क्रमmats */
		अगर (modअगरier & AFBC_FORMAT_MOD_YTR)
			वापस -EINVAL;
		वापस MAFBC_FMT_RGB888;
	हाल DRM_FORMAT_RGB565:
		/* YTR is क्रमbidden क्रम non XBGR क्रमmats */
		अगर (modअगरier & AFBC_FORMAT_MOD_YTR)
			वापस -EINVAL;
		वापस MAFBC_FMT_RGB565;
	/* TOFIX support mode क्रमmats */
	शेष:
		DRM_DEBUG("unsupported afbc format[%08x]\n", क्रमmat);
		वापस -EINVAL;
	पूर्ण
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_bpp(uपूर्णांक32_t क्रमmat)
अणु
	चयन (क्रमmat) अणु
	हाल DRM_FORMAT_XRGB8888:
	हाल DRM_FORMAT_ARGB8888:
	हाल DRM_FORMAT_XBGR8888:
	हाल DRM_FORMAT_ABGR8888:
		वापस 32;
	हाल DRM_FORMAT_RGB888:
		वापस 24;
	हाल DRM_FORMAT_RGB565:
		वापस 16;
	/* TOFIX support mode क्रमmats */
	शेष:
		DRM_ERROR("unsupported afbc format[%08x]\n", क्रमmat);
		वापस 0;
	पूर्ण
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_fmt_to_blk_mode(u64 modअगरier, uपूर्णांक32_t क्रमmat)
अणु
	चयन (क्रमmat) अणु
	हाल DRM_FORMAT_XRGB8888:
	हाल DRM_FORMAT_ARGB8888:
	हाल DRM_FORMAT_XBGR8888:
	हाल DRM_FORMAT_ABGR8888:
		वापस OSD_MALI_COLOR_MODE_RGBA8888;
	हाल DRM_FORMAT_RGB888:
		वापस OSD_MALI_COLOR_MODE_RGB888;
	हाल DRM_FORMAT_RGB565:
		वापस OSD_MALI_COLOR_MODE_RGB565;
	/* TOFIX support mode क्रमmats */
	शेष:
		DRM_DEBUG("unsupported afbc format[%08x]\n", क्रमmat);
		वापस -EINVAL;
	पूर्ण
पूर्ण

अटल bool meson_g12a_afbcd_supported_fmt(u64 modअगरier, uपूर्णांक32_t क्रमmat)
अणु
	वापस meson_g12a_afbcd_pixel_fmt(modअगरier, क्रमmat) >= 0;
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_init(काष्ठा meson_drm *priv)
अणु
	पूर्णांक ret;

	ret = meson_rdma_init(priv);
	अगर (ret)
		वापस ret;

	meson_rdma_setup(priv);

	/* Handle AFBC Decoder reset manually */
	ग_लिखोl_bits_relaxed(MALI_AFBCD_MANUAL_RESET, MALI_AFBCD_MANUAL_RESET,
			    priv->io_base + _REG(MALI_AFBCD_TOP_CTRL));

	वापस 0;
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_reset(काष्ठा meson_drm *priv)
अणु
	meson_rdma_reset(priv);

	meson_rdma_ग_लिखोl_sync(priv, VIU_SW_RESET_G12A_AFBC_ARB |
			       VIU_SW_RESET_G12A_OSD1_AFBCD,
			       VIU_SW_RESET);
	meson_rdma_ग_लिखोl_sync(priv, 0, VIU_SW_RESET);

	वापस 0;
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_enable(काष्ठा meson_drm *priv)
अणु
	meson_rdma_ग_लिखोl_sync(priv, VPU_MAFBC_IRQ_SURFACES_COMPLETED |
			       VPU_MAFBC_IRQ_CONFIGURATION_SWAPPED |
			       VPU_MAFBC_IRQ_DECODE_ERROR |
			       VPU_MAFBC_IRQ_DETILING_ERROR,
			       VPU_MAFBC_IRQ_MASK);

	meson_rdma_ग_लिखोl_sync(priv, VPU_MAFBC_S0_ENABLE,
			       VPU_MAFBC_SURFACE_CFG);

	meson_rdma_ग_लिखोl_sync(priv, VPU_MAFBC_सूचीECT_SWAP,
			       VPU_MAFBC_COMMAND);

	/* This will enable the RDMA replaying the रेजिस्टर ग_लिखोs on vsync */
	meson_rdma_flush(priv);

	वापस 0;
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_disable(काष्ठा meson_drm *priv)
अणु
	ग_लिखोl_bits_relaxed(VPU_MAFBC_S0_ENABLE, 0,
			    priv->io_base + _REG(VPU_MAFBC_SURFACE_CFG));

	वापस 0;
पूर्ण

अटल पूर्णांक meson_g12a_afbcd_setup(काष्ठा meson_drm *priv)
अणु
	u32 क्रमmat = meson_g12a_afbcd_pixel_fmt(priv->afbcd.modअगरier,
						priv->afbcd.क्रमmat);

	अगर (priv->afbcd.modअगरier & AFBC_FORMAT_MOD_YTR)
		क्रमmat |= VPU_MAFBC_YUV_TRANSFORM;

	अगर (priv->afbcd.modअगरier & AFBC_FORMAT_MOD_SPLIT)
		क्रमmat |= VPU_MAFBC_BLOCK_SPLIT;

	अगर (priv->afbcd.modअगरier & AFBC_FORMAT_MOD_TILED)
		क्रमmat |= VPU_MAFBC_TILED_HEADER_EN;

	अगर ((priv->afbcd.modअगरier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) ==
		AFBC_FORMAT_MOD_BLOCK_SIZE_32x8)
		क्रमmat |= FIELD_PREP(VPU_MAFBC_SUPER_BLOCK_ASPECT, 1);

	meson_rdma_ग_लिखोl_sync(priv, क्रमmat,
			       VPU_MAFBC_FORMAT_SPECIFIER_S0);

	meson_rdma_ग_लिखोl_sync(priv, priv->viu.osd1_addr,
			       VPU_MAFBC_HEADER_BUF_ADDR_LOW_S0);
	meson_rdma_ग_लिखोl_sync(priv, 0,
			       VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S0);

	meson_rdma_ग_लिखोl_sync(priv, priv->viu.osd1_width,
			       VPU_MAFBC_BUFFER_WIDTH_S0);
	meson_rdma_ग_लिखोl_sync(priv, ALIGN(priv->viu.osd1_height, 32),
			       VPU_MAFBC_BUFFER_HEIGHT_S0);

	meson_rdma_ग_लिखोl_sync(priv, 0,
			       VPU_MAFBC_BOUNDING_BOX_X_START_S0);
	meson_rdma_ग_लिखोl_sync(priv, priv->viu.osd1_width - 1,
			       VPU_MAFBC_BOUNDING_BOX_X_END_S0);
	meson_rdma_ग_लिखोl_sync(priv, 0,
			       VPU_MAFBC_BOUNDING_BOX_Y_START_S0);
	meson_rdma_ग_लिखोl_sync(priv, priv->viu.osd1_height - 1,
			       VPU_MAFBC_BOUNDING_BOX_Y_END_S0);

	meson_rdma_ग_लिखोl_sync(priv, MESON_G12A_AFBCD_OUT_ADDR,
			       VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S0);
	meson_rdma_ग_लिखोl_sync(priv, 0,
			       VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S0);

	meson_rdma_ग_लिखोl_sync(priv, priv->viu.osd1_width *
			       (meson_g12a_afbcd_bpp(priv->afbcd.क्रमmat) / 8),
			       VPU_MAFBC_OUTPUT_BUF_STRIDE_S0);

	वापस 0;
पूर्ण

काष्ठा meson_afbcd_ops meson_afbcd_g12a_ops = अणु
	.init = meson_g12a_afbcd_init,
	.reset = meson_g12a_afbcd_reset,
	.enable = meson_g12a_afbcd_enable,
	.disable = meson_g12a_afbcd_disable,
	.setup = meson_g12a_afbcd_setup,
	.fmt_to_blk_mode = meson_g12a_afbcd_fmt_to_blk_mode,
	.supported_fmt = meson_g12a_afbcd_supported_fmt,
पूर्ण;
