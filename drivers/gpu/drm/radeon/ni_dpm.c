<शैली गुरु>
/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modअगरy, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to करो so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#समावेश <linux/math64.h>
#समावेश <linux/pci.h>
#समावेश <linux/seq_file.h>

#समावेश "atom.h"
#समावेश "evergreen.h"
#समावेश "ni_dpm.h"
#समावेश "nid.h"
#समावेश "r600_dpm.h"
#समावेश "rv770.h"
#समावेश "radeon.h"
#समावेश "radeon_asic.h"

#घोषणा MC_CG_ARB_FREQ_F0           0x0a
#घोषणा MC_CG_ARB_FREQ_F1           0x0b
#घोषणा MC_CG_ARB_FREQ_F2           0x0c
#घोषणा MC_CG_ARB_FREQ_F3           0x0d

#घोषणा SMC_RAM_END 0xC000

अटल स्थिर काष्ठा ni_cac_weights cac_weights_cayman_xt =
अणु
	0x15,
	0x2,
	0x19,
	0x2,
	0x8,
	0x14,
	0x2,
	0x16,
	0xE,
	0x17,
	0x13,
	0x2B,
	0x10,
	0x7,
	0x5,
	0x5,
	0x5,
	0x2,
	0x3,
	0x9,
	0x10,
	0x10,
	0x2B,
	0xA,
	0x9,
	0x4,
	0xD,
	0xD,
	0x3E,
	0x18,
	0x14,
	0,
	0x3,
	0x3,
	0x5,
	0,
	0x2,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0x1CC,
	0,
	0x164,
	1,
	1,
	1,
	1,
	12,
	12,
	12,
	0x12,
	0x1F,
	132,
	5,
	7,
	0,
	अणु 0, 0, 0, 0, 0, 0, 0, 0 पूर्ण,
	अणु 0, 0, 0, 0 पूर्ण,
	true
पूर्ण;

अटल स्थिर काष्ठा ni_cac_weights cac_weights_cayman_pro =
अणु
	0x16,
	0x4,
	0x10,
	0x2,
	0xA,
	0x16,
	0x2,
	0x18,
	0x10,
	0x1A,
	0x16,
	0x2D,
	0x12,
	0xA,
	0x6,
	0x6,
	0x6,
	0x2,
	0x4,
	0xB,
	0x11,
	0x11,
	0x2D,
	0xC,
	0xC,
	0x7,
	0x10,
	0x10,
	0x3F,
	0x1A,
	0x16,
	0,
	0x7,
	0x4,
	0x6,
	1,
	0x2,
	0x1,
	0,
	0,
	0,
	0,
	0,
	0,
	0x30,
	0,
	0x1CF,
	0,
	0x166,
	1,
	1,
	1,
	1,
	12,
	12,
	12,
	0x15,
	0x1F,
	132,
	6,
	6,
	0,
	अणु 0, 0, 0, 0, 0, 0, 0, 0 पूर्ण,
	अणु 0, 0, 0, 0 पूर्ण,
	true
पूर्ण;

अटल स्थिर काष्ठा ni_cac_weights cac_weights_cayman_le =
अणु
	0x7,
	0xE,
	0x1,
	0xA,
	0x1,
	0x3F,
	0x2,
	0x18,
	0x10,
	0x1A,
	0x1,
	0x3F,
	0x1,
	0xE,
	0x6,
	0x6,
	0x6,
	0x2,
	0x4,
	0x9,
	0x1A,
	0x1A,
	0x2C,
	0xA,
	0x11,
	0x8,
	0x19,
	0x19,
	0x1,
	0x1,
	0x1A,
	0,
	0x8,
	0x5,
	0x8,
	0x1,
	0x3,
	0x1,
	0,
	0,
	0,
	0,
	0,
	0,
	0x38,
	0x38,
	0x239,
	0x3,
	0x18A,
	1,
	1,
	1,
	1,
	12,
	12,
	12,
	0x15,
	0x22,
	132,
	6,
	6,
	0,
	अणु 0, 0, 0, 0, 0, 0, 0, 0 पूर्ण,
	अणु 0, 0, 0, 0 पूर्ण,
	true
पूर्ण;

#घोषणा NISLANDS_MGCG_SEQUENCE  300

अटल स्थिर u32 cayman_cgcg_cgls_शेष[] =
अणु
	0x000008f8, 0x00000010, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000011, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000012, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000013, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000014, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000015, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000016, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000017, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000018, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000019, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001a, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001b, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000020, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000021, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000022, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000023, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000024, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000025, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000026, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000027, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000028, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000029, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000002a, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000002b, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_CGCG_CGLS_DEFAULT_LENGTH माप(cayman_cgcg_cgls_शेष) / (3 * माप(u32))

अटल स्थिर u32 cayman_cgcg_cgls_disable[] =
अणु
	0x000008f8, 0x00000010, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000011, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000012, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000013, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000014, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000015, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000016, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000017, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000018, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000019, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x0000001a, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x0000001b, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000020, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000021, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000022, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000023, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000024, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000025, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000026, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000027, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000028, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000029, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000002a, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000002b, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x00000644, 0x000f7902, 0x001f4180,
	0x00000644, 0x000f3802, 0x001f4180
पूर्ण;
#घोषणा CAYMAN_CGCG_CGLS_DISABLE_LENGTH माप(cayman_cgcg_cgls_disable) / (3 * माप(u32))

अटल स्थिर u32 cayman_cgcg_cgls_enable[] =
अणु
	0x00000644, 0x000f7882, 0x001f4080,
	0x000008f8, 0x00000010, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000011, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000012, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000013, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000014, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000015, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000016, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000017, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000018, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000019, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001a, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001b, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000020, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000021, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000022, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000023, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000024, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000025, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000026, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000027, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000028, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000029, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x0000002a, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x0000002b, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_CGCG_CGLS_ENABLE_LENGTH  माप(cayman_cgcg_cgls_enable) / (3 * माप(u32))

अटल स्थिर u32 cayman_mgcg_शेष[] =
अणु
	0x0000802c, 0xc0000000, 0xffffffff,
	0x00003fc4, 0xc0000000, 0xffffffff,
	0x00005448, 0x00000100, 0xffffffff,
	0x000055e4, 0x00000100, 0xffffffff,
	0x0000160c, 0x00000100, 0xffffffff,
	0x00008984, 0x06000100, 0xffffffff,
	0x0000c164, 0x00000100, 0xffffffff,
	0x00008a18, 0x00000100, 0xffffffff,
	0x0000897c, 0x06000100, 0xffffffff,
	0x00008b28, 0x00000100, 0xffffffff,
	0x00009144, 0x00800200, 0xffffffff,
	0x00009a60, 0x00000100, 0xffffffff,
	0x00009868, 0x00000100, 0xffffffff,
	0x00008d58, 0x00000100, 0xffffffff,
	0x00009510, 0x00000100, 0xffffffff,
	0x0000949c, 0x00000100, 0xffffffff,
	0x00009654, 0x00000100, 0xffffffff,
	0x00009030, 0x00000100, 0xffffffff,
	0x00009034, 0x00000100, 0xffffffff,
	0x00009038, 0x00000100, 0xffffffff,
	0x0000903c, 0x00000100, 0xffffffff,
	0x00009040, 0x00000100, 0xffffffff,
	0x0000a200, 0x00000100, 0xffffffff,
	0x0000a204, 0x00000100, 0xffffffff,
	0x0000a208, 0x00000100, 0xffffffff,
	0x0000a20c, 0x00000100, 0xffffffff,
	0x00009744, 0x00000100, 0xffffffff,
	0x00003f80, 0x00000100, 0xffffffff,
	0x0000a210, 0x00000100, 0xffffffff,
	0x0000a214, 0x00000100, 0xffffffff,
	0x000004d8, 0x00000100, 0xffffffff,
	0x00009664, 0x00000100, 0xffffffff,
	0x00009698, 0x00000100, 0xffffffff,
	0x000004d4, 0x00000200, 0xffffffff,
	0x000004d0, 0x00000000, 0xffffffff,
	0x000030cc, 0x00000104, 0xffffffff,
	0x0000d0c0, 0x00000100, 0xffffffff,
	0x0000d8c0, 0x00000100, 0xffffffff,
	0x0000802c, 0x40000000, 0xffffffff,
	0x00003fc4, 0x40000000, 0xffffffff,
	0x0000915c, 0x00010000, 0xffffffff,
	0x00009160, 0x00030002, 0xffffffff,
	0x00009164, 0x00050004, 0xffffffff,
	0x00009168, 0x00070006, 0xffffffff,
	0x00009178, 0x00070000, 0xffffffff,
	0x0000917c, 0x00030002, 0xffffffff,
	0x00009180, 0x00050004, 0xffffffff,
	0x0000918c, 0x00010006, 0xffffffff,
	0x00009190, 0x00090008, 0xffffffff,
	0x00009194, 0x00070000, 0xffffffff,
	0x00009198, 0x00030002, 0xffffffff,
	0x0000919c, 0x00050004, 0xffffffff,
	0x000091a8, 0x00010006, 0xffffffff,
	0x000091ac, 0x00090008, 0xffffffff,
	0x000091b0, 0x00070000, 0xffffffff,
	0x000091b4, 0x00030002, 0xffffffff,
	0x000091b8, 0x00050004, 0xffffffff,
	0x000091c4, 0x00010006, 0xffffffff,
	0x000091c8, 0x00090008, 0xffffffff,
	0x000091cc, 0x00070000, 0xffffffff,
	0x000091d0, 0x00030002, 0xffffffff,
	0x000091d4, 0x00050004, 0xffffffff,
	0x000091e0, 0x00010006, 0xffffffff,
	0x000091e4, 0x00090008, 0xffffffff,
	0x000091e8, 0x00000000, 0xffffffff,
	0x000091ec, 0x00070000, 0xffffffff,
	0x000091f0, 0x00030002, 0xffffffff,
	0x000091f4, 0x00050004, 0xffffffff,
	0x00009200, 0x00010006, 0xffffffff,
	0x00009204, 0x00090008, 0xffffffff,
	0x00009208, 0x00070000, 0xffffffff,
	0x0000920c, 0x00030002, 0xffffffff,
	0x00009210, 0x00050004, 0xffffffff,
	0x0000921c, 0x00010006, 0xffffffff,
	0x00009220, 0x00090008, 0xffffffff,
	0x00009224, 0x00070000, 0xffffffff,
	0x00009228, 0x00030002, 0xffffffff,
	0x0000922c, 0x00050004, 0xffffffff,
	0x00009238, 0x00010006, 0xffffffff,
	0x0000923c, 0x00090008, 0xffffffff,
	0x00009240, 0x00070000, 0xffffffff,
	0x00009244, 0x00030002, 0xffffffff,
	0x00009248, 0x00050004, 0xffffffff,
	0x00009254, 0x00010006, 0xffffffff,
	0x00009258, 0x00090008, 0xffffffff,
	0x0000925c, 0x00070000, 0xffffffff,
	0x00009260, 0x00030002, 0xffffffff,
	0x00009264, 0x00050004, 0xffffffff,
	0x00009270, 0x00010006, 0xffffffff,
	0x00009274, 0x00090008, 0xffffffff,
	0x00009278, 0x00070000, 0xffffffff,
	0x0000927c, 0x00030002, 0xffffffff,
	0x00009280, 0x00050004, 0xffffffff,
	0x0000928c, 0x00010006, 0xffffffff,
	0x00009290, 0x00090008, 0xffffffff,
	0x000092a8, 0x00070000, 0xffffffff,
	0x000092ac, 0x00030002, 0xffffffff,
	0x000092b0, 0x00050004, 0xffffffff,
	0x000092bc, 0x00010006, 0xffffffff,
	0x000092c0, 0x00090008, 0xffffffff,
	0x000092c4, 0x00070000, 0xffffffff,
	0x000092c8, 0x00030002, 0xffffffff,
	0x000092cc, 0x00050004, 0xffffffff,
	0x000092d8, 0x00010006, 0xffffffff,
	0x000092dc, 0x00090008, 0xffffffff,
	0x00009294, 0x00000000, 0xffffffff,
	0x0000802c, 0x40010000, 0xffffffff,
	0x00003fc4, 0x40010000, 0xffffffff,
	0x0000915c, 0x00010000, 0xffffffff,
	0x00009160, 0x00030002, 0xffffffff,
	0x00009164, 0x00050004, 0xffffffff,
	0x00009168, 0x00070006, 0xffffffff,
	0x00009178, 0x00070000, 0xffffffff,
	0x0000917c, 0x00030002, 0xffffffff,
	0x00009180, 0x00050004, 0xffffffff,
	0x0000918c, 0x00010006, 0xffffffff,
	0x00009190, 0x00090008, 0xffffffff,
	0x00009194, 0x00070000, 0xffffffff,
	0x00009198, 0x00030002, 0xffffffff,
	0x0000919c, 0x00050004, 0xffffffff,
	0x000091a8, 0x00010006, 0xffffffff,
	0x000091ac, 0x00090008, 0xffffffff,
	0x000091b0, 0x00070000, 0xffffffff,
	0x000091b4, 0x00030002, 0xffffffff,
	0x000091b8, 0x00050004, 0xffffffff,
	0x000091c4, 0x00010006, 0xffffffff,
	0x000091c8, 0x00090008, 0xffffffff,
	0x000091cc, 0x00070000, 0xffffffff,
	0x000091d0, 0x00030002, 0xffffffff,
	0x000091d4, 0x00050004, 0xffffffff,
	0x000091e0, 0x00010006, 0xffffffff,
	0x000091e4, 0x00090008, 0xffffffff,
	0x000091e8, 0x00000000, 0xffffffff,
	0x000091ec, 0x00070000, 0xffffffff,
	0x000091f0, 0x00030002, 0xffffffff,
	0x000091f4, 0x00050004, 0xffffffff,
	0x00009200, 0x00010006, 0xffffffff,
	0x00009204, 0x00090008, 0xffffffff,
	0x00009208, 0x00070000, 0xffffffff,
	0x0000920c, 0x00030002, 0xffffffff,
	0x00009210, 0x00050004, 0xffffffff,
	0x0000921c, 0x00010006, 0xffffffff,
	0x00009220, 0x00090008, 0xffffffff,
	0x00009224, 0x00070000, 0xffffffff,
	0x00009228, 0x00030002, 0xffffffff,
	0x0000922c, 0x00050004, 0xffffffff,
	0x00009238, 0x00010006, 0xffffffff,
	0x0000923c, 0x00090008, 0xffffffff,
	0x00009240, 0x00070000, 0xffffffff,
	0x00009244, 0x00030002, 0xffffffff,
	0x00009248, 0x00050004, 0xffffffff,
	0x00009254, 0x00010006, 0xffffffff,
	0x00009258, 0x00090008, 0xffffffff,
	0x0000925c, 0x00070000, 0xffffffff,
	0x00009260, 0x00030002, 0xffffffff,
	0x00009264, 0x00050004, 0xffffffff,
	0x00009270, 0x00010006, 0xffffffff,
	0x00009274, 0x00090008, 0xffffffff,
	0x00009278, 0x00070000, 0xffffffff,
	0x0000927c, 0x00030002, 0xffffffff,
	0x00009280, 0x00050004, 0xffffffff,
	0x0000928c, 0x00010006, 0xffffffff,
	0x00009290, 0x00090008, 0xffffffff,
	0x000092a8, 0x00070000, 0xffffffff,
	0x000092ac, 0x00030002, 0xffffffff,
	0x000092b0, 0x00050004, 0xffffffff,
	0x000092bc, 0x00010006, 0xffffffff,
	0x000092c0, 0x00090008, 0xffffffff,
	0x000092c4, 0x00070000, 0xffffffff,
	0x000092c8, 0x00030002, 0xffffffff,
	0x000092cc, 0x00050004, 0xffffffff,
	0x000092d8, 0x00010006, 0xffffffff,
	0x000092dc, 0x00090008, 0xffffffff,
	0x00009294, 0x00000000, 0xffffffff,
	0x0000802c, 0xc0000000, 0xffffffff,
	0x00003fc4, 0xc0000000, 0xffffffff,
	0x000008f8, 0x00000010, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000011, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000012, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000013, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000014, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000015, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000016, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000017, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000018, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000019, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001a, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x0000001b, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_MGCG_DEFAULT_LENGTH माप(cayman_mgcg_शेष) / (3 * माप(u32))

अटल स्थिर u32 cayman_mgcg_disable[] =
अणु
	0x0000802c, 0xc0000000, 0xffffffff,
	0x000008f8, 0x00000000, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000001, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000002, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x000008f8, 0x00000003, 0xffffffff,
	0x000008fc, 0xffffffff, 0xffffffff,
	0x00009150, 0x00600000, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_MGCG_DISABLE_LENGTH   माप(cayman_mgcg_disable) / (3 * माप(u32))

अटल स्थिर u32 cayman_mgcg_enable[] =
अणु
	0x0000802c, 0xc0000000, 0xffffffff,
	0x000008f8, 0x00000000, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000001, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x000008f8, 0x00000002, 0xffffffff,
	0x000008fc, 0x00600000, 0xffffffff,
	0x000008f8, 0x00000003, 0xffffffff,
	0x000008fc, 0x00000000, 0xffffffff,
	0x00009150, 0x96944200, 0xffffffff
पूर्ण;

#घोषणा CAYMAN_MGCG_ENABLE_LENGTH   माप(cayman_mgcg_enable) / (3 * माप(u32))

#घोषणा NISLANDS_SYSLS_SEQUENCE  100

अटल स्थिर u32 cayman_sysls_शेष[] =
अणु
	/* Register,   Value,     Mask bits */
	0x000055e8, 0x00000000, 0xffffffff,
	0x0000d0bc, 0x00000000, 0xffffffff,
	0x0000d8bc, 0x00000000, 0xffffffff,
	0x000015c0, 0x000c1401, 0xffffffff,
	0x0000264c, 0x000c0400, 0xffffffff,
	0x00002648, 0x000c0400, 0xffffffff,
	0x00002650, 0x000c0400, 0xffffffff,
	0x000020b8, 0x000c0400, 0xffffffff,
	0x000020bc, 0x000c0400, 0xffffffff,
	0x000020c0, 0x000c0c80, 0xffffffff,
	0x0000f4a0, 0x000000c0, 0xffffffff,
	0x0000f4a4, 0x00680fff, 0xffffffff,
	0x00002f50, 0x00000404, 0xffffffff,
	0x000004c8, 0x00000001, 0xffffffff,
	0x000064ec, 0x00000000, 0xffffffff,
	0x00000c7c, 0x00000000, 0xffffffff,
	0x00008dfc, 0x00000000, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_SYSLS_DEFAULT_LENGTH माप(cayman_sysls_शेष) / (3 * माप(u32))

अटल स्थिर u32 cayman_sysls_disable[] =
अणु
	/* Register,   Value,     Mask bits */
	0x0000d0c0, 0x00000000, 0xffffffff,
	0x0000d8c0, 0x00000000, 0xffffffff,
	0x000055e8, 0x00000000, 0xffffffff,
	0x0000d0bc, 0x00000000, 0xffffffff,
	0x0000d8bc, 0x00000000, 0xffffffff,
	0x000015c0, 0x00041401, 0xffffffff,
	0x0000264c, 0x00040400, 0xffffffff,
	0x00002648, 0x00040400, 0xffffffff,
	0x00002650, 0x00040400, 0xffffffff,
	0x000020b8, 0x00040400, 0xffffffff,
	0x000020bc, 0x00040400, 0xffffffff,
	0x000020c0, 0x00040c80, 0xffffffff,
	0x0000f4a0, 0x000000c0, 0xffffffff,
	0x0000f4a4, 0x00680000, 0xffffffff,
	0x00002f50, 0x00000404, 0xffffffff,
	0x000004c8, 0x00000001, 0xffffffff,
	0x000064ec, 0x00007ffd, 0xffffffff,
	0x00000c7c, 0x0000ff00, 0xffffffff,
	0x00008dfc, 0x0000007f, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_SYSLS_DISABLE_LENGTH माप(cayman_sysls_disable) / (3 * माप(u32))

अटल स्थिर u32 cayman_sysls_enable[] =
अणु
	/* Register,   Value,     Mask bits */
	0x000055e8, 0x00000001, 0xffffffff,
	0x0000d0bc, 0x00000100, 0xffffffff,
	0x0000d8bc, 0x00000100, 0xffffffff,
	0x000015c0, 0x000c1401, 0xffffffff,
	0x0000264c, 0x000c0400, 0xffffffff,
	0x00002648, 0x000c0400, 0xffffffff,
	0x00002650, 0x000c0400, 0xffffffff,
	0x000020b8, 0x000c0400, 0xffffffff,
	0x000020bc, 0x000c0400, 0xffffffff,
	0x000020c0, 0x000c0c80, 0xffffffff,
	0x0000f4a0, 0x000000c0, 0xffffffff,
	0x0000f4a4, 0x00680fff, 0xffffffff,
	0x00002f50, 0x00000903, 0xffffffff,
	0x000004c8, 0x00000000, 0xffffffff,
	0x000064ec, 0x00000000, 0xffffffff,
	0x00000c7c, 0x00000000, 0xffffffff,
	0x00008dfc, 0x00000000, 0xffffffff
पूर्ण;
#घोषणा CAYMAN_SYSLS_ENABLE_LENGTH माप(cayman_sysls_enable) / (3 * माप(u32))

बाह्य पूर्णांक ni_mc_load_microcode(काष्ठा radeon_device *rdev);

काष्ठा ni_घातer_info *ni_get_pi(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ni_घातer_info *pi = rdev->pm.dpm.priv;

	वापस pi;
पूर्ण

काष्ठा ni_ps *ni_get_ps(काष्ठा radeon_ps *rps)
अणु
	काष्ठा ni_ps *ps = rps->ps_priv;

	वापस ps;
पूर्ण

अटल व्योम ni_calculate_leakage_क्रम_v_and_t_क्रमmula(स्थिर काष्ठा ni_leakage_coeffients *coeff,
						     u16 v, s32 t,
						     u32 ileakage,
						     u32 *leakage)
अणु
	s64 kt, kv, leakage_w, i_leakage, vddc, temperature;

	i_leakage = भाग64_s64(drm_पूर्णांक2fixp(ileakage), 1000);
	vddc = भाग64_s64(drm_पूर्णांक2fixp(v), 1000);
	temperature = भाग64_s64(drm_पूर्णांक2fixp(t), 1000);

	kt = drm_fixp_mul(भाग64_s64(drm_पूर्णांक2fixp(coeff->at), 1000),
			  drm_fixp_exp(drm_fixp_mul(भाग64_s64(drm_पूर्णांक2fixp(coeff->bt), 1000), temperature)));
	kv = drm_fixp_mul(भाग64_s64(drm_पूर्णांक2fixp(coeff->av), 1000),
			  drm_fixp_exp(drm_fixp_mul(भाग64_s64(drm_पूर्णांक2fixp(coeff->bv), 1000), vddc)));

	leakage_w = drm_fixp_mul(drm_fixp_mul(drm_fixp_mul(i_leakage, kt), kv), vddc);

	*leakage = drm_fixp2पूर्णांक(leakage_w * 1000);
पूर्ण

अटल व्योम ni_calculate_leakage_क्रम_v_and_t(काष्ठा radeon_device *rdev,
					     स्थिर काष्ठा ni_leakage_coeffients *coeff,
					     u16 v,
					     s32 t,
					     u32 i_leakage,
					     u32 *leakage)
अणु
	ni_calculate_leakage_क्रम_v_and_t_क्रमmula(coeff, v, t, i_leakage, leakage);
पूर्ण

bool ni_dpm_vblank_too_लघु(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u32 vblank_समय = r600_dpm_get_vblank_समय(rdev);
	/* we never hit the non-gddr5 limit so disable it */
	u32 चयन_limit = pi->mem_gddr5 ? 450 : 0;

	अगर (vblank_समय < चयन_limit)
		वापस true;
	अन्यथा
		वापस false;

पूर्ण

अटल व्योम ni_apply_state_adjust_rules(काष्ठा radeon_device *rdev,
					काष्ठा radeon_ps *rps)
अणु
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	bool disable_mclk_चयनing;
	u32 mclk;
	u16 vddci;
	पूर्णांक i;

	अगर ((rdev->pm.dpm.new_active_crtc_count > 1) ||
	    ni_dpm_vblank_too_लघु(rdev))
		disable_mclk_चयनing = true;
	अन्यथा
		disable_mclk_चयनing = false;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (rdev->pm.dpm.ac_घातer == false) अणु
		क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
			अगर (ps->perक्रमmance_levels[i].mclk > max_limits->mclk)
				ps->perक्रमmance_levels[i].mclk = max_limits->mclk;
			अगर (ps->perक्रमmance_levels[i].sclk > max_limits->sclk)
				ps->perक्रमmance_levels[i].sclk = max_limits->sclk;
			अगर (ps->perक्रमmance_levels[i].vddc > max_limits->vddc)
				ps->perक्रमmance_levels[i].vddc = max_limits->vddc;
			अगर (ps->perक्रमmance_levels[i].vddci > max_limits->vddci)
				ps->perक्रमmance_levels[i].vddci = max_limits->vddci;
		पूर्ण
	पूर्ण

	/* XXX validate the min घड़ीs required क्रम display */

	/* adjust low state */
	अगर (disable_mclk_चयनing) अणु
		ps->perक्रमmance_levels[0].mclk =
			ps->perक्रमmance_levels[ps->perक्रमmance_level_count - 1].mclk;
		ps->perक्रमmance_levels[0].vddci =
			ps->perक्रमmance_levels[ps->perक्रमmance_level_count - 1].vddci;
	पूर्ण

	btc_skip_blacklist_घड़ीs(rdev, max_limits->sclk, max_limits->mclk,
				  &ps->perक्रमmance_levels[0].sclk,
				  &ps->perक्रमmance_levels[0].mclk);

	क्रम (i = 1; i < ps->perक्रमmance_level_count; i++) अणु
		अगर (ps->perक्रमmance_levels[i].sclk < ps->perक्रमmance_levels[i - 1].sclk)
			ps->perक्रमmance_levels[i].sclk = ps->perक्रमmance_levels[i - 1].sclk;
		अगर (ps->perक्रमmance_levels[i].vddc < ps->perक्रमmance_levels[i - 1].vddc)
			ps->perक्रमmance_levels[i].vddc = ps->perक्रमmance_levels[i - 1].vddc;
	पूर्ण

	/* adjust reमुख्यing states */
	अगर (disable_mclk_चयनing) अणु
		mclk = ps->perक्रमmance_levels[0].mclk;
		vddci = ps->perक्रमmance_levels[0].vddci;
		क्रम (i = 1; i < ps->perक्रमmance_level_count; i++) अणु
			अगर (mclk < ps->perक्रमmance_levels[i].mclk)
				mclk = ps->perक्रमmance_levels[i].mclk;
			अगर (vddci < ps->perक्रमmance_levels[i].vddci)
				vddci = ps->perक्रमmance_levels[i].vddci;
		पूर्ण
		क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
			ps->perक्रमmance_levels[i].mclk = mclk;
			ps->perक्रमmance_levels[i].vddci = vddci;
		पूर्ण
	पूर्ण अन्यथा अणु
		क्रम (i = 1; i < ps->perक्रमmance_level_count; i++) अणु
			अगर (ps->perक्रमmance_levels[i].mclk < ps->perक्रमmance_levels[i - 1].mclk)
				ps->perक्रमmance_levels[i].mclk = ps->perक्रमmance_levels[i - 1].mclk;
			अगर (ps->perक्रमmance_levels[i].vddci < ps->perक्रमmance_levels[i - 1].vddci)
				ps->perक्रमmance_levels[i].vddci = ps->perक्रमmance_levels[i - 1].vddci;
		पूर्ण
	पूर्ण

	क्रम (i = 1; i < ps->perक्रमmance_level_count; i++)
		btc_skip_blacklist_घड़ीs(rdev, max_limits->sclk, max_limits->mclk,
					  &ps->perक्रमmance_levels[i].sclk,
					  &ps->perक्रमmance_levels[i].mclk);

	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++)
		btc_adjust_घड़ी_combinations(rdev, max_limits,
					      &ps->perक्रमmance_levels[i]);

	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
						   ps->perक्रमmance_levels[i].sclk,
						   max_limits->vddc,  &ps->perक्रमmance_levels[i].vddc);
		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
						   ps->perक्रमmance_levels[i].mclk,
						   max_limits->vddci, &ps->perक्रमmance_levels[i].vddci);
		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
						   ps->perक्रमmance_levels[i].mclk,
						   max_limits->vddc,  &ps->perक्रमmance_levels[i].vddc);
		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,
						   rdev->घड़ी.current_dispclk,
						   max_limits->vddc,  &ps->perक्रमmance_levels[i].vddc);
	पूर्ण

	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
		btc_apply_voltage_delta_rules(rdev,
					      max_limits->vddc, max_limits->vddci,
					      &ps->perक्रमmance_levels[i].vddc,
					      &ps->perक्रमmance_levels[i].vddci);
	पूर्ण

	ps->dc_compatible = true;
	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
		अगर (ps->perक्रमmance_levels[i].vddc > rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc.vddc)
			ps->dc_compatible = false;

		अगर (ps->perक्रमmance_levels[i].vddc < rdev->pm.dpm.dyn_state.min_vddc_क्रम_pcie_gen2)
			ps->perक्रमmance_levels[i].flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;
	पूर्ण
पूर्ण

अटल व्योम ni_cg_घड़ीgating_शेष(काष्ठा radeon_device *rdev)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	ps = (स्थिर u32 *)&cayman_cgcg_cgls_शेष;
	count = CAYMAN_CGCG_CGLS_DEFAULT_LENGTH;

	btc_program_mgcg_hw_sequence(rdev, ps, count);
पूर्ण

अटल व्योम ni_gfx_घड़ीgating_enable(काष्ठा radeon_device *rdev,
				      bool enable)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	अगर (enable) अणु
		ps = (स्थिर u32 *)&cayman_cgcg_cgls_enable;
		count = CAYMAN_CGCG_CGLS_ENABLE_LENGTH;
	पूर्ण अन्यथा अणु
		ps = (स्थिर u32 *)&cayman_cgcg_cgls_disable;
		count = CAYMAN_CGCG_CGLS_DISABLE_LENGTH;
	पूर्ण

	btc_program_mgcg_hw_sequence(rdev, ps, count);
पूर्ण

अटल व्योम ni_mg_घड़ीgating_शेष(काष्ठा radeon_device *rdev)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	ps = (स्थिर u32 *)&cayman_mgcg_शेष;
	count = CAYMAN_MGCG_DEFAULT_LENGTH;

	btc_program_mgcg_hw_sequence(rdev, ps, count);
पूर्ण

अटल व्योम ni_mg_घड़ीgating_enable(काष्ठा radeon_device *rdev,
				     bool enable)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	अगर (enable) अणु
		ps = (स्थिर u32 *)&cayman_mgcg_enable;
		count = CAYMAN_MGCG_ENABLE_LENGTH;
	पूर्ण अन्यथा अणु
		ps = (स्थिर u32 *)&cayman_mgcg_disable;
		count = CAYMAN_MGCG_DISABLE_LENGTH;
	पूर्ण

	btc_program_mgcg_hw_sequence(rdev, ps, count);
पूर्ण

अटल व्योम ni_ls_घड़ीgating_शेष(काष्ठा radeon_device *rdev)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	ps = (स्थिर u32 *)&cayman_sysls_शेष;
	count = CAYMAN_SYSLS_DEFAULT_LENGTH;

	btc_program_mgcg_hw_sequence(rdev, ps, count);
पूर्ण

अटल व्योम ni_ls_घड़ीgating_enable(काष्ठा radeon_device *rdev,
				     bool enable)
अणु
	u32 count;
	स्थिर u32 *ps = शून्य;

	अगर (enable) अणु
		ps = (स्थिर u32 *)&cayman_sysls_enable;
		count = CAYMAN_SYSLS_ENABLE_LENGTH;
	पूर्ण अन्यथा अणु
		ps = (स्थिर u32 *)&cayman_sysls_disable;
		count = CAYMAN_SYSLS_DISABLE_LENGTH;
	पूर्ण

	btc_program_mgcg_hw_sequence(rdev, ps, count);

पूर्ण

अटल पूर्णांक ni_patch_single_dependency_table_based_on_leakage(काष्ठा radeon_device *rdev,
							     काष्ठा radeon_घड़ी_voltage_dependency_table *table)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++) अणु
			अगर (0xff01 == table->entries[i].v) अणु
				अगर (pi->max_vddc == 0)
					वापस -EINVAL;
				table->entries[i].v = pi->max_vddc;
			पूर्ण
		पूर्ण
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ni_patch_dependency_tables_based_on_leakage(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक ret = 0;

	ret = ni_patch_single_dependency_table_based_on_leakage(rdev,
								&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk);

	ret = ni_patch_single_dependency_table_based_on_leakage(rdev,
								&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk);
	वापस ret;
पूर्ण

अटल व्योम ni_stop_dpm(काष्ठा radeon_device *rdev)
अणु
	WREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);
पूर्ण

#अगर 0
अटल पूर्णांक ni_notअगरy_hw_of_घातer_source(काष्ठा radeon_device *rdev,
					bool ac_घातer)
अणु
	अगर (ac_घातer)
		वापस (rv770_send_msg_to_smc(rdev, PPSMC_MSG_RunningOnAC) == PPSMC_Result_OK) ?
			0 : -EINVAL;

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल PPSMC_Result ni_send_msg_to_smc_with_parameter(काष्ठा radeon_device *rdev,
						      PPSMC_Msg msg, u32 parameter)
अणु
	WREG32(SMC_SCRATCH0, parameter);
	वापस rv770_send_msg_to_smc(rdev, msg);
पूर्ण

अटल पूर्णांक ni_restrict_perक्रमmance_levels_beक्रमe_चयन(काष्ठा radeon_device *rdev)
अणु
	अगर (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)
		वापस -EINVAL;

	वापस (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 1) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण

पूर्णांक ni_dpm_क्रमce_perक्रमmance_level(काष्ठा radeon_device *rdev,
				   क्रमागत radeon_dpm_क्रमced_level level)
अणु
	अगर (level == RADEON_DPM_FORCED_LEVEL_HIGH) अणु
		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 0) != PPSMC_Result_OK)
			वापस -EINVAL;

		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 1) != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण अन्यथा अगर (level == RADEON_DPM_FORCED_LEVEL_LOW) अणु
		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)
			वापस -EINVAL;

		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 1) != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण अन्यथा अगर (level == RADEON_DPM_FORCED_LEVEL_AUTO) अणु
		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)
			वापस -EINVAL;

		अगर (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 0) != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	rdev->pm.dpm.क्रमced_level = level;

	वापस 0;
पूर्ण

अटल व्योम ni_stop_smc(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp;
	पूर्णांक i;

	क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
		पंचांगp = RREG32(LB_SYNC_RESET_SEL) & LB_SYNC_RESET_SEL_MASK;
		अगर (पंचांगp != 1)
			अवरोध;
		udelay(1);
	पूर्ण

	udelay(100);

	r7xx_stop_smc(rdev);
पूर्ण

अटल पूर्णांक ni_process_firmware_header(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 पंचांगp;
	पूर्णांक ret;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_stateTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	pi->state_table_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_softRegisters,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	pi->soft_regs_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_mcRegisterTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	eg_pi->mc_reg_table_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_fanTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	ni_pi->fan_table_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_mcArbDramAutoRefreshTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	ni_pi->arb_table_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_cacTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	ni_pi->cac_table_start = (u16)पंचांगp;

	ret = rv770_पढ़ो_smc_sram_dword(rdev,
					NISLANDS_SMC_FIRMWARE_HEADER_LOCATION +
					NISLANDS_SMC_FIRMWARE_HEADER_spllTable,
					&पंचांगp, pi->sram_end);

	अगर (ret)
		वापस ret;

	ni_pi->spll_table_start = (u16)पंचांगp;


	वापस ret;
पूर्ण

अटल व्योम ni_पढ़ो_घड़ी_रेजिस्टरs(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);

	ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl = RREG32(CG_SPLL_FUNC_CNTL);
	ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2 = RREG32(CG_SPLL_FUNC_CNTL_2);
	ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3 = RREG32(CG_SPLL_FUNC_CNTL_3);
	ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4 = RREG32(CG_SPLL_FUNC_CNTL_4);
	ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum = RREG32(CG_SPLL_SPREAD_SPECTRUM);
	ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2 = RREG32(CG_SPLL_SPREAD_SPECTRUM_2);
	ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl = RREG32(MPLL_AD_FUNC_CNTL);
	ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl_2 = RREG32(MPLL_AD_FUNC_CNTL_2);
	ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl = RREG32(MPLL_DQ_FUNC_CNTL);
	ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl_2 = RREG32(MPLL_DQ_FUNC_CNTL_2);
	ni_pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl = RREG32(MCLK_PWRMGT_CNTL);
	ni_pi->घड़ी_रेजिस्टरs.dll_cntl = RREG32(DLL_CNTL);
	ni_pi->घड़ी_रेजिस्टरs.mpll_ss1 = RREG32(MPLL_SS1);
	ni_pi->घड़ी_रेजिस्टरs.mpll_ss2 = RREG32(MPLL_SS2);
पूर्ण

#अगर 0
अटल पूर्णांक ni_enter_ulp_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);

	अगर (pi->gfx_घड़ी_gating) अणु
		WREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);
		WREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);
		WREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);
		RREG32(GB_ADDR_CONFIG);
	पूर्ण

	WREG32_P(SMC_MSG, HOST_SMC_MSG(PPSMC_MSG_SwitchToMinimumPower),
		 ~HOST_SMC_MSG_MASK);

	udelay(25000);

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल व्योम ni_program_response_बार(काष्ठा radeon_device *rdev)
अणु
	u32 voltage_response_समय, backbias_response_समय, acpi_delay_समय, vbi_समय_out;
	u32 vddc_dly, bb_dly, acpi_dly, vbi_dly, mclk_चयन_limit;
	u32 reference_घड़ी;

	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_mvdd_chg_समय, 1);

	voltage_response_समय = (u32)rdev->pm.dpm.voltage_response_समय;
	backbias_response_समय = (u32)rdev->pm.dpm.backbias_response_समय;

	अगर (voltage_response_समय == 0)
		voltage_response_समय = 1000;

	अगर (backbias_response_समय == 0)
		backbias_response_समय = 1000;

	acpi_delay_समय = 15000;
	vbi_समय_out = 100000;

	reference_घड़ी = radeon_get_xclk(rdev);

	vddc_dly = (voltage_response_समय  * reference_घड़ी) / 1600;
	bb_dly   = (backbias_response_समय * reference_घड़ी) / 1600;
	acpi_dly = (acpi_delay_समय * reference_घड़ी) / 1600;
	vbi_dly  = (vbi_समय_out * reference_घड़ी) / 1600;

	mclk_चयन_limit = (460 * reference_घड़ी) / 100;

	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_delay_vreg,  vddc_dly);
	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_delay_bbias, bb_dly);
	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_delay_acpi,  acpi_dly);
	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_mclk_chg_समयout, vbi_dly);
	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_mc_block_delay, 0xAA);
	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_mclk_चयन_lim, mclk_चयन_limit);
पूर्ण

अटल व्योम ni_populate_smc_voltage_table(काष्ठा radeon_device *rdev,
					  काष्ठा atom_voltage_table *voltage_table,
					  NISLANDS_SMC_STATETABLE *table)
अणु
	अचिन्हित पूर्णांक i;

	क्रम (i = 0; i < voltage_table->count; i++) अणु
		table->highSMIO[i] = 0;
		table->lowSMIO[i] |= cpu_to_be32(voltage_table->entries[i].smio_low);
	पूर्ण
पूर्ण

अटल व्योम ni_populate_smc_voltage_tables(काष्ठा radeon_device *rdev,
					   NISLANDS_SMC_STATETABLE *table)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	अचिन्हित अक्षर i;

	अगर (eg_pi->vddc_voltage_table.count) अणु
		ni_populate_smc_voltage_table(rdev, &eg_pi->vddc_voltage_table, table);
		table->voltageMaskTable.highMask[NISLANDS_SMC_VOLTAGEMASK_VDDC] = 0;
		table->voltageMaskTable.lowMask[NISLANDS_SMC_VOLTAGEMASK_VDDC] =
			cpu_to_be32(eg_pi->vddc_voltage_table.mask_low);

		क्रम (i = 0; i < eg_pi->vddc_voltage_table.count; i++) अणु
			अगर (pi->max_vddc_in_table <= eg_pi->vddc_voltage_table.entries[i].value) अणु
				table->maxVDDCIndexInPPTable = i;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण

	अगर (eg_pi->vddci_voltage_table.count) अणु
		ni_populate_smc_voltage_table(rdev, &eg_pi->vddci_voltage_table, table);

		table->voltageMaskTable.highMask[NISLANDS_SMC_VOLTAGEMASK_VDDCI] = 0;
		table->voltageMaskTable.lowMask[NISLANDS_SMC_VOLTAGEMASK_VDDCI] =
			cpu_to_be32(eg_pi->vddci_voltage_table.mask_low);
	पूर्ण
पूर्ण

अटल पूर्णांक ni_populate_voltage_value(काष्ठा radeon_device *rdev,
				     काष्ठा atom_voltage_table *table,
				     u16 value,
				     NISLANDS_SMC_VOLTAGE_VALUE *voltage)
अणु
	अचिन्हित पूर्णांक i;

	क्रम (i = 0; i < table->count; i++) अणु
		अगर (value <= table->entries[i].value) अणु
			voltage->index = (u8)i;
			voltage->value = cpu_to_be16(table->entries[i].value);
			अवरोध;
		पूर्ण
	पूर्ण

	अगर (i >= table->count)
		वापस -EINVAL;

	वापस 0;
पूर्ण

अटल व्योम ni_populate_mvdd_value(काष्ठा radeon_device *rdev,
				   u32 mclk,
				   NISLANDS_SMC_VOLTAGE_VALUE *voltage)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);

	अगर (!pi->mvdd_control) अणु
		voltage->index = eg_pi->mvdd_high_index;
		voltage->value = cpu_to_be16(MVDD_HIGH_VALUE);
		वापस;
	पूर्ण

	अगर (mclk <= pi->mvdd_split_frequency) अणु
		voltage->index = eg_pi->mvdd_low_index;
		voltage->value = cpu_to_be16(MVDD_LOW_VALUE);
	पूर्ण अन्यथा अणु
		voltage->index = eg_pi->mvdd_high_index;
		voltage->value = cpu_to_be16(MVDD_HIGH_VALUE);
	पूर्ण
पूर्ण

अटल पूर्णांक ni_get_std_voltage_value(काष्ठा radeon_device *rdev,
				    NISLANDS_SMC_VOLTAGE_VALUE *voltage,
				    u16 *std_voltage)
अणु
	अगर (rdev->pm.dpm.dyn_state.cac_leakage_table.entries &&
	    ((u32)voltage->index < rdev->pm.dpm.dyn_state.cac_leakage_table.count))
		*std_voltage = rdev->pm.dpm.dyn_state.cac_leakage_table.entries[voltage->index].vddc;
	अन्यथा
		*std_voltage = be16_to_cpu(voltage->value);

	वापस 0;
पूर्ण

अटल व्योम ni_populate_std_voltage_value(काष्ठा radeon_device *rdev,
					  u16 value, u8 index,
					  NISLANDS_SMC_VOLTAGE_VALUE *voltage)
अणु
	voltage->index = index;
	voltage->value = cpu_to_be16(value);
पूर्ण

अटल u32 ni_get_smc_घातer_scaling_factor(काष्ठा radeon_device *rdev)
अणु
	u32 xclk_period;
	u32 xclk = radeon_get_xclk(rdev);
	u32 पंचांगp = RREG32(CG_CAC_CTRL) & TID_CNT_MASK;

	xclk_period = (1000000000UL / xclk);
	xclk_period /= 10000UL;

	वापस पंचांगp * xclk_period;
पूर्ण

अटल u32 ni_scale_घातer_क्रम_smc(u32 घातer_in_watts, u32 scaling_factor)
अणु
	वापस (घातer_in_watts * scaling_factor) << 2;
पूर्ण

अटल u32 ni_calculate_घातer_boost_limit(काष्ठा radeon_device *rdev,
					  काष्ठा radeon_ps *radeon_state,
					  u32 near_tdp_limit)
अणु
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 घातer_boost_limit = 0;
	पूर्णांक ret;

	अगर (ni_pi->enable_घातer_containment &&
	    ni_pi->use_घातer_boost_limit) अणु
		NISLANDS_SMC_VOLTAGE_VALUE vddc;
		u16 std_vddc_med;
		u16 std_vddc_high;
		u64 पंचांगp, n, d;

		अगर (state->perक्रमmance_level_count < 3)
			वापस 0;

		ret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,
						state->perक्रमmance_levels[state->perक्रमmance_level_count - 2].vddc,
						&vddc);
		अगर (ret)
			वापस 0;

		ret = ni_get_std_voltage_value(rdev, &vddc, &std_vddc_med);
		अगर (ret)
			वापस 0;

		ret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,
						state->perक्रमmance_levels[state->perक्रमmance_level_count - 1].vddc,
						&vddc);
		अगर (ret)
			वापस 0;

		ret = ni_get_std_voltage_value(rdev, &vddc, &std_vddc_high);
		अगर (ret)
			वापस 0;

		n = ((u64)near_tdp_limit * ((u64)std_vddc_med * (u64)std_vddc_med) * 90);
		d = ((u64)std_vddc_high * (u64)std_vddc_high * 100);
		पंचांगp = भाग64_u64(n, d);

		अगर (पंचांगp >> 32)
			वापस 0;
		घातer_boost_limit = (u32)पंचांगp;
	पूर्ण

	वापस घातer_boost_limit;
पूर्ण

अटल पूर्णांक ni_calculate_adjusted_tdp_limits(काष्ठा radeon_device *rdev,
					    bool adjust_polarity,
					    u32 tdp_adjusपंचांगent,
					    u32 *tdp_limit,
					    u32 *near_tdp_limit)
अणु
	अगर (tdp_adjusपंचांगent > (u32)rdev->pm.dpm.tdp_od_limit)
		वापस -EINVAL;

	अगर (adjust_polarity) अणु
		*tdp_limit = ((100 + tdp_adjusपंचांगent) * rdev->pm.dpm.tdp_limit) / 100;
		*near_tdp_limit = rdev->pm.dpm.near_tdp_limit + (*tdp_limit - rdev->pm.dpm.tdp_limit);
	पूर्ण अन्यथा अणु
		*tdp_limit = ((100 - tdp_adjusपंचांगent) * rdev->pm.dpm.tdp_limit) / 100;
		*near_tdp_limit = rdev->pm.dpm.near_tdp_limit - (rdev->pm.dpm.tdp_limit - *tdp_limit);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ni_populate_smc_tdp_limits(काष्ठा radeon_device *rdev,
				      काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);

	अगर (ni_pi->enable_घातer_containment) अणु
		NISLANDS_SMC_STATETABLE *smc_table = &ni_pi->smc_statetable;
		u32 scaling_factor = ni_get_smc_घातer_scaling_factor(rdev);
		u32 tdp_limit;
		u32 near_tdp_limit;
		u32 घातer_boost_limit;
		पूर्णांक ret;

		अगर (scaling_factor == 0)
			वापस -EINVAL;

		स_रखो(smc_table, 0, माप(NISLANDS_SMC_STATETABLE));

		ret = ni_calculate_adjusted_tdp_limits(rdev,
						       false, /* ??? */
						       rdev->pm.dpm.tdp_adjusपंचांगent,
						       &tdp_limit,
						       &near_tdp_limit);
		अगर (ret)
			वापस ret;

		घातer_boost_limit = ni_calculate_घातer_boost_limit(rdev, radeon_state,
								   near_tdp_limit);

		smc_table->dpm2Params.TDPLimit =
			cpu_to_be32(ni_scale_घातer_क्रम_smc(tdp_limit, scaling_factor));
		smc_table->dpm2Params.NearTDPLimit =
			cpu_to_be32(ni_scale_घातer_क्रम_smc(near_tdp_limit, scaling_factor));
		smc_table->dpm2Params.SafePowerLimit =
			cpu_to_be32(ni_scale_घातer_क्रम_smc((near_tdp_limit * NISLANDS_DPM2_TDP_SAFE_LIMIT_PERCENT) / 100,
							   scaling_factor));
		smc_table->dpm2Params.PowerBoostLimit =
			cpu_to_be32(ni_scale_घातer_क्रम_smc(घातer_boost_limit, scaling_factor));

		ret = rv770_copy_bytes_to_smc(rdev,
					      (u16)(pi->state_table_start + दुरत्व(NISLANDS_SMC_STATETABLE, dpm2Params) +
						    दुरत्व(PP_NIslands_DPM2Parameters, TDPLimit)),
					      (u8 *)(&smc_table->dpm2Params.TDPLimit),
					      माप(u32) * 4, pi->sram_end);
		अगर (ret)
			वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

पूर्णांक ni_copy_and_चयन_arb_sets(काष्ठा radeon_device *rdev,
				u32 arb_freq_src, u32 arb_freq_dest)
अणु
	u32 mc_arb_dram_timing;
	u32 mc_arb_dram_timing2;
	u32 burst_समय;
	u32 mc_cg_config;

	चयन (arb_freq_src) अणु
	हाल MC_CG_ARB_FREQ_F0:
		mc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING);
		mc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);
		burst_समय = (RREG32(MC_ARB_BURST_TIME) & STATE0_MASK) >> STATE0_SHIFT;
		अवरोध;
	हाल MC_CG_ARB_FREQ_F1:
		mc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_1);
		mc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_1);
		burst_समय = (RREG32(MC_ARB_BURST_TIME) & STATE1_MASK) >> STATE1_SHIFT;
		अवरोध;
	हाल MC_CG_ARB_FREQ_F2:
		mc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_2);
		mc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_2);
		burst_समय = (RREG32(MC_ARB_BURST_TIME) & STATE2_MASK) >> STATE2_SHIFT;
		अवरोध;
	हाल MC_CG_ARB_FREQ_F3:
		mc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_3);
		mc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_3);
		burst_समय = (RREG32(MC_ARB_BURST_TIME) & STATE3_MASK) >> STATE3_SHIFT;
		अवरोध;
	शेष:
		वापस -EINVAL;
	पूर्ण

	चयन (arb_freq_dest) अणु
	हाल MC_CG_ARB_FREQ_F0:
		WREG32(MC_ARB_DRAM_TIMING, mc_arb_dram_timing);
		WREG32(MC_ARB_DRAM_TIMING2, mc_arb_dram_timing2);
		WREG32_P(MC_ARB_BURST_TIME, STATE0(burst_समय), ~STATE0_MASK);
		अवरोध;
	हाल MC_CG_ARB_FREQ_F1:
		WREG32(MC_ARB_DRAM_TIMING_1, mc_arb_dram_timing);
		WREG32(MC_ARB_DRAM_TIMING2_1, mc_arb_dram_timing2);
		WREG32_P(MC_ARB_BURST_TIME, STATE1(burst_समय), ~STATE1_MASK);
		अवरोध;
	हाल MC_CG_ARB_FREQ_F2:
		WREG32(MC_ARB_DRAM_TIMING_2, mc_arb_dram_timing);
		WREG32(MC_ARB_DRAM_TIMING2_2, mc_arb_dram_timing2);
		WREG32_P(MC_ARB_BURST_TIME, STATE2(burst_समय), ~STATE2_MASK);
		अवरोध;
	हाल MC_CG_ARB_FREQ_F3:
		WREG32(MC_ARB_DRAM_TIMING_3, mc_arb_dram_timing);
		WREG32(MC_ARB_DRAM_TIMING2_3, mc_arb_dram_timing2);
		WREG32_P(MC_ARB_BURST_TIME, STATE3(burst_समय), ~STATE3_MASK);
		अवरोध;
	शेष:
		वापस -EINVAL;
	पूर्ण

	mc_cg_config = RREG32(MC_CG_CONFIG) | 0x0000000F;
	WREG32(MC_CG_CONFIG, mc_cg_config);
	WREG32_P(MC_ARB_CG, CG_ARB_REQ(arb_freq_dest), ~CG_ARB_REQ_MASK);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_init_arb_table_index(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 पंचांगp;
	पूर्णांक ret;

	ret = rv770_पढ़ो_smc_sram_dword(rdev, ni_pi->arb_table_start,
					&पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	पंचांगp &= 0x00FFFFFF;
	पंचांगp |= ((u32)MC_CG_ARB_FREQ_F1) << 24;

	वापस rv770_ग_लिखो_smc_sram_dword(rdev, ni_pi->arb_table_start,
					  पंचांगp, pi->sram_end);
पूर्ण

अटल पूर्णांक ni_initial_चयन_from_arb_f0_to_f1(काष्ठा radeon_device *rdev)
अणु
	वापस ni_copy_and_चयन_arb_sets(rdev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);
पूर्ण

अटल पूर्णांक ni_क्रमce_चयन_to_arb_f0(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 पंचांगp;
	पूर्णांक ret;

	ret = rv770_पढ़ो_smc_sram_dword(rdev, ni_pi->arb_table_start,
					&पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	पंचांगp = (पंचांगp >> 24) & 0xff;

	अगर (पंचांगp == MC_CG_ARB_FREQ_F0)
		वापस 0;

	वापस ni_copy_and_चयन_arb_sets(rdev, पंचांगp, MC_CG_ARB_FREQ_F0);
पूर्ण

अटल पूर्णांक ni_populate_memory_timing_parameters(काष्ठा radeon_device *rdev,
						काष्ठा rv7xx_pl *pl,
						SMC_NIslands_MCArbDramTimingRegisterSet *arb_regs)
अणु
	u32 dram_timing;
	u32 dram_timing2;

	arb_regs->mc_arb_rfsh_rate =
		(u8)rv770_calculate_memory_refresh_rate(rdev, pl->sclk);


	radeon_atom_set_engine_dram_timings(rdev, pl->sclk, pl->mclk);

	dram_timing = RREG32(MC_ARB_DRAM_TIMING);
	dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);

	arb_regs->mc_arb_dram_timing  = cpu_to_be32(dram_timing);
	arb_regs->mc_arb_dram_timing2 = cpu_to_be32(dram_timing2);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_करो_program_memory_timing_parameters(काष्ठा radeon_device *rdev,
						  काष्ठा radeon_ps *radeon_state,
						  अचिन्हित पूर्णांक first_arb_set)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	SMC_NIslands_MCArbDramTimingRegisterSet arb_regs = अणु 0 पूर्ण;
	पूर्णांक i, ret = 0;

	क्रम (i = 0; i < state->perक्रमmance_level_count; i++) अणु
		ret = ni_populate_memory_timing_parameters(rdev, &state->perक्रमmance_levels[i], &arb_regs);
		अगर (ret)
			अवरोध;

		ret = rv770_copy_bytes_to_smc(rdev,
					      (u16)(ni_pi->arb_table_start +
						    दुरत्व(SMC_NIslands_MCArbDramTimingRegisters, data) +
						    माप(SMC_NIslands_MCArbDramTimingRegisterSet) * (first_arb_set + i)),
					      (u8 *)&arb_regs,
					      (u16)माप(SMC_NIslands_MCArbDramTimingRegisterSet),
					      pi->sram_end);
		अगर (ret)
			अवरोध;
	पूर्ण
	वापस ret;
पूर्ण

अटल पूर्णांक ni_program_memory_timing_parameters(काष्ठा radeon_device *rdev,
					       काष्ठा radeon_ps *radeon_new_state)
अणु
	वापस ni_करो_program_memory_timing_parameters(rdev, radeon_new_state,
						      NISLANDS_DRIVER_STATE_ARB_INDEX);
पूर्ण

अटल व्योम ni_populate_initial_mvdd_value(काष्ठा radeon_device *rdev,
					   काष्ठा NISLANDS_SMC_VOLTAGE_VALUE *voltage)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);

	voltage->index = eg_pi->mvdd_high_index;
	voltage->value = cpu_to_be16(MVDD_HIGH_VALUE);
पूर्ण

अटल पूर्णांक ni_populate_smc_initial_state(काष्ठा radeon_device *rdev,
					 काष्ठा radeon_ps *radeon_initial_state,
					 NISLANDS_SMC_STATETABLE *table)
अणु
	काष्ठा ni_ps *initial_state = ni_get_ps(radeon_initial_state);
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 reg;
	पूर्णांक ret;

	table->initialState.level.mclk.vMPLL_AD_FUNC_CNTL =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl);
	table->initialState.level.mclk.vMPLL_AD_FUNC_CNTL_2 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl_2);
	table->initialState.level.mclk.vMPLL_DQ_FUNC_CNTL =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl);
	table->initialState.level.mclk.vMPLL_DQ_FUNC_CNTL_2 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl_2);
	table->initialState.level.mclk.vMCLK_PWRMGT_CNTL =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl);
	table->initialState.level.mclk.vDLL_CNTL =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.dll_cntl);
	table->initialState.level.mclk.vMPLL_SS =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_ss1);
	table->initialState.level.mclk.vMPLL_SS2 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.mpll_ss2);
	table->initialState.level.mclk.mclk_value =
		cpu_to_be32(initial_state->perक्रमmance_levels[0].mclk);

	table->initialState.level.sclk.vCG_SPLL_FUNC_CNTL =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl);
	table->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_2 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2);
	table->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_3 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3);
	table->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_4 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4);
	table->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum);
	table->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =
		cpu_to_be32(ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2);
	table->initialState.level.sclk.sclk_value =
		cpu_to_be32(initial_state->perक्रमmance_levels[0].sclk);
	table->initialState.level.arbRefreshState =
		NISLANDS_INITIAL_STATE_ARB_INDEX;

	table->initialState.level.ACIndex = 0;

	ret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,
					initial_state->perक्रमmance_levels[0].vddc,
					&table->initialState.level.vddc);
	अगर (!ret) अणु
		u16 std_vddc;

		ret = ni_get_std_voltage_value(rdev,
					       &table->initialState.level.vddc,
					       &std_vddc);
		अगर (!ret)
			ni_populate_std_voltage_value(rdev, std_vddc,
						      table->initialState.level.vddc.index,
						      &table->initialState.level.std_vddc);
	पूर्ण

	अगर (eg_pi->vddci_control)
		ni_populate_voltage_value(rdev,
					  &eg_pi->vddci_voltage_table,
					  initial_state->perक्रमmance_levels[0].vddci,
					  &table->initialState.level.vddci);

	ni_populate_initial_mvdd_value(rdev, &table->initialState.level.mvdd);

	reg = CG_R(0xffff) | CG_L(0);
	table->initialState.level.aT = cpu_to_be32(reg);

	table->initialState.level.bSP = cpu_to_be32(pi->dsp);

	अगर (pi->boot_in_gen2)
		table->initialState.level.gen2PCIE = 1;
	अन्यथा
		table->initialState.level.gen2PCIE = 0;

	अगर (pi->mem_gddr5) अणु
		table->initialState.level.strobeMode =
			cypress_get_strobe_mode_settings(rdev,
							 initial_state->perक्रमmance_levels[0].mclk);

		अगर (initial_state->perक्रमmance_levels[0].mclk > pi->mclk_edc_enable_threshold)
			table->initialState.level.mcFlags = NISLANDS_SMC_MC_EDC_RD_FLAG | NISLANDS_SMC_MC_EDC_WR_FLAG;
		अन्यथा
			table->initialState.level.mcFlags =  0;
	पूर्ण

	table->initialState.levelCount = 1;

	table->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;

	table->initialState.level.dpm2.MaxPS = 0;
	table->initialState.level.dpm2.NearTDPDec = 0;
	table->initialState.level.dpm2.AboveSafeInc = 0;
	table->initialState.level.dpm2.BelowSafeInc = 0;

	reg = MIN_POWER_MASK | MAX_POWER_MASK;
	table->initialState.level.SQPowerThrottle = cpu_to_be32(reg);

	reg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;
	table->initialState.level.SQPowerThrottle_2 = cpu_to_be32(reg);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_populate_smc_acpi_state(काष्ठा radeon_device *rdev,
				      NISLANDS_SMC_STATETABLE *table)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 mpll_ad_func_cntl   = ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl;
	u32 mpll_ad_func_cntl_2 = ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl_2;
	u32 mpll_dq_func_cntl   = ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl;
	u32 mpll_dq_func_cntl_2 = ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl_2;
	u32 spll_func_cntl      = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl;
	u32 spll_func_cntl_2    = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2;
	u32 spll_func_cntl_3    = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3;
	u32 spll_func_cntl_4    = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4;
	u32 mclk_pwrmgt_cntl    = ni_pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl;
	u32 dll_cntl            = ni_pi->घड़ी_रेजिस्टरs.dll_cntl;
	u32 reg;
	पूर्णांक ret;

	table->ACPIState = table->initialState;

	table->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;

	अगर (pi->acpi_vddc) अणु
		ret = ni_populate_voltage_value(rdev,
						&eg_pi->vddc_voltage_table,
						pi->acpi_vddc, &table->ACPIState.level.vddc);
		अगर (!ret) अणु
			u16 std_vddc;

			ret = ni_get_std_voltage_value(rdev,
						       &table->ACPIState.level.vddc, &std_vddc);
			अगर (!ret)
				ni_populate_std_voltage_value(rdev, std_vddc,
							      table->ACPIState.level.vddc.index,
							      &table->ACPIState.level.std_vddc);
		पूर्ण

		अगर (pi->pcie_gen2) अणु
			अगर (pi->acpi_pcie_gen2)
				table->ACPIState.level.gen2PCIE = 1;
			अन्यथा
				table->ACPIState.level.gen2PCIE = 0;
		पूर्ण अन्यथा अणु
			table->ACPIState.level.gen2PCIE = 0;
		पूर्ण
	पूर्ण अन्यथा अणु
		ret = ni_populate_voltage_value(rdev,
						&eg_pi->vddc_voltage_table,
						pi->min_vddc_in_table,
						&table->ACPIState.level.vddc);
		अगर (!ret) अणु
			u16 std_vddc;

			ret = ni_get_std_voltage_value(rdev,
						       &table->ACPIState.level.vddc,
						       &std_vddc);
			अगर (!ret)
				ni_populate_std_voltage_value(rdev, std_vddc,
							      table->ACPIState.level.vddc.index,
							      &table->ACPIState.level.std_vddc);
		पूर्ण
		table->ACPIState.level.gen2PCIE = 0;
	पूर्ण

	अगर (eg_pi->acpi_vddci) अणु
		अगर (eg_pi->vddci_control)
			ni_populate_voltage_value(rdev,
						  &eg_pi->vddci_voltage_table,
						  eg_pi->acpi_vddci,
						  &table->ACPIState.level.vddci);
	पूर्ण


	mpll_ad_func_cntl &= ~PDNB;

	mpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;

	अगर (pi->mem_gddr5)
		mpll_dq_func_cntl &= ~PDNB;
	mpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN | BYPASS;


	mclk_pwrmgt_cntl |= (MRDCKA0_RESET |
			     MRDCKA1_RESET |
			     MRDCKB0_RESET |
			     MRDCKB1_RESET |
			     MRDCKC0_RESET |
			     MRDCKC1_RESET |
			     MRDCKD0_RESET |
			     MRDCKD1_RESET);

	mclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |
			      MRDCKA1_PDNB |
			      MRDCKB0_PDNB |
			      MRDCKB1_PDNB |
			      MRDCKC0_PDNB |
			      MRDCKC1_PDNB |
			      MRDCKD0_PDNB |
			      MRDCKD1_PDNB);

	dll_cntl |= (MRDCKA0_BYPASS |
		     MRDCKA1_BYPASS |
		     MRDCKB0_BYPASS |
		     MRDCKB1_BYPASS |
		     MRDCKC0_BYPASS |
		     MRDCKC1_BYPASS |
		     MRDCKD0_BYPASS |
		     MRDCKD1_BYPASS);

	spll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;
	spll_func_cntl_2 |= SCLK_MUX_SEL(4);

	table->ACPIState.level.mclk.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);
	table->ACPIState.level.mclk.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);
	table->ACPIState.level.mclk.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);
	table->ACPIState.level.mclk.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);
	table->ACPIState.level.mclk.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);
	table->ACPIState.level.mclk.vDLL_CNTL = cpu_to_be32(dll_cntl);

	table->ACPIState.level.mclk.mclk_value = 0;

	table->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);
	table->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);
	table->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);
	table->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32(spll_func_cntl_4);

	table->ACPIState.level.sclk.sclk_value = 0;

	ni_populate_mvdd_value(rdev, 0, &table->ACPIState.level.mvdd);

	अगर (eg_pi->dynamic_ac_timing)
		table->ACPIState.level.ACIndex = 1;

	table->ACPIState.level.dpm2.MaxPS = 0;
	table->ACPIState.level.dpm2.NearTDPDec = 0;
	table->ACPIState.level.dpm2.AboveSafeInc = 0;
	table->ACPIState.level.dpm2.BelowSafeInc = 0;

	reg = MIN_POWER_MASK | MAX_POWER_MASK;
	table->ACPIState.level.SQPowerThrottle = cpu_to_be32(reg);

	reg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;
	table->ACPIState.level.SQPowerThrottle_2 = cpu_to_be32(reg);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_init_smc_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	पूर्णांक ret;
	काष्ठा radeon_ps *radeon_boot_state = rdev->pm.dpm.boot_ps;
	NISLANDS_SMC_STATETABLE *table = &ni_pi->smc_statetable;

	स_रखो(table, 0, माप(NISLANDS_SMC_STATETABLE));

	ni_populate_smc_voltage_tables(rdev, table);

	चयन (rdev->pm.पूर्णांक_thermal_type) अणु
	हाल THERMAL_TYPE_NI:
	हाल THERMAL_TYPE_EMC2103_WITH_INTERNAL:
		table->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;
		अवरोध;
	हाल THERMAL_TYPE_NONE:
		table->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;
		अवरोध;
	शेष:
		table->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;
		अवरोध;
	पूर्ण

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)
		table->प्रणालीFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)
		table->प्रणालीFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)
		table->प्रणालीFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;

	अगर (pi->mem_gddr5)
		table->प्रणालीFlags |= PPSMC_SYSTEMFLAG_GDDR5;

	ret = ni_populate_smc_initial_state(rdev, radeon_boot_state, table);
	अगर (ret)
		वापस ret;

	ret = ni_populate_smc_acpi_state(rdev, table);
	अगर (ret)
		वापस ret;

	table->driverState.flags = table->initialState.flags;
	table->driverState.levelCount = table->initialState.levelCount;
	table->driverState.levels[0] = table->initialState.level;

	table->ULVState = table->initialState;

	ret = ni_करो_program_memory_timing_parameters(rdev, radeon_boot_state,
						     NISLANDS_INITIAL_STATE_ARB_INDEX);
	अगर (ret)
		वापस ret;

	वापस rv770_copy_bytes_to_smc(rdev, pi->state_table_start, (u8 *)table,
				       माप(NISLANDS_SMC_STATETABLE), pi->sram_end);
पूर्ण

अटल पूर्णांक ni_calculate_sclk_params(काष्ठा radeon_device *rdev,
				    u32 engine_घड़ी,
				    NISLANDS_SMC_SCLK_VALUE *sclk)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा atom_घड़ी_भागiders भागiders;
	u32 spll_func_cntl = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl;
	u32 spll_func_cntl_2 = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2;
	u32 spll_func_cntl_3 = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3;
	u32 spll_func_cntl_4 = ni_pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4;
	u32 cg_spll_spपढ़ो_spectrum = ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum;
	u32 cg_spll_spपढ़ो_spectrum_2 = ni_pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2;
	u64 पंचांगp;
	u32 reference_घड़ी = rdev->घड़ी.spll.reference_freq;
	u32 reference_भागider;
	u32 fbभाग;
	पूर्णांक ret;

	ret = radeon_atom_get_घड़ी_भागiders(rdev, COMPUTE_ENGINE_PLL_PARAM,
					     engine_घड़ी, false, &भागiders);
	अगर (ret)
		वापस ret;

	reference_भागider = 1 + भागiders.ref_भाग;


	पंचांगp = (u64) engine_घड़ी * reference_भागider * भागiders.post_भाग * 16834;
	करो_भाग(पंचांगp, reference_घड़ी);
	fbभाग = (u32) पंचांगp;

	spll_func_cntl &= ~(SPLL_PDIV_A_MASK | SPLL_REF_DIV_MASK);
	spll_func_cntl |= SPLL_REF_DIV(भागiders.ref_भाग);
	spll_func_cntl |= SPLL_PDIV_A(भागiders.post_भाग);

	spll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;
	spll_func_cntl_2 |= SCLK_MUX_SEL(2);

	spll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;
	spll_func_cntl_3 |= SPLL_FB_DIV(fbभाग);
	spll_func_cntl_3 |= SPLL_DITHEN;

	अगर (pi->sclk_ss) अणु
		काष्ठा radeon_atom_ss ss;
		u32 vco_freq = engine_घड़ी * भागiders.post_भाग;

		अगर (radeon_atombios_get_asic_ss_info(rdev, &ss,
						     ASIC_INTERNAL_ENGINE_SS, vco_freq)) अणु
			u32 clk_s = reference_घड़ी * 5 / (reference_भागider * ss.rate);
			u32 clk_v = 4 * ss.percentage * fbभाग / (clk_s * 10000);

			cg_spll_spपढ़ो_spectrum &= ~CLK_S_MASK;
			cg_spll_spपढ़ो_spectrum |= CLK_S(clk_s);
			cg_spll_spपढ़ो_spectrum |= SSEN;

			cg_spll_spपढ़ो_spectrum_2 &= ~CLK_V_MASK;
			cg_spll_spपढ़ो_spectrum_2 |= CLK_V(clk_v);
		पूर्ण
	पूर्ण

	sclk->sclk_value = engine_घड़ी;
	sclk->vCG_SPLL_FUNC_CNTL = spll_func_cntl;
	sclk->vCG_SPLL_FUNC_CNTL_2 = spll_func_cntl_2;
	sclk->vCG_SPLL_FUNC_CNTL_3 = spll_func_cntl_3;
	sclk->vCG_SPLL_FUNC_CNTL_4 = spll_func_cntl_4;
	sclk->vCG_SPLL_SPREAD_SPECTRUM = cg_spll_spपढ़ो_spectrum;
	sclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cg_spll_spपढ़ो_spectrum_2;

	वापस 0;
पूर्ण

अटल पूर्णांक ni_populate_sclk_value(काष्ठा radeon_device *rdev,
				  u32 engine_घड़ी,
				  NISLANDS_SMC_SCLK_VALUE *sclk)
अणु
	NISLANDS_SMC_SCLK_VALUE sclk_पंचांगp;
	पूर्णांक ret;

	ret = ni_calculate_sclk_params(rdev, engine_घड़ी, &sclk_पंचांगp);
	अगर (!ret) अणु
		sclk->sclk_value = cpu_to_be32(sclk_पंचांगp.sclk_value);
		sclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_FUNC_CNTL);
		sclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_FUNC_CNTL_2);
		sclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_FUNC_CNTL_3);
		sclk->vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_FUNC_CNTL_4);
		sclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_SPREAD_SPECTRUM);
		sclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(sclk_पंचांगp.vCG_SPLL_SPREAD_SPECTRUM_2);
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ni_init_smc_spll_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	SMC_NISLANDS_SPLL_DIV_TABLE *spll_table;
	NISLANDS_SMC_SCLK_VALUE sclk_params;
	u32 fb_भाग;
	u32 p_भाग;
	u32 clk_s;
	u32 clk_v;
	u32 sclk = 0;
	पूर्णांक i, ret;
	u32 पंचांगp;

	अगर (ni_pi->spll_table_start == 0)
		वापस -EINVAL;

	spll_table = kzalloc(माप(SMC_NISLANDS_SPLL_DIV_TABLE), GFP_KERNEL);
	अगर (spll_table == शून्य)
		वापस -ENOMEM;

	क्रम (i = 0; i < 256; i++) अणु
		ret = ni_calculate_sclk_params(rdev, sclk, &sclk_params);
		अगर (ret)
			अवरोध;

		p_भाग = (sclk_params.vCG_SPLL_FUNC_CNTL & SPLL_PDIV_A_MASK) >> SPLL_PDIV_A_SHIFT;
		fb_भाग = (sclk_params.vCG_SPLL_FUNC_CNTL_3 & SPLL_FB_DIV_MASK) >> SPLL_FB_DIV_SHIFT;
		clk_s = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM & CLK_S_MASK) >> CLK_S_SHIFT;
		clk_v = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM_2 & CLK_V_MASK) >> CLK_V_SHIFT;

		fb_भाग &= ~0x00001FFF;
		fb_भाग >>= 1;
		clk_v >>= 6;

		अगर (p_भाग & ~(SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT))
			ret = -EINVAL;

		अगर (clk_s & ~(SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT))
			ret = -EINVAL;

		अगर (fb_भाग & ~(SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT))
			ret = -EINVAL;

		अगर (clk_v & ~(SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT))
			ret = -EINVAL;

		अगर (ret)
			अवरोध;

		पंचांगp = ((fb_भाग << SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_MASK) |
			((p_भाग << SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_MASK);
		spll_table->freq[i] = cpu_to_be32(पंचांगp);

		पंचांगp = ((clk_v << SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_MASK) |
			((clk_s << SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_MASK);
		spll_table->ss[i] = cpu_to_be32(पंचांगp);

		sclk += 512;
	पूर्ण

	अगर (!ret)
		ret = rv770_copy_bytes_to_smc(rdev, ni_pi->spll_table_start, (u8 *)spll_table,
					      माप(SMC_NISLANDS_SPLL_DIV_TABLE), pi->sram_end);

	kमुक्त(spll_table);

	वापस ret;
पूर्ण

अटल पूर्णांक ni_populate_mclk_value(काष्ठा radeon_device *rdev,
				  u32 engine_घड़ी,
				  u32 memory_घड़ी,
				  NISLANDS_SMC_MCLK_VALUE *mclk,
				  bool strobe_mode,
				  bool dll_state_on)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 mpll_ad_func_cntl = ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl;
	u32 mpll_ad_func_cntl_2 = ni_pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl_2;
	u32 mpll_dq_func_cntl = ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl;
	u32 mpll_dq_func_cntl_2 = ni_pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl_2;
	u32 mclk_pwrmgt_cntl = ni_pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl;
	u32 dll_cntl = ni_pi->घड़ी_रेजिस्टरs.dll_cntl;
	u32 mpll_ss1 = ni_pi->घड़ी_रेजिस्टरs.mpll_ss1;
	u32 mpll_ss2 = ni_pi->घड़ी_रेजिस्टरs.mpll_ss2;
	काष्ठा atom_घड़ी_भागiders भागiders;
	u32 ibias;
	u32 dll_speed;
	पूर्णांक ret;
	u32 mc_seq_misc7;

	ret = radeon_atom_get_घड़ी_भागiders(rdev, COMPUTE_MEMORY_PLL_PARAM,
					     memory_घड़ी, strobe_mode, &भागiders);
	अगर (ret)
		वापस ret;

	अगर (!strobe_mode) अणु
		mc_seq_misc7 = RREG32(MC_SEQ_MISC7);

		अगर (mc_seq_misc7 & 0x8000000)
			भागiders.post_भाग = 1;
	पूर्ण

	ibias = cypress_map_clkf_to_ibias(rdev, भागiders.whole_fb_भाग);

	mpll_ad_func_cntl &= ~(CLKR_MASK |
			       YCLK_POST_DIV_MASK |
			       CLKF_MASK |
			       CLKFRAC_MASK |
			       IBIAS_MASK);
	mpll_ad_func_cntl |= CLKR(भागiders.ref_भाग);
	mpll_ad_func_cntl |= YCLK_POST_DIV(भागiders.post_भाग);
	mpll_ad_func_cntl |= CLKF(भागiders.whole_fb_भाग);
	mpll_ad_func_cntl |= CLKFRAC(भागiders.frac_fb_भाग);
	mpll_ad_func_cntl |= IBIAS(ibias);

	अगर (भागiders.vco_mode)
		mpll_ad_func_cntl_2 |= VCO_MODE;
	अन्यथा
		mpll_ad_func_cntl_2 &= ~VCO_MODE;

	अगर (pi->mem_gddr5) अणु
		mpll_dq_func_cntl &= ~(CLKR_MASK |
				       YCLK_POST_DIV_MASK |
				       CLKF_MASK |
				       CLKFRAC_MASK |
				       IBIAS_MASK);
		mpll_dq_func_cntl |= CLKR(भागiders.ref_भाग);
		mpll_dq_func_cntl |= YCLK_POST_DIV(भागiders.post_भाग);
		mpll_dq_func_cntl |= CLKF(भागiders.whole_fb_भाग);
		mpll_dq_func_cntl |= CLKFRAC(भागiders.frac_fb_भाग);
		mpll_dq_func_cntl |= IBIAS(ibias);

		अगर (strobe_mode)
			mpll_dq_func_cntl &= ~PDNB;
		अन्यथा
			mpll_dq_func_cntl |= PDNB;

		अगर (भागiders.vco_mode)
			mpll_dq_func_cntl_2 |= VCO_MODE;
		अन्यथा
			mpll_dq_func_cntl_2 &= ~VCO_MODE;
	पूर्ण

	अगर (pi->mclk_ss) अणु
		काष्ठा radeon_atom_ss ss;
		u32 vco_freq = memory_घड़ी * भागiders.post_भाग;

		अगर (radeon_atombios_get_asic_ss_info(rdev, &ss,
						     ASIC_INTERNAL_MEMORY_SS, vco_freq)) अणु
			u32 reference_घड़ी = rdev->घड़ी.mpll.reference_freq;
			u32 decoded_ref = rv740_get_decoded_reference_भागider(भागiders.ref_भाग);
			u32 clk_s = reference_घड़ी * 5 / (decoded_ref * ss.rate);
			u32 clk_v = ss.percentage *
				(0x4000 * भागiders.whole_fb_भाग + 0x800 * भागiders.frac_fb_भाग) / (clk_s * 625);

			mpll_ss1 &= ~CLKV_MASK;
			mpll_ss1 |= CLKV(clk_v);

			mpll_ss2 &= ~CLKS_MASK;
			mpll_ss2 |= CLKS(clk_s);
		पूर्ण
	पूर्ण

	dll_speed = rv740_get_dll_speed(pi->mem_gddr5,
					memory_घड़ी);

	mclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;
	mclk_pwrmgt_cntl |= DLL_SPEED(dll_speed);
	अगर (dll_state_on)
		mclk_pwrmgt_cntl |= (MRDCKA0_PDNB |
				     MRDCKA1_PDNB |
				     MRDCKB0_PDNB |
				     MRDCKB1_PDNB |
				     MRDCKC0_PDNB |
				     MRDCKC1_PDNB |
				     MRDCKD0_PDNB |
				     MRDCKD1_PDNB);
	अन्यथा
		mclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |
				      MRDCKA1_PDNB |
				      MRDCKB0_PDNB |
				      MRDCKB1_PDNB |
				      MRDCKC0_PDNB |
				      MRDCKC1_PDNB |
				      MRDCKD0_PDNB |
				      MRDCKD1_PDNB);


	mclk->mclk_value = cpu_to_be32(memory_घड़ी);
	mclk->vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);
	mclk->vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);
	mclk->vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);
	mclk->vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);
	mclk->vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);
	mclk->vDLL_CNTL = cpu_to_be32(dll_cntl);
	mclk->vMPLL_SS = cpu_to_be32(mpll_ss1);
	mclk->vMPLL_SS2 = cpu_to_be32(mpll_ss2);

	वापस 0;
पूर्ण

अटल व्योम ni_populate_smc_sp(काष्ठा radeon_device *rdev,
			       काष्ठा radeon_ps *radeon_state,
			       NISLANDS_SMC_SWSTATE *smc_state)
अणु
	काष्ठा ni_ps *ps = ni_get_ps(radeon_state);
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	पूर्णांक i;

	क्रम (i = 0; i < ps->perक्रमmance_level_count - 1; i++)
		smc_state->levels[i].bSP = cpu_to_be32(pi->dsp);

	smc_state->levels[ps->perक्रमmance_level_count - 1].bSP =
		cpu_to_be32(pi->psp);
पूर्ण

अटल पूर्णांक ni_convert_घातer_level_to_smc(काष्ठा radeon_device *rdev,
					 काष्ठा rv7xx_pl *pl,
					 NISLANDS_SMC_HW_PERFORMANCE_LEVEL *level)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	पूर्णांक ret;
	bool dll_state_on;
	u16 std_vddc;
	u32 पंचांगp = RREG32(DC_STUTTER_CNTL);

	level->gen2PCIE = pi->pcie_gen2 ?
		((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;

	ret = ni_populate_sclk_value(rdev, pl->sclk, &level->sclk);
	अगर (ret)
		वापस ret;

	level->mcFlags =  0;
	अगर (pi->mclk_stutter_mode_threshold &&
	    (pl->mclk <= pi->mclk_stutter_mode_threshold) &&
	    !eg_pi->uvd_enabled &&
	    (पंचांगp & DC_STUTTER_ENABLE_A) &&
	    (पंचांगp & DC_STUTTER_ENABLE_B))
		level->mcFlags |= NISLANDS_SMC_MC_STUTTER_EN;

	अगर (pi->mem_gddr5) अणु
		अगर (pl->mclk > pi->mclk_edc_enable_threshold)
			level->mcFlags |= NISLANDS_SMC_MC_EDC_RD_FLAG;
		अगर (pl->mclk > eg_pi->mclk_edc_wr_enable_threshold)
			level->mcFlags |= NISLANDS_SMC_MC_EDC_WR_FLAG;

		level->strobeMode = cypress_get_strobe_mode_settings(rdev, pl->mclk);

		अगर (level->strobeMode & NISLANDS_SMC_STROBE_ENABLE) अणु
			अगर (cypress_get_mclk_frequency_ratio(rdev, pl->mclk, true) >=
			    ((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))
				dll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;
			अन्यथा
				dll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;
		पूर्ण अन्यथा अणु
			dll_state_on = false;
			अगर (pl->mclk > ni_pi->mclk_rtt_mode_threshold)
				level->mcFlags |= NISLANDS_SMC_MC_RTT_ENABLE;
		पूर्ण

		ret = ni_populate_mclk_value(rdev, pl->sclk, pl->mclk,
					     &level->mclk,
					     (level->strobeMode & NISLANDS_SMC_STROBE_ENABLE) != 0,
					     dll_state_on);
	पूर्ण अन्यथा
		ret = ni_populate_mclk_value(rdev, pl->sclk, pl->mclk, &level->mclk, 1, 1);

	अगर (ret)
		वापस ret;

	ret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,
					pl->vddc, &level->vddc);
	अगर (ret)
		वापस ret;

	ret = ni_get_std_voltage_value(rdev, &level->vddc, &std_vddc);
	अगर (ret)
		वापस ret;

	ni_populate_std_voltage_value(rdev, std_vddc,
				      level->vddc.index, &level->std_vddc);

	अगर (eg_pi->vddci_control) अणु
		ret = ni_populate_voltage_value(rdev, &eg_pi->vddci_voltage_table,
						pl->vddci, &level->vddci);
		अगर (ret)
			वापस ret;
	पूर्ण

	ni_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);

	वापस ret;
पूर्ण

अटल पूर्णांक ni_populate_smc_t(काष्ठा radeon_device *rdev,
			     काष्ठा radeon_ps *radeon_state,
			     NISLANDS_SMC_SWSTATE *smc_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	u32 a_t;
	u32 t_l, t_h;
	u32 high_bsp;
	पूर्णांक i, ret;

	अगर (state->perक्रमmance_level_count >= 9)
		वापस -EINVAL;

	अगर (state->perक्रमmance_level_count < 2) अणु
		a_t = CG_R(0xffff) | CG_L(0);
		smc_state->levels[0].aT = cpu_to_be32(a_t);
		वापस 0;
	पूर्ण

	smc_state->levels[0].aT = cpu_to_be32(0);

	क्रम (i = 0; i <= state->perक्रमmance_level_count - 2; i++) अणु
		अगर (eg_pi->uvd_enabled)
			ret = r600_calculate_at(
				1000 * (i * (eg_pi->smu_uvd_hs ? 2 : 8) + 2),
				100 * R600_AH_DFLT,
				state->perक्रमmance_levels[i + 1].sclk,
				state->perक्रमmance_levels[i].sclk,
				&t_l,
				&t_h);
		अन्यथा
			ret = r600_calculate_at(
				1000 * (i + 1),
				100 * R600_AH_DFLT,
				state->perक्रमmance_levels[i + 1].sclk,
				state->perक्रमmance_levels[i].sclk,
				&t_l,
				&t_h);

		अगर (ret) अणु
			t_h = (i + 1) * 1000 - 50 * R600_AH_DFLT;
			t_l = (i + 1) * 1000 + 50 * R600_AH_DFLT;
		पूर्ण

		a_t = be32_to_cpu(smc_state->levels[i].aT) & ~CG_R_MASK;
		a_t |= CG_R(t_l * pi->bsp / 20000);
		smc_state->levels[i].aT = cpu_to_be32(a_t);

		high_bsp = (i == state->perक्रमmance_level_count - 2) ?
			pi->pbsp : pi->bsp;

		a_t = CG_R(0xffff) | CG_L(t_h * high_bsp / 20000);
		smc_state->levels[i + 1].aT = cpu_to_be32(a_t);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ni_populate_घातer_containment_values(काष्ठा radeon_device *rdev,
						काष्ठा radeon_ps *radeon_state,
						NISLANDS_SMC_SWSTATE *smc_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	u32 prev_sclk;
	u32 max_sclk;
	u32 min_sclk;
	पूर्णांक i, ret;
	u32 tdp_limit;
	u32 near_tdp_limit;
	u32 घातer_boost_limit;
	u8 max_ps_percent;

	अगर (ni_pi->enable_घातer_containment == false)
		वापस 0;

	अगर (state->perक्रमmance_level_count == 0)
		वापस -EINVAL;

	अगर (smc_state->levelCount != state->perक्रमmance_level_count)
		वापस -EINVAL;

	ret = ni_calculate_adjusted_tdp_limits(rdev,
					       false, /* ??? */
					       rdev->pm.dpm.tdp_adjusपंचांगent,
					       &tdp_limit,
					       &near_tdp_limit);
	अगर (ret)
		वापस ret;

	घातer_boost_limit = ni_calculate_घातer_boost_limit(rdev, radeon_state, near_tdp_limit);

	ret = rv770_ग_लिखो_smc_sram_dword(rdev,
					 pi->state_table_start +
					 दुरत्व(NISLANDS_SMC_STATETABLE, dpm2Params) +
					 दुरत्व(PP_NIslands_DPM2Parameters, PowerBoostLimit),
					 ni_scale_घातer_क्रम_smc(घातer_boost_limit, ni_get_smc_घातer_scaling_factor(rdev)),
					 pi->sram_end);
	अगर (ret)
		घातer_boost_limit = 0;

	smc_state->levels[0].dpm2.MaxPS = 0;
	smc_state->levels[0].dpm2.NearTDPDec = 0;
	smc_state->levels[0].dpm2.AboveSafeInc = 0;
	smc_state->levels[0].dpm2.BelowSafeInc = 0;
	smc_state->levels[0].stateFlags |= घातer_boost_limit ? PPSMC_STATEFLAG_POWERBOOST : 0;

	क्रम (i = 1; i < state->perक्रमmance_level_count; i++) अणु
		prev_sclk = state->perक्रमmance_levels[i-1].sclk;
		max_sclk  = state->perक्रमmance_levels[i].sclk;
		max_ps_percent = (i != (state->perक्रमmance_level_count - 1)) ?
			NISLANDS_DPM2_MAXPS_PERCENT_M : NISLANDS_DPM2_MAXPS_PERCENT_H;

		अगर (max_sclk < prev_sclk)
			वापस -EINVAL;

		अगर ((max_ps_percent == 0) || (prev_sclk == max_sclk) || eg_pi->uvd_enabled)
			min_sclk = max_sclk;
		अन्यथा अगर (1 == i)
			min_sclk = prev_sclk;
		अन्यथा
			min_sclk = (prev_sclk * (u32)max_ps_percent) / 100;

		अगर (min_sclk < state->perक्रमmance_levels[0].sclk)
			min_sclk = state->perक्रमmance_levels[0].sclk;

		अगर (min_sclk == 0)
			वापस -EINVAL;

		smc_state->levels[i].dpm2.MaxPS =
			(u8)((NISLANDS_DPM2_MAX_PULSE_SKIP * (max_sclk - min_sclk)) / max_sclk);
		smc_state->levels[i].dpm2.NearTDPDec = NISLANDS_DPM2_NEAR_TDP_DEC;
		smc_state->levels[i].dpm2.AboveSafeInc = NISLANDS_DPM2_ABOVE_SAFE_INC;
		smc_state->levels[i].dpm2.BelowSafeInc = NISLANDS_DPM2_BELOW_SAFE_INC;
		smc_state->levels[i].stateFlags |=
			((i != (state->perक्रमmance_level_count - 1)) && घातer_boost_limit) ?
			PPSMC_STATEFLAG_POWERBOOST : 0;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ni_populate_sq_ramping_values(काष्ठा radeon_device *rdev,
					 काष्ठा radeon_ps *radeon_state,
					 NISLANDS_SMC_SWSTATE *smc_state)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	u32 sq_घातer_throttle;
	u32 sq_घातer_throttle2;
	bool enable_sq_ramping = ni_pi->enable_sq_ramping;
	पूर्णांक i;

	अगर (state->perक्रमmance_level_count == 0)
		वापस -EINVAL;

	अगर (smc_state->levelCount != state->perक्रमmance_level_count)
		वापस -EINVAL;

	अगर (rdev->pm.dpm.sq_ramping_threshold == 0)
		वापस -EINVAL;

	अगर (NISLANDS_DPM2_SQ_RAMP_MAX_POWER > (MAX_POWER_MASK >> MAX_POWER_SHIFT))
		enable_sq_ramping = false;

	अगर (NISLANDS_DPM2_SQ_RAMP_MIN_POWER > (MIN_POWER_MASK >> MIN_POWER_SHIFT))
		enable_sq_ramping = false;

	अगर (NISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA > (MAX_POWER_DELTA_MASK >> MAX_POWER_DELTA_SHIFT))
		enable_sq_ramping = false;

	अगर (NISLANDS_DPM2_SQ_RAMP_STI_SIZE > (STI_SIZE_MASK >> STI_SIZE_SHIFT))
		enable_sq_ramping = false;

	अगर (NISLANDS_DPM2_SQ_RAMP_LTI_RATIO > (LTI_RATIO_MASK >> LTI_RATIO_SHIFT))
		enable_sq_ramping = false;

	क्रम (i = 0; i < state->perक्रमmance_level_count; i++) अणु
		sq_घातer_throttle  = 0;
		sq_घातer_throttle2 = 0;

		अगर ((state->perक्रमmance_levels[i].sclk >= rdev->pm.dpm.sq_ramping_threshold) &&
		    enable_sq_ramping) अणु
			sq_घातer_throttle |= MAX_POWER(NISLANDS_DPM2_SQ_RAMP_MAX_POWER);
			sq_घातer_throttle |= MIN_POWER(NISLANDS_DPM2_SQ_RAMP_MIN_POWER);
			sq_घातer_throttle2 |= MAX_POWER_DELTA(NISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA);
			sq_घातer_throttle2 |= STI_SIZE(NISLANDS_DPM2_SQ_RAMP_STI_SIZE);
			sq_घातer_throttle2 |= LTI_RATIO(NISLANDS_DPM2_SQ_RAMP_LTI_RATIO);
		पूर्ण अन्यथा अणु
			sq_घातer_throttle |= MAX_POWER_MASK | MIN_POWER_MASK;
			sq_घातer_throttle2 |= MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;
		पूर्ण

		smc_state->levels[i].SQPowerThrottle   = cpu_to_be32(sq_घातer_throttle);
		smc_state->levels[i].SQPowerThrottle_2 = cpu_to_be32(sq_घातer_throttle2);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ni_enable_घातer_containment(काष्ठा radeon_device *rdev,
				       काष्ठा radeon_ps *radeon_new_state,
				       bool enable)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	PPSMC_Result smc_result;
	पूर्णांक ret = 0;

	अगर (ni_pi->enable_घातer_containment) अणु
		अगर (enable) अणु
			अगर (!r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2)) अणु
				smc_result = rv770_send_msg_to_smc(rdev, PPSMC_TDPClampingActive);
				अगर (smc_result != PPSMC_Result_OK) अणु
					ret = -EINVAL;
					ni_pi->pc_enabled = false;
				पूर्ण अन्यथा अणु
					ni_pi->pc_enabled = true;
				पूर्ण
			पूर्ण
		पूर्ण अन्यथा अणु
			smc_result = rv770_send_msg_to_smc(rdev, PPSMC_TDPClampingInactive);
			अगर (smc_result != PPSMC_Result_OK)
				ret = -EINVAL;
			ni_pi->pc_enabled = false;
		पूर्ण
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ni_convert_घातer_state_to_smc(काष्ठा radeon_device *rdev,
					 काष्ठा radeon_ps *radeon_state,
					 NISLANDS_SMC_SWSTATE *smc_state)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	पूर्णांक i, ret;
	u32 threshold = state->perक्रमmance_levels[state->perक्रमmance_level_count - 1].sclk * 100 / 100;

	अगर (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))
		smc_state->flags |= PPSMC_SWSTATE_FLAG_DC;

	smc_state->levelCount = 0;

	अगर (state->perक्रमmance_level_count > NISLANDS_MAX_SMC_PERFORMANCE_LEVELS_PER_SWSTATE)
		वापस -EINVAL;

	क्रम (i = 0; i < state->perक्रमmance_level_count; i++) अणु
		ret = ni_convert_घातer_level_to_smc(rdev, &state->perक्रमmance_levels[i],
						    &smc_state->levels[i]);
		smc_state->levels[i].arbRefreshState =
			(u8)(NISLANDS_DRIVER_STATE_ARB_INDEX + i);

		अगर (ret)
			वापस ret;

		अगर (ni_pi->enable_घातer_containment)
			smc_state->levels[i].displayWatermark =
				(state->perक्रमmance_levels[i].sclk < threshold) ?
				PPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;
		अन्यथा
			smc_state->levels[i].displayWatermark = (i < 2) ?
				PPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;

		अगर (eg_pi->dynamic_ac_timing)
			smc_state->levels[i].ACIndex = NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i;
		अन्यथा
			smc_state->levels[i].ACIndex = 0;

		smc_state->levelCount++;
	पूर्ण

	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_watermark_threshold,
				      cpu_to_be32(threshold / 512));

	ni_populate_smc_sp(rdev, radeon_state, smc_state);

	ret = ni_populate_घातer_containment_values(rdev, radeon_state, smc_state);
	अगर (ret)
		ni_pi->enable_घातer_containment = false;

	ret = ni_populate_sq_ramping_values(rdev, radeon_state, smc_state);
	अगर (ret)
		ni_pi->enable_sq_ramping = false;

	वापस ni_populate_smc_t(rdev, radeon_state, smc_state);
पूर्ण

अटल पूर्णांक ni_upload_sw_state(काष्ठा radeon_device *rdev,
			      काष्ठा radeon_ps *radeon_new_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u16 address = pi->state_table_start +
		दुरत्व(NISLANDS_SMC_STATETABLE, driverState);
	NISLANDS_SMC_SWSTATE *smc_state;
	माप_प्रकार state_size = काष्ठा_size(smc_state, levels,
			NISLANDS_MAX_SMC_PERFORMANCE_LEVELS_PER_SWSTATE);
	पूर्णांक ret;

	smc_state = kzalloc(state_size, GFP_KERNEL);
	अगर (smc_state == शून्य)
		वापस -ENOMEM;

	ret = ni_convert_घातer_state_to_smc(rdev, radeon_new_state, smc_state);
	अगर (ret)
		जाओ करोne;

	ret = rv770_copy_bytes_to_smc(rdev, address, (u8 *)smc_state, state_size, pi->sram_end);

करोne:
	kमुक्त(smc_state);

	वापस ret;
पूर्ण

अटल पूर्णांक ni_set_mc_special_रेजिस्टरs(काष्ठा radeon_device *rdev,
				       काष्ठा ni_mc_reg_table *table)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u8 i, j, k;
	u32 temp_reg;

	क्रम (i = 0, j = table->last; i < table->last; i++) अणु
		चयन (table->mc_reg_address[i].s1) अणु
		हाल MC_SEQ_MISC1 >> 2:
			अगर (j >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			temp_reg = RREG32(MC_PMG_CMD_EMRS);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;
			क्रम (k = 0; k < table->num_entries; k++)
				table->mc_reg_table_entry[k].mc_data[j] =
					((temp_reg & 0xffff0000)) |
					((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);
			j++;
			अगर (j >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;

			temp_reg = RREG32(MC_PMG_CMD_MRS);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_MRS >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;
			क्रम(k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) |
					(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);
				अगर (!pi->mem_gddr5)
					table->mc_reg_table_entry[k].mc_data[j] |= 0x100;
			पूर्ण
			j++;
			अगर (j > SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			अवरोध;
		हाल MC_SEQ_RESERVE_M >> 2:
			temp_reg = RREG32(MC_PMG_CMD_MRS1);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1 >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;
			क्रम (k = 0; k < table->num_entries; k++)
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) |
					(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);
			j++;
			अगर (j > SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			अवरोध;
		शेष:
			अवरोध;
		पूर्ण
	पूर्ण

	table->last = j;

	वापस 0;
पूर्ण

अटल bool ni_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)
अणु
	bool result = true;

	चयन (in_reg) अणु
	हाल  MC_SEQ_RAS_TIMING >> 2:
		*out_reg = MC_SEQ_RAS_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_CAS_TIMING >> 2:
		*out_reg = MC_SEQ_CAS_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_MISC_TIMING >> 2:
		*out_reg = MC_SEQ_MISC_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_MISC_TIMING2 >> 2:
		*out_reg = MC_SEQ_MISC_TIMING2_LP >> 2;
		अवरोध;
	हाल MC_SEQ_RD_CTL_D0 >> 2:
		*out_reg = MC_SEQ_RD_CTL_D0_LP >> 2;
		अवरोध;
	हाल MC_SEQ_RD_CTL_D1 >> 2:
		*out_reg = MC_SEQ_RD_CTL_D1_LP >> 2;
		अवरोध;
	हाल MC_SEQ_WR_CTL_D0 >> 2:
		*out_reg = MC_SEQ_WR_CTL_D0_LP >> 2;
		अवरोध;
	हाल MC_SEQ_WR_CTL_D1 >> 2:
		*out_reg = MC_SEQ_WR_CTL_D1_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_EMRS >> 2:
		*out_reg = MC_SEQ_PMG_CMD_EMRS_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS1 >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS1_LP >> 2;
		अवरोध;
	हाल MC_SEQ_PMG_TIMING >> 2:
		*out_reg = MC_SEQ_PMG_TIMING_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS2 >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS2_LP >> 2;
		अवरोध;
	शेष:
		result = false;
		अवरोध;
	पूर्ण

	वापस result;
पूर्ण

अटल व्योम ni_set_valid_flag(काष्ठा ni_mc_reg_table *table)
अणु
	u8 i, j;

	क्रम (i = 0; i < table->last; i++) अणु
		क्रम (j = 1; j < table->num_entries; j++) अणु
			अगर (table->mc_reg_table_entry[j-1].mc_data[i] != table->mc_reg_table_entry[j].mc_data[i]) अणु
				table->valid_flag |= 1 << i;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ni_set_s0_mc_reg_index(काष्ठा ni_mc_reg_table *table)
अणु
	u32 i;
	u16 address;

	क्रम (i = 0; i < table->last; i++)
		table->mc_reg_address[i].s0 =
			ni_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?
			address : table->mc_reg_address[i].s1;
पूर्ण

अटल पूर्णांक ni_copy_vbios_mc_reg_table(काष्ठा atom_mc_reg_table *table,
				      काष्ठा ni_mc_reg_table *ni_table)
अणु
	u8 i, j;

	अगर (table->last > SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
		वापस -EINVAL;
	अगर (table->num_entries > MAX_AC_TIMING_ENTRIES)
		वापस -EINVAL;

	क्रम (i = 0; i < table->last; i++)
		ni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;
	ni_table->last = table->last;

	क्रम (i = 0; i < table->num_entries; i++) अणु
		ni_table->mc_reg_table_entry[i].mclk_max =
			table->mc_reg_table_entry[i].mclk_max;
		क्रम (j = 0; j < table->last; j++)
			ni_table->mc_reg_table_entry[i].mc_data[j] =
				table->mc_reg_table_entry[i].mc_data[j];
	पूर्ण
	ni_table->num_entries = table->num_entries;

	वापस 0;
पूर्ण

अटल पूर्णांक ni_initialize_mc_reg_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	पूर्णांक ret;
	काष्ठा atom_mc_reg_table *table;
	काष्ठा ni_mc_reg_table *ni_table = &ni_pi->mc_reg_table;
	u8 module_index = rv770_get_memory_module_index(rdev);

	table = kzalloc(माप(काष्ठा atom_mc_reg_table), GFP_KERNEL);
	अगर (!table)
		वापस -ENOMEM;

	WREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));
	WREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));
	WREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));
	WREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));
	WREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));
	WREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));
	WREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));
	WREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));
	WREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));
	WREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));
	WREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));
	WREG32(MC_SEQ_PMG_TIMING_LP, RREG32(MC_SEQ_PMG_TIMING));
	WREG32(MC_SEQ_PMG_CMD_MRS2_LP, RREG32(MC_PMG_CMD_MRS2));

	ret = radeon_atom_init_mc_reg_table(rdev, module_index, table);

	अगर (ret)
		जाओ init_mc_करोne;

	ret = ni_copy_vbios_mc_reg_table(table, ni_table);

	अगर (ret)
		जाओ init_mc_करोne;

	ni_set_s0_mc_reg_index(ni_table);

	ret = ni_set_mc_special_रेजिस्टरs(rdev, ni_table);

	अगर (ret)
		जाओ init_mc_करोne;

	ni_set_valid_flag(ni_table);

init_mc_करोne:
	kमुक्त(table);

	वापस ret;
पूर्ण

अटल व्योम ni_populate_mc_reg_addresses(काष्ठा radeon_device *rdev,
					 SMC_NIslands_MCRegisters *mc_reg_table)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 i, j;

	क्रम (i = 0, j = 0; j < ni_pi->mc_reg_table.last; j++) अणु
		अगर (ni_pi->mc_reg_table.valid_flag & (1 << j)) अणु
			अगर (i >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)
				अवरोध;
			mc_reg_table->address[i].s0 =
				cpu_to_be16(ni_pi->mc_reg_table.mc_reg_address[j].s0);
			mc_reg_table->address[i].s1 =
				cpu_to_be16(ni_pi->mc_reg_table.mc_reg_address[j].s1);
			i++;
		पूर्ण
	पूर्ण
	mc_reg_table->last = (u8)i;
पूर्ण


अटल व्योम ni_convert_mc_रेजिस्टरs(काष्ठा ni_mc_reg_entry *entry,
				    SMC_NIslands_MCRegisterSet *data,
				    u32 num_entries, u32 valid_flag)
अणु
	u32 i, j;

	क्रम (i = 0, j = 0; j < num_entries; j++) अणु
		अगर (valid_flag & (1 << j)) अणु
			data->value[i] = cpu_to_be32(entry->mc_data[j]);
			i++;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ni_convert_mc_reg_table_entry_to_smc(काष्ठा radeon_device *rdev,
						 काष्ठा rv7xx_pl *pl,
						 SMC_NIslands_MCRegisterSet *mc_reg_table_data)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 i = 0;

	क्रम (i = 0; i < ni_pi->mc_reg_table.num_entries; i++) अणु
		अगर (pl->mclk <= ni_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)
			अवरोध;
	पूर्ण

	अगर ((i == ni_pi->mc_reg_table.num_entries) && (i > 0))
		--i;

	ni_convert_mc_रेजिस्टरs(&ni_pi->mc_reg_table.mc_reg_table_entry[i],
				mc_reg_table_data,
				ni_pi->mc_reg_table.last,
				ni_pi->mc_reg_table.valid_flag);
पूर्ण

अटल व्योम ni_convert_mc_reg_table_to_smc(काष्ठा radeon_device *rdev,
					   काष्ठा radeon_ps *radeon_state,
					   SMC_NIslands_MCRegisters *mc_reg_table)
अणु
	काष्ठा ni_ps *state = ni_get_ps(radeon_state);
	पूर्णांक i;

	क्रम (i = 0; i < state->perक्रमmance_level_count; i++) अणु
		ni_convert_mc_reg_table_entry_to_smc(rdev,
						     &state->perक्रमmance_levels[i],
						     &mc_reg_table->data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i]);
	पूर्ण
पूर्ण

अटल पूर्णांक ni_populate_mc_reg_table(काष्ठा radeon_device *rdev,
				    काष्ठा radeon_ps *radeon_boot_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *boot_state = ni_get_ps(radeon_boot_state);
	SMC_NIslands_MCRegisters *mc_reg_table = &ni_pi->smc_mc_reg_table;

	स_रखो(mc_reg_table, 0, माप(SMC_NIslands_MCRegisters));

	rv770_ग_लिखो_smc_soft_रेजिस्टर(rdev, NI_SMC_SOFT_REGISTER_seq_index, 1);

	ni_populate_mc_reg_addresses(rdev, mc_reg_table);

	ni_convert_mc_reg_table_entry_to_smc(rdev, &boot_state->perक्रमmance_levels[0],
					     &mc_reg_table->data[0]);

	ni_convert_mc_रेजिस्टरs(&ni_pi->mc_reg_table.mc_reg_table_entry[0],
				&mc_reg_table->data[1],
				ni_pi->mc_reg_table.last,
				ni_pi->mc_reg_table.valid_flag);

	ni_convert_mc_reg_table_to_smc(rdev, radeon_boot_state, mc_reg_table);

	वापस rv770_copy_bytes_to_smc(rdev, eg_pi->mc_reg_table_start,
				       (u8 *)mc_reg_table,
				       माप(SMC_NIslands_MCRegisters),
				       pi->sram_end);
पूर्ण

अटल पूर्णांक ni_upload_mc_reg_table(काष्ठा radeon_device *rdev,
				  काष्ठा radeon_ps *radeon_new_state)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा ni_ps *ni_new_state = ni_get_ps(radeon_new_state);
	SMC_NIslands_MCRegisters *mc_reg_table = &ni_pi->smc_mc_reg_table;
	u16 address;

	स_रखो(mc_reg_table, 0, माप(SMC_NIslands_MCRegisters));

	ni_convert_mc_reg_table_to_smc(rdev, radeon_new_state, mc_reg_table);

	address = eg_pi->mc_reg_table_start +
		(u16)दुरत्व(SMC_NIslands_MCRegisters, data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT]);

	वापस rv770_copy_bytes_to_smc(rdev, address,
				       (u8 *)&mc_reg_table->data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT],
				       माप(SMC_NIslands_MCRegisterSet) * ni_new_state->perक्रमmance_level_count,
				       pi->sram_end);
पूर्ण

अटल पूर्णांक ni_init_driver_calculated_leakage_table(काष्ठा radeon_device *rdev,
						   PP_NIslands_CACTABLES *cac_tables)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	u32 leakage = 0;
	अचिन्हित पूर्णांक i, j, table_size;
	s32 t;
	u32 smc_leakage, max_leakage = 0;
	u32 scaling_factor;

	table_size = eg_pi->vddc_voltage_table.count;

	अगर (SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES < table_size)
		table_size = SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES;

	scaling_factor = ni_get_smc_घातer_scaling_factor(rdev);

	क्रम (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++) अणु
		क्रम (j = 0; j < table_size; j++) अणु
			t = (1000 * ((i + 1) * 8));

			अगर (t < ni_pi->cac_data.leakage_minimum_temperature)
				t = ni_pi->cac_data.leakage_minimum_temperature;

			ni_calculate_leakage_क्रम_v_and_t(rdev,
							 &ni_pi->cac_data.leakage_coefficients,
							 eg_pi->vddc_voltage_table.entries[j].value,
							 t,
							 ni_pi->cac_data.i_leakage,
							 &leakage);

			smc_leakage = ni_scale_घातer_क्रम_smc(leakage, scaling_factor) / 1000;
			अगर (smc_leakage > max_leakage)
				max_leakage = smc_leakage;

			cac_tables->cac_lkge_lut[i][j] = cpu_to_be32(smc_leakage);
		पूर्ण
	पूर्ण

	क्रम (j = table_size; j < SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) अणु
		क्रम (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)
			cac_tables->cac_lkge_lut[i][j] = cpu_to_be32(max_leakage);
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ni_init_simplअगरied_leakage_table(काष्ठा radeon_device *rdev,
					    PP_NIslands_CACTABLES *cac_tables)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_cac_leakage_table *leakage_table =
		&rdev->pm.dpm.dyn_state.cac_leakage_table;
	u32 i, j, table_size;
	u32 smc_leakage, max_leakage = 0;
	u32 scaling_factor;

	अगर (!leakage_table)
		वापस -EINVAL;

	table_size = leakage_table->count;

	अगर (eg_pi->vddc_voltage_table.count != table_size)
		table_size = (eg_pi->vddc_voltage_table.count < leakage_table->count) ?
			eg_pi->vddc_voltage_table.count : leakage_table->count;

	अगर (SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES < table_size)
		table_size = SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES;

	अगर (table_size == 0)
		वापस -EINVAL;

	scaling_factor = ni_get_smc_घातer_scaling_factor(rdev);

	क्रम (j = 0; j < table_size; j++) अणु
		smc_leakage = leakage_table->entries[j].leakage;

		अगर (smc_leakage > max_leakage)
			max_leakage = smc_leakage;

		क्रम (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)
			cac_tables->cac_lkge_lut[i][j] =
				cpu_to_be32(ni_scale_घातer_क्रम_smc(smc_leakage, scaling_factor));
	पूर्ण

	क्रम (j = table_size; j < SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) अणु
		क्रम (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)
			cac_tables->cac_lkge_lut[i][j] =
				cpu_to_be32(ni_scale_घातer_क्रम_smc(max_leakage, scaling_factor));
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ni_initialize_smc_cac_tables(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	PP_NIslands_CACTABLES *cac_tables = शून्य;
	पूर्णांक i, ret;
	u32 reg;

	अगर (ni_pi->enable_cac == false)
		वापस 0;

	cac_tables = kzalloc(माप(PP_NIslands_CACTABLES), GFP_KERNEL);
	अगर (!cac_tables)
		वापस -ENOMEM;

	reg = RREG32(CG_CAC_CTRL) & ~(TID_CNT_MASK | TID_UNIT_MASK);
	reg |= (TID_CNT(ni_pi->cac_weights->tid_cnt) |
		TID_UNIT(ni_pi->cac_weights->tid_unit));
	WREG32(CG_CAC_CTRL, reg);

	क्रम (i = 0; i < NISLANDS_DCCAC_MAX_LEVELS; i++)
		ni_pi->dc_cac_table[i] = ni_pi->cac_weights->dc_cac[i];

	क्रम (i = 0; i < SMC_NISLANDS_BIF_LUT_NUM_OF_ENTRIES; i++)
		cac_tables->cac_bअगर_lut[i] = ni_pi->cac_weights->pcie_cac[i];

	ni_pi->cac_data.i_leakage = rdev->pm.dpm.cac_leakage;
	ni_pi->cac_data.pwr_स्थिर = 0;
	ni_pi->cac_data.dc_cac_value = ni_pi->dc_cac_table[NISLANDS_DCCAC_LEVEL_0];
	ni_pi->cac_data.bअगर_cac_value = 0;
	ni_pi->cac_data.mc_wr_weight = ni_pi->cac_weights->mc_ग_लिखो_weight;
	ni_pi->cac_data.mc_rd_weight = ni_pi->cac_weights->mc_पढ़ो_weight;
	ni_pi->cac_data.allow_ovrflw = 0;
	ni_pi->cac_data.l2num_win_tdp = ni_pi->lta_winकरोw_size;
	ni_pi->cac_data.num_win_tdp = 0;
	ni_pi->cac_data.lts_truncate_n = ni_pi->lts_truncate;

	अगर (ni_pi->driver_calculate_cac_leakage)
		ret = ni_init_driver_calculated_leakage_table(rdev, cac_tables);
	अन्यथा
		ret = ni_init_simplअगरied_leakage_table(rdev, cac_tables);

	अगर (ret)
		जाओ करोne_मुक्त;

	cac_tables->pwr_स्थिर      = cpu_to_be32(ni_pi->cac_data.pwr_स्थिर);
	cac_tables->dc_cacValue    = cpu_to_be32(ni_pi->cac_data.dc_cac_value);
	cac_tables->bअगर_cacValue   = cpu_to_be32(ni_pi->cac_data.bअगर_cac_value);
	cac_tables->AllowOvrflw    = ni_pi->cac_data.allow_ovrflw;
	cac_tables->MCWrWeight     = ni_pi->cac_data.mc_wr_weight;
	cac_tables->MCRdWeight     = ni_pi->cac_data.mc_rd_weight;
	cac_tables->numWin_TDP     = ni_pi->cac_data.num_win_tdp;
	cac_tables->l2numWin_TDP   = ni_pi->cac_data.l2num_win_tdp;
	cac_tables->lts_truncate_n = ni_pi->cac_data.lts_truncate_n;

	ret = rv770_copy_bytes_to_smc(rdev, ni_pi->cac_table_start, (u8 *)cac_tables,
				      माप(PP_NIslands_CACTABLES), pi->sram_end);

करोne_मुक्त:
	अगर (ret) अणु
		ni_pi->enable_cac = false;
		ni_pi->enable_घातer_containment = false;
	पूर्ण

	kमुक्त(cac_tables);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_initialize_hardware_cac_manager(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	u32 reg;

	अगर (!ni_pi->enable_cac ||
	    !ni_pi->cac_configuration_required)
		वापस 0;

	अगर (ni_pi->cac_weights == शून्य)
		वापस -EINVAL;

	reg = RREG32_CG(CG_CAC_REGION_1_WEIGHT_0) & ~(WEIGHT_TCP_SIG0_MASK |
						      WEIGHT_TCP_SIG1_MASK |
						      WEIGHT_TA_SIG_MASK);
	reg |= (WEIGHT_TCP_SIG0(ni_pi->cac_weights->weight_tcp_sig0) |
		WEIGHT_TCP_SIG1(ni_pi->cac_weights->weight_tcp_sig1) |
		WEIGHT_TA_SIG(ni_pi->cac_weights->weight_ta_sig));
	WREG32_CG(CG_CAC_REGION_1_WEIGHT_0, reg);

	reg = RREG32_CG(CG_CAC_REGION_1_WEIGHT_1) & ~(WEIGHT_TCC_EN0_MASK |
						      WEIGHT_TCC_EN1_MASK |
						      WEIGHT_TCC_EN2_MASK);
	reg |= (WEIGHT_TCC_EN0(ni_pi->cac_weights->weight_tcc_en0) |
		WEIGHT_TCC_EN1(ni_pi->cac_weights->weight_tcc_en1) |
		WEIGHT_TCC_EN2(ni_pi->cac_weights->weight_tcc_en2));
	WREG32_CG(CG_CAC_REGION_1_WEIGHT_1, reg);

	reg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_0) & ~(WEIGHT_CB_EN0_MASK |
						      WEIGHT_CB_EN1_MASK |
						      WEIGHT_CB_EN2_MASK |
						      WEIGHT_CB_EN3_MASK);
	reg |= (WEIGHT_CB_EN0(ni_pi->cac_weights->weight_cb_en0) |
		WEIGHT_CB_EN1(ni_pi->cac_weights->weight_cb_en1) |
		WEIGHT_CB_EN2(ni_pi->cac_weights->weight_cb_en2) |
		WEIGHT_CB_EN3(ni_pi->cac_weights->weight_cb_en3));
	WREG32_CG(CG_CAC_REGION_2_WEIGHT_0, reg);

	reg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_1) & ~(WEIGHT_DB_SIG0_MASK |
						      WEIGHT_DB_SIG1_MASK |
						      WEIGHT_DB_SIG2_MASK |
						      WEIGHT_DB_SIG3_MASK);
	reg |= (WEIGHT_DB_SIG0(ni_pi->cac_weights->weight_db_sig0) |
		WEIGHT_DB_SIG1(ni_pi->cac_weights->weight_db_sig1) |
		WEIGHT_DB_SIG2(ni_pi->cac_weights->weight_db_sig2) |
		WEIGHT_DB_SIG3(ni_pi->cac_weights->weight_db_sig3));
	WREG32_CG(CG_CAC_REGION_2_WEIGHT_1, reg);

	reg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_2) & ~(WEIGHT_SXM_SIG0_MASK |
						      WEIGHT_SXM_SIG1_MASK |
						      WEIGHT_SXM_SIG2_MASK |
						      WEIGHT_SXS_SIG0_MASK |
						      WEIGHT_SXS_SIG1_MASK);
	reg |= (WEIGHT_SXM_SIG0(ni_pi->cac_weights->weight_sxm_sig0) |
		WEIGHT_SXM_SIG1(ni_pi->cac_weights->weight_sxm_sig1) |
		WEIGHT_SXM_SIG2(ni_pi->cac_weights->weight_sxm_sig2) |
		WEIGHT_SXS_SIG0(ni_pi->cac_weights->weight_sxs_sig0) |
		WEIGHT_SXS_SIG1(ni_pi->cac_weights->weight_sxs_sig1));
	WREG32_CG(CG_CAC_REGION_2_WEIGHT_2, reg);

	reg = RREG32_CG(CG_CAC_REGION_3_WEIGHT_0) & ~(WEIGHT_XBR_0_MASK |
						      WEIGHT_XBR_1_MASK |
						      WEIGHT_XBR_2_MASK |
						      WEIGHT_SPI_SIG0_MASK);
	reg |= (WEIGHT_XBR_0(ni_pi->cac_weights->weight_xbr_0) |
		WEIGHT_XBR_1(ni_pi->cac_weights->weight_xbr_1) |
		WEIGHT_XBR_2(ni_pi->cac_weights->weight_xbr_2) |
		WEIGHT_SPI_SIG0(ni_pi->cac_weights->weight_spi_sig0));
	WREG32_CG(CG_CAC_REGION_3_WEIGHT_0, reg);

	reg = RREG32_CG(CG_CAC_REGION_3_WEIGHT_1) & ~(WEIGHT_SPI_SIG1_MASK |
						      WEIGHT_SPI_SIG2_MASK |
						      WEIGHT_SPI_SIG3_MASK |
						      WEIGHT_SPI_SIG4_MASK |
						      WEIGHT_SPI_SIG5_MASK);
	reg |= (WEIGHT_SPI_SIG1(ni_pi->cac_weights->weight_spi_sig1) |
		WEIGHT_SPI_SIG2(ni_pi->cac_weights->weight_spi_sig2) |
		WEIGHT_SPI_SIG3(ni_pi->cac_weights->weight_spi_sig3) |
		WEIGHT_SPI_SIG4(ni_pi->cac_weights->weight_spi_sig4) |
		WEIGHT_SPI_SIG5(ni_pi->cac_weights->weight_spi_sig5));
	WREG32_CG(CG_CAC_REGION_3_WEIGHT_1, reg);

	reg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_0) & ~(WEIGHT_LDS_SIG0_MASK |
						      WEIGHT_LDS_SIG1_MASK |
						      WEIGHT_SC_MASK);
	reg |= (WEIGHT_LDS_SIG0(ni_pi->cac_weights->weight_lds_sig0) |
		WEIGHT_LDS_SIG1(ni_pi->cac_weights->weight_lds_sig1) |
		WEIGHT_SC(ni_pi->cac_weights->weight_sc));
	WREG32_CG(CG_CAC_REGION_4_WEIGHT_0, reg);

	reg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_1) & ~(WEIGHT_BIF_MASK |
						      WEIGHT_CP_MASK |
						      WEIGHT_PA_SIG0_MASK |
						      WEIGHT_PA_SIG1_MASK |
						      WEIGHT_VGT_SIG0_MASK);
	reg |= (WEIGHT_BIF(ni_pi->cac_weights->weight_bअगर) |
		WEIGHT_CP(ni_pi->cac_weights->weight_cp) |
		WEIGHT_PA_SIG0(ni_pi->cac_weights->weight_pa_sig0) |
		WEIGHT_PA_SIG1(ni_pi->cac_weights->weight_pa_sig1) |
		WEIGHT_VGT_SIG0(ni_pi->cac_weights->weight_vgt_sig0));
	WREG32_CG(CG_CAC_REGION_4_WEIGHT_1, reg);

	reg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_2) & ~(WEIGHT_VGT_SIG1_MASK |
						      WEIGHT_VGT_SIG2_MASK |
						      WEIGHT_DC_SIG0_MASK |
						      WEIGHT_DC_SIG1_MASK |
						      WEIGHT_DC_SIG2_MASK);
	reg |= (WEIGHT_VGT_SIG1(ni_pi->cac_weights->weight_vgt_sig1) |
		WEIGHT_VGT_SIG2(ni_pi->cac_weights->weight_vgt_sig2) |
		WEIGHT_DC_SIG0(ni_pi->cac_weights->weight_dc_sig0) |
		WEIGHT_DC_SIG1(ni_pi->cac_weights->weight_dc_sig1) |
		WEIGHT_DC_SIG2(ni_pi->cac_weights->weight_dc_sig2));
	WREG32_CG(CG_CAC_REGION_4_WEIGHT_2, reg);

	reg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_3) & ~(WEIGHT_DC_SIG3_MASK |
						      WEIGHT_UVD_SIG0_MASK |
						      WEIGHT_UVD_SIG1_MASK |
						      WEIGHT_SPARE0_MASK |
						      WEIGHT_SPARE1_MASK);
	reg |= (WEIGHT_DC_SIG3(ni_pi->cac_weights->weight_dc_sig3) |
		WEIGHT_UVD_SIG0(ni_pi->cac_weights->weight_uvd_sig0) |
		WEIGHT_UVD_SIG1(ni_pi->cac_weights->weight_uvd_sig1) |
		WEIGHT_SPARE0(ni_pi->cac_weights->weight_spare0) |
		WEIGHT_SPARE1(ni_pi->cac_weights->weight_spare1));
	WREG32_CG(CG_CAC_REGION_4_WEIGHT_3, reg);

	reg = RREG32_CG(CG_CAC_REGION_5_WEIGHT_0) & ~(WEIGHT_SQ_VSP_MASK |
						      WEIGHT_SQ_VSP0_MASK);
	reg |= (WEIGHT_SQ_VSP(ni_pi->cac_weights->weight_sq_vsp) |
		WEIGHT_SQ_VSP0(ni_pi->cac_weights->weight_sq_vsp0));
	WREG32_CG(CG_CAC_REGION_5_WEIGHT_0, reg);

	reg = RREG32_CG(CG_CAC_REGION_5_WEIGHT_1) & ~(WEIGHT_SQ_GPR_MASK);
	reg |= WEIGHT_SQ_GPR(ni_pi->cac_weights->weight_sq_gpr);
	WREG32_CG(CG_CAC_REGION_5_WEIGHT_1, reg);

	reg = RREG32_CG(CG_CAC_REGION_4_OVERRIDE_4) & ~(OVR_MODE_SPARE_0_MASK |
							OVR_VAL_SPARE_0_MASK |
							OVR_MODE_SPARE_1_MASK |
							OVR_VAL_SPARE_1_MASK);
	reg |= (OVR_MODE_SPARE_0(ni_pi->cac_weights->ovr_mode_spare_0) |
		OVR_VAL_SPARE_0(ni_pi->cac_weights->ovr_val_spare_0) |
		OVR_MODE_SPARE_1(ni_pi->cac_weights->ovr_mode_spare_1) |
		OVR_VAL_SPARE_1(ni_pi->cac_weights->ovr_val_spare_1));
	WREG32_CG(CG_CAC_REGION_4_OVERRIDE_4, reg);

	reg = RREG32(SQ_CAC_THRESHOLD) & ~(VSP_MASK |
					   VSP0_MASK |
					   GPR_MASK);
	reg |= (VSP(ni_pi->cac_weights->vsp) |
		VSP0(ni_pi->cac_weights->vsp0) |
		GPR(ni_pi->cac_weights->gpr));
	WREG32(SQ_CAC_THRESHOLD, reg);

	reg = (MCDW_WR_ENABLE |
	       MCDX_WR_ENABLE |
	       MCDY_WR_ENABLE |
	       MCDZ_WR_ENABLE |
	       INDEX(0x09D4));
	WREG32(MC_CG_CONFIG, reg);

	reg = (READ_WEIGHT(ni_pi->cac_weights->mc_पढ़ो_weight) |
	       WRITE_WEIGHT(ni_pi->cac_weights->mc_ग_लिखो_weight) |
	       ALLOW_OVERFLOW);
	WREG32(MC_CG_DATAPORT, reg);

	वापस 0;
पूर्ण

अटल पूर्णांक ni_enable_smc_cac(काष्ठा radeon_device *rdev,
			     काष्ठा radeon_ps *radeon_new_state,
			     bool enable)
अणु
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);
	पूर्णांक ret = 0;
	PPSMC_Result smc_result;

	अगर (ni_pi->enable_cac) अणु
		अगर (enable) अणु
			अगर (!r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2)) अणु
				smc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_CollectCAC_PowerCorreln);

				अगर (ni_pi->support_cac_दीर्घ_term_average) अणु
					smc_result = rv770_send_msg_to_smc(rdev, PPSMC_CACLongTermAvgEnable);
					अगर (PPSMC_Result_OK != smc_result)
						ni_pi->support_cac_दीर्घ_term_average = false;
				पूर्ण

				smc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_EnableCac);
				अगर (PPSMC_Result_OK != smc_result)
					ret = -EINVAL;

				ni_pi->cac_enabled = (PPSMC_Result_OK == smc_result) ? true : false;
			पूर्ण
		पूर्ण अन्यथा अगर (ni_pi->cac_enabled) अणु
			smc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_DisableCac);

			ni_pi->cac_enabled = false;

			अगर (ni_pi->support_cac_दीर्घ_term_average) अणु
				smc_result = rv770_send_msg_to_smc(rdev, PPSMC_CACLongTermAvgDisable);
				अगर (PPSMC_Result_OK != smc_result)
					ni_pi->support_cac_दीर्घ_term_average = false;
			पूर्ण
		पूर्ण
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ni_pcie_perक्रमmance_request(काष्ठा radeon_device *rdev,
				       u8 perf_req, bool advertise)
अणु
#अगर defined(CONFIG_ACPI)
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);

	अगर ((perf_req == PCIE_PERF_REQ_PECI_GEN1) ||
	    (perf_req == PCIE_PERF_REQ_PECI_GEN2)) अणु
		अगर (eg_pi->pcie_perक्रमmance_request_रेजिस्टरed == false)
			radeon_acpi_pcie_notअगरy_device_पढ़ोy(rdev);
		eg_pi->pcie_perक्रमmance_request_रेजिस्टरed = true;
		वापस radeon_acpi_pcie_perक्रमmance_request(rdev, perf_req, advertise);
	पूर्ण अन्यथा अगर ((perf_req == PCIE_PERF_REQ_REMOVE_REGISTRY) &&
		    eg_pi->pcie_perक्रमmance_request_रेजिस्टरed) अणु
		eg_pi->pcie_perक्रमmance_request_रेजिस्टरed = false;
		वापस radeon_acpi_pcie_perक्रमmance_request(rdev, perf_req, advertise);
	पूर्ण
#पूर्ण_अगर
	वापस 0;
पूर्ण

अटल पूर्णांक ni_advertise_gen2_capability(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u32 पंचांगp;

	पंचांगp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);

	अगर ((पंचांगp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&
	    (पंचांगp & LC_OTHER_SIDE_SUPPORTS_GEN2))
		pi->pcie_gen2 = true;
	अन्यथा
		pi->pcie_gen2 = false;

	अगर (!pi->pcie_gen2)
		ni_pcie_perक्रमmance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, true);

	वापस 0;
पूर्ण

अटल व्योम ni_enable_bअगर_dynamic_pcie_gen2(काष्ठा radeon_device *rdev,
					    bool enable)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	u32 पंचांगp, bअगर;

	पंचांगp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);

	अगर ((पंचांगp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&
	    (पंचांगp & LC_OTHER_SIDE_SUPPORTS_GEN2)) अणु
		अगर (enable) अणु
			अगर (!pi->boot_in_gen2) अणु
				bअगर = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;
				bअगर |= CG_CLIENT_REQ(0xd);
				WREG32(CG_BIF_REQ_AND_RSP, bअगर);
			पूर्ण
			पंचांगp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;
			पंचांगp |= LC_HW_VOLTAGE_IF_CONTROL(1);
			पंचांगp |= LC_GEN2_EN_STRAP;

			पंचांगp |= LC_CLR_FAILED_SPD_CHANGE_CNT;
			WREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, पंचांगp);
			udelay(10);
			पंचांगp &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;
			WREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, पंचांगp);
		पूर्ण अन्यथा अणु
			अगर (!pi->boot_in_gen2) अणु
				bअगर = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;
				bअगर |= CG_CLIENT_REQ(0xd);
				WREG32(CG_BIF_REQ_AND_RSP, bअगर);

				पंचांगp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;
				पंचांगp &= ~LC_GEN2_EN_STRAP;
			पूर्ण
			WREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, पंचांगp);
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ni_enable_dynamic_pcie_gen2(काष्ठा radeon_device *rdev,
					bool enable)
अणु
	ni_enable_bअगर_dynamic_pcie_gen2(rdev, enable);

	अगर (enable)
		WREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);
	अन्यथा
		WREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);
पूर्ण

व्योम ni_set_uvd_घड़ी_beक्रमe_set_eng_घड़ी(काष्ठा radeon_device *rdev,
					   काष्ठा radeon_ps *new_ps,
					   काष्ठा radeon_ps *old_ps)
अणु
	काष्ठा ni_ps *new_state = ni_get_ps(new_ps);
	काष्ठा ni_ps *current_state = ni_get_ps(old_ps);

	अगर ((new_ps->vclk == old_ps->vclk) &&
	    (new_ps->dclk == old_ps->dclk))
		वापस;

	अगर (new_state->perक्रमmance_levels[new_state->perक्रमmance_level_count - 1].sclk >=
	    current_state->perक्रमmance_levels[current_state->perक्रमmance_level_count - 1].sclk)
		वापस;

	radeon_set_uvd_घड़ीs(rdev, new_ps->vclk, new_ps->dclk);
पूर्ण

व्योम ni_set_uvd_घड़ी_after_set_eng_घड़ी(काष्ठा radeon_device *rdev,
					  काष्ठा radeon_ps *new_ps,
					  काष्ठा radeon_ps *old_ps)
अणु
	काष्ठा ni_ps *new_state = ni_get_ps(new_ps);
	काष्ठा ni_ps *current_state = ni_get_ps(old_ps);

	अगर ((new_ps->vclk == old_ps->vclk) &&
	    (new_ps->dclk == old_ps->dclk))
		वापस;

	अगर (new_state->perक्रमmance_levels[new_state->perक्रमmance_level_count - 1].sclk <
	    current_state->perक्रमmance_levels[current_state->perक्रमmance_level_count - 1].sclk)
		वापस;

	radeon_set_uvd_घड़ीs(rdev, new_ps->vclk, new_ps->dclk);
पूर्ण

व्योम ni_dpm_setup_asic(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	पूर्णांक r;

	r = ni_mc_load_microcode(rdev);
	अगर (r)
		DRM_ERROR("Failed to load MC firmware!\n");
	ni_पढ़ो_घड़ी_रेजिस्टरs(rdev);
	btc_पढ़ो_arb_रेजिस्टरs(rdev);
	rv770_get_memory_type(rdev);
	अगर (eg_pi->pcie_perक्रमmance_request)
		ni_advertise_gen2_capability(rdev);
	rv770_get_pcie_gen2_status(rdev);
	rv770_enable_acpi_pm(rdev);
पूर्ण

व्योम ni_update_current_ps(काष्ठा radeon_device *rdev,
			  काष्ठा radeon_ps *rps)
अणु
	काष्ठा ni_ps *new_ps = ni_get_ps(rps);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);

	eg_pi->current_rps = *rps;
	ni_pi->current_ps = *new_ps;
	eg_pi->current_rps.ps_priv = &ni_pi->current_ps;
पूर्ण

व्योम ni_update_requested_ps(काष्ठा radeon_device *rdev,
			    काष्ठा radeon_ps *rps)
अणु
	काष्ठा ni_ps *new_ps = ni_get_ps(rps);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_घातer_info *ni_pi = ni_get_pi(rdev);

	eg_pi->requested_rps = *rps;
	ni_pi->requested_ps = *new_ps;
	eg_pi->requested_rps.ps_priv = &ni_pi->requested_ps;
पूर्ण

पूर्णांक ni_dpm_enable(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;
	पूर्णांक ret;

	अगर (pi->gfx_घड़ी_gating)
		ni_cg_घड़ीgating_शेष(rdev);
	अगर (btc_dpm_enabled(rdev))
		वापस -EINVAL;
	अगर (pi->mg_घड़ी_gating)
		ni_mg_घड़ीgating_शेष(rdev);
	अगर (eg_pi->ls_घड़ी_gating)
		ni_ls_घड़ीgating_शेष(rdev);
	अगर (pi->voltage_control) अणु
		rv770_enable_voltage_control(rdev, true);
		ret = cypress_स्थिरruct_voltage_tables(rdev);
		अगर (ret) अणु
			DRM_ERROR("cypress_construct_voltage_tables failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	अगर (eg_pi->dynamic_ac_timing) अणु
		ret = ni_initialize_mc_reg_table(rdev);
		अगर (ret)
			eg_pi->dynamic_ac_timing = false;
	पूर्ण
	अगर (pi->dynamic_ss)
		cypress_enable_spपढ़ो_spectrum(rdev, true);
	अगर (pi->thermal_protection)
		rv770_enable_thermal_protection(rdev, true);
	rv770_setup_bsp(rdev);
	rv770_program_git(rdev);
	rv770_program_tp(rdev);
	rv770_program_tpp(rdev);
	rv770_program_sstp(rdev);
	cypress_enable_display_gap(rdev);
	rv770_program_vc(rdev);
	अगर (pi->dynamic_pcie_gen2)
		ni_enable_dynamic_pcie_gen2(rdev, true);
	ret = rv770_upload_firmware(rdev);
	अगर (ret) अणु
		DRM_ERROR("rv770_upload_firmware failed\n");
		वापस ret;
	पूर्ण
	ret = ni_process_firmware_header(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_process_firmware_header failed\n");
		वापस ret;
	पूर्ण
	ret = ni_initial_चयन_from_arb_f0_to_f1(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_initial_switch_from_arb_f0_to_f1 failed\n");
		वापस ret;
	पूर्ण
	ret = ni_init_smc_table(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_init_smc_table failed\n");
		वापस ret;
	पूर्ण
	ret = ni_init_smc_spll_table(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_init_smc_spll_table failed\n");
		वापस ret;
	पूर्ण
	ret = ni_init_arb_table_index(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_init_arb_table_index failed\n");
		वापस ret;
	पूर्ण
	अगर (eg_pi->dynamic_ac_timing) अणु
		ret = ni_populate_mc_reg_table(rdev, boot_ps);
		अगर (ret) अणु
			DRM_ERROR("ni_populate_mc_reg_table failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	ret = ni_initialize_smc_cac_tables(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_initialize_smc_cac_tables failed\n");
		वापस ret;
	पूर्ण
	ret = ni_initialize_hardware_cac_manager(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_initialize_hardware_cac_manager failed\n");
		वापस ret;
	पूर्ण
	ret = ni_populate_smc_tdp_limits(rdev, boot_ps);
	अगर (ret) अणु
		DRM_ERROR("ni_populate_smc_tdp_limits failed\n");
		वापस ret;
	पूर्ण
	ni_program_response_बार(rdev);
	r7xx_start_smc(rdev);
	ret = cypress_notअगरy_smc_display_change(rdev, false);
	अगर (ret) अणु
		DRM_ERROR("cypress_notify_smc_display_change failed\n");
		वापस ret;
	पूर्ण
	cypress_enable_sclk_control(rdev, true);
	अगर (eg_pi->memory_transition)
		cypress_enable_mclk_control(rdev, true);
	cypress_start_dpm(rdev);
	अगर (pi->gfx_घड़ी_gating)
		ni_gfx_घड़ीgating_enable(rdev, true);
	अगर (pi->mg_घड़ी_gating)
		ni_mg_घड़ीgating_enable(rdev, true);
	अगर (eg_pi->ls_घड़ी_gating)
		ni_ls_घड़ीgating_enable(rdev, true);

	rv770_enable_स्वतः_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);

	ni_update_current_ps(rdev, boot_ps);

	वापस 0;
पूर्ण

व्योम ni_dpm_disable(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;

	अगर (!btc_dpm_enabled(rdev))
		वापस;
	rv770_clear_vc(rdev);
	अगर (pi->thermal_protection)
		rv770_enable_thermal_protection(rdev, false);
	ni_enable_घातer_containment(rdev, boot_ps, false);
	ni_enable_smc_cac(rdev, boot_ps, false);
	cypress_enable_spपढ़ो_spectrum(rdev, false);
	rv770_enable_स्वतः_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, false);
	अगर (pi->dynamic_pcie_gen2)
		ni_enable_dynamic_pcie_gen2(rdev, false);

	अगर (rdev->irq.installed &&
	    r600_is_पूर्णांकernal_thermal_sensor(rdev->pm.पूर्णांक_thermal_type)) अणु
		rdev->irq.dpm_thermal = false;
		radeon_irq_set(rdev);
	पूर्ण

	अगर (pi->gfx_घड़ी_gating)
		ni_gfx_घड़ीgating_enable(rdev, false);
	अगर (pi->mg_घड़ी_gating)
		ni_mg_घड़ीgating_enable(rdev, false);
	अगर (eg_pi->ls_घड़ी_gating)
		ni_ls_घड़ीgating_enable(rdev, false);
	ni_stop_dpm(rdev);
	btc_reset_to_शेष(rdev);
	ni_stop_smc(rdev);
	ni_क्रमce_चयन_to_arb_f0(rdev);

	ni_update_current_ps(rdev, boot_ps);
पूर्ण

अटल पूर्णांक ni_घातer_control_set_level(काष्ठा radeon_device *rdev)
अणु
	काष्ठा radeon_ps *new_ps = rdev->pm.dpm.requested_ps;
	पूर्णांक ret;

	ret = ni_restrict_perक्रमmance_levels_beक्रमe_चयन(rdev);
	अगर (ret)
		वापस ret;
	ret = rv770_halt_smc(rdev);
	अगर (ret)
		वापस ret;
	ret = ni_populate_smc_tdp_limits(rdev, new_ps);
	अगर (ret)
		वापस ret;
	ret = rv770_resume_smc(rdev);
	अगर (ret)
		वापस ret;
	ret = rv770_set_sw_state(rdev);
	अगर (ret)
		वापस ret;

	वापस 0;
पूर्ण

पूर्णांक ni_dpm_pre_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;
	काष्ठा radeon_ps *new_ps = &requested_ps;

	ni_update_requested_ps(rdev, new_ps);

	ni_apply_state_adjust_rules(rdev, &eg_pi->requested_rps);

	वापस 0;
पूर्ण

पूर्णांक ni_dpm_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *new_ps = &eg_pi->requested_rps;
	काष्ठा radeon_ps *old_ps = &eg_pi->current_rps;
	पूर्णांक ret;

	ret = ni_restrict_perक्रमmance_levels_beक्रमe_चयन(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_restrict_performance_levels_before_switch failed\n");
		वापस ret;
	पूर्ण
	ni_set_uvd_घड़ी_beक्रमe_set_eng_घड़ी(rdev, new_ps, old_ps);
	ret = ni_enable_घातer_containment(rdev, new_ps, false);
	अगर (ret) अणु
		DRM_ERROR("ni_enable_power_containment failed\n");
		वापस ret;
	पूर्ण
	ret = ni_enable_smc_cac(rdev, new_ps, false);
	अगर (ret) अणु
		DRM_ERROR("ni_enable_smc_cac failed\n");
		वापस ret;
	पूर्ण
	ret = rv770_halt_smc(rdev);
	अगर (ret) अणु
		DRM_ERROR("rv770_halt_smc failed\n");
		वापस ret;
	पूर्ण
	अगर (eg_pi->smu_uvd_hs)
		btc_notअगरy_uvd_to_smc(rdev, new_ps);
	ret = ni_upload_sw_state(rdev, new_ps);
	अगर (ret) अणु
		DRM_ERROR("ni_upload_sw_state failed\n");
		वापस ret;
	पूर्ण
	अगर (eg_pi->dynamic_ac_timing) अणु
		ret = ni_upload_mc_reg_table(rdev, new_ps);
		अगर (ret) अणु
			DRM_ERROR("ni_upload_mc_reg_table failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	ret = ni_program_memory_timing_parameters(rdev, new_ps);
	अगर (ret) अणु
		DRM_ERROR("ni_program_memory_timing_parameters failed\n");
		वापस ret;
	पूर्ण
	ret = rv770_resume_smc(rdev);
	अगर (ret) अणु
		DRM_ERROR("rv770_resume_smc failed\n");
		वापस ret;
	पूर्ण
	ret = rv770_set_sw_state(rdev);
	अगर (ret) अणु
		DRM_ERROR("rv770_set_sw_state failed\n");
		वापस ret;
	पूर्ण
	ni_set_uvd_घड़ी_after_set_eng_घड़ी(rdev, new_ps, old_ps);
	ret = ni_enable_smc_cac(rdev, new_ps, true);
	अगर (ret) अणु
		DRM_ERROR("ni_enable_smc_cac failed\n");
		वापस ret;
	पूर्ण
	ret = ni_enable_घातer_containment(rdev, new_ps, true);
	अगर (ret) अणु
		DRM_ERROR("ni_enable_power_containment failed\n");
		वापस ret;
	पूर्ण

	/* update tdp */
	ret = ni_घातer_control_set_level(rdev);
	अगर (ret) अणु
		DRM_ERROR("ni_power_control_set_level failed\n");
		वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

व्योम ni_dpm_post_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *new_ps = &eg_pi->requested_rps;

	ni_update_current_ps(rdev, new_ps);
पूर्ण

#अगर 0
व्योम ni_dpm_reset_asic(काष्ठा radeon_device *rdev)
अणु
	ni_restrict_perक्रमmance_levels_beक्रमe_चयन(rdev);
	rv770_set_boot_state(rdev);
पूर्ण
#पूर्ण_अगर

जोड़ घातer_info अणु
	काष्ठा _ATOM_POWERPLAY_INFO info;
	काष्ठा _ATOM_POWERPLAY_INFO_V2 info_2;
	काष्ठा _ATOM_POWERPLAY_INFO_V3 info_3;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE pplib;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;
पूर्ण;

जोड़ pplib_घड़ी_info अणु
	काष्ठा _ATOM_PPLIB_R600_CLOCK_INFO r600;
	काष्ठा _ATOM_PPLIB_RS780_CLOCK_INFO rs780;
	काष्ठा _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;
	काष्ठा _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;
पूर्ण;

जोड़ pplib_घातer_state अणु
	काष्ठा _ATOM_PPLIB_STATE v1;
	काष्ठा _ATOM_PPLIB_STATE_V2 v2;
पूर्ण;

अटल व्योम ni_parse_pplib_non_घड़ी_info(काष्ठा radeon_device *rdev,
					  काष्ठा radeon_ps *rps,
					  काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *non_घड़ी_info,
					  u8 table_rev)
अणु
	rps->caps = le32_to_cpu(non_घड़ी_info->ulCapsAndSettings);
	rps->class = le16_to_cpu(non_घड़ी_info->usClassअगरication);
	rps->class2 = le16_to_cpu(non_घड़ी_info->usClassअगरication2);

	अगर (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) अणु
		rps->vclk = le32_to_cpu(non_घड़ी_info->ulVCLK);
		rps->dclk = le32_to_cpu(non_घड़ी_info->ulDCLK);
	पूर्ण अन्यथा अगर (r600_is_uvd_state(rps->class, rps->class2)) अणु
		rps->vclk = RV770_DEFAULT_VCLK_FREQ;
		rps->dclk = RV770_DEFAULT_DCLK_FREQ;
	पूर्ण अन्यथा अणु
		rps->vclk = 0;
		rps->dclk = 0;
	पूर्ण

	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)
		rdev->pm.dpm.boot_ps = rps;
	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)
		rdev->pm.dpm.uvd_ps = rps;
पूर्ण

अटल व्योम ni_parse_pplib_घड़ी_info(काष्ठा radeon_device *rdev,
				      काष्ठा radeon_ps *rps, पूर्णांक index,
				      जोड़ pplib_घड़ी_info *घड़ी_info)
अणु
	काष्ठा rv7xx_घातer_info *pi = rv770_get_pi(rdev);
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा rv7xx_pl *pl = &ps->perक्रमmance_levels[index];

	ps->perक्रमmance_level_count = index + 1;

	pl->sclk = le16_to_cpu(घड़ी_info->evergreen.usEngineClockLow);
	pl->sclk |= घड़ी_info->evergreen.ucEngineClockHigh << 16;
	pl->mclk = le16_to_cpu(घड़ी_info->evergreen.usMemoryClockLow);
	pl->mclk |= घड़ी_info->evergreen.ucMemoryClockHigh << 16;

	pl->vddc = le16_to_cpu(घड़ी_info->evergreen.usVDDC);
	pl->vddci = le16_to_cpu(घड़ी_info->evergreen.usVDDCI);
	pl->flags = le32_to_cpu(घड़ी_info->evergreen.ulFlags);

	/* patch up vddc अगर necessary */
	अगर (pl->vddc == 0xff01) अणु
		अगर (pi->max_vddc)
			pl->vddc = pi->max_vddc;
	पूर्ण

	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) अणु
		pi->acpi_vddc = pl->vddc;
		eg_pi->acpi_vddci = pl->vddci;
		अगर (ps->perक्रमmance_levels[0].flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)
			pi->acpi_pcie_gen2 = true;
		अन्यथा
			pi->acpi_pcie_gen2 = false;
	पूर्ण

	अगर (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) अणु
		eg_pi->ulv.supported = true;
		eg_pi->ulv.pl = pl;
	पूर्ण

	अगर (pi->min_vddc_in_table > pl->vddc)
		pi->min_vddc_in_table = pl->vddc;

	अगर (pi->max_vddc_in_table < pl->vddc)
		pi->max_vddc_in_table = pl->vddc;

	/* patch up boot state */
	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) अणु
		u16 vddc, vddci, mvdd;
		radeon_atombios_get_शेष_voltages(rdev, &vddc, &vddci, &mvdd);
		pl->mclk = rdev->घड़ी.शेष_mclk;
		pl->sclk = rdev->घड़ी.शेष_sclk;
		pl->vddc = vddc;
		pl->vddci = vddci;
	पूर्ण

	अगर ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==
	    ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) अणु
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.sclk = pl->sclk;
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.mclk = pl->mclk;
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.vddc = pl->vddc;
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.vddci = pl->vddci;
	पूर्ण
पूर्ण

अटल पूर्णांक ni_parse_घातer_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा radeon_mode_info *mode_info = &rdev->mode_info;
	काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *non_घड़ी_info;
	जोड़ pplib_घातer_state *घातer_state;
	पूर्णांक i, j;
	जोड़ pplib_घड़ी_info *घड़ी_info;
	जोड़ घातer_info *घातer_info;
	पूर्णांक index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);
	u16 data_offset;
	u8 frev, crev;
	काष्ठा ni_ps *ps;

	अगर (!atom_parse_data_header(mode_info->atom_context, index, शून्य,
				   &frev, &crev, &data_offset))
		वापस -EINVAL;
	घातer_info = (जोड़ घातer_info *)(mode_info->atom_context->bios + data_offset);

	rdev->pm.dpm.ps = kसुस्मृति(घातer_info->pplib.ucNumStates,
				  माप(काष्ठा radeon_ps),
				  GFP_KERNEL);
	अगर (!rdev->pm.dpm.ps)
		वापस -ENOMEM;

	क्रम (i = 0; i < घातer_info->pplib.ucNumStates; i++) अणु
		घातer_state = (जोड़ pplib_घातer_state *)
			(mode_info->atom_context->bios + data_offset +
			 le16_to_cpu(घातer_info->pplib.usStateArrayOffset) +
			 i * घातer_info->pplib.ucStateEntrySize);
		non_घड़ी_info = (काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *)
			(mode_info->atom_context->bios + data_offset +
			 le16_to_cpu(घातer_info->pplib.usNonClockInfoArrayOffset) +
			 (घातer_state->v1.ucNonClockStateIndex *
			  घातer_info->pplib.ucNonClockSize));
		अगर (घातer_info->pplib.ucStateEntrySize - 1) अणु
			u8 *idx;
			ps = kzalloc(माप(काष्ठा ni_ps), GFP_KERNEL);
			अगर (ps == शून्य) अणु
				kमुक्त(rdev->pm.dpm.ps);
				वापस -ENOMEM;
			पूर्ण
			rdev->pm.dpm.ps[i].ps_priv = ps;
			ni_parse_pplib_non_घड़ी_info(rdev, &rdev->pm.dpm.ps[i],
							 non_घड़ी_info,
							 घातer_info->pplib.ucNonClockSize);
			idx = (u8 *)&घातer_state->v1.ucClockStateIndices[0];
			क्रम (j = 0; j < (घातer_info->pplib.ucStateEntrySize - 1); j++) अणु
				घड़ी_info = (जोड़ pplib_घड़ी_info *)
					(mode_info->atom_context->bios + data_offset +
					 le16_to_cpu(घातer_info->pplib.usClockInfoArrayOffset) +
					 (idx[j] * घातer_info->pplib.ucClockInfoSize));
				ni_parse_pplib_घड़ी_info(rdev,
							  &rdev->pm.dpm.ps[i], j,
							  घड़ी_info);
			पूर्ण
		पूर्ण
	पूर्ण
	rdev->pm.dpm.num_ps = घातer_info->pplib.ucNumStates;
	वापस 0;
पूर्ण

पूर्णांक ni_dpm_init(काष्ठा radeon_device *rdev)
अणु
	काष्ठा rv7xx_घातer_info *pi;
	काष्ठा evergreen_घातer_info *eg_pi;
	काष्ठा ni_घातer_info *ni_pi;
	काष्ठा atom_घड़ी_भागiders भागiders;
	पूर्णांक ret;

	ni_pi = kzalloc(माप(काष्ठा ni_घातer_info), GFP_KERNEL);
	अगर (ni_pi == शून्य)
		वापस -ENOMEM;
	rdev->pm.dpm.priv = ni_pi;
	eg_pi = &ni_pi->eg;
	pi = &eg_pi->rv7xx;

	rv770_get_max_vddc(rdev);

	eg_pi->ulv.supported = false;
	pi->acpi_vddc = 0;
	eg_pi->acpi_vddci = 0;
	pi->min_vddc_in_table = 0;
	pi->max_vddc_in_table = 0;

	ret = r600_get_platक्रमm_caps(rdev);
	अगर (ret)
		वापस ret;

	ret = ni_parse_घातer_table(rdev);
	अगर (ret)
		वापस ret;
	ret = r600_parse_extended_घातer_table(rdev);
	अगर (ret)
		वापस ret;

	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
		kसुस्मृति(4,
			माप(काष्ठा radeon_घड़ी_voltage_dependency_entry),
			GFP_KERNEL);
	अगर (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) अणु
		r600_मुक्त_extended_घातer_table(rdev);
		वापस -ENOMEM;
	पूर्ण
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;

	ni_patch_dependency_tables_based_on_leakage(rdev);

	अगर (rdev->pm.dpm.voltage_response_समय == 0)
		rdev->pm.dpm.voltage_response_समय = R600_VOLTAGERESPONSETIME_DFLT;
	अगर (rdev->pm.dpm.backbias_response_समय == 0)
		rdev->pm.dpm.backbias_response_समय = R600_BACKBIASRESPONSETIME_DFLT;

	ret = radeon_atom_get_घड़ी_भागiders(rdev, COMPUTE_ENGINE_PLL_PARAM,
					     0, false, &भागiders);
	अगर (ret)
		pi->ref_भाग = भागiders.ref_भाग + 1;
	अन्यथा
		pi->ref_भाग = R600_REFERENCEDIVIDER_DFLT;

	pi->rlp = RV770_RLP_DFLT;
	pi->rmp = RV770_RMP_DFLT;
	pi->lhp = RV770_LHP_DFLT;
	pi->lmp = RV770_LMP_DFLT;

	eg_pi->ats[0].rlp = RV770_RLP_DFLT;
	eg_pi->ats[0].rmp = RV770_RMP_DFLT;
	eg_pi->ats[0].lhp = RV770_LHP_DFLT;
	eg_pi->ats[0].lmp = RV770_LMP_DFLT;

	eg_pi->ats[1].rlp = BTC_RLP_UVD_DFLT;
	eg_pi->ats[1].rmp = BTC_RMP_UVD_DFLT;
	eg_pi->ats[1].lhp = BTC_LHP_UVD_DFLT;
	eg_pi->ats[1].lmp = BTC_LMP_UVD_DFLT;

	eg_pi->smu_uvd_hs = true;

	अगर (rdev->pdev->device == 0x6707) अणु
		pi->mclk_strobe_mode_threshold = 55000;
		pi->mclk_edc_enable_threshold = 55000;
		eg_pi->mclk_edc_wr_enable_threshold = 55000;
	पूर्ण अन्यथा अणु
		pi->mclk_strobe_mode_threshold = 40000;
		pi->mclk_edc_enable_threshold = 40000;
		eg_pi->mclk_edc_wr_enable_threshold = 40000;
	पूर्ण
	ni_pi->mclk_rtt_mode_threshold = eg_pi->mclk_edc_wr_enable_threshold;

	pi->voltage_control =
		radeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);

	pi->mvdd_control =
		radeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);

	eg_pi->vddci_control =
		radeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0);

	rv770_get_engine_memory_ss(rdev);

	pi->asi = RV770_ASI_DFLT;
	pi->pasi = CYPRESS_HASI_DFLT;
	pi->vrc = CYPRESS_VRC_DFLT;

	pi->घातer_gating = false;

	pi->gfx_घड़ी_gating = true;

	pi->mg_घड़ी_gating = true;
	pi->mgcgtssm = true;
	eg_pi->ls_घड़ी_gating = false;
	eg_pi->sclk_deep_sleep = false;

	pi->dynamic_pcie_gen2 = true;

	अगर (rdev->pm.पूर्णांक_thermal_type != THERMAL_TYPE_NONE)
		pi->thermal_protection = true;
	अन्यथा
		pi->thermal_protection = false;

	pi->display_gap = true;

	pi->dcodt = true;

	pi->ulps = true;

	eg_pi->dynamic_ac_timing = true;
	eg_pi->abm = true;
	eg_pi->mcls = true;
	eg_pi->light_sleep = true;
	eg_pi->memory_transition = true;
#अगर defined(CONFIG_ACPI)
	eg_pi->pcie_perक्रमmance_request =
		radeon_acpi_is_pcie_perक्रमmance_request_supported(rdev);
#अन्यथा
	eg_pi->pcie_perक्रमmance_request = false;
#पूर्ण_अगर

	eg_pi->dll_शेष_on = false;

	eg_pi->sclk_deep_sleep = false;

	pi->mclk_stutter_mode_threshold = 0;

	pi->sram_end = SMC_RAM_END;

	rdev->pm.dpm.dyn_state.mclk_sclk_ratio = 3;
	rdev->pm.dpm.dyn_state.vddc_vddci_delta = 200;
	rdev->pm.dpm.dyn_state.min_vddc_क्रम_pcie_gen2 = 900;
	rdev->pm.dpm.dyn_state.valid_sclk_values.count = ARRAY_SIZE(btc_valid_sclk);
	rdev->pm.dpm.dyn_state.valid_sclk_values.values = btc_valid_sclk;
	rdev->pm.dpm.dyn_state.valid_mclk_values.count = 0;
	rdev->pm.dpm.dyn_state.valid_mclk_values.values = शून्य;
	rdev->pm.dpm.dyn_state.sclk_mclk_delta = 12500;

	ni_pi->cac_data.leakage_coefficients.at = 516;
	ni_pi->cac_data.leakage_coefficients.bt = 18;
	ni_pi->cac_data.leakage_coefficients.av = 51;
	ni_pi->cac_data.leakage_coefficients.bv = 2957;

	चयन (rdev->pdev->device) अणु
	हाल 0x6700:
	हाल 0x6701:
	हाल 0x6702:
	हाल 0x6703:
	हाल 0x6718:
		ni_pi->cac_weights = &cac_weights_cayman_xt;
		अवरोध;
	हाल 0x6705:
	हाल 0x6719:
	हाल 0x671D:
	हाल 0x671C:
	शेष:
		ni_pi->cac_weights = &cac_weights_cayman_pro;
		अवरोध;
	हाल 0x6704:
	हाल 0x6706:
	हाल 0x6707:
	हाल 0x6708:
	हाल 0x6709:
		ni_pi->cac_weights = &cac_weights_cayman_le;
		अवरोध;
	पूर्ण

	अगर (ni_pi->cac_weights->enable_घातer_containment_by_शेष) अणु
		ni_pi->enable_घातer_containment = true;
		ni_pi->enable_cac = true;
		ni_pi->enable_sq_ramping = true;
	पूर्ण अन्यथा अणु
		ni_pi->enable_घातer_containment = false;
		ni_pi->enable_cac = false;
		ni_pi->enable_sq_ramping = false;
	पूर्ण

	ni_pi->driver_calculate_cac_leakage = false;
	ni_pi->cac_configuration_required = true;

	अगर (ni_pi->cac_configuration_required) अणु
		ni_pi->support_cac_दीर्घ_term_average = true;
		ni_pi->lta_winकरोw_size = ni_pi->cac_weights->l2_lta_winकरोw_size;
		ni_pi->lts_truncate = ni_pi->cac_weights->lts_truncate;
	पूर्ण अन्यथा अणु
		ni_pi->support_cac_दीर्घ_term_average = false;
		ni_pi->lta_winकरोw_size = 0;
		ni_pi->lts_truncate = 0;
	पूर्ण

	ni_pi->use_घातer_boost_limit = true;

	/* make sure dc limits are valid */
	अगर ((rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc.sclk == 0) ||
	    (rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc.mclk == 0))
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc =
			rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;

	वापस 0;
पूर्ण

व्योम ni_dpm_fini(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक i;

	क्रम (i = 0; i < rdev->pm.dpm.num_ps; i++) अणु
		kमुक्त(rdev->pm.dpm.ps[i].ps_priv);
	पूर्ण
	kमुक्त(rdev->pm.dpm.ps);
	kमुक्त(rdev->pm.dpm.priv);
	kमुक्त(rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);
	r600_मुक्त_extended_घातer_table(rdev);
पूर्ण

व्योम ni_dpm_prपूर्णांक_घातer_state(काष्ठा radeon_device *rdev,
			      काष्ठा radeon_ps *rps)
अणु
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा rv7xx_pl *pl;
	पूर्णांक i;

	r600_dpm_prपूर्णांक_class_info(rps->class, rps->class2);
	r600_dpm_prपूर्णांक_cap_info(rps->caps);
	prपूर्णांकk("\tuvd    vclk: %d dclk: %d\n", rps->vclk, rps->dclk);
	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
		pl = &ps->perक्रमmance_levels[i];
		अगर (rdev->family >= CHIP_TAHITI)
			prपूर्णांकk("\t\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u pcie gen: %u\n",
			       i, pl->sclk, pl->mclk, pl->vddc, pl->vddci, pl->pcie_gen + 1);
		अन्यथा
			prपूर्णांकk("\t\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u\n",
			       i, pl->sclk, pl->mclk, pl->vddc, pl->vddci);
	पूर्ण
	r600_dpm_prपूर्णांक_ps_status(rdev, rps);
पूर्ण

व्योम ni_dpm_debugfs_prपूर्णांक_current_perक्रमmance_level(काष्ठा radeon_device *rdev,
						    काष्ठा seq_file *m)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *rps = &eg_pi->current_rps;
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा rv7xx_pl *pl;
	u32 current_index =
		(RREG32(TARGET_AND_CURRENT_PROखाता_INDEX) & CURRENT_STATE_INDEX_MASK) >>
		CURRENT_STATE_INDEX_SHIFT;

	अगर (current_index >= ps->perक्रमmance_level_count) अणु
		seq_म_लिखो(m, "invalid dpm profile %d\n", current_index);
	पूर्ण अन्यथा अणु
		pl = &ps->perक्रमmance_levels[current_index];
		seq_म_लिखो(m, "uvd    vclk: %d dclk: %d\n", rps->vclk, rps->dclk);
		seq_म_लिखो(m, "power level %d    sclk: %u mclk: %u vddc: %u vddci: %u\n",
			   current_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci);
	पूर्ण
पूर्ण

u32 ni_dpm_get_current_sclk(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *rps = &eg_pi->current_rps;
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा rv7xx_pl *pl;
	u32 current_index =
		(RREG32(TARGET_AND_CURRENT_PROखाता_INDEX) & CURRENT_STATE_INDEX_MASK) >>
		CURRENT_STATE_INDEX_SHIFT;

	अगर (current_index >= ps->perक्रमmance_level_count) अणु
		वापस 0;
	पूर्ण अन्यथा अणु
		pl = &ps->perक्रमmance_levels[current_index];
		वापस pl->sclk;
	पूर्ण
पूर्ण

u32 ni_dpm_get_current_mclk(काष्ठा radeon_device *rdev)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा radeon_ps *rps = &eg_pi->current_rps;
	काष्ठा ni_ps *ps = ni_get_ps(rps);
	काष्ठा rv7xx_pl *pl;
	u32 current_index =
		(RREG32(TARGET_AND_CURRENT_PROखाता_INDEX) & CURRENT_STATE_INDEX_MASK) >>
		CURRENT_STATE_INDEX_SHIFT;

	अगर (current_index >= ps->perक्रमmance_level_count) अणु
		वापस 0;
	पूर्ण अन्यथा अणु
		pl = &ps->perक्रमmance_levels[current_index];
		वापस pl->mclk;
	पूर्ण
पूर्ण

u32 ni_dpm_get_sclk(काष्ठा radeon_device *rdev, bool low)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_ps *requested_state = ni_get_ps(&eg_pi->requested_rps);

	अगर (low)
		वापस requested_state->perक्रमmance_levels[0].sclk;
	अन्यथा
		वापस requested_state->perक्रमmance_levels[requested_state->perक्रमmance_level_count - 1].sclk;
पूर्ण

u32 ni_dpm_get_mclk(काष्ठा radeon_device *rdev, bool low)
अणु
	काष्ठा evergreen_घातer_info *eg_pi = evergreen_get_pi(rdev);
	काष्ठा ni_ps *requested_state = ni_get_ps(&eg_pi->requested_rps);

	अगर (low)
		वापस requested_state->perक्रमmance_levels[0].mclk;
	अन्यथा
		वापस requested_state->perक्रमmance_levels[requested_state->perक्रमmance_level_count - 1].mclk;
पूर्ण

