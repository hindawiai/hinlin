<शैली गुरु>
/*
 * Copyright 2013 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modअगरy, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to करो so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#समावेश <linux/firmware.h>
#समावेश <linux/pci.h>
#समावेश <linux/seq_file.h>

#समावेश "atom.h"
#समावेश "ci_dpm.h"
#समावेश "cik.h"
#समावेश "cikd.h"
#समावेश "r600_dpm.h"
#समावेश "radeon.h"
#समावेश "radeon_asic.h"
#समावेश "radeon_ucode.h"
#समावेश "si_dpm.h"

#घोषणा MC_CG_ARB_FREQ_F0           0x0a
#घोषणा MC_CG_ARB_FREQ_F1           0x0b
#घोषणा MC_CG_ARB_FREQ_F2           0x0c
#घोषणा MC_CG_ARB_FREQ_F3           0x0d

#घोषणा SMC_RAM_END 0x40000

#घोषणा VOLTAGE_SCALE               4
#घोषणा VOLTAGE_VID_OFFSET_SCALE1    625
#घोषणा VOLTAGE_VID_OFFSET_SCALE2    100

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_hawaii_xt =
अणु
	1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0xB0000,
	अणु 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  पूर्ण,
	अणु 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_hawaii_pro =
अणु
	1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0x65062,
	अणु 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  पूर्ण,
	अणु 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_bonaire_xt =
अणु
	1, 0xF, 0xFD, 0x19, 5, 45, 0, 0xB0000,
	अणु 0x79,  0x253, 0x25D, 0xAE,  0x72,  0x80,  0x83,  0x86,  0x6F,  0xC8,  0xC9,  0xC9,  0x2F,  0x4D,  0x61  पूर्ण,
	अणु 0x17C, 0x172, 0x180, 0x1BC, 0x1B3, 0x1BD, 0x206, 0x200, 0x203, 0x25D, 0x25A, 0x255, 0x2C3, 0x2C5, 0x2B4 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_saturn_xt =
अणु
	1, 0xF, 0xFD, 0x19, 5, 55, 0, 0x70000,
	अणु 0x8C,  0x247, 0x249, 0xA6,  0x80,  0x81,  0x8B,  0x89,  0x86,  0xC9,  0xCA,  0xC9,  0x4D,  0x4D,  0x4D  पूर्ण,
	अणु 0x187, 0x187, 0x187, 0x1C7, 0x1C7, 0x1C7, 0x210, 0x210, 0x210, 0x266, 0x266, 0x266, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_config_reg didt_config_ci[] =
अणु
	अणु 0x10, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x10, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x10, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x10, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x11, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x11, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x11, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x11, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x12, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x12, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x12, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x12, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x2, 0x00003fff, 0, 0x4, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x2, 0x03ff0000, 16, 0x80, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x2, 0x78000000, 27, 0x3, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x1, 0x0000ffff, 0, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x1, 0xffff0000, 16, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x0, 0x00000001, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x30, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x30, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x30, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x30, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x31, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x31, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x31, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x31, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x32, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x32, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x32, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x32, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x22, 0x00003fff, 0, 0x4, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x22, 0x03ff0000, 16, 0x80, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x22, 0x78000000, 27, 0x3, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x21, 0x0000ffff, 0, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x21, 0xffff0000, 16, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x20, 0x00000001, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x50, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x50, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x50, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x50, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x51, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x51, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x51, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x51, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x52, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x52, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x52, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x52, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x42, 0x00003fff, 0, 0x4, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x42, 0x03ff0000, 16, 0x80, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x42, 0x78000000, 27, 0x3, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x41, 0x0000ffff, 0, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x41, 0xffff0000, 16, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x40, 0x00000001, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x70, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x70, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x70, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x70, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x71, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x71, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x71, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x71, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x72, 0x000000ff, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x72, 0x0000ff00, 8, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x72, 0x00ff0000, 16, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x72, 0xff000000, 24, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x62, 0x00003fff, 0, 0x4, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x62, 0x03ff0000, 16, 0x80, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x62, 0x78000000, 27, 0x3, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x61, 0x0000ffff, 0, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x61, 0xffff0000, 16, 0x3FFF, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0x60, 0x00000001, 0, 0x0, CISLANDS_CONFIGREG_DIDT_IND पूर्ण,
	अणु 0xFFFFFFFF पूर्ण
पूर्ण;

बाह्य u8 rv770_get_memory_module_index(काष्ठा radeon_device *rdev);
बाह्य पूर्णांक ni_copy_and_चयन_arb_sets(काष्ठा radeon_device *rdev,
				       u32 arb_freq_src, u32 arb_freq_dest);
अटल पूर्णांक ci_get_std_voltage_value_sidd(काष्ठा radeon_device *rdev,
					 काष्ठा atom_voltage_table_entry *voltage_table,
					 u16 *std_voltage_hi_sidd, u16 *std_voltage_lo_sidd);
अटल पूर्णांक ci_set_घातer_limit(काष्ठा radeon_device *rdev, u32 n);
अटल पूर्णांक ci_set_overdrive_target_tdp(काष्ठा radeon_device *rdev,
				       u32 target_tdp);
अटल पूर्णांक ci_update_uvd_dpm(काष्ठा radeon_device *rdev, bool gate);

अटल PPSMC_Result ci_send_msg_to_smc(काष्ठा radeon_device *rdev, PPSMC_Msg msg);
अटल PPSMC_Result ci_send_msg_to_smc_with_parameter(काष्ठा radeon_device *rdev,
						      PPSMC_Msg msg, u32 parameter);

अटल व्योम ci_thermal_start_smc_fan_control(काष्ठा radeon_device *rdev);
अटल व्योम ci_fan_ctrl_set_शेष_mode(काष्ठा radeon_device *rdev);

अटल काष्ठा ci_घातer_info *ci_get_pi(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = rdev->pm.dpm.priv;

	वापस pi;
पूर्ण

अटल काष्ठा ci_ps *ci_get_ps(काष्ठा radeon_ps *rps)
अणु
	काष्ठा ci_ps *ps = rps->ps_priv;

	वापस ps;
पूर्ण

अटल व्योम ci_initialize_घातertune_शेषs(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	चयन (rdev->pdev->device) अणु
	हाल 0x6649:
	हाल 0x6650:
	हाल 0x6651:
	हाल 0x6658:
	हाल 0x665C:
	हाल 0x665D:
	शेष:
		pi->घातertune_शेषs = &शेषs_bonaire_xt;
		अवरोध;
	हाल 0x6640:
	हाल 0x6641:
	हाल 0x6646:
	हाल 0x6647:
		pi->घातertune_शेषs = &शेषs_saturn_xt;
		अवरोध;
	हाल 0x67B8:
	हाल 0x67B0:
		pi->घातertune_शेषs = &शेषs_hawaii_xt;
		अवरोध;
	हाल 0x67BA:
	हाल 0x67B1:
		pi->घातertune_शेषs = &शेषs_hawaii_pro;
		अवरोध;
	हाल 0x67A0:
	हाल 0x67A1:
	हाल 0x67A2:
	हाल 0x67A8:
	हाल 0x67A9:
	हाल 0x67AA:
	हाल 0x67B9:
	हाल 0x67BE:
		pi->घातertune_शेषs = &शेषs_bonaire_xt;
		अवरोध;
	पूर्ण

	pi->dte_tj_offset = 0;

	pi->caps_घातer_containment = true;
	pi->caps_cac = false;
	pi->caps_sq_ramping = false;
	pi->caps_db_ramping = false;
	pi->caps_td_ramping = false;
	pi->caps_tcp_ramping = false;

	अगर (pi->caps_घातer_containment) अणु
		pi->caps_cac = true;
		अगर (rdev->family == CHIP_HAWAII)
			pi->enable_bapm_feature = false;
		अन्यथा
			pi->enable_bapm_feature = true;
		pi->enable_tdc_limit_feature = true;
		pi->enable_pkg_pwr_tracking_feature = true;
	पूर्ण
पूर्ण

अटल u8 ci_convert_to_vid(u16 vddc)
अणु
	वापस (6200 - (vddc * VOLTAGE_SCALE)) / 25;
पूर्ण

अटल पूर्णांक ci_populate_bapm_vddc_vid_sidd(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u8 *hi_vid = pi->smc_घातertune_table.BapmVddCVidHiSidd;
	u8 *lo_vid = pi->smc_घातertune_table.BapmVddCVidLoSidd;
	u8 *hi2_vid = pi->smc_घातertune_table.BapmVddCVidHiSidd2;
	u32 i;

	अगर (rdev->pm.dpm.dyn_state.cac_leakage_table.entries == शून्य)
		वापस -EINVAL;
	अगर (rdev->pm.dpm.dyn_state.cac_leakage_table.count > 8)
		वापस -EINVAL;
	अगर (rdev->pm.dpm.dyn_state.cac_leakage_table.count !=
	    rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count)
		वापस -EINVAL;

	क्रम (i = 0; i < rdev->pm.dpm.dyn_state.cac_leakage_table.count; i++) अणु
		अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_EVV) अणु
			lo_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1);
			hi_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2);
			hi2_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3);
		पूर्ण अन्यथा अणु
			lo_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc);
			hi_vid[i] = ci_convert_to_vid((u16)rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage);
		पूर्ण
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_vddc_vid(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u8 *vid = pi->smc_घातertune_table.VddCVid;
	u32 i;

	अगर (pi->vddc_voltage_table.count > 8)
		वापस -EINVAL;

	क्रम (i = 0; i < pi->vddc_voltage_table.count; i++)
		vid[i] = ci_convert_to_vid(pi->vddc_voltage_table.entries[i].value);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_svi_load_line(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा ci_pt_शेषs *pt_शेषs = pi->घातertune_शेषs;

	pi->smc_घातertune_table.SviLoadLineEn = pt_शेषs->svi_load_line_en;
	pi->smc_घातertune_table.SviLoadLineVddC = pt_शेषs->svi_load_line_vddc;
	pi->smc_घातertune_table.SviLoadLineTrimVddC = 3;
	pi->smc_घातertune_table.SviLoadLineOffsetVddC = 0;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_tdc_limit(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा ci_pt_शेषs *pt_शेषs = pi->घातertune_शेषs;
	u16 tdc_limit;

	tdc_limit = rdev->pm.dpm.dyn_state.cac_tdp_table->tdc * 256;
	pi->smc_घातertune_table.TDC_VDDC_PkgLimit = cpu_to_be16(tdc_limit);
	pi->smc_घातertune_table.TDC_VDDC_ThrottleReleaseLimitPerc =
		pt_शेषs->tdc_vddc_throttle_release_limit_perc;
	pi->smc_घातertune_table.TDC_MAWt = pt_शेषs->tdc_mawt;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_dw8(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा ci_pt_शेषs *pt_शेषs = pi->घातertune_शेषs;
	पूर्णांक ret;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, PmFuseTable) +
				     दुरत्व(SMU7_Discrete_PmFuses, TdcWaterfallCtl),
				     (u32 *)&pi->smc_घातertune_table.TdcWaterfallCtl,
				     pi->sram_end);
	अगर (ret)
		वापस -EINVAL;
	अन्यथा
		pi->smc_घातertune_table.TdcWaterfallCtl = pt_शेषs->tdc_waterfall_ctl;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_fuzzy_fan(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर ((rdev->pm.dpm.fan.fan_output_sensitivity & (1 << 15)) ||
	    (rdev->pm.dpm.fan.fan_output_sensitivity == 0))
		rdev->pm.dpm.fan.fan_output_sensitivity =
			rdev->pm.dpm.fan.शेष_fan_output_sensitivity;

	pi->smc_घातertune_table.FuzzyFan_PwmSetDelta =
		cpu_to_be16(rdev->pm.dpm.fan.fan_output_sensitivity);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u8 *hi_vid = pi->smc_घातertune_table.BapmVddCVidHiSidd;
	u8 *lo_vid = pi->smc_घातertune_table.BapmVddCVidLoSidd;
	पूर्णांक i, min, max;

	min = max = hi_vid[0];
	क्रम (i = 0; i < 8; i++) अणु
		अगर (0 != hi_vid[i]) अणु
			अगर (min > hi_vid[i])
				min = hi_vid[i];
			अगर (max < hi_vid[i])
				max = hi_vid[i];
		पूर्ण

		अगर (0 != lo_vid[i]) अणु
			अगर (min > lo_vid[i])
				min = lo_vid[i];
			अगर (max < lo_vid[i])
				max = lo_vid[i];
		पूर्ण
	पूर्ण

	अगर ((min == 0) || (max == 0))
		वापस -EINVAL;
	pi->smc_घातertune_table.GnbLPMLMaxVid = (u8)max;
	pi->smc_घातertune_table.GnbLPMLMinVid = (u8)min;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_bapm_vddc_base_leakage_sidd(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u16 hi_sidd = pi->smc_घातertune_table.BapmVddCBaseLeakageHiSidd;
	u16 lo_sidd = pi->smc_घातertune_table.BapmVddCBaseLeakageLoSidd;
	काष्ठा radeon_cac_tdp_table *cac_tdp_table =
		rdev->pm.dpm.dyn_state.cac_tdp_table;

	hi_sidd = cac_tdp_table->high_cac_leakage / 100 * 256;
	lo_sidd = cac_tdp_table->low_cac_leakage / 100 * 256;

	pi->smc_घातertune_table.BapmVddCBaseLeakageHiSidd = cpu_to_be16(hi_sidd);
	pi->smc_घातertune_table.BapmVddCBaseLeakageLoSidd = cpu_to_be16(lo_sidd);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_bapm_parameters_in_dpm_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा ci_pt_शेषs *pt_शेषs = pi->घातertune_शेषs;
	SMU7_Discrete_DpmTable  *dpm_table = &pi->smc_state_table;
	काष्ठा radeon_cac_tdp_table *cac_tdp_table =
		rdev->pm.dpm.dyn_state.cac_tdp_table;
	काष्ठा radeon_ppm_table *ppm = rdev->pm.dpm.dyn_state.ppm_table;
	पूर्णांक i, j, k;
	स्थिर u16 *def1;
	स्थिर u16 *def2;

	dpm_table->DefaultTdp = cac_tdp_table->tdp * 256;
	dpm_table->TargetTdp = cac_tdp_table->configurable_tdp * 256;

	dpm_table->DTETjOffset = (u8)pi->dte_tj_offset;
	dpm_table->GpuTjMax =
		(u8)(pi->thermal_temp_setting.temperature_high / 1000);
	dpm_table->GpuTjHyst = 8;

	dpm_table->DTEAmbientTempBase = pt_शेषs->dte_ambient_temp_base;

	अगर (ppm) अणु
		dpm_table->PPM_PkgPwrLimit = cpu_to_be16((u16)ppm->dgpu_tdp * 256 / 1000);
		dpm_table->PPM_TemperatureLimit = cpu_to_be16((u16)ppm->tj_max * 256);
	पूर्ण अन्यथा अणु
		dpm_table->PPM_PkgPwrLimit = cpu_to_be16(0);
		dpm_table->PPM_TemperatureLimit = cpu_to_be16(0);
	पूर्ण

	dpm_table->BAPM_TEMP_GRADIENT = cpu_to_be32(pt_शेषs->bapm_temp_gradient);
	def1 = pt_शेषs->bapmti_r;
	def2 = pt_शेषs->bapmti_rc;

	क्रम (i = 0; i < SMU7_DTE_ITERATIONS; i++) अणु
		क्रम (j = 0; j < SMU7_DTE_SOURCES; j++) अणु
			क्रम (k = 0; k < SMU7_DTE_SINKS; k++) अणु
				dpm_table->BAPMTI_R[i][j][k] = cpu_to_be16(*def1);
				dpm_table->BAPMTI_RC[i][j][k] = cpu_to_be16(*def2);
				def1++;
				def2++;
			पूर्ण
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_pm_base(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 pm_fuse_table_offset;
	पूर्णांक ret;

	अगर (pi->caps_घातer_containment) अणु
		ret = ci_पढ़ो_smc_sram_dword(rdev,
					     SMU7_FIRMWARE_HEADER_LOCATION +
					     दुरत्व(SMU7_Firmware_Header, PmFuseTable),
					     &pm_fuse_table_offset, pi->sram_end);
		अगर (ret)
			वापस ret;
		ret = ci_populate_bapm_vddc_vid_sidd(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_vddc_vid(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_svi_load_line(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_tdc_limit(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_dw8(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_fuzzy_fan(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_populate_bapm_vddc_base_leakage_sidd(rdev);
		अगर (ret)
			वापस ret;
		ret = ci_copy_bytes_to_smc(rdev, pm_fuse_table_offset,
					   (u8 *)&pi->smc_घातertune_table,
					   माप(SMU7_Discrete_PmFuses), pi->sram_end);
		अगर (ret)
			वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ci_करो_enable_didt(काष्ठा radeon_device *rdev, स्थिर bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 data;

	अगर (pi->caps_sq_ramping) अणु
		data = RREG32_DIDT(DIDT_SQ_CTRL0);
		अगर (enable)
			data |= DIDT_CTRL_EN;
		अन्यथा
			data &= ~DIDT_CTRL_EN;
		WREG32_DIDT(DIDT_SQ_CTRL0, data);
	पूर्ण

	अगर (pi->caps_db_ramping) अणु
		data = RREG32_DIDT(DIDT_DB_CTRL0);
		अगर (enable)
			data |= DIDT_CTRL_EN;
		अन्यथा
			data &= ~DIDT_CTRL_EN;
		WREG32_DIDT(DIDT_DB_CTRL0, data);
	पूर्ण

	अगर (pi->caps_td_ramping) अणु
		data = RREG32_DIDT(DIDT_TD_CTRL0);
		अगर (enable)
			data |= DIDT_CTRL_EN;
		अन्यथा
			data &= ~DIDT_CTRL_EN;
		WREG32_DIDT(DIDT_TD_CTRL0, data);
	पूर्ण

	अगर (pi->caps_tcp_ramping) अणु
		data = RREG32_DIDT(DIDT_TCP_CTRL0);
		अगर (enable)
			data |= DIDT_CTRL_EN;
		अन्यथा
			data &= ~DIDT_CTRL_EN;
		WREG32_DIDT(DIDT_TCP_CTRL0, data);
	पूर्ण
पूर्ण

अटल पूर्णांक ci_program_pt_config_रेजिस्टरs(काष्ठा radeon_device *rdev,
					  स्थिर काष्ठा ci_pt_config_reg *cac_config_regs)
अणु
	स्थिर काष्ठा ci_pt_config_reg *config_regs = cac_config_regs;
	u32 data;
	u32 cache = 0;

	अगर (config_regs == शून्य)
		वापस -EINVAL;

	जबतक (config_regs->offset != 0xFFFFFFFF) अणु
		अगर (config_regs->type == CISLANDS_CONFIGREG_CACHE) अणु
			cache |= ((config_regs->value << config_regs->shअगरt) & config_regs->mask);
		पूर्ण अन्यथा अणु
			चयन (config_regs->type) अणु
			हाल CISLANDS_CONFIGREG_SMC_IND:
				data = RREG32_SMC(config_regs->offset);
				अवरोध;
			हाल CISLANDS_CONFIGREG_DIDT_IND:
				data = RREG32_DIDT(config_regs->offset);
				अवरोध;
			शेष:
				data = RREG32(config_regs->offset << 2);
				अवरोध;
			पूर्ण

			data &= ~config_regs->mask;
			data |= ((config_regs->value << config_regs->shअगरt) & config_regs->mask);
			data |= cache;

			चयन (config_regs->type) अणु
			हाल CISLANDS_CONFIGREG_SMC_IND:
				WREG32_SMC(config_regs->offset, data);
				अवरोध;
			हाल CISLANDS_CONFIGREG_DIDT_IND:
				WREG32_DIDT(config_regs->offset, data);
				अवरोध;
			शेष:
				WREG32(config_regs->offset << 2, data);
				अवरोध;
			पूर्ण
			cache = 0;
		पूर्ण
		config_regs++;
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ci_enable_didt(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;

	अगर (pi->caps_sq_ramping || pi->caps_db_ramping ||
	    pi->caps_td_ramping || pi->caps_tcp_ramping) अणु
		cik_enter_rlc_safe_mode(rdev);

		अगर (enable) अणु
			ret = ci_program_pt_config_रेजिस्टरs(rdev, didt_config_ci);
			अगर (ret) अणु
				cik_निकास_rlc_safe_mode(rdev);
				वापस ret;
			पूर्ण
		पूर्ण

		ci_करो_enable_didt(rdev, enable);

		cik_निकास_rlc_safe_mode(rdev);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_enable_घातer_containment(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;
	पूर्णांक ret = 0;

	अगर (enable) अणु
		pi->घातer_containment_features = 0;
		अगर (pi->caps_घातer_containment) अणु
			अगर (pi->enable_bapm_feature) अणु
				smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableDTE);
				अगर (smc_result != PPSMC_Result_OK)
					ret = -EINVAL;
				अन्यथा
					pi->घातer_containment_features |= POWERCONTAINMENT_FEATURE_BAPM;
			पूर्ण

			अगर (pi->enable_tdc_limit_feature) अणु
				smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_TDCLimitEnable);
				अगर (smc_result != PPSMC_Result_OK)
					ret = -EINVAL;
				अन्यथा
					pi->घातer_containment_features |= POWERCONTAINMENT_FEATURE_TDCLimit;
			पूर्ण

			अगर (pi->enable_pkg_pwr_tracking_feature) अणु
				smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PkgPwrLimitEnable);
				अगर (smc_result != PPSMC_Result_OK) अणु
					ret = -EINVAL;
				पूर्ण अन्यथा अणु
					काष्ठा radeon_cac_tdp_table *cac_tdp_table =
						rdev->pm.dpm.dyn_state.cac_tdp_table;
					u32 शेष_pwr_limit =
						(u32)(cac_tdp_table->maximum_घातer_delivery_limit * 256);

					pi->घातer_containment_features |= POWERCONTAINMENT_FEATURE_PkgPwrLimit;

					ci_set_घातer_limit(rdev, शेष_pwr_limit);
				पूर्ण
			पूर्ण
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (pi->caps_घातer_containment && pi->घातer_containment_features) अणु
			अगर (pi->घातer_containment_features & POWERCONTAINMENT_FEATURE_TDCLimit)
				ci_send_msg_to_smc(rdev, PPSMC_MSG_TDCLimitDisable);

			अगर (pi->घातer_containment_features & POWERCONTAINMENT_FEATURE_BAPM)
				ci_send_msg_to_smc(rdev, PPSMC_MSG_DisableDTE);

			अगर (pi->घातer_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit)
				ci_send_msg_to_smc(rdev, PPSMC_MSG_PkgPwrLimitDisable);
			pi->घातer_containment_features = 0;
		पूर्ण
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_enable_smc_cac(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;
	पूर्णांक ret = 0;

	अगर (pi->caps_cac) अणु
		अगर (enable) अणु
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableCac);
			अगर (smc_result != PPSMC_Result_OK) अणु
				ret = -EINVAL;
				pi->cac_enabled = false;
			पूर्ण अन्यथा अणु
				pi->cac_enabled = true;
			पूर्ण
		पूर्ण अन्यथा अगर (pi->cac_enabled) अणु
			ci_send_msg_to_smc(rdev, PPSMC_MSG_DisableCac);
			pi->cac_enabled = false;
		पूर्ण
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_enable_thermal_based_sclk_dpm(काष्ठा radeon_device *rdev,
					    bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result = PPSMC_Result_OK;

	अगर (pi->thermal_sclk_dpm_enabled) अणु
		अगर (enable)
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_ENABLE_THERMAL_DPM);
		अन्यथा
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DISABLE_THERMAL_DPM);
	पूर्ण

	अगर (smc_result == PPSMC_Result_OK)
		वापस 0;
	अन्यथा
		वापस -EINVAL;
पूर्ण

अटल पूर्णांक ci_घातer_control_set_level(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_cac_tdp_table *cac_tdp_table =
		rdev->pm.dpm.dyn_state.cac_tdp_table;
	s32 adjust_percent;
	s32 target_tdp;
	पूर्णांक ret = 0;
	bool adjust_polarity = false; /* ??? */

	अगर (pi->caps_घातer_containment) अणु
		adjust_percent = adjust_polarity ?
			rdev->pm.dpm.tdp_adjusपंचांगent : (-1 * rdev->pm.dpm.tdp_adjusपंचांगent);
		target_tdp = ((100 + adjust_percent) *
			      (s32)cac_tdp_table->configurable_tdp) / 100;

		ret = ci_set_overdrive_target_tdp(rdev, (u32)target_tdp);
	पूर्ण

	वापस ret;
पूर्ण

व्योम ci_dpm_घातergate_uvd(काष्ठा radeon_device *rdev, bool gate)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (pi->uvd_घातer_gated == gate)
		वापस;

	pi->uvd_घातer_gated = gate;

	ci_update_uvd_dpm(rdev, gate);
पूर्ण

bool ci_dpm_vblank_too_लघु(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 vblank_समय = r600_dpm_get_vblank_समय(rdev);
	u32 चयन_limit = pi->mem_gddr5 ? 450 : 300;

	/* disable mclk चयनing अगर the refresh is >120Hz, even अगर the
        * blanking period would allow it
        */
	अगर (r600_dpm_get_vrefresh(rdev) > 120)
		वापस true;

	अगर (vblank_समय < चयन_limit)
		वापस true;
	अन्यथा
		वापस false;

पूर्ण

अटल व्योम ci_apply_state_adjust_rules(काष्ठा radeon_device *rdev,
					काष्ठा radeon_ps *rps)
अणु
	काष्ठा ci_ps *ps = ci_get_ps(rps);
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	bool disable_mclk_चयनing;
	u32 sclk, mclk;
	पूर्णांक i;

	अगर (rps->vce_active) अणु
		rps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;
		rps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;
	पूर्ण अन्यथा अणु
		rps->evclk = 0;
		rps->ecclk = 0;
	पूर्ण

	अगर ((rdev->pm.dpm.new_active_crtc_count > 1) ||
	    ci_dpm_vblank_too_लघु(rdev))
		disable_mclk_चयनing = true;
	अन्यथा
		disable_mclk_चयनing = false;

	अगर ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)
		pi->battery_state = true;
	अन्यथा
		pi->battery_state = false;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (rdev->pm.dpm.ac_घातer == false) अणु
		क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
			अगर (ps->perक्रमmance_levels[i].mclk > max_limits->mclk)
				ps->perक्रमmance_levels[i].mclk = max_limits->mclk;
			अगर (ps->perक्रमmance_levels[i].sclk > max_limits->sclk)
				ps->perक्रमmance_levels[i].sclk = max_limits->sclk;
		पूर्ण
	पूर्ण

	/* XXX validate the min घड़ीs required क्रम display */

	अगर (disable_mclk_चयनing) अणु
		mclk  = ps->perक्रमmance_levels[ps->perक्रमmance_level_count - 1].mclk;
		sclk = ps->perक्रमmance_levels[0].sclk;
	पूर्ण अन्यथा अणु
		mclk = ps->perक्रमmance_levels[0].mclk;
		sclk = ps->perक्रमmance_levels[0].sclk;
	पूर्ण

	अगर (rps->vce_active) अणु
		अगर (sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)
			sclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;
		अगर (mclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk)
			mclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk;
	पूर्ण

	ps->perक्रमmance_levels[0].sclk = sclk;
	ps->perक्रमmance_levels[0].mclk = mclk;

	अगर (ps->perक्रमmance_levels[1].sclk < ps->perक्रमmance_levels[0].sclk)
		ps->perक्रमmance_levels[1].sclk = ps->perक्रमmance_levels[0].sclk;

	अगर (disable_mclk_चयनing) अणु
		अगर (ps->perक्रमmance_levels[0].mclk < ps->perक्रमmance_levels[1].mclk)
			ps->perक्रमmance_levels[0].mclk = ps->perक्रमmance_levels[1].mclk;
	पूर्ण अन्यथा अणु
		अगर (ps->perक्रमmance_levels[1].mclk < ps->perक्रमmance_levels[0].mclk)
			ps->perक्रमmance_levels[1].mclk = ps->perक्रमmance_levels[0].mclk;
	पूर्ण
पूर्ण

अटल पूर्णांक ci_thermal_set_temperature_range(काष्ठा radeon_device *rdev,
					    पूर्णांक min_temp, पूर्णांक max_temp)
अणु
	पूर्णांक low_temp = 0 * 1000;
	पूर्णांक high_temp = 255 * 1000;
	u32 पंचांगp;

	अगर (low_temp < min_temp)
		low_temp = min_temp;
	अगर (high_temp > max_temp)
		high_temp = max_temp;
	अगर (high_temp < low_temp) अणु
		DRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);
		वापस -EINVAL;
	पूर्ण

	पंचांगp = RREG32_SMC(CG_THERMAL_INT);
	पंचांगp &= ~(CI_DIG_THERM_INTH_MASK | CI_DIG_THERM_INTL_MASK);
	पंचांगp |= CI_DIG_THERM_INTH(high_temp / 1000) |
		CI_DIG_THERM_INTL(low_temp / 1000);
	WREG32_SMC(CG_THERMAL_INT, पंचांगp);

#अगर 0
	/* XXX: need to figure out how to handle this properly */
	पंचांगp = RREG32_SMC(CG_THERMAL_CTRL);
	पंचांगp &= DIG_THERM_DPM_MASK;
	पंचांगp |= DIG_THERM_DPM(high_temp / 1000);
	WREG32_SMC(CG_THERMAL_CTRL, पंचांगp);
#पूर्ण_अगर

	rdev->pm.dpm.thermal.min_temp = low_temp;
	rdev->pm.dpm.thermal.max_temp = high_temp;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_thermal_enable_alert(काष्ठा radeon_device *rdev,
				   bool enable)
अणु
	u32 thermal_पूर्णांक = RREG32_SMC(CG_THERMAL_INT);
	PPSMC_Result result;

	अगर (enable) अणु
		thermal_पूर्णांक &= ~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);
		WREG32_SMC(CG_THERMAL_INT, thermal_पूर्णांक);
		rdev->irq.dpm_thermal = false;
		result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Thermal_Cntl_Enable);
		अगर (result != PPSMC_Result_OK) अणु
			DRM_DEBUG_KMS("Could not enable thermal interrupts.\n");
			वापस -EINVAL;
		पूर्ण
	पूर्ण अन्यथा अणु
		thermal_पूर्णांक |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;
		WREG32_SMC(CG_THERMAL_INT, thermal_पूर्णांक);
		rdev->irq.dpm_thermal = true;
		result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Thermal_Cntl_Disable);
		अगर (result != PPSMC_Result_OK) अणु
			DRM_DEBUG_KMS("Could not disable thermal interrupts.\n");
			वापस -EINVAL;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ci_fan_ctrl_set_अटल_mode(काष्ठा radeon_device *rdev, u32 mode)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (pi->fan_ctrl_is_in_शेष_mode) अणु
		पंचांगp = (RREG32_SMC(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK) >> FDO_PWM_MODE_SHIFT;
		pi->fan_ctrl_शेष_mode = पंचांगp;
		पंचांगp = (RREG32_SMC(CG_FDO_CTRL2) & TMIN_MASK) >> TMIN_SHIFT;
		pi->t_min = पंचांगp;
		pi->fan_ctrl_is_in_शेष_mode = false;
	पूर्ण

	पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & ~TMIN_MASK;
	पंचांगp |= TMIN(0);
	WREG32_SMC(CG_FDO_CTRL2, पंचांगp);

	पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;
	पंचांगp |= FDO_PWM_MODE(mode);
	WREG32_SMC(CG_FDO_CTRL2, पंचांगp);
पूर्ण

अटल पूर्णांक ci_thermal_setup_fan_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	SMU7_Discrete_FanTable fan_table = अणु FDO_MODE_HARDWARE पूर्ण;
	u32 duty100;
	u32 t_dअगरf1, t_dअगरf2, pwm_dअगरf1, pwm_dअगरf2;
	u16 fकरो_min, slope1, slope2;
	u32 reference_घड़ी, पंचांगp;
	पूर्णांक ret;
	u64 पंचांगp64;

	अगर (!pi->fan_table_start) अणु
		rdev->pm.dpm.fan.ucode_fan_control = false;
		वापस 0;
	पूर्ण

	duty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;

	अगर (duty100 == 0) अणु
		rdev->pm.dpm.fan.ucode_fan_control = false;
		वापस 0;
	पूर्ण

	पंचांगp64 = (u64)rdev->pm.dpm.fan.pwm_min * duty100;
	करो_भाग(पंचांगp64, 10000);
	fकरो_min = (u16)पंचांगp64;

	t_dअगरf1 = rdev->pm.dpm.fan.t_med - rdev->pm.dpm.fan.t_min;
	t_dअगरf2 = rdev->pm.dpm.fan.t_high - rdev->pm.dpm.fan.t_med;

	pwm_dअगरf1 = rdev->pm.dpm.fan.pwm_med - rdev->pm.dpm.fan.pwm_min;
	pwm_dअगरf2 = rdev->pm.dpm.fan.pwm_high - rdev->pm.dpm.fan.pwm_med;

	slope1 = (u16)((50 + ((16 * duty100 * pwm_dअगरf1) / t_dअगरf1)) / 100);
	slope2 = (u16)((50 + ((16 * duty100 * pwm_dअगरf2) / t_dअगरf2)) / 100);

	fan_table.TempMin = cpu_to_be16((50 + rdev->pm.dpm.fan.t_min) / 100);
	fan_table.TempMed = cpu_to_be16((50 + rdev->pm.dpm.fan.t_med) / 100);
	fan_table.TempMax = cpu_to_be16((50 + rdev->pm.dpm.fan.t_max) / 100);

	fan_table.Slope1 = cpu_to_be16(slope1);
	fan_table.Slope2 = cpu_to_be16(slope2);

	fan_table.FकरोMin = cpu_to_be16(fकरो_min);

	fan_table.HystDown = cpu_to_be16(rdev->pm.dpm.fan.t_hyst);

	fan_table.HystUp = cpu_to_be16(1);

	fan_table.HystSlope = cpu_to_be16(1);

	fan_table.TempRespLim = cpu_to_be16(5);

	reference_घड़ी = radeon_get_xclk(rdev);

	fan_table.RefreshPeriod = cpu_to_be32((rdev->pm.dpm.fan.cycle_delay *
					       reference_घड़ी) / 1600);

	fan_table.FकरोMax = cpu_to_be16((u16)duty100);

	पंचांगp = (RREG32_SMC(CG_MULT_THERMAL_CTRL) & TEMP_SEL_MASK) >> TEMP_SEL_SHIFT;
	fan_table.TempSrc = (uपूर्णांक8_t)पंचांगp;

	ret = ci_copy_bytes_to_smc(rdev,
				   pi->fan_table_start,
				   (u8 *)(&fan_table),
				   माप(fan_table),
				   pi->sram_end);

	अगर (ret) अणु
		DRM_ERROR("Failed to load fan table to the SMC.");
		rdev->pm.dpm.fan.ucode_fan_control = false;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_fan_ctrl_start_smc_fan_control(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result ret;

	अगर (pi->caps_od_fuzzy_fan_control_support) अणु
		ret = ci_send_msg_to_smc_with_parameter(rdev,
							PPSMC_StartFanControl,
							FAN_CONTROL_FUZZY);
		अगर (ret != PPSMC_Result_OK)
			वापस -EINVAL;
		ret = ci_send_msg_to_smc_with_parameter(rdev,
							PPSMC_MSG_SetFanPwmMax,
							rdev->pm.dpm.fan.शेष_max_fan_pwm);
		अगर (ret != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण अन्यथा अणु
		ret = ci_send_msg_to_smc_with_parameter(rdev,
							PPSMC_StartFanControl,
							FAN_CONTROL_TABLE);
		अगर (ret != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	pi->fan_is_controlled_by_smc = true;
	वापस 0;
पूर्ण

अटल पूर्णांक ci_fan_ctrl_stop_smc_fan_control(काष्ठा radeon_device *rdev)
अणु
	PPSMC_Result ret;
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	ret = ci_send_msg_to_smc(rdev, PPSMC_StopFanControl);
	अगर (ret == PPSMC_Result_OK) अणु
		pi->fan_is_controlled_by_smc = false;
		वापस 0;
	पूर्ण अन्यथा
		वापस -EINVAL;
पूर्ण

पूर्णांक ci_fan_ctrl_get_fan_speed_percent(काष्ठा radeon_device *rdev,
					     u32 *speed)
अणु
	u32 duty, duty100;
	u64 पंचांगp64;

	अगर (rdev->pm.no_fan)
		वापस -ENOENT;

	duty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;
	duty = (RREG32_SMC(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;

	अगर (duty100 == 0)
		वापस -EINVAL;

	पंचांगp64 = (u64)duty * 100;
	करो_भाग(पंचांगp64, duty100);
	*speed = (u32)पंचांगp64;

	अगर (*speed > 100)
		*speed = 100;

	वापस 0;
पूर्ण

पूर्णांक ci_fan_ctrl_set_fan_speed_percent(काष्ठा radeon_device *rdev,
					     u32 speed)
अणु
	u32 पंचांगp;
	u32 duty, duty100;
	u64 पंचांगp64;
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (rdev->pm.no_fan)
		वापस -ENOENT;

	अगर (pi->fan_is_controlled_by_smc)
		वापस -EINVAL;

	अगर (speed > 100)
		वापस -EINVAL;

	duty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;

	अगर (duty100 == 0)
		वापस -EINVAL;

	पंचांगp64 = (u64)speed * duty100;
	करो_भाग(पंचांगp64, 100);
	duty = (u32)पंचांगp64;

	पंचांगp = RREG32_SMC(CG_FDO_CTRL0) & ~FDO_STATIC_DUTY_MASK;
	पंचांगp |= FDO_STATIC_DUTY(duty);
	WREG32_SMC(CG_FDO_CTRL0, पंचांगp);

	वापस 0;
पूर्ण

व्योम ci_fan_ctrl_set_mode(काष्ठा radeon_device *rdev, u32 mode)
अणु
	अगर (mode) अणु
		/* stop स्वतः-manage */
		अगर (rdev->pm.dpm.fan.ucode_fan_control)
			ci_fan_ctrl_stop_smc_fan_control(rdev);
		ci_fan_ctrl_set_अटल_mode(rdev, mode);
	पूर्ण अन्यथा अणु
		/* restart स्वतः-manage */
		अगर (rdev->pm.dpm.fan.ucode_fan_control)
			ci_thermal_start_smc_fan_control(rdev);
		अन्यथा
			ci_fan_ctrl_set_शेष_mode(rdev);
	पूर्ण
पूर्ण

u32 ci_fan_ctrl_get_mode(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (pi->fan_is_controlled_by_smc)
		वापस 0;

	पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK;
	वापस (पंचांगp >> FDO_PWM_MODE_SHIFT);
पूर्ण

#अगर 0
अटल पूर्णांक ci_fan_ctrl_get_fan_speed_rpm(काष्ठा radeon_device *rdev,
					 u32 *speed)
अणु
	u32 tach_period;
	u32 xclk = radeon_get_xclk(rdev);

	अगर (rdev->pm.no_fan)
		वापस -ENOENT;

	अगर (rdev->pm.fan_pulses_per_revolution == 0)
		वापस -ENOENT;

	tach_period = (RREG32_SMC(CG_TACH_STATUS) & TACH_PERIOD_MASK) >> TACH_PERIOD_SHIFT;
	अगर (tach_period == 0)
		वापस -ENOENT;

	*speed = 60 * xclk * 10000 / tach_period;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_fan_ctrl_set_fan_speed_rpm(काष्ठा radeon_device *rdev,
					 u32 speed)
अणु
	u32 tach_period, पंचांगp;
	u32 xclk = radeon_get_xclk(rdev);

	अगर (rdev->pm.no_fan)
		वापस -ENOENT;

	अगर (rdev->pm.fan_pulses_per_revolution == 0)
		वापस -ENOENT;

	अगर ((speed < rdev->pm.fan_min_rpm) ||
	    (speed > rdev->pm.fan_max_rpm))
		वापस -EINVAL;

	अगर (rdev->pm.dpm.fan.ucode_fan_control)
		ci_fan_ctrl_stop_smc_fan_control(rdev);

	tach_period = 60 * xclk * 10000 / (8 * speed);
	पंचांगp = RREG32_SMC(CG_TACH_CTRL) & ~TARGET_PERIOD_MASK;
	पंचांगp |= TARGET_PERIOD(tach_period);
	WREG32_SMC(CG_TACH_CTRL, पंचांगp);

	ci_fan_ctrl_set_अटल_mode(rdev, FDO_PWM_MODE_STATIC_RPM);

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल व्योम ci_fan_ctrl_set_शेष_mode(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (!pi->fan_ctrl_is_in_शेष_mode) अणु
		पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;
		पंचांगp |= FDO_PWM_MODE(pi->fan_ctrl_शेष_mode);
		WREG32_SMC(CG_FDO_CTRL2, पंचांगp);

		पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & ~TMIN_MASK;
		पंचांगp |= TMIN(pi->t_min);
		WREG32_SMC(CG_FDO_CTRL2, पंचांगp);
		pi->fan_ctrl_is_in_शेष_mode = true;
	पूर्ण
पूर्ण

अटल व्योम ci_thermal_start_smc_fan_control(काष्ठा radeon_device *rdev)
अणु
	अगर (rdev->pm.dpm.fan.ucode_fan_control) अणु
		ci_fan_ctrl_start_smc_fan_control(rdev);
		ci_fan_ctrl_set_अटल_mode(rdev, FDO_PWM_MODE_STATIC);
	पूर्ण
पूर्ण

अटल व्योम ci_thermal_initialize(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp;

	अगर (rdev->pm.fan_pulses_per_revolution) अणु
		पंचांगp = RREG32_SMC(CG_TACH_CTRL) & ~EDGE_PER_REV_MASK;
		पंचांगp |= EDGE_PER_REV(rdev->pm.fan_pulses_per_revolution -1);
		WREG32_SMC(CG_TACH_CTRL, पंचांगp);
	पूर्ण

	पंचांगp = RREG32_SMC(CG_FDO_CTRL2) & ~TACH_PWM_RESP_RATE_MASK;
	पंचांगp |= TACH_PWM_RESP_RATE(0x28);
	WREG32_SMC(CG_FDO_CTRL2, पंचांगp);
पूर्ण

अटल पूर्णांक ci_thermal_start_thermal_controller(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक ret;

	ci_thermal_initialize(rdev);
	ret = ci_thermal_set_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);
	अगर (ret)
		वापस ret;
	ret = ci_thermal_enable_alert(rdev, true);
	अगर (ret)
		वापस ret;
	अगर (rdev->pm.dpm.fan.ucode_fan_control) अणु
		ret = ci_thermal_setup_fan_table(rdev);
		अगर (ret)
			वापस ret;
		ci_thermal_start_smc_fan_control(rdev);
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ci_thermal_stop_thermal_controller(काष्ठा radeon_device *rdev)
अणु
	अगर (!rdev->pm.no_fan)
		ci_fan_ctrl_set_शेष_mode(rdev);
पूर्ण

#अगर 0
अटल पूर्णांक ci_पढ़ो_smc_soft_रेजिस्टर(काष्ठा radeon_device *rdev,
				     u16 reg_offset, u32 *value)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	वापस ci_पढ़ो_smc_sram_dword(rdev,
				      pi->soft_regs_start + reg_offset,
				      value, pi->sram_end);
पूर्ण
#पूर्ण_अगर

अटल पूर्णांक ci_ग_लिखो_smc_soft_रेजिस्टर(काष्ठा radeon_device *rdev,
				      u16 reg_offset, u32 value)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	वापस ci_ग_लिखो_smc_sram_dword(rdev,
				       pi->soft_regs_start + reg_offset,
				       value, pi->sram_end);
पूर्ण

अटल व्योम ci_init_fps_limits(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	SMU7_Discrete_DpmTable *table = &pi->smc_state_table;

	अगर (pi->caps_fps) अणु
		u16 पंचांगp;

		पंचांगp = 45;
		table->FpsHighT = cpu_to_be16(पंचांगp);

		पंचांगp = 30;
		table->FpsLowT = cpu_to_be16(पंचांगp);
	पूर्ण
पूर्ण

अटल पूर्णांक ci_update_sclk_t(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret = 0;
	u32 low_sclk_पूर्णांकerrupt_t = 0;

	अगर (pi->caps_sclk_throttle_low_notअगरication) अणु
		low_sclk_पूर्णांकerrupt_t = cpu_to_be32(pi->low_sclk_पूर्णांकerrupt_t);

		ret = ci_copy_bytes_to_smc(rdev,
					   pi->dpm_table_start +
					   दुरत्व(SMU7_Discrete_DpmTable, LowSclkInterruptT),
					   (u8 *)&low_sclk_पूर्णांकerrupt_t,
					   माप(u32), pi->sram_end);

	पूर्ण

	वापस ret;
पूर्ण

अटल व्योम ci_get_leakage_voltages(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u16 leakage_id, भव_voltage_id;
	u16 vddc, vddci;
	पूर्णांक i;

	pi->vddc_leakage.count = 0;
	pi->vddci_leakage.count = 0;

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_EVV) अणु
		क्रम (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) अणु
			भव_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;
			अगर (radeon_atom_get_voltage_evv(rdev, भव_voltage_id, &vddc) != 0)
				जारी;
			अगर (vddc != 0 && vddc != भव_voltage_id) अणु
				pi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;
				pi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = भव_voltage_id;
				pi->vddc_leakage.count++;
			पूर्ण
		पूर्ण
	पूर्ण अन्यथा अगर (radeon_atom_get_leakage_id_from_vbios(rdev, &leakage_id) == 0) अणु
		क्रम (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) अणु
			भव_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;
			अगर (radeon_atom_get_leakage_vddc_based_on_leakage_params(rdev, &vddc, &vddci,
										 भव_voltage_id,
										 leakage_id) == 0) अणु
				अगर (vddc != 0 && vddc != भव_voltage_id) अणु
					pi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;
					pi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = भव_voltage_id;
					pi->vddc_leakage.count++;
				पूर्ण
				अगर (vddci != 0 && vddci != भव_voltage_id) अणु
					pi->vddci_leakage.actual_voltage[pi->vddci_leakage.count] = vddci;
					pi->vddci_leakage.leakage_id[pi->vddci_leakage.count] = भव_voltage_id;
					pi->vddci_leakage.count++;
				पूर्ण
			पूर्ण
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_set_dpm_event_sources(काष्ठा radeon_device *rdev, u32 sources)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	bool want_thermal_protection;
	u32 पंचांगp;

	चयन (sources) अणु
	हाल 0:
	शेष:
		want_thermal_protection = false;
		अवरोध;
	हाल (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):
		want_thermal_protection = true;
		अवरोध;
	हाल (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):
		want_thermal_protection = true;
		अवरोध;
	हाल ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |
	      (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):
		want_thermal_protection = true;
		अवरोध;
	पूर्ण

	अगर (want_thermal_protection) अणु
		पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
		अगर (pi->thermal_protection)
			पंचांगp &= ~THERMAL_PROTECTION_DIS;
		अन्यथा
			पंचांगp |= THERMAL_PROTECTION_DIS;
		WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
	पूर्ण अन्यथा अणु
		पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
		पंचांगp |= THERMAL_PROTECTION_DIS;
		WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
	पूर्ण
पूर्ण

अटल व्योम ci_enable_स्वतः_throttle_source(काष्ठा radeon_device *rdev,
					   क्रमागत radeon_dpm_स्वतः_throttle_src source,
					   bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (enable) अणु
		अगर (!(pi->active_स्वतः_throttle_sources & (1 << source))) अणु
			pi->active_स्वतः_throttle_sources |= 1 << source;
			ci_set_dpm_event_sources(rdev, pi->active_स्वतः_throttle_sources);
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (pi->active_स्वतः_throttle_sources & (1 << source)) अणु
			pi->active_स्वतः_throttle_sources &= ~(1 << source);
			ci_set_dpm_event_sources(rdev, pi->active_स्वतः_throttle_sources);
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_enable_vr_hot_gpio_पूर्णांकerrupt(काष्ठा radeon_device *rdev)
अणु
	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)
		ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableVRHotGPIOInterrupt);
पूर्ण

अटल पूर्णांक ci_unमुक्तze_sclk_mclk_dpm(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;

	अगर (!pi->need_update_smu7_dpm_table)
		वापस 0;

	अगर ((!pi->sclk_dpm_key_disabled) &&
	    (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_SCLKDPM_Unमुक्तzeLevel);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	अगर ((!pi->mclk_dpm_key_disabled) &&
	    (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_Unमुक्तzeLevel);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	pi->need_update_smu7_dpm_table = 0;
	वापस 0;
पूर्ण

अटल पूर्णांक ci_enable_sclk_mclk_dpm(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;

	अगर (enable) अणु
		अगर (!pi->sclk_dpm_key_disabled) अणु
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DPM_Enable);
			अगर (smc_result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण

		अगर (!pi->mclk_dpm_key_disabled) अणु
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_Enable);
			अगर (smc_result != PPSMC_Result_OK)
				वापस -EINVAL;

			WREG32_P(MC_SEQ_CNTL_3, CAC_EN, ~CAC_EN);

			WREG32_SMC(LCAC_MC0_CNTL, 0x05);
			WREG32_SMC(LCAC_MC1_CNTL, 0x05);
			WREG32_SMC(LCAC_CPL_CNTL, 0x100005);

			udelay(10);

			WREG32_SMC(LCAC_MC0_CNTL, 0x400005);
			WREG32_SMC(LCAC_MC1_CNTL, 0x400005);
			WREG32_SMC(LCAC_CPL_CNTL, 0x500005);
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (!pi->sclk_dpm_key_disabled) अणु
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DPM_Disable);
			अगर (smc_result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण

		अगर (!pi->mclk_dpm_key_disabled) अणु
			smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_Disable);
			अगर (smc_result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_start_dpm(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;
	पूर्णांक ret;
	u32 पंचांगp;

	पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
	पंचांगp |= GLOBAL_PWRMGT_EN;
	WREG32_SMC(GENERAL_PWRMGT, पंचांगp);

	पंचांगp = RREG32_SMC(SCLK_PWRMGT_CNTL);
	पंचांगp |= DYNAMIC_PM_EN;
	WREG32_SMC(SCLK_PWRMGT_CNTL, पंचांगp);

	ci_ग_लिखो_smc_soft_रेजिस्टर(rdev, दुरत्व(SMU7_SoftRegisters, VoltageChangeTimeout), 0x1000);

	WREG32_P(BIF_LNCNT_RESET, 0, ~RESET_LNCNT_EN);

	smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Voltage_Cntl_Enable);
	अगर (smc_result != PPSMC_Result_OK)
		वापस -EINVAL;

	ret = ci_enable_sclk_mclk_dpm(rdev, true);
	अगर (ret)
		वापस ret;

	अगर (!pi->pcie_dpm_key_disabled) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PCIeDPM_Enable);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_मुक्तze_sclk_mclk_dpm(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;

	अगर (!pi->need_update_smu7_dpm_table)
		वापस 0;

	अगर ((!pi->sclk_dpm_key_disabled) &&
	    (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_SCLKDPM_FreezeLevel);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	अगर ((!pi->mclk_dpm_key_disabled) &&
	    (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_FreezeLevel);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_stop_dpm(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result smc_result;
	पूर्णांक ret;
	u32 पंचांगp;

	पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
	पंचांगp &= ~GLOBAL_PWRMGT_EN;
	WREG32_SMC(GENERAL_PWRMGT, पंचांगp);

	पंचांगp = RREG32_SMC(SCLK_PWRMGT_CNTL);
	पंचांगp &= ~DYNAMIC_PM_EN;
	WREG32_SMC(SCLK_PWRMGT_CNTL, पंचांगp);

	अगर (!pi->pcie_dpm_key_disabled) अणु
		smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PCIeDPM_Disable);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	ret = ci_enable_sclk_mclk_dpm(rdev, false);
	अगर (ret)
		वापस ret;

	smc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Voltage_Cntl_Disable);
	अगर (smc_result != PPSMC_Result_OK)
		वापस -EINVAL;

	वापस 0;
पूर्ण

अटल व्योम ci_enable_sclk_control(काष्ठा radeon_device *rdev, bool enable)
अणु
	u32 पंचांगp = RREG32_SMC(SCLK_PWRMGT_CNTL);

	अगर (enable)
		पंचांगp &= ~SCLK_PWRMGT_OFF;
	अन्यथा
		पंचांगp |= SCLK_PWRMGT_OFF;
	WREG32_SMC(SCLK_PWRMGT_CNTL, पंचांगp);
पूर्ण

#अगर 0
अटल पूर्णांक ci_notअगरy_hw_of_घातer_source(काष्ठा radeon_device *rdev,
					bool ac_घातer)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_cac_tdp_table *cac_tdp_table =
		rdev->pm.dpm.dyn_state.cac_tdp_table;
	u32 घातer_limit;

	अगर (ac_घातer)
		घातer_limit = (u32)(cac_tdp_table->maximum_घातer_delivery_limit * 256);
	अन्यथा
		घातer_limit = (u32)(cac_tdp_table->battery_घातer_limit * 256);

	ci_set_घातer_limit(rdev, घातer_limit);

	अगर (pi->caps_स्वतःmatic_dc_transition) अणु
		अगर (ac_घातer)
			ci_send_msg_to_smc(rdev, PPSMC_MSG_RunningOnAC);
		अन्यथा
			ci_send_msg_to_smc(rdev, PPSMC_MSG_Remove_DC_Clamp);
	पूर्ण

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल PPSMC_Result ci_send_msg_to_smc(काष्ठा radeon_device *rdev, PPSMC_Msg msg)
अणु
	u32 पंचांगp;
	पूर्णांक i;

	अगर (!ci_is_smc_running(rdev))
		वापस PPSMC_Result_Failed;

	WREG32(SMC_MESSAGE_0, msg);

	क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
		पंचांगp = RREG32(SMC_RESP_0);
		अगर (पंचांगp != 0)
			अवरोध;
		udelay(1);
	पूर्ण
	पंचांगp = RREG32(SMC_RESP_0);

	वापस (PPSMC_Result)पंचांगp;
पूर्ण

अटल PPSMC_Result ci_send_msg_to_smc_with_parameter(काष्ठा radeon_device *rdev,
						      PPSMC_Msg msg, u32 parameter)
अणु
	WREG32(SMC_MSG_ARG_0, parameter);
	वापस ci_send_msg_to_smc(rdev, msg);
पूर्ण

अटल PPSMC_Result ci_send_msg_to_smc_वापस_parameter(काष्ठा radeon_device *rdev,
							PPSMC_Msg msg, u32 *parameter)
अणु
	PPSMC_Result smc_result;

	smc_result = ci_send_msg_to_smc(rdev, msg);

	अगर ((smc_result == PPSMC_Result_OK) && parameter)
		*parameter = RREG32(SMC_MSG_ARG_0);

	वापस smc_result;
पूर्ण

अटल पूर्णांक ci_dpm_क्रमce_state_sclk(काष्ठा radeon_device *rdev, u32 n)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (!pi->sclk_dpm_key_disabled) अणु
		PPSMC_Result smc_result =
			ci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SCLKDPM_SetEnabledMask, 1 << n);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_dpm_क्रमce_state_mclk(काष्ठा radeon_device *rdev, u32 n)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (!pi->mclk_dpm_key_disabled) अणु
		PPSMC_Result smc_result =
			ci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_MCLKDPM_SetEnabledMask, 1 << n);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_dpm_क्रमce_state_pcie(काष्ठा radeon_device *rdev, u32 n)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (!pi->pcie_dpm_key_disabled) अणु
		PPSMC_Result smc_result =
			ci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_PCIeDPM_ForceLevel, n);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_घातer_limit(काष्ठा radeon_device *rdev, u32 n)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (pi->घातer_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit) अणु
		PPSMC_Result smc_result =
			ci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_PkgPwrSetLimit, n);
		अगर (smc_result != PPSMC_Result_OK)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_overdrive_target_tdp(काष्ठा radeon_device *rdev,
				       u32 target_tdp)
अणु
	PPSMC_Result smc_result =
		ci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_OverDriveSetTargetTdp, target_tdp);
	अगर (smc_result != PPSMC_Result_OK)
		वापस -EINVAL;
	वापस 0;
पूर्ण

#अगर 0
अटल पूर्णांक ci_set_boot_state(काष्ठा radeon_device *rdev)
अणु
	वापस ci_enable_sclk_mclk_dpm(rdev, false);
पूर्ण
#पूर्ण_अगर

अटल u32 ci_get_average_sclk_freq(काष्ठा radeon_device *rdev)
अणु
	u32 sclk_freq;
	PPSMC_Result smc_result =
		ci_send_msg_to_smc_वापस_parameter(rdev,
						    PPSMC_MSG_API_GetSclkFrequency,
						    &sclk_freq);
	अगर (smc_result != PPSMC_Result_OK)
		sclk_freq = 0;

	वापस sclk_freq;
पूर्ण

अटल u32 ci_get_average_mclk_freq(काष्ठा radeon_device *rdev)
अणु
	u32 mclk_freq;
	PPSMC_Result smc_result =
		ci_send_msg_to_smc_वापस_parameter(rdev,
						    PPSMC_MSG_API_GetMclkFrequency,
						    &mclk_freq);
	अगर (smc_result != PPSMC_Result_OK)
		mclk_freq = 0;

	वापस mclk_freq;
पूर्ण

अटल व्योम ci_dpm_start_smc(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक i;

	ci_program_jump_on_start(rdev);
	ci_start_smc_घड़ी(rdev);
	ci_start_smc(rdev);
	क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
		अगर (RREG32_SMC(FIRMWARE_FLAGS) & INTERRUPTS_ENABLED)
			अवरोध;
	पूर्ण
पूर्ण

अटल व्योम ci_dpm_stop_smc(काष्ठा radeon_device *rdev)
अणु
	ci_reset_smc(rdev);
	ci_stop_smc_घड़ी(rdev);
पूर्ण

अटल पूर्णांक ci_process_firmware_header(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;
	पूर्णांक ret;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, DpmTable),
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	pi->dpm_table_start = पंचांगp;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, SoftRegisters),
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	pi->soft_regs_start = पंचांगp;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, mcRegisterTable),
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	pi->mc_reg_table_start = पंचांगp;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, FanTable),
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	pi->fan_table_start = पंचांगp;

	ret = ci_पढ़ो_smc_sram_dword(rdev,
				     SMU7_FIRMWARE_HEADER_LOCATION +
				     दुरत्व(SMU7_Firmware_Header, mcArbDramTimingTable),
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	pi->arb_table_start = पंचांगp;

	वापस 0;
पूर्ण

अटल व्योम ci_पढ़ो_घड़ी_रेजिस्टरs(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl =
		RREG32_SMC(CG_SPLL_FUNC_CNTL);
	pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2 =
		RREG32_SMC(CG_SPLL_FUNC_CNTL_2);
	pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3 =
		RREG32_SMC(CG_SPLL_FUNC_CNTL_3);
	pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4 =
		RREG32_SMC(CG_SPLL_FUNC_CNTL_4);
	pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum =
		RREG32_SMC(CG_SPLL_SPREAD_SPECTRUM);
	pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2 =
		RREG32_SMC(CG_SPLL_SPREAD_SPECTRUM_2);
	pi->घड़ी_रेजिस्टरs.dll_cntl = RREG32(DLL_CNTL);
	pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl = RREG32(MCLK_PWRMGT_CNTL);
	pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl = RREG32(MPLL_AD_FUNC_CNTL);
	pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl = RREG32(MPLL_DQ_FUNC_CNTL);
	pi->घड़ी_रेजिस्टरs.mpll_func_cntl = RREG32(MPLL_FUNC_CNTL);
	pi->घड़ी_रेजिस्टरs.mpll_func_cntl_1 = RREG32(MPLL_FUNC_CNTL_1);
	pi->घड़ी_रेजिस्टरs.mpll_func_cntl_2 = RREG32(MPLL_FUNC_CNTL_2);
	pi->घड़ी_रेजिस्टरs.mpll_ss1 = RREG32(MPLL_SS1);
	pi->घड़ी_रेजिस्टरs.mpll_ss2 = RREG32(MPLL_SS2);
पूर्ण

अटल व्योम ci_init_sclk_t(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	pi->low_sclk_पूर्णांकerrupt_t = 0;
पूर्ण

अटल व्योम ci_enable_thermal_protection(काष्ठा radeon_device *rdev,
					 bool enable)
अणु
	u32 पंचांगp = RREG32_SMC(GENERAL_PWRMGT);

	अगर (enable)
		पंचांगp &= ~THERMAL_PROTECTION_DIS;
	अन्यथा
		पंचांगp |= THERMAL_PROTECTION_DIS;
	WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
पूर्ण

अटल व्योम ci_enable_acpi_घातer_management(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp = RREG32_SMC(GENERAL_PWRMGT);

	पंचांगp |= STATIC_PM_EN;

	WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
पूर्ण

#अगर 0
अटल पूर्णांक ci_enter_ulp_state(काष्ठा radeon_device *rdev)
अणु

	WREG32(SMC_MESSAGE_0, PPSMC_MSG_SwitchToMinimumPower);

	udelay(25000);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_निकास_ulp_state(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक i;

	WREG32(SMC_MESSAGE_0, PPSMC_MSG_ResumeFromMinimumPower);

	udelay(7000);

	क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
		अगर (RREG32(SMC_RESP_0) == 1)
			अवरोध;
		udelay(1000);
	पूर्ण

	वापस 0;
पूर्ण
#पूर्ण_अगर

अटल पूर्णांक ci_notअगरy_smc_display_change(काष्ठा radeon_device *rdev,
					bool has_display)
अणु
	PPSMC_Msg msg = has_display ? PPSMC_MSG_HasDisplay : PPSMC_MSG_NoDisplay;

	वापस (ci_send_msg_to_smc(rdev, msg) == PPSMC_Result_OK) ?  0 : -EINVAL;
पूर्ण

अटल पूर्णांक ci_enable_ds_master_चयन(काष्ठा radeon_device *rdev,
				      bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (enable) अणु
		अगर (pi->caps_sclk_ds) अणु
			अगर (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_ON) != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण अन्यथा अणु
			अगर (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (pi->caps_sclk_ds) अणु
			अगर (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ci_program_display_gap(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp = RREG32_SMC(CG_DISPLAY_GAP_CNTL);
	u32 pre_vbi_समय_in_us;
	u32 frame_समय_in_us;
	u32 ref_घड़ी = rdev->घड़ी.spll.reference_freq;
	u32 refresh_rate = r600_dpm_get_vrefresh(rdev);
	u32 vblank_समय = r600_dpm_get_vblank_समय(rdev);

	पंचांगp &= ~DISP_GAP_MASK;
	अगर (rdev->pm.dpm.new_active_crtc_count > 0)
		पंचांगp |= DISP_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);
	अन्यथा
		पंचांगp |= DISP_GAP(R600_PM_DISPLAY_GAP_IGNORE);
	WREG32_SMC(CG_DISPLAY_GAP_CNTL, पंचांगp);

	अगर (refresh_rate == 0)
		refresh_rate = 60;
	अगर (vblank_समय == 0xffffffff)
		vblank_समय = 500;
	frame_समय_in_us = 1000000 / refresh_rate;
	pre_vbi_समय_in_us =
		frame_समय_in_us - 200 - vblank_समय;
	पंचांगp = pre_vbi_समय_in_us * (ref_घड़ी / 100);

	WREG32_SMC(CG_DISPLAY_GAP_CNTL2, पंचांगp);
	ci_ग_लिखो_smc_soft_रेजिस्टर(rdev, दुरत्व(SMU7_SoftRegisters, PreVBlankGap), 0x64);
	ci_ग_लिखो_smc_soft_रेजिस्टर(rdev, दुरत्व(SMU7_SoftRegisters, VBlankTimeout), (frame_समय_in_us - pre_vbi_समय_in_us));


	ci_notअगरy_smc_display_change(rdev, (rdev->pm.dpm.new_active_crtc_count == 1));

पूर्ण

अटल व्योम ci_enable_spपढ़ो_spectrum(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (enable) अणु
		अगर (pi->caps_sclk_ss_support) अणु
			पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
			पंचांगp |= DYN_SPREAD_SPECTRUM_EN;
			WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
		पूर्ण
	पूर्ण अन्यथा अणु
		पंचांगp = RREG32_SMC(CG_SPLL_SPREAD_SPECTRUM);
		पंचांगp &= ~SSEN;
		WREG32_SMC(CG_SPLL_SPREAD_SPECTRUM, पंचांगp);

		पंचांगp = RREG32_SMC(GENERAL_PWRMGT);
		पंचांगp &= ~DYN_SPREAD_SPECTRUM_EN;
		WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
	पूर्ण
पूर्ण

अटल व्योम ci_program_sstp(काष्ठा radeon_device *rdev)
अणु
	WREG32_SMC(CG_SSP, (SSTU(R600_SSTU_DFLT) | SST(R600_SST_DFLT)));
पूर्ण

अटल व्योम ci_enable_display_gap(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp = RREG32_SMC(CG_DISPLAY_GAP_CNTL);

	पंचांगp &= ~(DISP_GAP_MASK | DISP_GAP_MCHG_MASK);
	पंचांगp |= (DISP_GAP(R600_PM_DISPLAY_GAP_IGNORE) |
		DISP_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK));

	WREG32_SMC(CG_DISPLAY_GAP_CNTL, पंचांगp);
पूर्ण

अटल व्योम ci_program_vc(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp;

	पंचांगp = RREG32_SMC(SCLK_PWRMGT_CNTL);
	पंचांगp &= ~(RESET_SCLK_CNT | RESET_BUSY_CNT);
	WREG32_SMC(SCLK_PWRMGT_CNTL, पंचांगp);

	WREG32_SMC(CG_FTV_0, CISLANDS_VRC_DFLT0);
	WREG32_SMC(CG_FTV_1, CISLANDS_VRC_DFLT1);
	WREG32_SMC(CG_FTV_2, CISLANDS_VRC_DFLT2);
	WREG32_SMC(CG_FTV_3, CISLANDS_VRC_DFLT3);
	WREG32_SMC(CG_FTV_4, CISLANDS_VRC_DFLT4);
	WREG32_SMC(CG_FTV_5, CISLANDS_VRC_DFLT5);
	WREG32_SMC(CG_FTV_6, CISLANDS_VRC_DFLT6);
	WREG32_SMC(CG_FTV_7, CISLANDS_VRC_DFLT7);
पूर्ण

अटल व्योम ci_clear_vc(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp;

	पंचांगp = RREG32_SMC(SCLK_PWRMGT_CNTL);
	पंचांगp |= (RESET_SCLK_CNT | RESET_BUSY_CNT);
	WREG32_SMC(SCLK_PWRMGT_CNTL, पंचांगp);

	WREG32_SMC(CG_FTV_0, 0);
	WREG32_SMC(CG_FTV_1, 0);
	WREG32_SMC(CG_FTV_2, 0);
	WREG32_SMC(CG_FTV_3, 0);
	WREG32_SMC(CG_FTV_4, 0);
	WREG32_SMC(CG_FTV_5, 0);
	WREG32_SMC(CG_FTV_6, 0);
	WREG32_SMC(CG_FTV_7, 0);
पूर्ण

अटल पूर्णांक ci_upload_firmware(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक i, ret;

	क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
		अगर (RREG32_SMC(RCU_UC_EVENTS) & BOOT_SEQ_DONE)
			अवरोध;
	पूर्ण
	WREG32_SMC(SMC_SYSCON_MISC_CNTL, 1);

	ci_stop_smc_घड़ी(rdev);
	ci_reset_smc(rdev);

	ret = ci_load_smc_ucode(rdev, pi->sram_end);

	वापस ret;

पूर्ण

अटल पूर्णांक ci_get_svi2_voltage_table(काष्ठा radeon_device *rdev,
				     काष्ठा radeon_घड़ी_voltage_dependency_table *voltage_dependency_table,
				     काष्ठा atom_voltage_table *voltage_table)
अणु
	u32 i;

	अगर (voltage_dependency_table == शून्य)
		वापस -EINVAL;

	voltage_table->mask_low = 0;
	voltage_table->phase_delay = 0;

	voltage_table->count = voltage_dependency_table->count;
	क्रम (i = 0; i < voltage_table->count; i++) अणु
		voltage_table->entries[i].value = voltage_dependency_table->entries[i].v;
		voltage_table->entries[i].smio_low = 0;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_स्थिरruct_voltage_tables(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;

	अगर (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) अणु
		ret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_VDDC,
						    VOLTAGE_OBJ_GPIO_LUT,
						    &pi->vddc_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण अन्यथा अगर (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) अणु
		ret = ci_get_svi2_voltage_table(rdev,
						&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
						&pi->vddc_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (pi->vddc_voltage_table.count > SMU7_MAX_LEVELS_VDDC)
		si_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_VDDC,
							 &pi->vddc_voltage_table);

	अगर (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) अणु
		ret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_VDDCI,
						    VOLTAGE_OBJ_GPIO_LUT,
						    &pi->vddci_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण अन्यथा अगर (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) अणु
		ret = ci_get_svi2_voltage_table(rdev,
						&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
						&pi->vddci_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (pi->vddci_voltage_table.count > SMU7_MAX_LEVELS_VDDCI)
		si_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_VDDCI,
							 &pi->vddci_voltage_table);

	अगर (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) अणु
		ret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_MVDDC,
						    VOLTAGE_OBJ_GPIO_LUT,
						    &pi->mvdd_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण अन्यथा अगर (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) अणु
		ret = ci_get_svi2_voltage_table(rdev,
						&rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,
						&pi->mvdd_voltage_table);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (pi->mvdd_voltage_table.count > SMU7_MAX_LEVELS_MVDD)
		si_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_MVDD,
							 &pi->mvdd_voltage_table);

	वापस 0;
पूर्ण

अटल व्योम ci_populate_smc_voltage_table(काष्ठा radeon_device *rdev,
					  काष्ठा atom_voltage_table_entry *voltage_table,
					  SMU7_Discrete_VoltageLevel *smc_voltage_table)
अणु
	पूर्णांक ret;

	ret = ci_get_std_voltage_value_sidd(rdev, voltage_table,
					    &smc_voltage_table->StdVoltageHiSidd,
					    &smc_voltage_table->StdVoltageLoSidd);

	अगर (ret) अणु
		smc_voltage_table->StdVoltageHiSidd = voltage_table->value * VOLTAGE_SCALE;
		smc_voltage_table->StdVoltageLoSidd = voltage_table->value * VOLTAGE_SCALE;
	पूर्ण

	smc_voltage_table->Voltage = cpu_to_be16(voltage_table->value * VOLTAGE_SCALE);
	smc_voltage_table->StdVoltageHiSidd =
		cpu_to_be16(smc_voltage_table->StdVoltageHiSidd);
	smc_voltage_table->StdVoltageLoSidd =
		cpu_to_be16(smc_voltage_table->StdVoltageLoSidd);
पूर्ण

अटल पूर्णांक ci_populate_smc_vddc_table(काष्ठा radeon_device *rdev,
				      SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	अचिन्हित पूर्णांक count;

	table->VddcLevelCount = pi->vddc_voltage_table.count;
	क्रम (count = 0; count < table->VddcLevelCount; count++) अणु
		ci_populate_smc_voltage_table(rdev,
					      &pi->vddc_voltage_table.entries[count],
					      &table->VddcLevel[count]);

		अगर (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)
			table->VddcLevel[count].Smio |=
				pi->vddc_voltage_table.entries[count].smio_low;
		अन्यथा
			table->VddcLevel[count].Smio = 0;
	पूर्ण
	table->VddcLevelCount = cpu_to_be32(table->VddcLevelCount);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_vddci_table(काष्ठा radeon_device *rdev,
				       SMU7_Discrete_DpmTable *table)
अणु
	अचिन्हित पूर्णांक count;
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	table->VddciLevelCount = pi->vddci_voltage_table.count;
	क्रम (count = 0; count < table->VddciLevelCount; count++) अणु
		ci_populate_smc_voltage_table(rdev,
					      &pi->vddci_voltage_table.entries[count],
					      &table->VddciLevel[count]);

		अगर (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)
			table->VddciLevel[count].Smio |=
				pi->vddci_voltage_table.entries[count].smio_low;
		अन्यथा
			table->VddciLevel[count].Smio = 0;
	पूर्ण
	table->VddciLevelCount = cpu_to_be32(table->VddciLevelCount);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_mvdd_table(काष्ठा radeon_device *rdev,
				      SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	अचिन्हित पूर्णांक count;

	table->MvddLevelCount = pi->mvdd_voltage_table.count;
	क्रम (count = 0; count < table->MvddLevelCount; count++) अणु
		ci_populate_smc_voltage_table(rdev,
					      &pi->mvdd_voltage_table.entries[count],
					      &table->MvddLevel[count]);

		अगर (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)
			table->MvddLevel[count].Smio |=
				pi->mvdd_voltage_table.entries[count].smio_low;
		अन्यथा
			table->MvddLevel[count].Smio = 0;
	पूर्ण
	table->MvddLevelCount = cpu_to_be32(table->MvddLevelCount);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_voltage_tables(काष्ठा radeon_device *rdev,
					  SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक ret;

	ret = ci_populate_smc_vddc_table(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_vddci_table(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_mvdd_table(rdev, table);
	अगर (ret)
		वापस ret;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_mvdd_value(काष्ठा radeon_device *rdev, u32 mclk,
				  SMU7_Discrete_VoltageLevel *voltage)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 i = 0;

	अगर (pi->mvdd_control != CISLANDS_VOLTAGE_CONTROL_NONE) अणु
		क्रम (i = 0; i < rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count; i++) अणु
			अगर (mclk <= rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries[i].clk) अणु
				voltage->Voltage = pi->mvdd_voltage_table.entries[i].value;
				अवरोध;
			पूर्ण
		पूर्ण

		अगर (i >= rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count)
			वापस -EINVAL;
	पूर्ण

	वापस -EINVAL;
पूर्ण

अटल पूर्णांक ci_get_std_voltage_value_sidd(काष्ठा radeon_device *rdev,
					 काष्ठा atom_voltage_table_entry *voltage_table,
					 u16 *std_voltage_hi_sidd, u16 *std_voltage_lo_sidd)
अणु
	u16 v_index, idx;
	bool voltage_found = false;
	*std_voltage_hi_sidd = voltage_table->value * VOLTAGE_SCALE;
	*std_voltage_lo_sidd = voltage_table->value * VOLTAGE_SCALE;

	अगर (rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries == शून्य)
		वापस -EINVAL;

	अगर (rdev->pm.dpm.dyn_state.cac_leakage_table.entries) अणु
		क्रम (v_index = 0; (u32)v_index < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) अणु
			अगर (voltage_table->value ==
			    rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) अणु
				voltage_found = true;
				अगर ((u32)v_index < rdev->pm.dpm.dyn_state.cac_leakage_table.count)
					idx = v_index;
				अन्यथा
					idx = rdev->pm.dpm.dyn_state.cac_leakage_table.count - 1;
				*std_voltage_lo_sidd =
					rdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;
				*std_voltage_hi_sidd =
					rdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;
				अवरोध;
			पूर्ण
		पूर्ण

		अगर (!voltage_found) अणु
			क्रम (v_index = 0; (u32)v_index < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) अणु
				अगर (voltage_table->value <=
				    rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) अणु
					voltage_found = true;
					अगर ((u32)v_index < rdev->pm.dpm.dyn_state.cac_leakage_table.count)
						idx = v_index;
					अन्यथा
						idx = rdev->pm.dpm.dyn_state.cac_leakage_table.count - 1;
					*std_voltage_lo_sidd =
						rdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;
					*std_voltage_hi_sidd =
						rdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;
					अवरोध;
				पूर्ण
			पूर्ण
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ci_populate_phase_value_based_on_sclk(काष्ठा radeon_device *rdev,
						  स्थिर काष्ठा radeon_phase_shedding_limits_table *limits,
						  u32 sclk,
						  u32 *phase_shedding)
अणु
	अचिन्हित पूर्णांक i;

	*phase_shedding = 1;

	क्रम (i = 0; i < limits->count; i++) अणु
		अगर (sclk < limits->entries[i].sclk) अणु
			*phase_shedding = i;
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_populate_phase_value_based_on_mclk(काष्ठा radeon_device *rdev,
						  स्थिर काष्ठा radeon_phase_shedding_limits_table *limits,
						  u32 mclk,
						  u32 *phase_shedding)
अणु
	अचिन्हित पूर्णांक i;

	*phase_shedding = 1;

	क्रम (i = 0; i < limits->count; i++) अणु
		अगर (mclk < limits->entries[i].mclk) अणु
			*phase_shedding = i;
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक ci_init_arb_table_index(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;
	पूर्णांक ret;

	ret = ci_पढ़ो_smc_sram_dword(rdev, pi->arb_table_start,
				     &पंचांगp, pi->sram_end);
	अगर (ret)
		वापस ret;

	पंचांगp &= 0x00FFFFFF;
	पंचांगp |= MC_CG_ARB_FREQ_F1 << 24;

	वापस ci_ग_लिखो_smc_sram_dword(rdev, pi->arb_table_start,
				       पंचांगp, pi->sram_end);
पूर्ण

अटल पूर्णांक ci_get_dependency_volt_by_clk(काष्ठा radeon_device *rdev,
					 काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_घड़ी_voltage_table,
					 u32 घड़ी, u32 *voltage)
अणु
	u32 i = 0;

	अगर (allowed_घड़ी_voltage_table->count == 0)
		वापस -EINVAL;

	क्रम (i = 0; i < allowed_घड़ी_voltage_table->count; i++) अणु
		अगर (allowed_घड़ी_voltage_table->entries[i].clk >= घड़ी) अणु
			*voltage = allowed_घड़ी_voltage_table->entries[i].v;
			वापस 0;
		पूर्ण
	पूर्ण

	*voltage = allowed_घड़ी_voltage_table->entries[i-1].v;

	वापस 0;
पूर्ण

अटल u8 ci_get_sleep_भागider_id_from_घड़ी(काष्ठा radeon_device *rdev,
					     u32 sclk, u32 min_sclk_in_sr)
अणु
	u32 i;
	u32 पंचांगp;
	u32 min = (min_sclk_in_sr > CISLAND_MINIMUM_ENGINE_CLOCK) ?
		min_sclk_in_sr : CISLAND_MINIMUM_ENGINE_CLOCK;

	अगर (sclk < min)
		वापस 0;

	क्रम (i = CISLAND_MAX_DEEPSLEEP_DIVIDER_ID;  ; i--) अणु
		पंचांगp = sclk / (1 << i);
		अगर (पंचांगp >= min || i == 0)
			अवरोध;
	पूर्ण

	वापस (u8)i;
पूर्ण

अटल पूर्णांक ci_initial_चयन_from_arb_f0_to_f1(काष्ठा radeon_device *rdev)
अणु
	वापस ni_copy_and_चयन_arb_sets(rdev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);
पूर्ण

अटल पूर्णांक ci_reset_to_शेष(काष्ठा radeon_device *rdev)
अणु
	वापस (ci_send_msg_to_smc(rdev, PPSMC_MSG_ResetToDefaults) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण

अटल पूर्णांक ci_क्रमce_चयन_to_arb_f0(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp;

	पंचांगp = (RREG32_SMC(SMC_SCRATCH9) & 0x0000ff00) >> 8;

	अगर (पंचांगp == MC_CG_ARB_FREQ_F0)
		वापस 0;

	वापस ni_copy_and_चयन_arb_sets(rdev, पंचांगp, MC_CG_ARB_FREQ_F0);
पूर्ण

अटल व्योम ci_रेजिस्टर_patching_mc_arb(काष्ठा radeon_device *rdev,
					स्थिर u32 engine_घड़ी,
					स्थिर u32 memory_घड़ी,
					u32 *dram_timimg2)
अणु
	bool patch;
	u32 पंचांगp, पंचांगp2;

	पंचांगp = RREG32(MC_SEQ_MISC0);
	patch = ((पंचांगp & 0x0000f00) == 0x300) ? true : false;

	अगर (patch &&
	    ((rdev->pdev->device == 0x67B0) ||
	     (rdev->pdev->device == 0x67B1))) अणु
		अगर ((memory_घड़ी > 100000) && (memory_घड़ी <= 125000)) अणु
			पंचांगp2 = (((0x31 * engine_घड़ी) / 125000) - 1) & 0xff;
			*dram_timimg2 &= ~0x00ff0000;
			*dram_timimg2 |= पंचांगp2 << 16;
		पूर्ण अन्यथा अगर ((memory_घड़ी > 125000) && (memory_घड़ी <= 137500)) अणु
			पंचांगp2 = (((0x36 * engine_घड़ी) / 137500) - 1) & 0xff;
			*dram_timimg2 &= ~0x00ff0000;
			*dram_timimg2 |= पंचांगp2 << 16;
		पूर्ण
	पूर्ण
पूर्ण


अटल पूर्णांक ci_populate_memory_timing_parameters(काष्ठा radeon_device *rdev,
						u32 sclk,
						u32 mclk,
						SMU7_Discrete_MCArbDramTimingTableEntry *arb_regs)
अणु
	u32 dram_timing;
	u32 dram_timing2;
	u32 burst_समय;

	radeon_atom_set_engine_dram_timings(rdev, sclk, mclk);

	dram_timing  = RREG32(MC_ARB_DRAM_TIMING);
	dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);
	burst_समय = RREG32(MC_ARB_BURST_TIME) & STATE0_MASK;

	ci_रेजिस्टर_patching_mc_arb(rdev, sclk, mclk, &dram_timing2);

	arb_regs->McArbDramTiming  = cpu_to_be32(dram_timing);
	arb_regs->McArbDramTiming2 = cpu_to_be32(dram_timing2);
	arb_regs->McArbBurstTime = (u8)burst_समय;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_करो_program_memory_timing_parameters(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	SMU7_Discrete_MCArbDramTimingTable arb_regs;
	u32 i, j;
	पूर्णांक ret =  0;

	स_रखो(&arb_regs, 0, माप(SMU7_Discrete_MCArbDramTimingTable));

	क्रम (i = 0; i < pi->dpm_table.sclk_table.count; i++) अणु
		क्रम (j = 0; j < pi->dpm_table.mclk_table.count; j++) अणु
			ret = ci_populate_memory_timing_parameters(rdev,
								   pi->dpm_table.sclk_table.dpm_levels[i].value,
								   pi->dpm_table.mclk_table.dpm_levels[j].value,
								   &arb_regs.entries[i][j]);
			अगर (ret)
				अवरोध;
		पूर्ण
	पूर्ण

	अगर (ret == 0)
		ret = ci_copy_bytes_to_smc(rdev,
					   pi->arb_table_start,
					   (u8 *)&arb_regs,
					   माप(SMU7_Discrete_MCArbDramTimingTable),
					   pi->sram_end);

	वापस ret;
पूर्ण

अटल पूर्णांक ci_program_memory_timing_parameters(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (pi->need_update_smu7_dpm_table == 0)
		वापस 0;

	वापस ci_करो_program_memory_timing_parameters(rdev);
पूर्ण

अटल व्योम ci_populate_smc_initial_state(काष्ठा radeon_device *rdev,
					  काष्ठा radeon_ps *radeon_boot_state)
अणु
	काष्ठा ci_ps *boot_state = ci_get_ps(radeon_boot_state);
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 level = 0;

	क्रम (level = 0; level < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; level++) अणु
		अगर (rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[level].clk >=
		    boot_state->perक्रमmance_levels[0].sclk) अणु
			pi->smc_state_table.GraphicsBootLevel = level;
			अवरोध;
		पूर्ण
	पूर्ण

	क्रम (level = 0; level < rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.count; level++) अणु
		अगर (rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries[level].clk >=
		    boot_state->perक्रमmance_levels[0].mclk) अणु
			pi->smc_state_table.MemoryBootLevel = level;
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल u32 ci_get_dpm_level_enable_mask_value(काष्ठा ci_single_dpm_table *dpm_table)
अणु
	u32 i;
	u32 mask_value = 0;

	क्रम (i = dpm_table->count; i > 0; i--) अणु
		mask_value = mask_value << 1;
		अगर (dpm_table->dpm_levels[i-1].enabled)
			mask_value |= 0x1;
		अन्यथा
			mask_value &= 0xFFFFFFFE;
	पूर्ण

	वापस mask_value;
पूर्ण

अटल व्योम ci_populate_smc_link_level(काष्ठा radeon_device *rdev,
				       SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_dpm_table *dpm_table = &pi->dpm_table;
	u32 i;

	क्रम (i = 0; i < dpm_table->pcie_speed_table.count; i++) अणु
		table->LinkLevel[i].PcieGenSpeed =
			(u8)dpm_table->pcie_speed_table.dpm_levels[i].value;
		table->LinkLevel[i].PcieLaneCount =
			r600_encode_pci_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);
		table->LinkLevel[i].EnabledForActivity = 1;
		table->LinkLevel[i].DownT = cpu_to_be32(5);
		table->LinkLevel[i].UpT = cpu_to_be32(30);
	पूर्ण

	pi->smc_state_table.LinkLevelCount = (u8)dpm_table->pcie_speed_table.count;
	pi->dpm_level_enable_mask.pcie_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);
पूर्ण

अटल पूर्णांक ci_populate_smc_uvd_level(काष्ठा radeon_device *rdev,
				     SMU7_Discrete_DpmTable *table)
अणु
	u32 count;
	काष्ठा atom_घड़ी_भागiders भागiders;
	पूर्णांक ret = -EINVAL;

	table->UvdLevelCount =
		rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.count;

	क्रम (count = 0; count < table->UvdLevelCount; count++) अणु
		table->UvdLevel[count].VclkFrequency =
			rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.entries[count].vclk;
		table->UvdLevel[count].DclkFrequency =
			rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.entries[count].dclk;
		table->UvdLevel[count].MinVddc =
			rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;
		table->UvdLevel[count].MinVddcPhases = 1;

		ret = radeon_atom_get_घड़ी_भागiders(rdev,
						     COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
						     table->UvdLevel[count].VclkFrequency, false, &भागiders);
		अगर (ret)
			वापस ret;

		table->UvdLevel[count].VclkDivider = (u8)भागiders.post_भागider;

		ret = radeon_atom_get_घड़ी_भागiders(rdev,
						     COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
						     table->UvdLevel[count].DclkFrequency, false, &भागiders);
		अगर (ret)
			वापस ret;

		table->UvdLevel[count].DclkDivider = (u8)भागiders.post_भागider;

		table->UvdLevel[count].VclkFrequency = cpu_to_be32(table->UvdLevel[count].VclkFrequency);
		table->UvdLevel[count].DclkFrequency = cpu_to_be32(table->UvdLevel[count].DclkFrequency);
		table->UvdLevel[count].MinVddc = cpu_to_be16(table->UvdLevel[count].MinVddc);
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_populate_smc_vce_level(काष्ठा radeon_device *rdev,
				     SMU7_Discrete_DpmTable *table)
अणु
	u32 count;
	काष्ठा atom_घड़ी_भागiders भागiders;
	पूर्णांक ret = -EINVAL;

	table->VceLevelCount =
		rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table.count;

	क्रम (count = 0; count < table->VceLevelCount; count++) अणु
		table->VceLevel[count].Frequency =
			rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table.entries[count].evclk;
		table->VceLevel[count].MinVoltage =
			(u16)rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;
		table->VceLevel[count].MinPhases = 1;

		ret = radeon_atom_get_घड़ी_भागiders(rdev,
						     COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
						     table->VceLevel[count].Frequency, false, &भागiders);
		अगर (ret)
			वापस ret;

		table->VceLevel[count].Divider = (u8)भागiders.post_भागider;

		table->VceLevel[count].Frequency = cpu_to_be32(table->VceLevel[count].Frequency);
		table->VceLevel[count].MinVoltage = cpu_to_be16(table->VceLevel[count].MinVoltage);
	पूर्ण

	वापस ret;

पूर्ण

अटल पूर्णांक ci_populate_smc_acp_level(काष्ठा radeon_device *rdev,
				     SMU7_Discrete_DpmTable *table)
अणु
	u32 count;
	काष्ठा atom_घड़ी_भागiders भागiders;
	पूर्णांक ret = -EINVAL;

	table->AcpLevelCount = (u8)
		(rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table.count);

	क्रम (count = 0; count < table->AcpLevelCount; count++) अणु
		table->AcpLevel[count].Frequency =
			rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table.entries[count].clk;
		table->AcpLevel[count].MinVoltage =
			rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table.entries[count].v;
		table->AcpLevel[count].MinPhases = 1;

		ret = radeon_atom_get_घड़ी_भागiders(rdev,
						     COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
						     table->AcpLevel[count].Frequency, false, &भागiders);
		अगर (ret)
			वापस ret;

		table->AcpLevel[count].Divider = (u8)भागiders.post_भागider;

		table->AcpLevel[count].Frequency = cpu_to_be32(table->AcpLevel[count].Frequency);
		table->AcpLevel[count].MinVoltage = cpu_to_be16(table->AcpLevel[count].MinVoltage);
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_populate_smc_samu_level(काष्ठा radeon_device *rdev,
				      SMU7_Discrete_DpmTable *table)
अणु
	u32 count;
	काष्ठा atom_घड़ी_भागiders भागiders;
	पूर्णांक ret = -EINVAL;

	table->SamuLevelCount =
		rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table.count;

	क्रम (count = 0; count < table->SamuLevelCount; count++) अणु
		table->SamuLevel[count].Frequency =
			rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table.entries[count].clk;
		table->SamuLevel[count].MinVoltage =
			rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;
		table->SamuLevel[count].MinPhases = 1;

		ret = radeon_atom_get_घड़ी_भागiders(rdev,
						     COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
						     table->SamuLevel[count].Frequency, false, &भागiders);
		अगर (ret)
			वापस ret;

		table->SamuLevel[count].Divider = (u8)भागiders.post_भागider;

		table->SamuLevel[count].Frequency = cpu_to_be32(table->SamuLevel[count].Frequency);
		table->SamuLevel[count].MinVoltage = cpu_to_be16(table->SamuLevel[count].MinVoltage);
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_calculate_mclk_params(काष्ठा radeon_device *rdev,
				    u32 memory_घड़ी,
				    SMU7_Discrete_MemoryLevel *mclk,
				    bool strobe_mode,
				    bool dll_state_on)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32  dll_cntl = pi->घड़ी_रेजिस्टरs.dll_cntl;
	u32  mclk_pwrmgt_cntl = pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl;
	u32  mpll_ad_func_cntl = pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl;
	u32  mpll_dq_func_cntl = pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl;
	u32  mpll_func_cntl = pi->घड़ी_रेजिस्टरs.mpll_func_cntl;
	u32  mpll_func_cntl_1 = pi->घड़ी_रेजिस्टरs.mpll_func_cntl_1;
	u32  mpll_func_cntl_2 = pi->घड़ी_रेजिस्टरs.mpll_func_cntl_2;
	u32  mpll_ss1 = pi->घड़ी_रेजिस्टरs.mpll_ss1;
	u32  mpll_ss2 = pi->घड़ी_रेजिस्टरs.mpll_ss2;
	काष्ठा atom_mpll_param mpll_param;
	पूर्णांक ret;

	ret = radeon_atom_get_memory_pll_भागiders(rdev, memory_घड़ी, strobe_mode, &mpll_param);
	अगर (ret)
		वापस ret;

	mpll_func_cntl &= ~BWCTRL_MASK;
	mpll_func_cntl |= BWCTRL(mpll_param.bwcntl);

	mpll_func_cntl_1 &= ~(CLKF_MASK | CLKFRAC_MASK | VCO_MODE_MASK);
	mpll_func_cntl_1 |= CLKF(mpll_param.clkf) |
		CLKFRAC(mpll_param.clkfrac) | VCO_MODE(mpll_param.vco_mode);

	mpll_ad_func_cntl &= ~YCLK_POST_DIV_MASK;
	mpll_ad_func_cntl |= YCLK_POST_DIV(mpll_param.post_भाग);

	अगर (pi->mem_gddr5) अणु
		mpll_dq_func_cntl &= ~(YCLK_SEL_MASK | YCLK_POST_DIV_MASK);
		mpll_dq_func_cntl |= YCLK_SEL(mpll_param.yclk_sel) |
			YCLK_POST_DIV(mpll_param.post_भाग);
	पूर्ण

	अगर (pi->caps_mclk_ss_support) अणु
		काष्ठा radeon_atom_ss ss;
		u32 freq_nom;
		u32 पंचांगp;
		u32 reference_घड़ी = rdev->घड़ी.mpll.reference_freq;

		अगर (mpll_param.qdr == 1)
			freq_nom = memory_घड़ी * 4 * (1 << mpll_param.post_भाग);
		अन्यथा
			freq_nom = memory_घड़ी * 2 * (1 << mpll_param.post_भाग);

		पंचांगp = (freq_nom / reference_घड़ी);
		पंचांगp = पंचांगp * पंचांगp;
		अगर (radeon_atombios_get_asic_ss_info(rdev, &ss,
						     ASIC_INTERNAL_MEMORY_SS, freq_nom)) अणु
			u32 clks = reference_घड़ी * 5 / ss.rate;
			u32 clkv = (u32)((((131 * ss.percentage * ss.rate) / 100) * पंचांगp) / freq_nom);

			mpll_ss1 &= ~CLKV_MASK;
			mpll_ss1 |= CLKV(clkv);

			mpll_ss2 &= ~CLKS_MASK;
			mpll_ss2 |= CLKS(clks);
		पूर्ण
	पूर्ण

	mclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;
	mclk_pwrmgt_cntl |= DLL_SPEED(mpll_param.dll_speed);

	अगर (dll_state_on)
		mclk_pwrmgt_cntl |= MRDCK0_PDNB | MRDCK1_PDNB;
	अन्यथा
		mclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);

	mclk->MclkFrequency = memory_घड़ी;
	mclk->MpllFuncCntl = mpll_func_cntl;
	mclk->MpllFuncCntl_1 = mpll_func_cntl_1;
	mclk->MpllFuncCntl_2 = mpll_func_cntl_2;
	mclk->MpllAdFuncCntl = mpll_ad_func_cntl;
	mclk->MpllDqFuncCntl = mpll_dq_func_cntl;
	mclk->MclkPwrmgtCntl = mclk_pwrmgt_cntl;
	mclk->DllCntl = dll_cntl;
	mclk->MpllSs1 = mpll_ss1;
	mclk->MpllSs2 = mpll_ss2;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_single_memory_level(काष्ठा radeon_device *rdev,
					   u32 memory_घड़ी,
					   SMU7_Discrete_MemoryLevel *memory_level)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;
	bool dll_state_on;

	अगर (rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries) अणु
		ret = ci_get_dependency_volt_by_clk(rdev,
						    &rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
						    memory_घड़ी, &memory_level->MinVddc);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk.entries) अणु
		ret = ci_get_dependency_volt_by_clk(rdev,
						    &rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
						    memory_घड़ी, &memory_level->MinVddci);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries) अणु
		ret = ci_get_dependency_volt_by_clk(rdev,
						    &rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,
						    memory_घड़ी, &memory_level->MinMvdd);
		अगर (ret)
			वापस ret;
	पूर्ण

	memory_level->MinVddcPhases = 1;

	अगर (pi->vddc_phase_shed_control)
		ci_populate_phase_value_based_on_mclk(rdev,
						      &rdev->pm.dpm.dyn_state.phase_shedding_limits_table,
						      memory_घड़ी,
						      &memory_level->MinVddcPhases);

	memory_level->EnabledForThrottle = 1;
	memory_level->UpH = 0;
	memory_level->DownH = 100;
	memory_level->VoltageDownH = 0;
	memory_level->ActivityLevel = (u16)pi->mclk_activity_target;

	memory_level->StutterEnable = false;
	memory_level->StrobeEnable = false;
	memory_level->EdcReadEnable = false;
	memory_level->EdcWriteEnable = false;
	memory_level->RttEnable = false;

	memory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;

	अगर (pi->mclk_stutter_mode_threshold &&
	    (memory_घड़ी <= pi->mclk_stutter_mode_threshold) &&
	    (pi->uvd_enabled == false) &&
	    (RREG32(DPG_PIPE_STUTTER_CONTROL) & STUTTER_ENABLE) &&
	    (rdev->pm.dpm.new_active_crtc_count <= 2))
		memory_level->StutterEnable = true;

	अगर (pi->mclk_strobe_mode_threshold &&
	    (memory_घड़ी <= pi->mclk_strobe_mode_threshold))
		memory_level->StrobeEnable = 1;

	अगर (pi->mem_gddr5) अणु
		memory_level->StrobeRatio =
			si_get_mclk_frequency_ratio(memory_घड़ी, memory_level->StrobeEnable);
		अगर (pi->mclk_edc_enable_threshold &&
		    (memory_घड़ी > pi->mclk_edc_enable_threshold))
			memory_level->EdcReadEnable = true;

		अगर (pi->mclk_edc_wr_enable_threshold &&
		    (memory_घड़ी > pi->mclk_edc_wr_enable_threshold))
			memory_level->EdcWriteEnable = true;

		अगर (memory_level->StrobeEnable) अणु
			अगर (si_get_mclk_frequency_ratio(memory_घड़ी, true) >=
			    ((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))
				dll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;
			अन्यथा
				dll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;
		पूर्ण अन्यथा अणु
			dll_state_on = pi->dll_शेष_on;
		पूर्ण
	पूर्ण अन्यथा अणु
		memory_level->StrobeRatio = si_get_ddr3_mclk_frequency_ratio(memory_घड़ी);
		dll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;
	पूर्ण

	ret = ci_calculate_mclk_params(rdev, memory_घड़ी, memory_level, memory_level->StrobeEnable, dll_state_on);
	अगर (ret)
		वापस ret;

	memory_level->MinVddc = cpu_to_be32(memory_level->MinVddc * VOLTAGE_SCALE);
	memory_level->MinVddcPhases = cpu_to_be32(memory_level->MinVddcPhases);
	memory_level->MinVddci = cpu_to_be32(memory_level->MinVddci * VOLTAGE_SCALE);
	memory_level->MinMvdd = cpu_to_be32(memory_level->MinMvdd * VOLTAGE_SCALE);

	memory_level->MclkFrequency = cpu_to_be32(memory_level->MclkFrequency);
	memory_level->ActivityLevel = cpu_to_be16(memory_level->ActivityLevel);
	memory_level->MpllFuncCntl = cpu_to_be32(memory_level->MpllFuncCntl);
	memory_level->MpllFuncCntl_1 = cpu_to_be32(memory_level->MpllFuncCntl_1);
	memory_level->MpllFuncCntl_2 = cpu_to_be32(memory_level->MpllFuncCntl_2);
	memory_level->MpllAdFuncCntl = cpu_to_be32(memory_level->MpllAdFuncCntl);
	memory_level->MpllDqFuncCntl = cpu_to_be32(memory_level->MpllDqFuncCntl);
	memory_level->MclkPwrmgtCntl = cpu_to_be32(memory_level->MclkPwrmgtCntl);
	memory_level->DllCntl = cpu_to_be32(memory_level->DllCntl);
	memory_level->MpllSs1 = cpu_to_be32(memory_level->MpllSs1);
	memory_level->MpllSs2 = cpu_to_be32(memory_level->MpllSs2);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_acpi_level(काष्ठा radeon_device *rdev,
				      SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा atom_घड़ी_भागiders भागiders;
	SMU7_Discrete_VoltageLevel voltage_level;
	u32 spll_func_cntl = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl;
	u32 spll_func_cntl_2 = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_2;
	u32 dll_cntl = pi->घड़ी_रेजिस्टरs.dll_cntl;
	u32 mclk_pwrmgt_cntl = pi->घड़ी_रेजिस्टरs.mclk_pwrmgt_cntl;
	पूर्णांक ret;

	table->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;

	अगर (pi->acpi_vddc)
		table->ACPILevel.MinVddc = cpu_to_be32(pi->acpi_vddc * VOLTAGE_SCALE);
	अन्यथा
		table->ACPILevel.MinVddc = cpu_to_be32(pi->min_vddc_in_pp_table * VOLTAGE_SCALE);

	table->ACPILevel.MinVddcPhases = pi->vddc_phase_shed_control ? 0 : 1;

	table->ACPILevel.SclkFrequency = rdev->घड़ी.spll.reference_freq;

	ret = radeon_atom_get_घड़ी_भागiders(rdev,
					     COMPUTE_GPUCLK_INPUT_FLAG_SCLK,
					     table->ACPILevel.SclkFrequency, false, &भागiders);
	अगर (ret)
		वापस ret;

	table->ACPILevel.SclkDid = (u8)भागiders.post_भागider;
	table->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;
	table->ACPILevel.DeepSleepDivId = 0;

	spll_func_cntl &= ~SPLL_PWRON;
	spll_func_cntl |= SPLL_RESET;

	spll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;
	spll_func_cntl_2 |= SCLK_MUX_SEL(4);

	table->ACPILevel.CgSpllFuncCntl = spll_func_cntl;
	table->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;
	table->ACPILevel.CgSpllFuncCntl3 = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3;
	table->ACPILevel.CgSpllFuncCntl4 = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4;
	table->ACPILevel.SpllSpपढ़ोSpectrum = pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum;
	table->ACPILevel.SpllSpपढ़ोSpectrum2 = pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2;
	table->ACPILevel.CcPwrDynRm = 0;
	table->ACPILevel.CcPwrDynRm1 = 0;

	table->ACPILevel.Flags = cpu_to_be32(table->ACPILevel.Flags);
	table->ACPILevel.MinVddcPhases = cpu_to_be32(table->ACPILevel.MinVddcPhases);
	table->ACPILevel.SclkFrequency = cpu_to_be32(table->ACPILevel.SclkFrequency);
	table->ACPILevel.CgSpllFuncCntl = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl);
	table->ACPILevel.CgSpllFuncCntl2 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl2);
	table->ACPILevel.CgSpllFuncCntl3 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl3);
	table->ACPILevel.CgSpllFuncCntl4 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl4);
	table->ACPILevel.SpllSpपढ़ोSpectrum = cpu_to_be32(table->ACPILevel.SpllSpपढ़ोSpectrum);
	table->ACPILevel.SpllSpपढ़ोSpectrum2 = cpu_to_be32(table->ACPILevel.SpllSpपढ़ोSpectrum2);
	table->ACPILevel.CcPwrDynRm = cpu_to_be32(table->ACPILevel.CcPwrDynRm);
	table->ACPILevel.CcPwrDynRm1 = cpu_to_be32(table->ACPILevel.CcPwrDynRm1);

	table->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;
	table->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;

	अगर (pi->vddci_control != CISLANDS_VOLTAGE_CONTROL_NONE) अणु
		अगर (pi->acpi_vddci)
			table->MemoryACPILevel.MinVddci =
				cpu_to_be32(pi->acpi_vddci * VOLTAGE_SCALE);
		अन्यथा
			table->MemoryACPILevel.MinVddci =
				cpu_to_be32(pi->min_vddci_in_pp_table * VOLTAGE_SCALE);
	पूर्ण

	अगर (ci_populate_mvdd_value(rdev, 0, &voltage_level))
		table->MemoryACPILevel.MinMvdd = 0;
	अन्यथा
		table->MemoryACPILevel.MinMvdd =
			cpu_to_be32(voltage_level.Voltage * VOLTAGE_SCALE);

	mclk_pwrmgt_cntl |= MRDCK0_RESET | MRDCK1_RESET;
	mclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);

	dll_cntl &= ~(MRDCK0_BYPASS | MRDCK1_BYPASS);

	table->MemoryACPILevel.DllCntl = cpu_to_be32(dll_cntl);
	table->MemoryACPILevel.MclkPwrmgtCntl = cpu_to_be32(mclk_pwrmgt_cntl);
	table->MemoryACPILevel.MpllAdFuncCntl =
		cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_ad_func_cntl);
	table->MemoryACPILevel.MpllDqFuncCntl =
		cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_dq_func_cntl);
	table->MemoryACPILevel.MpllFuncCntl =
		cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_func_cntl);
	table->MemoryACPILevel.MpllFuncCntl_1 =
		cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_func_cntl_1);
	table->MemoryACPILevel.MpllFuncCntl_2 =
		cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_func_cntl_2);
	table->MemoryACPILevel.MpllSs1 = cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_ss1);
	table->MemoryACPILevel.MpllSs2 = cpu_to_be32(pi->घड़ी_रेजिस्टरs.mpll_ss2);

	table->MemoryACPILevel.EnabledForThrottle = 0;
	table->MemoryACPILevel.EnabledForActivity = 0;
	table->MemoryACPILevel.UpH = 0;
	table->MemoryACPILevel.DownH = 100;
	table->MemoryACPILevel.VoltageDownH = 0;
	table->MemoryACPILevel.ActivityLevel =
		cpu_to_be16((u16)pi->mclk_activity_target);

	table->MemoryACPILevel.StutterEnable = false;
	table->MemoryACPILevel.StrobeEnable = false;
	table->MemoryACPILevel.EdcReadEnable = false;
	table->MemoryACPILevel.EdcWriteEnable = false;
	table->MemoryACPILevel.RttEnable = false;

	वापस 0;
पूर्ण


अटल पूर्णांक ci_enable_ulv(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ulv_parm *ulv = &pi->ulv;

	अगर (ulv->supported) अणु
		अगर (enable)
			वापस (ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableULV) == PPSMC_Result_OK) ?
				0 : -EINVAL;
		अन्यथा
			वापस (ci_send_msg_to_smc(rdev, PPSMC_MSG_DisableULV) == PPSMC_Result_OK) ?
				0 : -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_ulv_level(काष्ठा radeon_device *rdev,
				 SMU7_Discrete_Ulv *state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u16 ulv_voltage = rdev->pm.dpm.backbias_response_समय;

	state->CcPwrDynRm = 0;
	state->CcPwrDynRm1 = 0;

	अगर (ulv_voltage == 0) अणु
		pi->ulv.supported = false;
		वापस 0;
	पूर्ण

	अगर (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_BY_SVID2) अणु
		अगर (ulv_voltage > rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)
			state->VddcOffset = 0;
		अन्यथा
			state->VddcOffset =
				rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage;
	पूर्ण अन्यथा अणु
		अगर (ulv_voltage > rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)
			state->VddcOffsetVid = 0;
		अन्यथा
			state->VddcOffsetVid = (u8)
				((rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage) *
				 VOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);
	पूर्ण
	state->VddcPhase = pi->vddc_phase_shed_control ? 0 : 1;

	state->CcPwrDynRm = cpu_to_be32(state->CcPwrDynRm);
	state->CcPwrDynRm1 = cpu_to_be32(state->CcPwrDynRm1);
	state->VddcOffset = cpu_to_be16(state->VddcOffset);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_calculate_sclk_params(काष्ठा radeon_device *rdev,
				    u32 engine_घड़ी,
				    SMU7_Discrete_GraphicsLevel *sclk)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा atom_घड़ी_भागiders भागiders;
	u32 spll_func_cntl_3 = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_3;
	u32 spll_func_cntl_4 = pi->घड़ी_रेजिस्टरs.cg_spll_func_cntl_4;
	u32 cg_spll_spपढ़ो_spectrum = pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum;
	u32 cg_spll_spपढ़ो_spectrum_2 = pi->घड़ी_रेजिस्टरs.cg_spll_spपढ़ो_spectrum_2;
	u32 reference_घड़ी = rdev->घड़ी.spll.reference_freq;
	u32 reference_भागider;
	u32 fbभाग;
	पूर्णांक ret;

	ret = radeon_atom_get_घड़ी_भागiders(rdev,
					     COMPUTE_GPUCLK_INPUT_FLAG_SCLK,
					     engine_घड़ी, false, &भागiders);
	अगर (ret)
		वापस ret;

	reference_भागider = 1 + भागiders.ref_भाग;
	fbभाग = भागiders.fb_भाग & 0x3FFFFFF;

	spll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;
	spll_func_cntl_3 |= SPLL_FB_DIV(fbभाग);
	spll_func_cntl_3 |= SPLL_DITHEN;

	अगर (pi->caps_sclk_ss_support) अणु
		काष्ठा radeon_atom_ss ss;
		u32 vco_freq = engine_घड़ी * भागiders.post_भाग;

		अगर (radeon_atombios_get_asic_ss_info(rdev, &ss,
						     ASIC_INTERNAL_ENGINE_SS, vco_freq)) अणु
			u32 clk_s = reference_घड़ी * 5 / (reference_भागider * ss.rate);
			u32 clk_v = 4 * ss.percentage * fbभाग / (clk_s * 10000);

			cg_spll_spपढ़ो_spectrum &= ~CLK_S_MASK;
			cg_spll_spपढ़ो_spectrum |= CLK_S(clk_s);
			cg_spll_spपढ़ो_spectrum |= SSEN;

			cg_spll_spपढ़ो_spectrum_2 &= ~CLK_V_MASK;
			cg_spll_spपढ़ो_spectrum_2 |= CLK_V(clk_v);
		पूर्ण
	पूर्ण

	sclk->SclkFrequency = engine_घड़ी;
	sclk->CgSpllFuncCntl3 = spll_func_cntl_3;
	sclk->CgSpllFuncCntl4 = spll_func_cntl_4;
	sclk->SpllSpपढ़ोSpectrum = cg_spll_spपढ़ो_spectrum;
	sclk->SpllSpपढ़ोSpectrum2  = cg_spll_spपढ़ो_spectrum_2;
	sclk->SclkDid = (u8)भागiders.post_भागider;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_single_graphic_level(काष्ठा radeon_device *rdev,
					    u32 engine_घड़ी,
					    u16 sclk_activity_level_t,
					    SMU7_Discrete_GraphicsLevel *graphic_level)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;

	ret = ci_calculate_sclk_params(rdev, engine_घड़ी, graphic_level);
	अगर (ret)
		वापस ret;

	ret = ci_get_dependency_volt_by_clk(rdev,
					    &rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
					    engine_घड़ी, &graphic_level->MinVddc);
	अगर (ret)
		वापस ret;

	graphic_level->SclkFrequency = engine_घड़ी;

	graphic_level->Flags =  0;
	graphic_level->MinVddcPhases = 1;

	अगर (pi->vddc_phase_shed_control)
		ci_populate_phase_value_based_on_sclk(rdev,
						      &rdev->pm.dpm.dyn_state.phase_shedding_limits_table,
						      engine_घड़ी,
						      &graphic_level->MinVddcPhases);

	graphic_level->ActivityLevel = sclk_activity_level_t;

	graphic_level->CcPwrDynRm = 0;
	graphic_level->CcPwrDynRm1 = 0;
	graphic_level->EnabledForThrottle = 1;
	graphic_level->UpH = 0;
	graphic_level->DownH = 0;
	graphic_level->VoltageDownH = 0;
	graphic_level->PowerThrottle = 0;

	अगर (pi->caps_sclk_ds)
		graphic_level->DeepSleepDivId = ci_get_sleep_भागider_id_from_घड़ी(rdev,
										   engine_घड़ी,
										   CISLAND_MINIMUM_ENGINE_CLOCK);

	graphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;

	graphic_level->Flags = cpu_to_be32(graphic_level->Flags);
	graphic_level->MinVddc = cpu_to_be32(graphic_level->MinVddc * VOLTAGE_SCALE);
	graphic_level->MinVddcPhases = cpu_to_be32(graphic_level->MinVddcPhases);
	graphic_level->SclkFrequency = cpu_to_be32(graphic_level->SclkFrequency);
	graphic_level->ActivityLevel = cpu_to_be16(graphic_level->ActivityLevel);
	graphic_level->CgSpllFuncCntl3 = cpu_to_be32(graphic_level->CgSpllFuncCntl3);
	graphic_level->CgSpllFuncCntl4 = cpu_to_be32(graphic_level->CgSpllFuncCntl4);
	graphic_level->SpllSpपढ़ोSpectrum = cpu_to_be32(graphic_level->SpllSpपढ़ोSpectrum);
	graphic_level->SpllSpपढ़ोSpectrum2 = cpu_to_be32(graphic_level->SpllSpपढ़ोSpectrum2);
	graphic_level->CcPwrDynRm = cpu_to_be32(graphic_level->CcPwrDynRm);
	graphic_level->CcPwrDynRm1 = cpu_to_be32(graphic_level->CcPwrDynRm1);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_all_graphic_levels(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_dpm_table *dpm_table = &pi->dpm_table;
	u32 level_array_address = pi->dpm_table_start +
		दुरत्व(SMU7_Discrete_DpmTable, GraphicsLevel);
	u32 level_array_size = माप(SMU7_Discrete_GraphicsLevel) *
		SMU7_MAX_LEVELS_GRAPHICS;
	SMU7_Discrete_GraphicsLevel *levels = pi->smc_state_table.GraphicsLevel;
	u32 i, ret;

	स_रखो(levels, 0, level_array_size);

	क्रम (i = 0; i < dpm_table->sclk_table.count; i++) अणु
		ret = ci_populate_single_graphic_level(rdev,
						       dpm_table->sclk_table.dpm_levels[i].value,
						       (u16)pi->activity_target[i],
						       &pi->smc_state_table.GraphicsLevel[i]);
		अगर (ret)
			वापस ret;
		अगर (i > 1)
			pi->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;
		अगर (i == (dpm_table->sclk_table.count - 1))
			pi->smc_state_table.GraphicsLevel[i].DisplayWatermark =
				PPSMC_DISPLAY_WATERMARK_HIGH;
	पूर्ण
	pi->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;

	pi->smc_state_table.GraphicsDpmLevelCount = (u8)dpm_table->sclk_table.count;
	pi->dpm_level_enable_mask.sclk_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);

	ret = ci_copy_bytes_to_smc(rdev, level_array_address,
				   (u8 *)levels, level_array_size,
				   pi->sram_end);
	अगर (ret)
		वापस ret;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_ulv_state(काष्ठा radeon_device *rdev,
				 SMU7_Discrete_Ulv *ulv_level)
अणु
	वापस ci_populate_ulv_level(rdev, ulv_level);
पूर्ण

अटल पूर्णांक ci_populate_all_memory_levels(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_dpm_table *dpm_table = &pi->dpm_table;
	u32 level_array_address = pi->dpm_table_start +
		दुरत्व(SMU7_Discrete_DpmTable, MemoryLevel);
	u32 level_array_size = माप(SMU7_Discrete_MemoryLevel) *
		SMU7_MAX_LEVELS_MEMORY;
	SMU7_Discrete_MemoryLevel *levels = pi->smc_state_table.MemoryLevel;
	u32 i, ret;

	स_रखो(levels, 0, level_array_size);

	क्रम (i = 0; i < dpm_table->mclk_table.count; i++) अणु
		अगर (dpm_table->mclk_table.dpm_levels[i].value == 0)
			वापस -EINVAL;
		ret = ci_populate_single_memory_level(rdev,
						      dpm_table->mclk_table.dpm_levels[i].value,
						      &pi->smc_state_table.MemoryLevel[i]);
		अगर (ret)
			वापस ret;
	पूर्ण

	pi->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;

	अगर ((dpm_table->mclk_table.count >= 2) &&
	    ((rdev->pdev->device == 0x67B0) || (rdev->pdev->device == 0x67B1))) अणु
		pi->smc_state_table.MemoryLevel[1].MinVddc =
			pi->smc_state_table.MemoryLevel[0].MinVddc;
		pi->smc_state_table.MemoryLevel[1].MinVddcPhases =
			pi->smc_state_table.MemoryLevel[0].MinVddcPhases;
	पूर्ण

	pi->smc_state_table.MemoryLevel[0].ActivityLevel = cpu_to_be16(0x1F);

	pi->smc_state_table.MemoryDpmLevelCount = (u8)dpm_table->mclk_table.count;
	pi->dpm_level_enable_mask.mclk_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);

	pi->smc_state_table.MemoryLevel[dpm_table->mclk_table.count - 1].DisplayWatermark =
		PPSMC_DISPLAY_WATERMARK_HIGH;

	ret = ci_copy_bytes_to_smc(rdev, level_array_address,
				   (u8 *)levels, level_array_size,
				   pi->sram_end);
	अगर (ret)
		वापस ret;

	वापस 0;
पूर्ण

अटल व्योम ci_reset_single_dpm_table(काष्ठा radeon_device *rdev,
				      काष्ठा ci_single_dpm_table* dpm_table,
				      u32 count)
अणु
	u32 i;

	dpm_table->count = count;
	क्रम (i = 0; i < MAX_REGULAR_DPM_NUMBER; i++)
		dpm_table->dpm_levels[i].enabled = false;
पूर्ण

अटल व्योम ci_setup_pcie_table_entry(काष्ठा ci_single_dpm_table* dpm_table,
				      u32 index, u32 pcie_gen, u32 pcie_lanes)
अणु
	dpm_table->dpm_levels[index].value = pcie_gen;
	dpm_table->dpm_levels[index].param1 = pcie_lanes;
	dpm_table->dpm_levels[index].enabled = true;
पूर्ण

अटल पूर्णांक ci_setup_शेष_pcie_tables(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (!pi->use_pcie_perक्रमmance_levels && !pi->use_pcie_घातersaving_levels)
		वापस -EINVAL;

	अगर (pi->use_pcie_perक्रमmance_levels && !pi->use_pcie_घातersaving_levels) अणु
		pi->pcie_gen_घातersaving = pi->pcie_gen_perक्रमmance;
		pi->pcie_lane_घातersaving = pi->pcie_lane_perक्रमmance;
	पूर्ण अन्यथा अगर (!pi->use_pcie_perक्रमmance_levels && pi->use_pcie_घातersaving_levels) अणु
		pi->pcie_gen_perक्रमmance = pi->pcie_gen_घातersaving;
		pi->pcie_lane_perक्रमmance = pi->pcie_lane_घातersaving;
	पूर्ण

	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.pcie_speed_table,
				  SMU7_MAX_LEVELS_LINK);

	अगर (rdev->family == CHIP_BONAIRE)
		ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,
					  pi->pcie_gen_घातersaving.min,
					  pi->pcie_lane_घातersaving.max);
	अन्यथा
		ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,
					  pi->pcie_gen_घातersaving.min,
					  pi->pcie_lane_घातersaving.min);
	ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 1,
				  pi->pcie_gen_perक्रमmance.min,
				  pi->pcie_lane_perक्रमmance.min);
	ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 2,
				  pi->pcie_gen_घातersaving.min,
				  pi->pcie_lane_घातersaving.max);
	ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 3,
				  pi->pcie_gen_perक्रमmance.min,
				  pi->pcie_lane_perक्रमmance.max);
	ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 4,
				  pi->pcie_gen_घातersaving.max,
				  pi->pcie_lane_घातersaving.max);
	ci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 5,
				  pi->pcie_gen_perक्रमmance.max,
				  pi->pcie_lane_perक्रमmance.max);

	pi->dpm_table.pcie_speed_table.count = 6;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_setup_शेष_dpm_tables(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_sclk_vddc_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;
	काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_mclk_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk;
	काष्ठा radeon_cac_leakage_table *std_voltage_table =
		&rdev->pm.dpm.dyn_state.cac_leakage_table;
	u32 i;

	अगर (allowed_sclk_vddc_table == शून्य)
		वापस -EINVAL;
	अगर (allowed_sclk_vddc_table->count < 1)
		वापस -EINVAL;
	अगर (allowed_mclk_table == शून्य)
		वापस -EINVAL;
	अगर (allowed_mclk_table->count < 1)
		वापस -EINVAL;

	स_रखो(&pi->dpm_table, 0, माप(काष्ठा ci_dpm_table));

	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.sclk_table,
				  SMU7_MAX_LEVELS_GRAPHICS);
	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.mclk_table,
				  SMU7_MAX_LEVELS_MEMORY);
	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.vddc_table,
				  SMU7_MAX_LEVELS_VDDC);
	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.vddci_table,
				  SMU7_MAX_LEVELS_VDDCI);
	ci_reset_single_dpm_table(rdev,
				  &pi->dpm_table.mvdd_table,
				  SMU7_MAX_LEVELS_MVDD);

	pi->dpm_table.sclk_table.count = 0;
	क्रम (i = 0; i < allowed_sclk_vddc_table->count; i++) अणु
		अगर ((i == 0) ||
		    (pi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count-1].value !=
		     allowed_sclk_vddc_table->entries[i].clk)) अणु
			pi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].value =
				allowed_sclk_vddc_table->entries[i].clk;
			pi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].enabled =
				(i == 0) ? true : false;
			pi->dpm_table.sclk_table.count++;
		पूर्ण
	पूर्ण

	pi->dpm_table.mclk_table.count = 0;
	क्रम (i = 0; i < allowed_mclk_table->count; i++) अणु
		अगर ((i == 0) ||
		    (pi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count-1].value !=
		     allowed_mclk_table->entries[i].clk)) अणु
			pi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].value =
				allowed_mclk_table->entries[i].clk;
			pi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].enabled =
				(i == 0) ? true : false;
			pi->dpm_table.mclk_table.count++;
		पूर्ण
	पूर्ण

	क्रम (i = 0; i < allowed_sclk_vddc_table->count; i++) अणु
		pi->dpm_table.vddc_table.dpm_levels[i].value =
			allowed_sclk_vddc_table->entries[i].v;
		pi->dpm_table.vddc_table.dpm_levels[i].param1 =
			std_voltage_table->entries[i].leakage;
		pi->dpm_table.vddc_table.dpm_levels[i].enabled = true;
	पूर्ण
	pi->dpm_table.vddc_table.count = allowed_sclk_vddc_table->count;

	allowed_mclk_table = &rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk;
	अगर (allowed_mclk_table) अणु
		क्रम (i = 0; i < allowed_mclk_table->count; i++) अणु
			pi->dpm_table.vddci_table.dpm_levels[i].value =
				allowed_mclk_table->entries[i].v;
			pi->dpm_table.vddci_table.dpm_levels[i].enabled = true;
		पूर्ण
		pi->dpm_table.vddci_table.count = allowed_mclk_table->count;
	पूर्ण

	allowed_mclk_table = &rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk;
	अगर (allowed_mclk_table) अणु
		क्रम (i = 0; i < allowed_mclk_table->count; i++) अणु
			pi->dpm_table.mvdd_table.dpm_levels[i].value =
				allowed_mclk_table->entries[i].v;
			pi->dpm_table.mvdd_table.dpm_levels[i].enabled = true;
		पूर्ण
		pi->dpm_table.mvdd_table.count = allowed_mclk_table->count;
	पूर्ण

	ci_setup_शेष_pcie_tables(rdev);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_find_boot_level(काष्ठा ci_single_dpm_table *table,
			      u32 value, u32 *boot_level)
अणु
	u32 i;
	पूर्णांक ret = -EINVAL;

	क्रम(i = 0; i < table->count; i++) अणु
		अगर (value == table->dpm_levels[i].value) अणु
			*boot_level = i;
			ret = 0;
		पूर्ण
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक ci_init_smc_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ulv_parm *ulv = &pi->ulv;
	काष्ठा radeon_ps *radeon_boot_state = rdev->pm.dpm.boot_ps;
	SMU7_Discrete_DpmTable *table = &pi->smc_state_table;
	पूर्णांक ret;

	ret = ci_setup_शेष_dpm_tables(rdev);
	अगर (ret)
		वापस ret;

	अगर (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE)
		ci_populate_smc_voltage_tables(rdev, table);

	ci_init_fps_limits(rdev);

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)
		table->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)
		table->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;

	अगर (pi->mem_gddr5)
		table->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;

	अगर (ulv->supported) अणु
		ret = ci_populate_ulv_state(rdev, &pi->smc_state_table.Ulv);
		अगर (ret)
			वापस ret;
		WREG32_SMC(CG_ULV_PARAMETER, ulv->cg_ulv_parameter);
	पूर्ण

	ret = ci_populate_all_graphic_levels(rdev);
	अगर (ret)
		वापस ret;

	ret = ci_populate_all_memory_levels(rdev);
	अगर (ret)
		वापस ret;

	ci_populate_smc_link_level(rdev, table);

	ret = ci_populate_smc_acpi_level(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_vce_level(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_acp_level(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_samu_level(rdev, table);
	अगर (ret)
		वापस ret;

	ret = ci_करो_program_memory_timing_parameters(rdev);
	अगर (ret)
		वापस ret;

	ret = ci_populate_smc_uvd_level(rdev, table);
	अगर (ret)
		वापस ret;

	table->UvdBootLevel  = 0;
	table->VceBootLevel  = 0;
	table->AcpBootLevel  = 0;
	table->SamuBootLevel  = 0;
	table->GraphicsBootLevel  = 0;
	table->MemoryBootLevel  = 0;

	ret = ci_find_boot_level(&pi->dpm_table.sclk_table,
				 pi->vbios_boot_state.sclk_bootup_value,
				 (u32 *)&pi->smc_state_table.GraphicsBootLevel);

	ret = ci_find_boot_level(&pi->dpm_table.mclk_table,
				 pi->vbios_boot_state.mclk_bootup_value,
				 (u32 *)&pi->smc_state_table.MemoryBootLevel);

	table->BootVddc = pi->vbios_boot_state.vddc_bootup_value;
	table->BootVddci = pi->vbios_boot_state.vddci_bootup_value;
	table->BootMVdd = pi->vbios_boot_state.mvdd_bootup_value;

	ci_populate_smc_initial_state(rdev, radeon_boot_state);

	ret = ci_populate_bapm_parameters_in_dpm_table(rdev);
	अगर (ret)
		वापस ret;

	table->UVDInterval = 1;
	table->VCEInterval = 1;
	table->ACPInterval = 1;
	table->SAMUInterval = 1;
	table->GraphicsVoltageChangeEnable = 1;
	table->GraphicsThermThrottleEnable = 1;
	table->GraphicsInterval = 1;
	table->VoltageInterval = 1;
	table->ThermalInterval = 1;
	table->TemperatureLimitHigh = (u16)((pi->thermal_temp_setting.temperature_high *
					     CISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);
	table->TemperatureLimitLow = (u16)((pi->thermal_temp_setting.temperature_low *
					    CISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);
	table->MemoryVoltageChangeEnable = 1;
	table->MemoryInterval = 1;
	table->VoltageResponseTime = 0;
	table->VddcVddciDelta = 4000;
	table->PhaseResponseTime = 0;
	table->MemoryThermThrottleEnable = 1;
	table->PCIeBootLinkLevel = pi->dpm_table.pcie_speed_table.count - 1;
	table->PCIeGenInterval = 1;
	अगर (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2)
		table->SVI2Enable  = 1;
	अन्यथा
		table->SVI2Enable  = 0;

	table->ThermGpio = 17;
	table->SclkStepSize = 0x4000;

	table->SystemFlags = cpu_to_be32(table->SystemFlags);
	table->SmioMaskVddcVid = cpu_to_be32(table->SmioMaskVddcVid);
	table->SmioMaskVddcPhase = cpu_to_be32(table->SmioMaskVddcPhase);
	table->SmioMaskVddciVid = cpu_to_be32(table->SmioMaskVddciVid);
	table->SmioMaskMvddVid = cpu_to_be32(table->SmioMaskMvddVid);
	table->SclkStepSize = cpu_to_be32(table->SclkStepSize);
	table->TemperatureLimitHigh = cpu_to_be16(table->TemperatureLimitHigh);
	table->TemperatureLimitLow = cpu_to_be16(table->TemperatureLimitLow);
	table->VddcVddciDelta = cpu_to_be16(table->VddcVddciDelta);
	table->VoltageResponseTime = cpu_to_be16(table->VoltageResponseTime);
	table->PhaseResponseTime = cpu_to_be16(table->PhaseResponseTime);
	table->BootVddc = cpu_to_be16(table->BootVddc * VOLTAGE_SCALE);
	table->BootVddci = cpu_to_be16(table->BootVddci * VOLTAGE_SCALE);
	table->BootMVdd = cpu_to_be16(table->BootMVdd * VOLTAGE_SCALE);

	ret = ci_copy_bytes_to_smc(rdev,
				   pi->dpm_table_start +
				   दुरत्व(SMU7_Discrete_DpmTable, SystemFlags),
				   (u8 *)&table->SystemFlags,
				   माप(SMU7_Discrete_DpmTable) - 3 * माप(SMU7_PIDController),
				   pi->sram_end);
	अगर (ret)
		वापस ret;

	वापस 0;
पूर्ण

अटल व्योम ci_trim_single_dpm_states(काष्ठा radeon_device *rdev,
				      काष्ठा ci_single_dpm_table *dpm_table,
				      u32 low_limit, u32 high_limit)
अणु
	u32 i;

	क्रम (i = 0; i < dpm_table->count; i++) अणु
		अगर ((dpm_table->dpm_levels[i].value < low_limit) ||
		    (dpm_table->dpm_levels[i].value > high_limit))
			dpm_table->dpm_levels[i].enabled = false;
		अन्यथा
			dpm_table->dpm_levels[i].enabled = true;
	पूर्ण
पूर्ण

अटल व्योम ci_trim_pcie_dpm_states(काष्ठा radeon_device *rdev,
				    u32 speed_low, u32 lanes_low,
				    u32 speed_high, u32 lanes_high)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_single_dpm_table *pcie_table = &pi->dpm_table.pcie_speed_table;
	u32 i, j;

	क्रम (i = 0; i < pcie_table->count; i++) अणु
		अगर ((pcie_table->dpm_levels[i].value < speed_low) ||
		    (pcie_table->dpm_levels[i].param1 < lanes_low) ||
		    (pcie_table->dpm_levels[i].value > speed_high) ||
		    (pcie_table->dpm_levels[i].param1 > lanes_high))
			pcie_table->dpm_levels[i].enabled = false;
		अन्यथा
			pcie_table->dpm_levels[i].enabled = true;
	पूर्ण

	क्रम (i = 0; i < pcie_table->count; i++) अणु
		अगर (pcie_table->dpm_levels[i].enabled) अणु
			क्रम (j = i + 1; j < pcie_table->count; j++) अणु
				अगर (pcie_table->dpm_levels[j].enabled) अणु
					अगर ((pcie_table->dpm_levels[i].value == pcie_table->dpm_levels[j].value) &&
					    (pcie_table->dpm_levels[i].param1 == pcie_table->dpm_levels[j].param1))
						pcie_table->dpm_levels[j].enabled = false;
				पूर्ण
			पूर्ण
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक ci_trim_dpm_states(काष्ठा radeon_device *rdev,
			      काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा ci_ps *state = ci_get_ps(radeon_state);
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 high_limit_count;

	अगर (state->perक्रमmance_level_count < 1)
		वापस -EINVAL;

	अगर (state->perक्रमmance_level_count == 1)
		high_limit_count = 0;
	अन्यथा
		high_limit_count = 1;

	ci_trim_single_dpm_states(rdev,
				  &pi->dpm_table.sclk_table,
				  state->perक्रमmance_levels[0].sclk,
				  state->perक्रमmance_levels[high_limit_count].sclk);

	ci_trim_single_dpm_states(rdev,
				  &pi->dpm_table.mclk_table,
				  state->perक्रमmance_levels[0].mclk,
				  state->perक्रमmance_levels[high_limit_count].mclk);

	ci_trim_pcie_dpm_states(rdev,
				state->perक्रमmance_levels[0].pcie_gen,
				state->perक्रमmance_levels[0].pcie_lane,
				state->perक्रमmance_levels[high_limit_count].pcie_gen,
				state->perक्रमmance_levels[high_limit_count].pcie_lane);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_apply_disp_minimum_voltage_request(काष्ठा radeon_device *rdev)
अणु
	काष्ठा radeon_घड़ी_voltage_dependency_table *disp_voltage_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk;
	काष्ठा radeon_घड़ी_voltage_dependency_table *vddc_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;
	u32 requested_voltage = 0;
	u32 i;

	अगर (disp_voltage_table == शून्य)
		वापस -EINVAL;
	अगर (!disp_voltage_table->count)
		वापस -EINVAL;

	क्रम (i = 0; i < disp_voltage_table->count; i++) अणु
		अगर (rdev->घड़ी.current_dispclk == disp_voltage_table->entries[i].clk)
			requested_voltage = disp_voltage_table->entries[i].v;
	पूर्ण

	क्रम (i = 0; i < vddc_table->count; i++) अणु
		अगर (requested_voltage <= vddc_table->entries[i].v) अणु
			requested_voltage = vddc_table->entries[i].v;
			वापस (ci_send_msg_to_smc_with_parameter(rdev,
								  PPSMC_MSG_VddC_Request,
								  requested_voltage * VOLTAGE_SCALE) == PPSMC_Result_OK) ?
				0 : -EINVAL;
		पूर्ण
	पूर्ण

	वापस -EINVAL;
पूर्ण

अटल पूर्णांक ci_upload_dpm_level_enable_mask(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	PPSMC_Result result;

	ci_apply_disp_minimum_voltage_request(rdev);

	अगर (!pi->sclk_dpm_key_disabled) अणु
		अगर (pi->dpm_level_enable_mask.sclk_dpm_enable_mask) अणु
			result = ci_send_msg_to_smc_with_parameter(rdev,
								   PPSMC_MSG_SCLKDPM_SetEnabledMask,
								   pi->dpm_level_enable_mask.sclk_dpm_enable_mask);
			अगर (result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण

	अगर (!pi->mclk_dpm_key_disabled) अणु
		अगर (pi->dpm_level_enable_mask.mclk_dpm_enable_mask) अणु
			result = ci_send_msg_to_smc_with_parameter(rdev,
								   PPSMC_MSG_MCLKDPM_SetEnabledMask,
								   pi->dpm_level_enable_mask.mclk_dpm_enable_mask);
			अगर (result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण
#अगर 0
	अगर (!pi->pcie_dpm_key_disabled) अणु
		अगर (pi->dpm_level_enable_mask.pcie_dpm_enable_mask) अणु
			result = ci_send_msg_to_smc_with_parameter(rdev,
								   PPSMC_MSG_PCIeDPM_SetEnabledMask,
								   pi->dpm_level_enable_mask.pcie_dpm_enable_mask);
			अगर (result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
	पूर्ण
#पूर्ण_अगर
	वापस 0;
पूर्ण

अटल व्योम ci_find_dpm_states_घड़ीs_in_dpm_table(काष्ठा radeon_device *rdev,
						   काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ps *state = ci_get_ps(radeon_state);
	काष्ठा ci_single_dpm_table *sclk_table = &pi->dpm_table.sclk_table;
	u32 sclk = state->perक्रमmance_levels[state->perक्रमmance_level_count-1].sclk;
	काष्ठा ci_single_dpm_table *mclk_table = &pi->dpm_table.mclk_table;
	u32 mclk = state->perक्रमmance_levels[state->perक्रमmance_level_count-1].mclk;
	u32 i;

	pi->need_update_smu7_dpm_table = 0;

	क्रम (i = 0; i < sclk_table->count; i++) अणु
		अगर (sclk == sclk_table->dpm_levels[i].value)
			अवरोध;
	पूर्ण

	अगर (i >= sclk_table->count) अणु
		pi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_SCLK;
	पूर्ण अन्यथा अणु
		/* XXX The current code always reprogrammed the sclk levels,
		 * but we करोn't currently handle disp sclk requirements
		 * so just skip it.
		 */
		अगर (CISLAND_MINIMUM_ENGINE_CLOCK != CISLAND_MINIMUM_ENGINE_CLOCK)
			pi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_SCLK;
	पूर्ण

	क्रम (i = 0; i < mclk_table->count; i++) अणु
		अगर (mclk == mclk_table->dpm_levels[i].value)
			अवरोध;
	पूर्ण

	अगर (i >= mclk_table->count)
		pi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_MCLK;

	अगर (rdev->pm.dpm.current_active_crtc_count !=
	    rdev->pm.dpm.new_active_crtc_count)
		pi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_MCLK;
पूर्ण

अटल पूर्णांक ci_populate_and_upload_sclk_mclk_dpm_levels(काष्ठा radeon_device *rdev,
						       काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ps *state = ci_get_ps(radeon_state);
	u32 sclk = state->perक्रमmance_levels[state->perक्रमmance_level_count-1].sclk;
	u32 mclk = state->perक्रमmance_levels[state->perक्रमmance_level_count-1].mclk;
	काष्ठा ci_dpm_table *dpm_table = &pi->dpm_table;
	पूर्णांक ret;

	अगर (!pi->need_update_smu7_dpm_table)
		वापस 0;

	अगर (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_SCLK)
		dpm_table->sclk_table.dpm_levels[dpm_table->sclk_table.count-1].value = sclk;

	अगर (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)
		dpm_table->mclk_table.dpm_levels[dpm_table->mclk_table.count-1].value = mclk;

	अगर (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK)) अणु
		ret = ci_populate_all_graphic_levels(rdev);
		अगर (ret)
			वापस ret;
	पूर्ण

	अगर (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_MCLK | DPMTABLE_UPDATE_MCLK)) अणु
		ret = ci_populate_all_memory_levels(rdev);
		अगर (ret)
			वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_enable_uvd_dpm(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	पूर्णांक i;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (enable) अणु
		pi->dpm_level_enable_mask.uvd_dpm_enable_mask = 0;

		क्रम (i = rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.count - 1; i >= 0; i--) अणु
			अगर (rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.entries[i].v <= max_limits->vddc) अणु
				pi->dpm_level_enable_mask.uvd_dpm_enable_mask |= 1 << i;

				अगर (!pi->caps_uvd_dpm)
					अवरोध;
			पूर्ण
		पूर्ण

		ci_send_msg_to_smc_with_parameter(rdev,
						  PPSMC_MSG_UVDDPM_SetEnabledMask,
						  pi->dpm_level_enable_mask.uvd_dpm_enable_mask);

		अगर (pi->last_mclk_dpm_enable_mask & 0x1) अणु
			pi->uvd_enabled = true;
			pi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;
			ci_send_msg_to_smc_with_parameter(rdev,
							  PPSMC_MSG_MCLKDPM_SetEnabledMask,
							  pi->dpm_level_enable_mask.mclk_dpm_enable_mask);
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (pi->last_mclk_dpm_enable_mask & 0x1) अणु
			pi->uvd_enabled = false;
			pi->dpm_level_enable_mask.mclk_dpm_enable_mask |= 1;
			ci_send_msg_to_smc_with_parameter(rdev,
							  PPSMC_MSG_MCLKDPM_SetEnabledMask,
							  pi->dpm_level_enable_mask.mclk_dpm_enable_mask);
		पूर्ण
	पूर्ण

	वापस (ci_send_msg_to_smc(rdev, enable ?
				   PPSMC_MSG_UVDDPM_Enable : PPSMC_MSG_UVDDPM_Disable) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण

अटल पूर्णांक ci_enable_vce_dpm(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	पूर्णांक i;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (enable) अणु
		pi->dpm_level_enable_mask.vce_dpm_enable_mask = 0;
		क्रम (i = rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table.count - 1; i >= 0; i--) अणु
			अगर (rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table.entries[i].v <= max_limits->vddc) अणु
				pi->dpm_level_enable_mask.vce_dpm_enable_mask |= 1 << i;

				अगर (!pi->caps_vce_dpm)
					अवरोध;
			पूर्ण
		पूर्ण

		ci_send_msg_to_smc_with_parameter(rdev,
						  PPSMC_MSG_VCEDPM_SetEnabledMask,
						  pi->dpm_level_enable_mask.vce_dpm_enable_mask);
	पूर्ण

	वापस (ci_send_msg_to_smc(rdev, enable ?
				   PPSMC_MSG_VCEDPM_Enable : PPSMC_MSG_VCEDPM_Disable) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण

#अगर 0
अटल पूर्णांक ci_enable_samu_dpm(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	पूर्णांक i;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (enable) अणु
		pi->dpm_level_enable_mask.samu_dpm_enable_mask = 0;
		क्रम (i = rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table.count - 1; i >= 0; i--) अणु
			अगर (rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table.entries[i].v <= max_limits->vddc) अणु
				pi->dpm_level_enable_mask.samu_dpm_enable_mask |= 1 << i;

				अगर (!pi->caps_samu_dpm)
					अवरोध;
			पूर्ण
		पूर्ण

		ci_send_msg_to_smc_with_parameter(rdev,
						  PPSMC_MSG_SAMUDPM_SetEnabledMask,
						  pi->dpm_level_enable_mask.samu_dpm_enable_mask);
	पूर्ण
	वापस (ci_send_msg_to_smc(rdev, enable ?
				   PPSMC_MSG_SAMUDPM_Enable : PPSMC_MSG_SAMUDPM_Disable) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण

अटल पूर्णांक ci_enable_acp_dpm(काष्ठा radeon_device *rdev, bool enable)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	स्थिर काष्ठा radeon_घड़ी_and_voltage_limits *max_limits;
	पूर्णांक i;

	अगर (rdev->pm.dpm.ac_घातer)
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;
	अन्यथा
		max_limits = &rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc;

	अगर (enable) अणु
		pi->dpm_level_enable_mask.acp_dpm_enable_mask = 0;
		क्रम (i = rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table.count - 1; i >= 0; i--) अणु
			अगर (rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table.entries[i].v <= max_limits->vddc) अणु
				pi->dpm_level_enable_mask.acp_dpm_enable_mask |= 1 << i;

				अगर (!pi->caps_acp_dpm)
					अवरोध;
			पूर्ण
		पूर्ण

		ci_send_msg_to_smc_with_parameter(rdev,
						  PPSMC_MSG_ACPDPM_SetEnabledMask,
						  pi->dpm_level_enable_mask.acp_dpm_enable_mask);
	पूर्ण

	वापस (ci_send_msg_to_smc(rdev, enable ?
				   PPSMC_MSG_ACPDPM_Enable : PPSMC_MSG_ACPDPM_Disable) == PPSMC_Result_OK) ?
		0 : -EINVAL;
पूर्ण
#पूर्ण_अगर

अटल पूर्णांक ci_update_uvd_dpm(काष्ठा radeon_device *rdev, bool gate)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (!gate) अणु
		अगर (pi->caps_uvd_dpm ||
		    (rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.count <= 0))
			pi->smc_state_table.UvdBootLevel = 0;
		अन्यथा
			pi->smc_state_table.UvdBootLevel =
				rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table.count - 1;

		पंचांगp = RREG32_SMC(DPM_TABLE_475);
		पंचांगp &= ~UvdBootLevel_MASK;
		पंचांगp |= UvdBootLevel(pi->smc_state_table.UvdBootLevel);
		WREG32_SMC(DPM_TABLE_475, पंचांगp);
	पूर्ण

	वापस ci_enable_uvd_dpm(rdev, !gate);
पूर्ण

अटल u8 ci_get_vce_boot_level(काष्ठा radeon_device *rdev)
अणु
	u8 i;
	u32 min_evclk = 30000; /* ??? */
	काष्ठा radeon_vce_घड़ी_voltage_dependency_table *table =
		&rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table;

	क्रम (i = 0; i < table->count; i++) अणु
		अगर (table->entries[i].evclk >= min_evclk)
			वापस i;
	पूर्ण

	वापस table->count - 1;
पूर्ण

अटल पूर्णांक ci_update_vce_dpm(काष्ठा radeon_device *rdev,
			     काष्ठा radeon_ps *radeon_new_state,
			     काष्ठा radeon_ps *radeon_current_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret = 0;
	u32 पंचांगp;

	अगर (radeon_current_state->evclk != radeon_new_state->evclk) अणु
		अगर (radeon_new_state->evclk) अणु
			/* turn the घड़ीs on when encoding */
			cik_update_cg(rdev, RADEON_CG_BLOCK_VCE, false);

			pi->smc_state_table.VceBootLevel = ci_get_vce_boot_level(rdev);
			पंचांगp = RREG32_SMC(DPM_TABLE_475);
			पंचांगp &= ~VceBootLevel_MASK;
			पंचांगp |= VceBootLevel(pi->smc_state_table.VceBootLevel);
			WREG32_SMC(DPM_TABLE_475, पंचांगp);

			ret = ci_enable_vce_dpm(rdev, true);
		पूर्ण अन्यथा अणु
			/* turn the घड़ीs off when not encoding */
			cik_update_cg(rdev, RADEON_CG_BLOCK_VCE, true);

			ret = ci_enable_vce_dpm(rdev, false);
		पूर्ण
	पूर्ण
	वापस ret;
पूर्ण

#अगर 0
अटल पूर्णांक ci_update_samu_dpm(काष्ठा radeon_device *rdev, bool gate)
अणु
	वापस ci_enable_samu_dpm(rdev, gate);
पूर्ण

अटल पूर्णांक ci_update_acp_dpm(काष्ठा radeon_device *rdev, bool gate)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	अगर (!gate) अणु
		pi->smc_state_table.AcpBootLevel = 0;

		पंचांगp = RREG32_SMC(DPM_TABLE_475);
		पंचांगp &= ~AcpBootLevel_MASK;
		पंचांगp |= AcpBootLevel(pi->smc_state_table.AcpBootLevel);
		WREG32_SMC(DPM_TABLE_475, पंचांगp);
	पूर्ण

	वापस ci_enable_acp_dpm(rdev, !gate);
पूर्ण
#पूर्ण_अगर

अटल पूर्णांक ci_generate_dpm_level_enable_mask(काष्ठा radeon_device *rdev,
					     काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;

	ret = ci_trim_dpm_states(rdev, radeon_state);
	अगर (ret)
		वापस ret;

	pi->dpm_level_enable_mask.sclk_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&pi->dpm_table.sclk_table);
	pi->dpm_level_enable_mask.mclk_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&pi->dpm_table.mclk_table);
	pi->last_mclk_dpm_enable_mask =
		pi->dpm_level_enable_mask.mclk_dpm_enable_mask;
	अगर (pi->uvd_enabled) अणु
		अगर (pi->dpm_level_enable_mask.mclk_dpm_enable_mask & 1)
			pi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;
	पूर्ण
	pi->dpm_level_enable_mask.pcie_dpm_enable_mask =
		ci_get_dpm_level_enable_mask_value(&pi->dpm_table.pcie_speed_table);

	वापस 0;
पूर्ण

अटल u32 ci_get_lowest_enabled_level(काष्ठा radeon_device *rdev,
				       u32 level_mask)
अणु
	u32 level = 0;

	जबतक ((level_mask & (1 << level)) == 0)
		level++;

	वापस level;
पूर्ण


पूर्णांक ci_dpm_क्रमce_perक्रमmance_level(काष्ठा radeon_device *rdev,
				   क्रमागत radeon_dpm_क्रमced_level level)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp, levels, i;
	पूर्णांक ret;

	अगर (level == RADEON_DPM_FORCED_LEVEL_HIGH) अणु
		अगर ((!pi->pcie_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.pcie_dpm_enable_mask) अणु
			levels = 0;
			पंचांगp = pi->dpm_level_enable_mask.pcie_dpm_enable_mask;
			जबतक (पंचांगp >>= 1)
				levels++;
			अगर (levels) अणु
				ret = ci_dpm_क्रमce_state_pcie(rdev, level);
				अगर (ret)
					वापस ret;
				क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
					पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX_1) &
					       CURR_PCIE_INDEX_MASK) >> CURR_PCIE_INDEX_SHIFT;
					अगर (पंचांगp == levels)
						अवरोध;
					udelay(1);
				पूर्ण
			पूर्ण
		पूर्ण
		अगर ((!pi->sclk_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.sclk_dpm_enable_mask) अणु
			levels = 0;
			पंचांगp = pi->dpm_level_enable_mask.sclk_dpm_enable_mask;
			जबतक (पंचांगp >>= 1)
				levels++;
			अगर (levels) अणु
				ret = ci_dpm_क्रमce_state_sclk(rdev, levels);
				अगर (ret)
					वापस ret;
				क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
					पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX) &
					       CURR_SCLK_INDEX_MASK) >> CURR_SCLK_INDEX_SHIFT;
					अगर (पंचांगp == levels)
						अवरोध;
					udelay(1);
				पूर्ण
			पूर्ण
		पूर्ण
		अगर ((!pi->mclk_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.mclk_dpm_enable_mask) अणु
			levels = 0;
			पंचांगp = pi->dpm_level_enable_mask.mclk_dpm_enable_mask;
			जबतक (पंचांगp >>= 1)
				levels++;
			अगर (levels) अणु
				ret = ci_dpm_क्रमce_state_mclk(rdev, levels);
				अगर (ret)
					वापस ret;
				क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
					पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX) &
					       CURR_MCLK_INDEX_MASK) >> CURR_MCLK_INDEX_SHIFT;
					अगर (पंचांगp == levels)
						अवरोध;
					udelay(1);
				पूर्ण
			पूर्ण
		पूर्ण
	पूर्ण अन्यथा अगर (level == RADEON_DPM_FORCED_LEVEL_LOW) अणु
		अगर ((!pi->sclk_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.sclk_dpm_enable_mask) अणु
			levels = ci_get_lowest_enabled_level(rdev,
							     pi->dpm_level_enable_mask.sclk_dpm_enable_mask);
			ret = ci_dpm_क्रमce_state_sclk(rdev, levels);
			अगर (ret)
				वापस ret;
			क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
				पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX) &
				       CURR_SCLK_INDEX_MASK) >> CURR_SCLK_INDEX_SHIFT;
				अगर (पंचांगp == levels)
					अवरोध;
				udelay(1);
			पूर्ण
		पूर्ण
		अगर ((!pi->mclk_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.mclk_dpm_enable_mask) अणु
			levels = ci_get_lowest_enabled_level(rdev,
							     pi->dpm_level_enable_mask.mclk_dpm_enable_mask);
			ret = ci_dpm_क्रमce_state_mclk(rdev, levels);
			अगर (ret)
				वापस ret;
			क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
				पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX) &
				       CURR_MCLK_INDEX_MASK) >> CURR_MCLK_INDEX_SHIFT;
				अगर (पंचांगp == levels)
					अवरोध;
				udelay(1);
			पूर्ण
		पूर्ण
		अगर ((!pi->pcie_dpm_key_disabled) &&
		    pi->dpm_level_enable_mask.pcie_dpm_enable_mask) अणु
			levels = ci_get_lowest_enabled_level(rdev,
							     pi->dpm_level_enable_mask.pcie_dpm_enable_mask);
			ret = ci_dpm_क्रमce_state_pcie(rdev, levels);
			अगर (ret)
				वापस ret;
			क्रम (i = 0; i < rdev->usec_समयout; i++) अणु
				पंचांगp = (RREG32_SMC(TARGET_AND_CURRENT_PROखाता_INDEX_1) &
				       CURR_PCIE_INDEX_MASK) >> CURR_PCIE_INDEX_SHIFT;
				अगर (पंचांगp == levels)
					अवरोध;
				udelay(1);
			पूर्ण
		पूर्ण
	पूर्ण अन्यथा अगर (level == RADEON_DPM_FORCED_LEVEL_AUTO) अणु
		अगर (!pi->pcie_dpm_key_disabled) अणु
			PPSMC_Result smc_result;

			smc_result = ci_send_msg_to_smc(rdev,
							PPSMC_MSG_PCIeDPM_UnForceLevel);
			अगर (smc_result != PPSMC_Result_OK)
				वापस -EINVAL;
		पूर्ण
		ret = ci_upload_dpm_level_enable_mask(rdev);
		अगर (ret)
			वापस ret;
	पूर्ण

	rdev->pm.dpm.क्रमced_level = level;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_mc_special_रेजिस्टरs(काष्ठा radeon_device *rdev,
				       काष्ठा ci_mc_reg_table *table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u8 i, j, k;
	u32 temp_reg;

	क्रम (i = 0, j = table->last; i < table->last; i++) अणु
		अगर (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
			वापस -EINVAL;
		चयन(table->mc_reg_address[i].s1 << 2) अणु
		हाल MC_SEQ_MISC1:
			temp_reg = RREG32(MC_PMG_CMD_EMRS);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					((temp_reg & 0xffff0000)) | ((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);
			पूर्ण
			j++;
			अगर (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;

			temp_reg = RREG32(MC_PMG_CMD_MRS);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_MRS >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);
				अगर (!pi->mem_gddr5)
					table->mc_reg_table_entry[k].mc_data[j] |= 0x100;
			पूर्ण
			j++;
			अगर (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;

			अगर (!pi->mem_gddr5) अणु
				table->mc_reg_address[j].s1 = MC_PMG_AUTO_CMD >> 2;
				table->mc_reg_address[j].s0 = MC_PMG_AUTO_CMD >> 2;
				क्रम (k = 0; k < table->num_entries; k++) अणु
					table->mc_reg_table_entry[k].mc_data[j] =
						(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;
				पूर्ण
				j++;
				अगर (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
					वापस -EINVAL;
			पूर्ण
			अवरोध;
		हाल MC_SEQ_RESERVE_M:
			temp_reg = RREG32(MC_PMG_CMD_MRS1);
			table->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1 >> 2;
			table->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);
			पूर्ण
			j++;
			अगर (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			अवरोध;
		शेष:
			अवरोध;
		पूर्ण

	पूर्ण

	table->last = j;

	वापस 0;
पूर्ण

अटल bool ci_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)
अणु
	bool result = true;

	चयन(in_reg) अणु
	हाल MC_SEQ_RAS_TIMING >> 2:
		*out_reg = MC_SEQ_RAS_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_DLL_STBY >> 2:
		*out_reg = MC_SEQ_DLL_STBY_LP >> 2;
		अवरोध;
	हाल MC_SEQ_G5PDX_CMD0 >> 2:
		*out_reg = MC_SEQ_G5PDX_CMD0_LP >> 2;
		अवरोध;
	हाल MC_SEQ_G5PDX_CMD1 >> 2:
		*out_reg = MC_SEQ_G5PDX_CMD1_LP >> 2;
		अवरोध;
	हाल MC_SEQ_G5PDX_CTRL >> 2:
		*out_reg = MC_SEQ_G5PDX_CTRL_LP >> 2;
		अवरोध;
	हाल MC_SEQ_CAS_TIMING >> 2:
		*out_reg = MC_SEQ_CAS_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_MISC_TIMING >> 2:
		*out_reg = MC_SEQ_MISC_TIMING_LP >> 2;
		अवरोध;
	हाल MC_SEQ_MISC_TIMING2 >> 2:
		*out_reg = MC_SEQ_MISC_TIMING2_LP >> 2;
		अवरोध;
	हाल MC_SEQ_PMG_DVS_CMD >> 2:
		*out_reg = MC_SEQ_PMG_DVS_CMD_LP >> 2;
		अवरोध;
	हाल MC_SEQ_PMG_DVS_CTL >> 2:
		*out_reg = MC_SEQ_PMG_DVS_CTL_LP >> 2;
		अवरोध;
	हाल MC_SEQ_RD_CTL_D0 >> 2:
		*out_reg = MC_SEQ_RD_CTL_D0_LP >> 2;
		अवरोध;
	हाल MC_SEQ_RD_CTL_D1 >> 2:
		*out_reg = MC_SEQ_RD_CTL_D1_LP >> 2;
		अवरोध;
	हाल MC_SEQ_WR_CTL_D0 >> 2:
		*out_reg = MC_SEQ_WR_CTL_D0_LP >> 2;
		अवरोध;
	हाल MC_SEQ_WR_CTL_D1 >> 2:
		*out_reg = MC_SEQ_WR_CTL_D1_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_EMRS >> 2:
		*out_reg = MC_SEQ_PMG_CMD_EMRS_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS1 >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS1_LP >> 2;
		अवरोध;
	हाल MC_SEQ_PMG_TIMING >> 2:
		*out_reg = MC_SEQ_PMG_TIMING_LP >> 2;
		अवरोध;
	हाल MC_PMG_CMD_MRS2 >> 2:
		*out_reg = MC_SEQ_PMG_CMD_MRS2_LP >> 2;
		अवरोध;
	हाल MC_SEQ_WR_CTL_2 >> 2:
		*out_reg = MC_SEQ_WR_CTL_2_LP >> 2;
		अवरोध;
	शेष:
		result = false;
		अवरोध;
	पूर्ण

	वापस result;
पूर्ण

अटल व्योम ci_set_valid_flag(काष्ठा ci_mc_reg_table *table)
अणु
	u8 i, j;

	क्रम (i = 0; i < table->last; i++) अणु
		क्रम (j = 1; j < table->num_entries; j++) अणु
			अगर (table->mc_reg_table_entry[j-1].mc_data[i] !=
			    table->mc_reg_table_entry[j].mc_data[i]) अणु
				table->valid_flag |= 1 << i;
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_set_s0_mc_reg_index(काष्ठा ci_mc_reg_table *table)
अणु
	u32 i;
	u16 address;

	क्रम (i = 0; i < table->last; i++) अणु
		table->mc_reg_address[i].s0 =
			ci_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?
			address : table->mc_reg_address[i].s1;
	पूर्ण
पूर्ण

अटल पूर्णांक ci_copy_vbios_mc_reg_table(स्थिर काष्ठा atom_mc_reg_table *table,
				      काष्ठा ci_mc_reg_table *ci_table)
अणु
	u8 i, j;

	अगर (table->last > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
		वापस -EINVAL;
	अगर (table->num_entries > MAX_AC_TIMING_ENTRIES)
		वापस -EINVAL;

	क्रम (i = 0; i < table->last; i++)
		ci_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;

	ci_table->last = table->last;

	क्रम (i = 0; i < table->num_entries; i++) अणु
		ci_table->mc_reg_table_entry[i].mclk_max =
			table->mc_reg_table_entry[i].mclk_max;
		क्रम (j = 0; j < table->last; j++)
			ci_table->mc_reg_table_entry[i].mc_data[j] =
				table->mc_reg_table_entry[i].mc_data[j];
	पूर्ण
	ci_table->num_entries = table->num_entries;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_रेजिस्टर_patching_mc_seq(काष्ठा radeon_device *rdev,
				       काष्ठा ci_mc_reg_table *table)
अणु
	u8 i, k;
	u32 पंचांगp;
	bool patch;

	पंचांगp = RREG32(MC_SEQ_MISC0);
	patch = ((पंचांगp & 0x0000f00) == 0x300) ? true : false;

	अगर (patch &&
	    ((rdev->pdev->device == 0x67B0) ||
	     (rdev->pdev->device == 0x67B1))) अणु
		क्रम (i = 0; i < table->last; i++) अणु
			अगर (table->last >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			चयन(table->mc_reg_address[i].s1 >> 2) अणु
			हाल MC_SEQ_MISC1:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर ((table->mc_reg_table_entry[k].mclk_max == 125000) ||
					    (table->mc_reg_table_entry[k].mclk_max == 137500))
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFF8) |
							0x00000007;
				पूर्ण
				अवरोध;
			हाल MC_SEQ_WR_CTL_D0:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर ((table->mc_reg_table_entry[k].mclk_max == 125000) ||
					    (table->mc_reg_table_entry[k].mclk_max == 137500))
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |
							0x0000D0DD;
				पूर्ण
				अवरोध;
			हाल MC_SEQ_WR_CTL_D1:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर ((table->mc_reg_table_entry[k].mclk_max == 125000) ||
					    (table->mc_reg_table_entry[k].mclk_max == 137500))
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |
							0x0000D0DD;
				पूर्ण
				अवरोध;
			हाल MC_SEQ_WR_CTL_2:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर ((table->mc_reg_table_entry[k].mclk_max == 125000) ||
					    (table->mc_reg_table_entry[k].mclk_max == 137500))
						table->mc_reg_table_entry[k].mc_data[i] = 0;
				पूर्ण
				अवरोध;
			हाल MC_SEQ_CAS_TIMING:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर (table->mc_reg_table_entry[k].mclk_max == 125000)
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |
							0x000C0140;
					अन्यथा अगर (table->mc_reg_table_entry[k].mclk_max == 137500)
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |
							0x000C0150;
				पूर्ण
				अवरोध;
			हाल MC_SEQ_MISC_TIMING:
				क्रम (k = 0; k < table->num_entries; k++) अणु
					अगर (table->mc_reg_table_entry[k].mclk_max == 125000)
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |
							0x00000030;
					अन्यथा अगर (table->mc_reg_table_entry[k].mclk_max == 137500)
						table->mc_reg_table_entry[k].mc_data[i] =
							(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |
							0x00000035;
				पूर्ण
				अवरोध;
			शेष:
				अवरोध;
			पूर्ण
		पूर्ण

		WREG32(MC_SEQ_IO_DEBUG_INDEX, 3);
		पंचांगp = RREG32(MC_SEQ_IO_DEBUG_DATA);
		पंचांगp = (पंचांगp & 0xFFF8FFFF) | (1 << 16);
		WREG32(MC_SEQ_IO_DEBUG_INDEX, 3);
		WREG32(MC_SEQ_IO_DEBUG_DATA, पंचांगp);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_initialize_mc_reg_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा atom_mc_reg_table *table;
	काष्ठा ci_mc_reg_table *ci_table = &pi->mc_reg_table;
	u8 module_index = rv770_get_memory_module_index(rdev);
	पूर्णांक ret;

	table = kzalloc(माप(काष्ठा atom_mc_reg_table), GFP_KERNEL);
	अगर (!table)
		वापस -ENOMEM;

	WREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));
	WREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));
	WREG32(MC_SEQ_DLL_STBY_LP, RREG32(MC_SEQ_DLL_STBY));
	WREG32(MC_SEQ_G5PDX_CMD0_LP, RREG32(MC_SEQ_G5PDX_CMD0));
	WREG32(MC_SEQ_G5PDX_CMD1_LP, RREG32(MC_SEQ_G5PDX_CMD1));
	WREG32(MC_SEQ_G5PDX_CTRL_LP, RREG32(MC_SEQ_G5PDX_CTRL));
	WREG32(MC_SEQ_PMG_DVS_CMD_LP, RREG32(MC_SEQ_PMG_DVS_CMD));
	WREG32(MC_SEQ_PMG_DVS_CTL_LP, RREG32(MC_SEQ_PMG_DVS_CTL));
	WREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));
	WREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));
	WREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));
	WREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));
	WREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));
	WREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));
	WREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));
	WREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));
	WREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));
	WREG32(MC_SEQ_PMG_TIMING_LP, RREG32(MC_SEQ_PMG_TIMING));
	WREG32(MC_SEQ_PMG_CMD_MRS2_LP, RREG32(MC_PMG_CMD_MRS2));
	WREG32(MC_SEQ_WR_CTL_2_LP, RREG32(MC_SEQ_WR_CTL_2));

	ret = radeon_atom_init_mc_reg_table(rdev, module_index, table);
	अगर (ret)
		जाओ init_mc_करोne;

	ret = ci_copy_vbios_mc_reg_table(table, ci_table);
	अगर (ret)
		जाओ init_mc_करोne;

	ci_set_s0_mc_reg_index(ci_table);

	ret = ci_रेजिस्टर_patching_mc_seq(rdev, ci_table);
	अगर (ret)
		जाओ init_mc_करोne;

	ret = ci_set_mc_special_रेजिस्टरs(rdev, ci_table);
	अगर (ret)
		जाओ init_mc_करोne;

	ci_set_valid_flag(ci_table);

init_mc_करोne:
	kमुक्त(table);

	वापस ret;
पूर्ण

अटल पूर्णांक ci_populate_mc_reg_addresses(काष्ठा radeon_device *rdev,
					SMU7_Discrete_MCRegisters *mc_reg_table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 i, j;

	क्रम (i = 0, j = 0; j < pi->mc_reg_table.last; j++) अणु
		अगर (pi->mc_reg_table.valid_flag & (1 << j)) अणु
			अगर (i >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)
				वापस -EINVAL;
			mc_reg_table->address[i].s0 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s0);
			mc_reg_table->address[i].s1 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s1);
			i++;
		पूर्ण
	पूर्ण

	mc_reg_table->last = (u8)i;

	वापस 0;
पूर्ण

अटल व्योम ci_convert_mc_रेजिस्टरs(स्थिर काष्ठा ci_mc_reg_entry *entry,
				    SMU7_Discrete_MCRegisterSet *data,
				    u32 num_entries, u32 valid_flag)
अणु
	u32 i, j;

	क्रम (i = 0, j = 0; j < num_entries; j++) अणु
		अगर (valid_flag & (1 << j)) अणु
			data->value[i] = cpu_to_be32(entry->mc_data[j]);
			i++;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_convert_mc_reg_table_entry_to_smc(काष्ठा radeon_device *rdev,
						 स्थिर u32 memory_घड़ी,
						 SMU7_Discrete_MCRegisterSet *mc_reg_table_data)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 i = 0;

	क्रम(i = 0; i < pi->mc_reg_table.num_entries; i++) अणु
		अगर (memory_घड़ी <= pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)
			अवरोध;
	पूर्ण

	अगर ((i == pi->mc_reg_table.num_entries) && (i > 0))
		--i;

	ci_convert_mc_रेजिस्टरs(&pi->mc_reg_table.mc_reg_table_entry[i],
				mc_reg_table_data, pi->mc_reg_table.last,
				pi->mc_reg_table.valid_flag);
पूर्ण

अटल व्योम ci_convert_mc_reg_table_to_smc(काष्ठा radeon_device *rdev,
					   SMU7_Discrete_MCRegisters *mc_reg_table)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 i;

	क्रम (i = 0; i < pi->dpm_table.mclk_table.count; i++)
		ci_convert_mc_reg_table_entry_to_smc(rdev,
						     pi->dpm_table.mclk_table.dpm_levels[i].value,
						     &mc_reg_table->data[i]);
पूर्ण

अटल पूर्णांक ci_populate_initial_mc_reg_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	पूर्णांक ret;

	स_रखो(&pi->smc_mc_reg_table, 0, माप(SMU7_Discrete_MCRegisters));

	ret = ci_populate_mc_reg_addresses(rdev, &pi->smc_mc_reg_table);
	अगर (ret)
		वापस ret;
	ci_convert_mc_reg_table_to_smc(rdev, &pi->smc_mc_reg_table);

	वापस ci_copy_bytes_to_smc(rdev,
				    pi->mc_reg_table_start,
				    (u8 *)&pi->smc_mc_reg_table,
				    माप(SMU7_Discrete_MCRegisters),
				    pi->sram_end);
पूर्ण

अटल पूर्णांक ci_update_and_upload_mc_reg_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	अगर (!(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))
		वापस 0;

	स_रखो(&pi->smc_mc_reg_table, 0, माप(SMU7_Discrete_MCRegisters));

	ci_convert_mc_reg_table_to_smc(rdev, &pi->smc_mc_reg_table);

	वापस ci_copy_bytes_to_smc(rdev,
				    pi->mc_reg_table_start +
				    दुरत्व(SMU7_Discrete_MCRegisters, data[0]),
				    (u8 *)&pi->smc_mc_reg_table.data[0],
				    माप(SMU7_Discrete_MCRegisterSet) *
				    pi->dpm_table.mclk_table.count,
				    pi->sram_end);
पूर्ण

अटल व्योम ci_enable_voltage_control(काष्ठा radeon_device *rdev)
अणु
	u32 पंचांगp = RREG32_SMC(GENERAL_PWRMGT);

	पंचांगp |= VOLT_PWRMGT_EN;
	WREG32_SMC(GENERAL_PWRMGT, पंचांगp);
पूर्ण

अटल क्रमागत radeon_pcie_gen ci_get_maximum_link_speed(काष्ठा radeon_device *rdev,
						      काष्ठा radeon_ps *radeon_state)
अणु
	काष्ठा ci_ps *state = ci_get_ps(radeon_state);
	पूर्णांक i;
	u16 pcie_speed, max_speed = 0;

	क्रम (i = 0; i < state->perक्रमmance_level_count; i++) अणु
		pcie_speed = state->perक्रमmance_levels[i].pcie_gen;
		अगर (max_speed < pcie_speed)
			max_speed = pcie_speed;
	पूर्ण

	वापस max_speed;
पूर्ण

अटल u16 ci_get_current_pcie_speed(काष्ठा radeon_device *rdev)
अणु
	u32 speed_cntl = 0;

	speed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & LC_CURRENT_DATA_RATE_MASK;
	speed_cntl >>= LC_CURRENT_DATA_RATE_SHIFT;

	वापस (u16)speed_cntl;
पूर्ण

अटल पूर्णांक ci_get_current_pcie_lane_number(काष्ठा radeon_device *rdev)
अणु
	u32 link_width = 0;

	link_width = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL) & LC_LINK_WIDTH_RD_MASK;
	link_width >>= LC_LINK_WIDTH_RD_SHIFT;

	चयन (link_width) अणु
	हाल RADEON_PCIE_LC_LINK_WIDTH_X1:
		वापस 1;
	हाल RADEON_PCIE_LC_LINK_WIDTH_X2:
		वापस 2;
	हाल RADEON_PCIE_LC_LINK_WIDTH_X4:
		वापस 4;
	हाल RADEON_PCIE_LC_LINK_WIDTH_X8:
		वापस 8;
	हाल RADEON_PCIE_LC_LINK_WIDTH_X12:
		/* not actually supported */
		वापस 12;
	हाल RADEON_PCIE_LC_LINK_WIDTH_X0:
	हाल RADEON_PCIE_LC_LINK_WIDTH_X16:
	शेष:
		वापस 16;
	पूर्ण
पूर्ण

अटल व्योम ci_request_link_speed_change_beक्रमe_state_change(काष्ठा radeon_device *rdev,
							     काष्ठा radeon_ps *radeon_new_state,
							     काष्ठा radeon_ps *radeon_current_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	क्रमागत radeon_pcie_gen target_link_speed =
		ci_get_maximum_link_speed(rdev, radeon_new_state);
	क्रमागत radeon_pcie_gen current_link_speed;

	अगर (pi->क्रमce_pcie_gen == RADEON_PCIE_GEN_INVALID)
		current_link_speed = ci_get_maximum_link_speed(rdev, radeon_current_state);
	अन्यथा
		current_link_speed = pi->क्रमce_pcie_gen;

	pi->क्रमce_pcie_gen = RADEON_PCIE_GEN_INVALID;
	pi->pspp_notअगरy_required = false;
	अगर (target_link_speed > current_link_speed) अणु
		चयन (target_link_speed) अणु
#अगर_घोषित CONFIG_ACPI
		हाल RADEON_PCIE_GEN3:
			अगर (radeon_acpi_pcie_perक्रमmance_request(rdev, PCIE_PERF_REQ_PECI_GEN3, false) == 0)
				अवरोध;
			pi->क्रमce_pcie_gen = RADEON_PCIE_GEN2;
			अगर (current_link_speed == RADEON_PCIE_GEN2)
				अवरोध;
			fallthrough;
		हाल RADEON_PCIE_GEN2:
			अगर (radeon_acpi_pcie_perक्रमmance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)
				अवरोध;
			fallthrough;
#पूर्ण_अगर
		शेष:
			pi->क्रमce_pcie_gen = ci_get_current_pcie_speed(rdev);
			अवरोध;
		पूर्ण
	पूर्ण अन्यथा अणु
		अगर (target_link_speed < current_link_speed)
			pi->pspp_notअगरy_required = true;
	पूर्ण
पूर्ण

अटल व्योम ci_notअगरy_link_speed_change_after_state_change(काष्ठा radeon_device *rdev,
							   काष्ठा radeon_ps *radeon_new_state,
							   काष्ठा radeon_ps *radeon_current_state)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	क्रमागत radeon_pcie_gen target_link_speed =
		ci_get_maximum_link_speed(rdev, radeon_new_state);
	u8 request;

	अगर (pi->pspp_notअगरy_required) अणु
		अगर (target_link_speed == RADEON_PCIE_GEN3)
			request = PCIE_PERF_REQ_PECI_GEN3;
		अन्यथा अगर (target_link_speed == RADEON_PCIE_GEN2)
			request = PCIE_PERF_REQ_PECI_GEN2;
		अन्यथा
			request = PCIE_PERF_REQ_PECI_GEN1;

		अगर ((request == PCIE_PERF_REQ_PECI_GEN1) &&
		    (ci_get_current_pcie_speed(rdev) > 0))
			वापस;

#अगर_घोषित CONFIG_ACPI
		radeon_acpi_pcie_perक्रमmance_request(rdev, request, false);
#पूर्ण_अगर
	पूर्ण
पूर्ण

अटल पूर्णांक ci_set_निजी_data_variables_based_on_pptable(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_sclk_vddc_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;
	काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_mclk_vddc_table =
		&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk;
	काष्ठा radeon_घड़ी_voltage_dependency_table *allowed_mclk_vddci_table =
		&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk;

	अगर (allowed_sclk_vddc_table == शून्य)
		वापस -EINVAL;
	अगर (allowed_sclk_vddc_table->count < 1)
		वापस -EINVAL;
	अगर (allowed_mclk_vddc_table == शून्य)
		वापस -EINVAL;
	अगर (allowed_mclk_vddc_table->count < 1)
		वापस -EINVAL;
	अगर (allowed_mclk_vddci_table == शून्य)
		वापस -EINVAL;
	अगर (allowed_mclk_vddci_table->count < 1)
		वापस -EINVAL;

	pi->min_vddc_in_pp_table = allowed_sclk_vddc_table->entries[0].v;
	pi->max_vddc_in_pp_table =
		allowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;

	pi->min_vddci_in_pp_table = allowed_mclk_vddci_table->entries[0].v;
	pi->max_vddci_in_pp_table =
		allowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;

	rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.sclk =
		allowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;
	rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.mclk =
		allowed_mclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;
	rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.vddc =
		allowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;
	rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac.vddci =
		allowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;

	वापस 0;
पूर्ण

अटल व्योम ci_patch_with_vddc_leakage(काष्ठा radeon_device *rdev, u16 *vddc)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_leakage_voltage *leakage_table = &pi->vddc_leakage;
	u32 leakage_index;

	क्रम (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) अणु
		अगर (leakage_table->leakage_id[leakage_index] == *vddc) अणु
			*vddc = leakage_table->actual_voltage[leakage_index];
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_patch_with_vddci_leakage(काष्ठा radeon_device *rdev, u16 *vddci)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_leakage_voltage *leakage_table = &pi->vddci_leakage;
	u32 leakage_index;

	क्रम (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) अणु
		अगर (leakage_table->leakage_id[leakage_index] == *vddci) अणु
			*vddci = leakage_table->actual_voltage[leakage_index];
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(काष्ठा radeon_device *rdev,
								      काष्ठा radeon_घड़ी_voltage_dependency_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddc_leakage(rdev, &table->entries[i].v);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_घड़ी_voltage_dependency_table_with_vddci_leakage(काष्ठा radeon_device *rdev,
								       काष्ठा radeon_घड़ी_voltage_dependency_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddci_leakage(rdev, &table->entries[i].v);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_vce_घड़ी_voltage_dependency_table_with_vddc_leakage(काष्ठा radeon_device *rdev,
									  काष्ठा radeon_vce_घड़ी_voltage_dependency_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddc_leakage(rdev, &table->entries[i].v);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_uvd_घड़ी_voltage_dependency_table_with_vddc_leakage(काष्ठा radeon_device *rdev,
									  काष्ठा radeon_uvd_घड़ी_voltage_dependency_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddc_leakage(rdev, &table->entries[i].v);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(काष्ठा radeon_device *rdev,
								   काष्ठा radeon_phase_shedding_limits_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddc_leakage(rdev, &table->entries[i].voltage);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_घड़ी_voltage_limits_with_vddc_leakage(काष्ठा radeon_device *rdev,
							    काष्ठा radeon_घड़ी_and_voltage_limits *table)
अणु
	अगर (table) अणु
		ci_patch_with_vddc_leakage(rdev, (u16 *)&table->vddc);
		ci_patch_with_vddci_leakage(rdev, (u16 *)&table->vddci);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_cac_leakage_table_with_vddc_leakage(काष्ठा radeon_device *rdev,
							 काष्ठा radeon_cac_leakage_table *table)
अणु
	u32 i;

	अगर (table) अणु
		क्रम (i = 0; i < table->count; i++)
			ci_patch_with_vddc_leakage(rdev, &table->entries[i].vddc);
	पूर्ण
पूर्ण

अटल व्योम ci_patch_dependency_tables_with_leakage(काष्ठा radeon_device *rdev)
अणु

	ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								  &rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk);
	ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								  &rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk);
	ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								  &rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk);
	ci_patch_घड़ी_voltage_dependency_table_with_vddci_leakage(rdev,
								   &rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk);
	ci_patch_vce_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								      &rdev->pm.dpm.dyn_state.vce_घड़ी_voltage_dependency_table);
	ci_patch_uvd_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								      &rdev->pm.dpm.dyn_state.uvd_घड़ी_voltage_dependency_table);
	ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								  &rdev->pm.dpm.dyn_state.samu_घड़ी_voltage_dependency_table);
	ci_patch_घड़ी_voltage_dependency_table_with_vddc_leakage(rdev,
								  &rdev->pm.dpm.dyn_state.acp_घड़ी_voltage_dependency_table);
	ci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(rdev,
							       &rdev->pm.dpm.dyn_state.phase_shedding_limits_table);
	ci_patch_घड़ी_voltage_limits_with_vddc_leakage(rdev,
							&rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac);
	ci_patch_घड़ी_voltage_limits_with_vddc_leakage(rdev,
							&rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc);
	ci_patch_cac_leakage_table_with_vddc_leakage(rdev,
						     &rdev->pm.dpm.dyn_state.cac_leakage_table);

पूर्ण

अटल व्योम ci_get_memory_type(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	u32 पंचांगp;

	पंचांगp = RREG32(MC_SEQ_MISC0);

	अगर (((पंचांगp & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT) ==
	    MC_SEQ_MISC0_GDDR5_VALUE)
		pi->mem_gddr5 = true;
	अन्यथा
		pi->mem_gddr5 = false;

पूर्ण

अटल व्योम ci_update_current_ps(काष्ठा radeon_device *rdev,
				 काष्ठा radeon_ps *rps)
अणु
	काष्ठा ci_ps *new_ps = ci_get_ps(rps);
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	pi->current_rps = *rps;
	pi->current_ps = *new_ps;
	pi->current_rps.ps_priv = &pi->current_ps;
पूर्ण

अटल व्योम ci_update_requested_ps(काष्ठा radeon_device *rdev,
				   काष्ठा radeon_ps *rps)
अणु
	काष्ठा ci_ps *new_ps = ci_get_ps(rps);
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);

	pi->requested_rps = *rps;
	pi->requested_ps = *new_ps;
	pi->requested_rps.ps_priv = &pi->requested_ps;
पूर्ण

पूर्णांक ci_dpm_pre_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;
	काष्ठा radeon_ps *new_ps = &requested_ps;

	ci_update_requested_ps(rdev, new_ps);

	ci_apply_state_adjust_rules(rdev, &pi->requested_rps);

	वापस 0;
पूर्ण

व्योम ci_dpm_post_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps *new_ps = &pi->requested_rps;

	ci_update_current_ps(rdev, new_ps);
पूर्ण


व्योम ci_dpm_setup_asic(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक r;

	r = ci_mc_load_microcode(rdev);
	अगर (r)
		DRM_ERROR("Failed to load MC firmware!\n");
	ci_पढ़ो_घड़ी_रेजिस्टरs(rdev);
	ci_get_memory_type(rdev);
	ci_enable_acpi_घातer_management(rdev);
	ci_init_sclk_t(rdev);
पूर्ण

पूर्णांक ci_dpm_enable(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;
	पूर्णांक ret;

	अगर (ci_is_smc_running(rdev))
		वापस -EINVAL;
	अगर (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE) अणु
		ci_enable_voltage_control(rdev);
		ret = ci_स्थिरruct_voltage_tables(rdev);
		अगर (ret) अणु
			DRM_ERROR("ci_construct_voltage_tables failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	अगर (pi->caps_dynamic_ac_timing) अणु
		ret = ci_initialize_mc_reg_table(rdev);
		अगर (ret)
			pi->caps_dynamic_ac_timing = false;
	पूर्ण
	अगर (pi->dynamic_ss)
		ci_enable_spपढ़ो_spectrum(rdev, true);
	अगर (pi->thermal_protection)
		ci_enable_thermal_protection(rdev, true);
	ci_program_sstp(rdev);
	ci_enable_display_gap(rdev);
	ci_program_vc(rdev);
	ret = ci_upload_firmware(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_upload_firmware failed\n");
		वापस ret;
	पूर्ण
	ret = ci_process_firmware_header(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_process_firmware_header failed\n");
		वापस ret;
	पूर्ण
	ret = ci_initial_चयन_from_arb_f0_to_f1(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_initial_switch_from_arb_f0_to_f1 failed\n");
		वापस ret;
	पूर्ण
	ret = ci_init_smc_table(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_init_smc_table failed\n");
		वापस ret;
	पूर्ण
	ret = ci_init_arb_table_index(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_init_arb_table_index failed\n");
		वापस ret;
	पूर्ण
	अगर (pi->caps_dynamic_ac_timing) अणु
		ret = ci_populate_initial_mc_reg_table(rdev);
		अगर (ret) अणु
			DRM_ERROR("ci_populate_initial_mc_reg_table failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	ret = ci_populate_pm_base(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_populate_pm_base failed\n");
		वापस ret;
	पूर्ण
	ci_dpm_start_smc(rdev);
	ci_enable_vr_hot_gpio_पूर्णांकerrupt(rdev);
	ret = ci_notअगरy_smc_display_change(rdev, false);
	अगर (ret) अणु
		DRM_ERROR("ci_notify_smc_display_change failed\n");
		वापस ret;
	पूर्ण
	ci_enable_sclk_control(rdev, true);
	ret = ci_enable_ulv(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_ulv failed\n");
		वापस ret;
	पूर्ण
	ret = ci_enable_ds_master_चयन(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_ds_master_switch failed\n");
		वापस ret;
	पूर्ण
	ret = ci_start_dpm(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_start_dpm failed\n");
		वापस ret;
	पूर्ण
	ret = ci_enable_didt(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_didt failed\n");
		वापस ret;
	पूर्ण
	ret = ci_enable_smc_cac(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_smc_cac failed\n");
		वापस ret;
	पूर्ण
	ret = ci_enable_घातer_containment(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_power_containment failed\n");
		वापस ret;
	पूर्ण

	ret = ci_घातer_control_set_level(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_power_control_set_level failed\n");
		वापस ret;
	पूर्ण

	ci_enable_स्वतः_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);

	ret = ci_enable_thermal_based_sclk_dpm(rdev, true);
	अगर (ret) अणु
		DRM_ERROR("ci_enable_thermal_based_sclk_dpm failed\n");
		वापस ret;
	पूर्ण

	ci_thermal_start_thermal_controller(rdev);

	ci_update_current_ps(rdev, boot_ps);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_temperature_range(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक ret;

	ret = ci_thermal_enable_alert(rdev, false);
	अगर (ret)
		वापस ret;
	ret = ci_thermal_set_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);
	अगर (ret)
		वापस ret;
	ret = ci_thermal_enable_alert(rdev, true);
	अगर (ret)
		वापस ret;

	वापस ret;
पूर्ण

पूर्णांक ci_dpm_late_enable(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक ret;

	ret = ci_set_temperature_range(rdev);
	अगर (ret)
		वापस ret;

	ci_dpm_घातergate_uvd(rdev, true);

	वापस 0;
पूर्ण

व्योम ci_dpm_disable(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;

	ci_dpm_घातergate_uvd(rdev, false);

	अगर (!ci_is_smc_running(rdev))
		वापस;

	ci_thermal_stop_thermal_controller(rdev);

	अगर (pi->thermal_protection)
		ci_enable_thermal_protection(rdev, false);
	ci_enable_घातer_containment(rdev, false);
	ci_enable_smc_cac(rdev, false);
	ci_enable_didt(rdev, false);
	ci_enable_spपढ़ो_spectrum(rdev, false);
	ci_enable_स्वतः_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, false);
	ci_stop_dpm(rdev);
	ci_enable_ds_master_चयन(rdev, false);
	ci_enable_ulv(rdev, false);
	ci_clear_vc(rdev);
	ci_reset_to_शेष(rdev);
	ci_dpm_stop_smc(rdev);
	ci_क्रमce_चयन_to_arb_f0(rdev);
	ci_enable_thermal_based_sclk_dpm(rdev, false);

	ci_update_current_ps(rdev, boot_ps);
पूर्ण

पूर्णांक ci_dpm_set_घातer_state(काष्ठा radeon_device *rdev)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps *new_ps = &pi->requested_rps;
	काष्ठा radeon_ps *old_ps = &pi->current_rps;
	पूर्णांक ret;

	ci_find_dpm_states_घड़ीs_in_dpm_table(rdev, new_ps);
	अगर (pi->pcie_perक्रमmance_request)
		ci_request_link_speed_change_beक्रमe_state_change(rdev, new_ps, old_ps);
	ret = ci_मुक्तze_sclk_mclk_dpm(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_freeze_sclk_mclk_dpm failed\n");
		वापस ret;
	पूर्ण
	ret = ci_populate_and_upload_sclk_mclk_dpm_levels(rdev, new_ps);
	अगर (ret) अणु
		DRM_ERROR("ci_populate_and_upload_sclk_mclk_dpm_levels failed\n");
		वापस ret;
	पूर्ण
	ret = ci_generate_dpm_level_enable_mask(rdev, new_ps);
	अगर (ret) अणु
		DRM_ERROR("ci_generate_dpm_level_enable_mask failed\n");
		वापस ret;
	पूर्ण

	ret = ci_update_vce_dpm(rdev, new_ps, old_ps);
	अगर (ret) अणु
		DRM_ERROR("ci_update_vce_dpm failed\n");
		वापस ret;
	पूर्ण

	ret = ci_update_sclk_t(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_update_sclk_t failed\n");
		वापस ret;
	पूर्ण
	अगर (pi->caps_dynamic_ac_timing) अणु
		ret = ci_update_and_upload_mc_reg_table(rdev);
		अगर (ret) अणु
			DRM_ERROR("ci_update_and_upload_mc_reg_table failed\n");
			वापस ret;
		पूर्ण
	पूर्ण
	ret = ci_program_memory_timing_parameters(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_program_memory_timing_parameters failed\n");
		वापस ret;
	पूर्ण
	ret = ci_unमुक्तze_sclk_mclk_dpm(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_unfreeze_sclk_mclk_dpm failed\n");
		वापस ret;
	पूर्ण
	ret = ci_upload_dpm_level_enable_mask(rdev);
	अगर (ret) अणु
		DRM_ERROR("ci_upload_dpm_level_enable_mask failed\n");
		वापस ret;
	पूर्ण
	अगर (pi->pcie_perक्रमmance_request)
		ci_notअगरy_link_speed_change_after_state_change(rdev, new_ps, old_ps);

	वापस 0;
पूर्ण

#अगर 0
व्योम ci_dpm_reset_asic(काष्ठा radeon_device *rdev)
अणु
	ci_set_boot_state(rdev);
पूर्ण
#पूर्ण_अगर

व्योम ci_dpm_display_configuration_changed(काष्ठा radeon_device *rdev)
अणु
	ci_program_display_gap(rdev);
पूर्ण

जोड़ घातer_info अणु
	काष्ठा _ATOM_POWERPLAY_INFO info;
	काष्ठा _ATOM_POWERPLAY_INFO_V2 info_2;
	काष्ठा _ATOM_POWERPLAY_INFO_V3 info_3;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE pplib;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;
	काष्ठा _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;
पूर्ण;

जोड़ pplib_घड़ी_info अणु
	काष्ठा _ATOM_PPLIB_R600_CLOCK_INFO r600;
	काष्ठा _ATOM_PPLIB_RS780_CLOCK_INFO rs780;
	काष्ठा _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;
	काष्ठा _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;
	काष्ठा _ATOM_PPLIB_SI_CLOCK_INFO si;
	काष्ठा _ATOM_PPLIB_CI_CLOCK_INFO ci;
पूर्ण;

जोड़ pplib_घातer_state अणु
	काष्ठा _ATOM_PPLIB_STATE v1;
	काष्ठा _ATOM_PPLIB_STATE_V2 v2;
पूर्ण;

अटल व्योम ci_parse_pplib_non_घड़ी_info(काष्ठा radeon_device *rdev,
					  काष्ठा radeon_ps *rps,
					  काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *non_घड़ी_info,
					  u8 table_rev)
अणु
	rps->caps = le32_to_cpu(non_घड़ी_info->ulCapsAndSettings);
	rps->class = le16_to_cpu(non_घड़ी_info->usClassअगरication);
	rps->class2 = le16_to_cpu(non_घड़ी_info->usClassअगरication2);

	अगर (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) अणु
		rps->vclk = le32_to_cpu(non_घड़ी_info->ulVCLK);
		rps->dclk = le32_to_cpu(non_घड़ी_info->ulDCLK);
	पूर्ण अन्यथा अणु
		rps->vclk = 0;
		rps->dclk = 0;
	पूर्ण

	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)
		rdev->pm.dpm.boot_ps = rps;
	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)
		rdev->pm.dpm.uvd_ps = rps;
पूर्ण

अटल व्योम ci_parse_pplib_घड़ी_info(काष्ठा radeon_device *rdev,
				      काष्ठा radeon_ps *rps, पूर्णांक index,
				      जोड़ pplib_घड़ी_info *घड़ी_info)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ps *ps = ci_get_ps(rps);
	काष्ठा ci_pl *pl = &ps->perक्रमmance_levels[index];

	ps->perक्रमmance_level_count = index + 1;

	pl->sclk = le16_to_cpu(घड़ी_info->ci.usEngineClockLow);
	pl->sclk |= घड़ी_info->ci.ucEngineClockHigh << 16;
	pl->mclk = le16_to_cpu(घड़ी_info->ci.usMemoryClockLow);
	pl->mclk |= घड़ी_info->ci.ucMemoryClockHigh << 16;

	pl->pcie_gen = r600_get_pcie_gen_support(rdev,
						 pi->sys_pcie_mask,
						 pi->vbios_boot_state.pcie_gen_bootup_value,
						 घड़ी_info->ci.ucPCIEGen);
	pl->pcie_lane = r600_get_pcie_lane_support(rdev,
						   pi->vbios_boot_state.pcie_lane_bootup_value,
						   le16_to_cpu(घड़ी_info->ci.usPCIELane));

	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) अणु
		pi->acpi_pcie_gen = pl->pcie_gen;
	पूर्ण

	अगर (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) अणु
		pi->ulv.supported = true;
		pi->ulv.pl = *pl;
		pi->ulv.cg_ulv_parameter = CISLANDS_CGULVPARAMETER_DFLT;
	पूर्ण

	/* patch up boot state */
	अगर (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) अणु
		pl->mclk = pi->vbios_boot_state.mclk_bootup_value;
		pl->sclk = pi->vbios_boot_state.sclk_bootup_value;
		pl->pcie_gen = pi->vbios_boot_state.pcie_gen_bootup_value;
		pl->pcie_lane = pi->vbios_boot_state.pcie_lane_bootup_value;
	पूर्ण

	चयन (rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) अणु
	हाल ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:
		pi->use_pcie_घातersaving_levels = true;
		अगर (pi->pcie_gen_घातersaving.max < pl->pcie_gen)
			pi->pcie_gen_घातersaving.max = pl->pcie_gen;
		अगर (pi->pcie_gen_घातersaving.min > pl->pcie_gen)
			pi->pcie_gen_घातersaving.min = pl->pcie_gen;
		अगर (pi->pcie_lane_घातersaving.max < pl->pcie_lane)
			pi->pcie_lane_घातersaving.max = pl->pcie_lane;
		अगर (pi->pcie_lane_घातersaving.min > pl->pcie_lane)
			pi->pcie_lane_घातersaving.min = pl->pcie_lane;
		अवरोध;
	हाल ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:
		pi->use_pcie_perक्रमmance_levels = true;
		अगर (pi->pcie_gen_perक्रमmance.max < pl->pcie_gen)
			pi->pcie_gen_perक्रमmance.max = pl->pcie_gen;
		अगर (pi->pcie_gen_perक्रमmance.min > pl->pcie_gen)
			pi->pcie_gen_perक्रमmance.min = pl->pcie_gen;
		अगर (pi->pcie_lane_perक्रमmance.max < pl->pcie_lane)
			pi->pcie_lane_perक्रमmance.max = pl->pcie_lane;
		अगर (pi->pcie_lane_perक्रमmance.min > pl->pcie_lane)
			pi->pcie_lane_perक्रमmance.min = pl->pcie_lane;
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल पूर्णांक ci_parse_घातer_table(काष्ठा radeon_device *rdev)
अणु
	काष्ठा radeon_mode_info *mode_info = &rdev->mode_info;
	काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *non_घड़ी_info;
	जोड़ pplib_घातer_state *घातer_state;
	पूर्णांक i, j, k, non_घड़ी_array_index, घड़ी_array_index;
	जोड़ pplib_घड़ी_info *घड़ी_info;
	काष्ठा _StateArray *state_array;
	काष्ठा _ClockInfoArray *घड़ी_info_array;
	काष्ठा _NonClockInfoArray *non_घड़ी_info_array;
	जोड़ घातer_info *घातer_info;
	पूर्णांक index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);
	u16 data_offset;
	u8 frev, crev;
	u8 *घातer_state_offset;
	काष्ठा ci_ps *ps;

	अगर (!atom_parse_data_header(mode_info->atom_context, index, शून्य,
				   &frev, &crev, &data_offset))
		वापस -EINVAL;
	घातer_info = (जोड़ घातer_info *)(mode_info->atom_context->bios + data_offset);

	state_array = (काष्ठा _StateArray *)
		(mode_info->atom_context->bios + data_offset +
		 le16_to_cpu(घातer_info->pplib.usStateArrayOffset));
	घड़ी_info_array = (काष्ठा _ClockInfoArray *)
		(mode_info->atom_context->bios + data_offset +
		 le16_to_cpu(घातer_info->pplib.usClockInfoArrayOffset));
	non_घड़ी_info_array = (काष्ठा _NonClockInfoArray *)
		(mode_info->atom_context->bios + data_offset +
		 le16_to_cpu(घातer_info->pplib.usNonClockInfoArrayOffset));

	rdev->pm.dpm.ps = kसुस्मृति(state_array->ucNumEntries,
				  माप(काष्ठा radeon_ps),
				  GFP_KERNEL);
	अगर (!rdev->pm.dpm.ps)
		वापस -ENOMEM;
	घातer_state_offset = (u8 *)state_array->states;
	rdev->pm.dpm.num_ps = 0;
	क्रम (i = 0; i < state_array->ucNumEntries; i++) अणु
		u8 *idx;
		घातer_state = (जोड़ pplib_घातer_state *)घातer_state_offset;
		non_घड़ी_array_index = घातer_state->v2.nonClockInfoIndex;
		non_घड़ी_info = (काष्ठा _ATOM_PPLIB_NONCLOCK_INFO *)
			&non_घड़ी_info_array->nonClockInfo[non_घड़ी_array_index];
		अगर (!rdev->pm.घातer_state[i].घड़ी_info)
			वापस -EINVAL;
		ps = kzalloc(माप(काष्ठा ci_ps), GFP_KERNEL);
		अगर (ps == शून्य)
			वापस -ENOMEM;
		rdev->pm.dpm.ps[i].ps_priv = ps;
		ci_parse_pplib_non_घड़ी_info(rdev, &rdev->pm.dpm.ps[i],
					      non_घड़ी_info,
					      non_घड़ी_info_array->ucEntrySize);
		k = 0;
		idx = (u8 *)&घातer_state->v2.घड़ीInfoIndex[0];
		क्रम (j = 0; j < घातer_state->v2.ucNumDPMLevels; j++) अणु
			घड़ी_array_index = idx[j];
			अगर (घड़ी_array_index >= घड़ी_info_array->ucNumEntries)
				जारी;
			अगर (k >= CISLANDS_MAX_HARDWARE_POWERLEVELS)
				अवरोध;
			घड़ी_info = (जोड़ pplib_घड़ी_info *)
				((u8 *)&घड़ी_info_array->घड़ीInfo[0] +
				 (घड़ी_array_index * घड़ी_info_array->ucEntrySize));
			ci_parse_pplib_घड़ी_info(rdev,
						  &rdev->pm.dpm.ps[i], k,
						  घड़ी_info);
			k++;
		पूर्ण
		घातer_state_offset += 2 + घातer_state->v2.ucNumDPMLevels;
		rdev->pm.dpm.num_ps = i + 1;
	पूर्ण

	/* fill in the vce घातer states */
	क्रम (i = 0; i < RADEON_MAX_VCE_LEVELS; i++) अणु
		u32 sclk, mclk;
		घड़ी_array_index = rdev->pm.dpm.vce_states[i].clk_idx;
		घड़ी_info = (जोड़ pplib_घड़ी_info *)
			&घड़ी_info_array->घड़ीInfo[घड़ी_array_index * घड़ी_info_array->ucEntrySize];
		sclk = le16_to_cpu(घड़ी_info->ci.usEngineClockLow);
		sclk |= घड़ी_info->ci.ucEngineClockHigh << 16;
		mclk = le16_to_cpu(घड़ी_info->ci.usMemoryClockLow);
		mclk |= घड़ी_info->ci.ucMemoryClockHigh << 16;
		rdev->pm.dpm.vce_states[i].sclk = sclk;
		rdev->pm.dpm.vce_states[i].mclk = mclk;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_get_vbios_boot_values(काष्ठा radeon_device *rdev,
				    काष्ठा ci_vbios_boot_state *boot_state)
अणु
	काष्ठा radeon_mode_info *mode_info = &rdev->mode_info;
	पूर्णांक index = GetIndexIntoMasterTable(DATA, FirmwareInfo);
	ATOM_FIRMWARE_INFO_V2_2 *firmware_info;
	u8 frev, crev;
	u16 data_offset;

	अगर (atom_parse_data_header(mode_info->atom_context, index, शून्य,
				   &frev, &crev, &data_offset)) अणु
		firmware_info =
			(ATOM_FIRMWARE_INFO_V2_2 *)(mode_info->atom_context->bios +
						    data_offset);
		boot_state->mvdd_bootup_value = le16_to_cpu(firmware_info->usBootUpMVDDCVoltage);
		boot_state->vddc_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCVoltage);
		boot_state->vddci_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCIVoltage);
		boot_state->pcie_gen_bootup_value = ci_get_current_pcie_speed(rdev);
		boot_state->pcie_lane_bootup_value = ci_get_current_pcie_lane_number(rdev);
		boot_state->sclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultEngineClock);
		boot_state->mclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultMemoryClock);

		वापस 0;
	पूर्ण
	वापस -EINVAL;
पूर्ण

व्योम ci_dpm_fini(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक i;

	क्रम (i = 0; i < rdev->pm.dpm.num_ps; i++) अणु
		kमुक्त(rdev->pm.dpm.ps[i].ps_priv);
	पूर्ण
	kमुक्त(rdev->pm.dpm.ps);
	kमुक्त(rdev->pm.dpm.priv);
	kमुक्त(rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);
	r600_मुक्त_extended_घातer_table(rdev);
पूर्ण

पूर्णांक ci_dpm_init(काष्ठा radeon_device *rdev)
अणु
	पूर्णांक index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);
	SMU7_Discrete_DpmTable  *dpm_table;
	काष्ठा radeon_gpio_rec gpio;
	u16 data_offset, size;
	u8 frev, crev;
	काष्ठा ci_घातer_info *pi;
	क्रमागत pci_bus_speed speed_cap = PCI_SPEED_UNKNOWN;
	काष्ठा pci_dev *root = rdev->pdev->bus->self;
	पूर्णांक ret;

	pi = kzalloc(माप(काष्ठा ci_घातer_info), GFP_KERNEL);
	अगर (pi == शून्य)
		वापस -ENOMEM;
	rdev->pm.dpm.priv = pi;

	अगर (!pci_is_root_bus(rdev->pdev->bus))
		speed_cap = pcie_get_speed_cap(root);
	अगर (speed_cap == PCI_SPEED_UNKNOWN) अणु
		pi->sys_pcie_mask = 0;
	पूर्ण अन्यथा अणु
		अगर (speed_cap == PCIE_SPEED_8_0GT)
			pi->sys_pcie_mask = RADEON_PCIE_SPEED_25 |
				RADEON_PCIE_SPEED_50 |
				RADEON_PCIE_SPEED_80;
		अन्यथा अगर (speed_cap == PCIE_SPEED_5_0GT)
			pi->sys_pcie_mask = RADEON_PCIE_SPEED_25 |
				RADEON_PCIE_SPEED_50;
		अन्यथा
			pi->sys_pcie_mask = RADEON_PCIE_SPEED_25;
	पूर्ण
	pi->क्रमce_pcie_gen = RADEON_PCIE_GEN_INVALID;

	pi->pcie_gen_perक्रमmance.max = RADEON_PCIE_GEN1;
	pi->pcie_gen_perक्रमmance.min = RADEON_PCIE_GEN3;
	pi->pcie_gen_घातersaving.max = RADEON_PCIE_GEN1;
	pi->pcie_gen_घातersaving.min = RADEON_PCIE_GEN3;

	pi->pcie_lane_perक्रमmance.max = 0;
	pi->pcie_lane_perक्रमmance.min = 16;
	pi->pcie_lane_घातersaving.max = 0;
	pi->pcie_lane_घातersaving.min = 16;

	ret = ci_get_vbios_boot_values(rdev, &pi->vbios_boot_state);
	अगर (ret) अणु
		ci_dpm_fini(rdev);
		वापस ret;
	पूर्ण

	ret = r600_get_platक्रमm_caps(rdev);
	अगर (ret) अणु
		ci_dpm_fini(rdev);
		वापस ret;
	पूर्ण

	ret = r600_parse_extended_घातer_table(rdev);
	अगर (ret) अणु
		ci_dpm_fini(rdev);
		वापस ret;
	पूर्ण

	ret = ci_parse_घातer_table(rdev);
	अगर (ret) अणु
		ci_dpm_fini(rdev);
		वापस ret;
	पूर्ण

	pi->dll_शेष_on = false;
	pi->sram_end = SMC_RAM_END;

	pi->activity_target[0] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[1] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[2] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[3] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[4] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[5] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[6] = CISLAND_TARGETACTIVITY_DFLT;
	pi->activity_target[7] = CISLAND_TARGETACTIVITY_DFLT;

	pi->mclk_activity_target = CISLAND_MCLK_TARGETACTIVITY_DFLT;

	pi->sclk_dpm_key_disabled = 0;
	pi->mclk_dpm_key_disabled = 0;
	pi->pcie_dpm_key_disabled = 0;
	pi->thermal_sclk_dpm_enabled = 0;

	/* mclk dpm is unstable on some R7 260X cards with the old mc ucode */
	अगर ((rdev->pdev->device == 0x6658) &&
	    (rdev->mc_fw->size == (BONAIRE_MC_UCODE_SIZE * 4))) अणु
		pi->mclk_dpm_key_disabled = 1;
	पूर्ण

	pi->caps_sclk_ds = true;

	pi->mclk_strobe_mode_threshold = 40000;
	pi->mclk_stutter_mode_threshold = 40000;
	pi->mclk_edc_enable_threshold = 40000;
	pi->mclk_edc_wr_enable_threshold = 40000;

	ci_initialize_घातertune_शेषs(rdev);

	pi->caps_fps = false;

	pi->caps_sclk_throttle_low_notअगरication = false;

	pi->caps_uvd_dpm = true;
	pi->caps_vce_dpm = true;

	ci_get_leakage_voltages(rdev);
	ci_patch_dependency_tables_with_leakage(rdev);
	ci_set_निजी_data_variables_based_on_pptable(rdev);

	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
		kसुस्मृति(4,
			माप(काष्ठा radeon_घड़ी_voltage_dependency_entry),
			GFP_KERNEL);
	अगर (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) अणु
		ci_dpm_fini(rdev);
		वापस -ENOMEM;
	पूर्ण
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;
	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;

	rdev->pm.dpm.dyn_state.mclk_sclk_ratio = 4;
	rdev->pm.dpm.dyn_state.sclk_mclk_delta = 15000;
	rdev->pm.dpm.dyn_state.vddc_vddci_delta = 200;

	rdev->pm.dpm.dyn_state.valid_sclk_values.count = 0;
	rdev->pm.dpm.dyn_state.valid_sclk_values.values = शून्य;
	rdev->pm.dpm.dyn_state.valid_mclk_values.count = 0;
	rdev->pm.dpm.dyn_state.valid_mclk_values.values = शून्य;

	अगर (rdev->family == CHIP_HAWAII) अणु
		pi->thermal_temp_setting.temperature_low = 94500;
		pi->thermal_temp_setting.temperature_high = 95000;
		pi->thermal_temp_setting.temperature_shutकरोwn = 104000;
	पूर्ण अन्यथा अणु
		pi->thermal_temp_setting.temperature_low = 99500;
		pi->thermal_temp_setting.temperature_high = 100000;
		pi->thermal_temp_setting.temperature_shutकरोwn = 104000;
	पूर्ण

	pi->uvd_enabled = false;

	dpm_table = &pi->smc_state_table;

	gpio = radeon_atombios_lookup_gpio(rdev, VDDC_VRHOT_GPIO_PINID);
	अगर (gpio.valid) अणु
		dpm_table->VRHotGpio = gpio.shअगरt;
		rdev->pm.dpm.platक्रमm_caps |= ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;
	पूर्ण अन्यथा अणु
		dpm_table->VRHotGpio = CISLANDS_UNUSED_GPIO_PIN;
		rdev->pm.dpm.platक्रमm_caps &= ~ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;
	पूर्ण

	gpio = radeon_atombios_lookup_gpio(rdev, PP_AC_DC_SWITCH_GPIO_PINID);
	अगर (gpio.valid) अणु
		dpm_table->AcDcGpio = gpio.shअगरt;
		rdev->pm.dpm.platक्रमm_caps |= ATOM_PP_PLATFORM_CAP_HARDWAREDC;
	पूर्ण अन्यथा अणु
		dpm_table->AcDcGpio = CISLANDS_UNUSED_GPIO_PIN;
		rdev->pm.dpm.platक्रमm_caps &= ~ATOM_PP_PLATFORM_CAP_HARDWAREDC;
	पूर्ण

	gpio = radeon_atombios_lookup_gpio(rdev, VDDC_PCC_GPIO_PINID);
	अगर (gpio.valid) अणु
		u32 पंचांगp = RREG32_SMC(CNB_PWRMGT_CNTL);

		चयन (gpio.shअगरt) अणु
		हाल 0:
			पंचांगp &= ~GNB_SLOW_MODE_MASK;
			पंचांगp |= GNB_SLOW_MODE(1);
			अवरोध;
		हाल 1:
			पंचांगp &= ~GNB_SLOW_MODE_MASK;
			पंचांगp |= GNB_SLOW_MODE(2);
			अवरोध;
		हाल 2:
			पंचांगp |= GNB_SLOW;
			अवरोध;
		हाल 3:
			पंचांगp |= FORCE_NB_PS1;
			अवरोध;
		हाल 4:
			पंचांगp |= DPM_ENABLED;
			अवरोध;
		शेष:
			DRM_DEBUG("Invalid PCC GPIO: %u!\n", gpio.shअगरt);
			अवरोध;
		पूर्ण
		WREG32_SMC(CNB_PWRMGT_CNTL, पंचांगp);
	पूर्ण

	pi->voltage_control = CISLANDS_VOLTAGE_CONTROL_NONE;
	pi->vddci_control = CISLANDS_VOLTAGE_CONTROL_NONE;
	pi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_NONE;
	अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_GPIO_LUT))
		pi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;
	अन्यथा अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_SVID2))
		pi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL) अणु
		अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_GPIO_LUT))
			pi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;
		अन्यथा अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_SVID2))
			pi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;
		अन्यथा
			rdev->pm.dpm.platक्रमm_caps &= ~ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL;
	पूर्ण

	अगर (rdev->pm.dpm.platक्रमm_caps & ATOM_PP_PLATFORM_CAP_MVDDCONTROL) अणु
		अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_GPIO_LUT))
			pi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;
		अन्यथा अगर (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_SVID2))
			pi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;
		अन्यथा
			rdev->pm.dpm.platक्रमm_caps &= ~ATOM_PP_PLATFORM_CAP_MVDDCONTROL;
	पूर्ण

	pi->vddc_phase_shed_control = true;

#अगर defined(CONFIG_ACPI)
	pi->pcie_perक्रमmance_request =
		radeon_acpi_is_pcie_perक्रमmance_request_supported(rdev);
#अन्यथा
	pi->pcie_perक्रमmance_request = false;
#पूर्ण_अगर

	अगर (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,
				   &frev, &crev, &data_offset)) अणु
		pi->caps_sclk_ss_support = true;
		pi->caps_mclk_ss_support = true;
		pi->dynamic_ss = true;
	पूर्ण अन्यथा अणु
		pi->caps_sclk_ss_support = false;
		pi->caps_mclk_ss_support = false;
		pi->dynamic_ss = true;
	पूर्ण

	अगर (rdev->pm.पूर्णांक_thermal_type != THERMAL_TYPE_NONE)
		pi->thermal_protection = true;
	अन्यथा
		pi->thermal_protection = false;

	pi->caps_dynamic_ac_timing = true;

	pi->uvd_घातer_gated = false;

	/* make sure dc limits are valid */
	अगर ((rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc.sclk == 0) ||
	    (rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc.mclk == 0))
		rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_dc =
			rdev->pm.dpm.dyn_state.max_घड़ी_voltage_on_ac;

	pi->fan_ctrl_is_in_शेष_mode = true;

	वापस 0;
पूर्ण

व्योम ci_dpm_debugfs_prपूर्णांक_current_perक्रमmance_level(काष्ठा radeon_device *rdev,
						    काष्ठा seq_file *m)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा radeon_ps *rps = &pi->current_rps;
	u32 sclk = ci_get_average_sclk_freq(rdev);
	u32 mclk = ci_get_average_mclk_freq(rdev);

	seq_म_लिखो(m, "uvd    %sabled\n", pi->uvd_enabled ? "en" : "dis");
	seq_म_लिखो(m, "vce    %sabled\n", rps->vce_active ? "en" : "dis");
	seq_म_लिखो(m, "power level avg    sclk: %u mclk: %u\n",
		   sclk, mclk);
पूर्ण

व्योम ci_dpm_prपूर्णांक_घातer_state(काष्ठा radeon_device *rdev,
			      काष्ठा radeon_ps *rps)
अणु
	काष्ठा ci_ps *ps = ci_get_ps(rps);
	काष्ठा ci_pl *pl;
	पूर्णांक i;

	r600_dpm_prपूर्णांक_class_info(rps->class, rps->class2);
	r600_dpm_prपूर्णांक_cap_info(rps->caps);
	prपूर्णांकk("\tuvd    vclk: %d dclk: %d\n", rps->vclk, rps->dclk);
	क्रम (i = 0; i < ps->perक्रमmance_level_count; i++) अणु
		pl = &ps->perक्रमmance_levels[i];
		prपूर्णांकk("\t\tpower level %d    sclk: %u mclk: %u pcie gen: %u pcie lanes: %u\n",
		       i, pl->sclk, pl->mclk, pl->pcie_gen + 1, pl->pcie_lane);
	पूर्ण
	r600_dpm_prपूर्णांक_ps_status(rdev, rps);
पूर्ण

u32 ci_dpm_get_current_sclk(काष्ठा radeon_device *rdev)
अणु
	u32 sclk = ci_get_average_sclk_freq(rdev);

	वापस sclk;
पूर्ण

u32 ci_dpm_get_current_mclk(काष्ठा radeon_device *rdev)
अणु
	u32 mclk = ci_get_average_mclk_freq(rdev);

	वापस mclk;
पूर्ण

u32 ci_dpm_get_sclk(काष्ठा radeon_device *rdev, bool low)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ps *requested_state = ci_get_ps(&pi->requested_rps);

	अगर (low)
		वापस requested_state->perक्रमmance_levels[0].sclk;
	अन्यथा
		वापस requested_state->perक्रमmance_levels[requested_state->perक्रमmance_level_count - 1].sclk;
पूर्ण

u32 ci_dpm_get_mclk(काष्ठा radeon_device *rdev, bool low)
अणु
	काष्ठा ci_घातer_info *pi = ci_get_pi(rdev);
	काष्ठा ci_ps *requested_state = ci_get_ps(&pi->requested_rps);

	अगर (low)
		वापस requested_state->perक्रमmance_levels[0].mclk;
	अन्यथा
		वापस requested_state->perक्रमmance_levels[requested_state->perक्रमmance_level_count - 1].mclk;
पूर्ण
