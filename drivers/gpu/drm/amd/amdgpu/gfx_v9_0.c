<शैली गुरु>
/*
 * Copyright 2016 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modअगरy, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to करो so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#समावेश <linux/delay.h>
#समावेश <linux/kernel.h>
#समावेश <linux/firmware.h>
#समावेश <linux/module.h>
#समावेश <linux/pci.h>

#समावेश "amdgpu.h"
#समावेश "amdgpu_gfx.h"
#समावेश "soc15.h"
#समावेश "soc15d.h"
#समावेश "amdgpu_atomfirmware.h"
#समावेश "amdgpu_pm.h"

#समावेश "gc/gc_9_0_offset.h"
#समावेश "gc/gc_9_0_sh_mask.h"

#समावेश "vega10_enum.h"

#समावेश "soc15_common.h"
#समावेश "clearstate_gfx9.h"
#समावेश "v9_structs.h"

#समावेश "ivsrcid/gfx/irqsrcs_gfx_9_0.h"

#समावेश "amdgpu_ras.h"

#समावेश "gfx_v9_4.h"
#समावेश "gfx_v9_0.h"
#समावेश "gfx_v9_4_2.h"

#समावेश "asic_reg/pwr/pwr_10_0_offset.h"
#समावेश "asic_reg/pwr/pwr_10_0_sh_mask.h"
#समावेश "asic_reg/gc/gc_9_0_default.h"

#घोषणा GFX9_NUM_GFX_RINGS     1
#घोषणा GFX9_MEC_HPD_SIZE 4096
#घोषणा RLCG_UCODE_LOADING_START_ADDRESS 0x00002000L
#घोषणा RLC_SAVE_RESTORE_ADDR_STARTING_OFFSET 0x00000000L

#घोषणा mmGCEA_PROBE_MAP                        0x070c
#घोषणा mmGCEA_PROBE_MAP_BASE_IDX               0

MODULE_FIRMWARE("amdgpu/vega10_ce.bin");
MODULE_FIRMWARE("amdgpu/vega10_pfp.bin");
MODULE_FIRMWARE("amdgpu/vega10_me.bin");
MODULE_FIRMWARE("amdgpu/vega10_mec.bin");
MODULE_FIRMWARE("amdgpu/vega10_mec2.bin");
MODULE_FIRMWARE("amdgpu/vega10_rlc.bin");

MODULE_FIRMWARE("amdgpu/vega12_ce.bin");
MODULE_FIRMWARE("amdgpu/vega12_pfp.bin");
MODULE_FIRMWARE("amdgpu/vega12_me.bin");
MODULE_FIRMWARE("amdgpu/vega12_mec.bin");
MODULE_FIRMWARE("amdgpu/vega12_mec2.bin");
MODULE_FIRMWARE("amdgpu/vega12_rlc.bin");

MODULE_FIRMWARE("amdgpu/vega20_ce.bin");
MODULE_FIRMWARE("amdgpu/vega20_pfp.bin");
MODULE_FIRMWARE("amdgpu/vega20_me.bin");
MODULE_FIRMWARE("amdgpu/vega20_mec.bin");
MODULE_FIRMWARE("amdgpu/vega20_mec2.bin");
MODULE_FIRMWARE("amdgpu/vega20_rlc.bin");

MODULE_FIRMWARE("amdgpu/raven_ce.bin");
MODULE_FIRMWARE("amdgpu/raven_pfp.bin");
MODULE_FIRMWARE("amdgpu/raven_me.bin");
MODULE_FIRMWARE("amdgpu/raven_mec.bin");
MODULE_FIRMWARE("amdgpu/raven_mec2.bin");
MODULE_FIRMWARE("amdgpu/raven_rlc.bin");

MODULE_FIRMWARE("amdgpu/picasso_ce.bin");
MODULE_FIRMWARE("amdgpu/picasso_pfp.bin");
MODULE_FIRMWARE("amdgpu/picasso_me.bin");
MODULE_FIRMWARE("amdgpu/picasso_mec.bin");
MODULE_FIRMWARE("amdgpu/picasso_mec2.bin");
MODULE_FIRMWARE("amdgpu/picasso_rlc.bin");
MODULE_FIRMWARE("amdgpu/picasso_rlc_am4.bin");

MODULE_FIRMWARE("amdgpu/raven2_ce.bin");
MODULE_FIRMWARE("amdgpu/raven2_pfp.bin");
MODULE_FIRMWARE("amdgpu/raven2_me.bin");
MODULE_FIRMWARE("amdgpu/raven2_mec.bin");
MODULE_FIRMWARE("amdgpu/raven2_mec2.bin");
MODULE_FIRMWARE("amdgpu/raven2_rlc.bin");
MODULE_FIRMWARE("amdgpu/raven_kicker_rlc.bin");

MODULE_FIRMWARE("amdgpu/arcturus_mec.bin");
MODULE_FIRMWARE("amdgpu/arcturus_rlc.bin");

MODULE_FIRMWARE("amdgpu/renoir_ce.bin");
MODULE_FIRMWARE("amdgpu/renoir_pfp.bin");
MODULE_FIRMWARE("amdgpu/renoir_me.bin");
MODULE_FIRMWARE("amdgpu/renoir_mec.bin");
MODULE_FIRMWARE("amdgpu/renoir_rlc.bin");

MODULE_FIRMWARE("amdgpu/green_sardine_ce.bin");
MODULE_FIRMWARE("amdgpu/green_sardine_pfp.bin");
MODULE_FIRMWARE("amdgpu/green_sardine_me.bin");
MODULE_FIRMWARE("amdgpu/green_sardine_mec.bin");
MODULE_FIRMWARE("amdgpu/green_sardine_mec2.bin");
MODULE_FIRMWARE("amdgpu/green_sardine_rlc.bin");

MODULE_FIRMWARE("amdgpu/aldebaran_mec.bin");
MODULE_FIRMWARE("amdgpu/aldebaran_mec2.bin");
MODULE_FIRMWARE("amdgpu/aldebaran_rlc.bin");

#घोषणा mmTCP_CHAN_STEER_0_ARCT								0x0b03
#घोषणा mmTCP_CHAN_STEER_0_ARCT_BASE_IDX							0
#घोषणा mmTCP_CHAN_STEER_1_ARCT								0x0b04
#घोषणा mmTCP_CHAN_STEER_1_ARCT_BASE_IDX							0
#घोषणा mmTCP_CHAN_STEER_2_ARCT								0x0b09
#घोषणा mmTCP_CHAN_STEER_2_ARCT_BASE_IDX							0
#घोषणा mmTCP_CHAN_STEER_3_ARCT								0x0b0a
#घोषणा mmTCP_CHAN_STEER_3_ARCT_BASE_IDX							0
#घोषणा mmTCP_CHAN_STEER_4_ARCT								0x0b0b
#घोषणा mmTCP_CHAN_STEER_4_ARCT_BASE_IDX							0
#घोषणा mmTCP_CHAN_STEER_5_ARCT								0x0b0c
#घोषणा mmTCP_CHAN_STEER_5_ARCT_BASE_IDX							0

क्रमागत ta_ras_gfx_subblock अणु
	/*CPC*/
	TA_RAS_BLOCK__GFX_CPC_INDEX_START = 0,
	TA_RAS_BLOCK__GFX_CPC_SCRATCH = TA_RAS_BLOCK__GFX_CPC_INDEX_START,
	TA_RAS_BLOCK__GFX_CPC_UCODE,
	TA_RAS_BLOCK__GFX_DC_STATE_ME1,
	TA_RAS_BLOCK__GFX_DC_CSINVOC_ME1,
	TA_RAS_BLOCK__GFX_DC_RESTORE_ME1,
	TA_RAS_BLOCK__GFX_DC_STATE_ME2,
	TA_RAS_BLOCK__GFX_DC_CSINVOC_ME2,
	TA_RAS_BLOCK__GFX_DC_RESTORE_ME2,
	TA_RAS_BLOCK__GFX_CPC_INDEX_END = TA_RAS_BLOCK__GFX_DC_RESTORE_ME2,
	/* CPF*/
	TA_RAS_BLOCK__GFX_CPF_INDEX_START,
	TA_RAS_BLOCK__GFX_CPF_ROQ_ME2 = TA_RAS_BLOCK__GFX_CPF_INDEX_START,
	TA_RAS_BLOCK__GFX_CPF_ROQ_ME1,
	TA_RAS_BLOCK__GFX_CPF_TAG,
	TA_RAS_BLOCK__GFX_CPF_INDEX_END = TA_RAS_BLOCK__GFX_CPF_TAG,
	/* CPG*/
	TA_RAS_BLOCK__GFX_CPG_INDEX_START,
	TA_RAS_BLOCK__GFX_CPG_DMA_ROQ = TA_RAS_BLOCK__GFX_CPG_INDEX_START,
	TA_RAS_BLOCK__GFX_CPG_DMA_TAG,
	TA_RAS_BLOCK__GFX_CPG_TAG,
	TA_RAS_BLOCK__GFX_CPG_INDEX_END = TA_RAS_BLOCK__GFX_CPG_TAG,
	/* GDS*/
	TA_RAS_BLOCK__GFX_GDS_INDEX_START,
	TA_RAS_BLOCK__GFX_GDS_MEM = TA_RAS_BLOCK__GFX_GDS_INDEX_START,
	TA_RAS_BLOCK__GFX_GDS_INPUT_QUEUE,
	TA_RAS_BLOCK__GFX_GDS_OA_PHY_CMD_RAM_MEM,
	TA_RAS_BLOCK__GFX_GDS_OA_PHY_DATA_RAM_MEM,
	TA_RAS_BLOCK__GFX_GDS_OA_PIPE_MEM,
	TA_RAS_BLOCK__GFX_GDS_INDEX_END = TA_RAS_BLOCK__GFX_GDS_OA_PIPE_MEM,
	/* SPI*/
	TA_RAS_BLOCK__GFX_SPI_SR_MEM,
	/* SQ*/
	TA_RAS_BLOCK__GFX_SQ_INDEX_START,
	TA_RAS_BLOCK__GFX_SQ_SGPR = TA_RAS_BLOCK__GFX_SQ_INDEX_START,
	TA_RAS_BLOCK__GFX_SQ_LDS_D,
	TA_RAS_BLOCK__GFX_SQ_LDS_I,
	TA_RAS_BLOCK__GFX_SQ_VGPR, /* VGPR = SP*/
	TA_RAS_BLOCK__GFX_SQ_INDEX_END = TA_RAS_BLOCK__GFX_SQ_VGPR,
	/* SQC (3 ranges)*/
	TA_RAS_BLOCK__GFX_SQC_INDEX_START,
	/* SQC range 0*/
	TA_RAS_BLOCK__GFX_SQC_INDEX0_START = TA_RAS_BLOCK__GFX_SQC_INDEX_START,
	TA_RAS_BLOCK__GFX_SQC_INST_UTCL1_LFIFO =
		TA_RAS_BLOCK__GFX_SQC_INDEX0_START,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU0_WRITE_DATA_BUF,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU0_UTCL1_LFIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU1_WRITE_DATA_BUF,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU1_UTCL1_LFIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU2_WRITE_DATA_BUF,
	TA_RAS_BLOCK__GFX_SQC_DATA_CU2_UTCL1_LFIFO,
	TA_RAS_BLOCK__GFX_SQC_INDEX0_END =
		TA_RAS_BLOCK__GFX_SQC_DATA_CU2_UTCL1_LFIFO,
	/* SQC range 1*/
	TA_RAS_BLOCK__GFX_SQC_INDEX1_START,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKA_TAG_RAM =
		TA_RAS_BLOCK__GFX_SQC_INDEX1_START,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKA_UTCL1_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKA_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKA_BANK_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_TAG_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_HIT_FIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_सूचीTY_BIT_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_BANK_RAM,
	TA_RAS_BLOCK__GFX_SQC_INDEX1_END =
		TA_RAS_BLOCK__GFX_SQC_DATA_BANKA_BANK_RAM,
	/* SQC range 2*/
	TA_RAS_BLOCK__GFX_SQC_INDEX2_START,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKB_TAG_RAM =
		TA_RAS_BLOCK__GFX_SQC_INDEX2_START,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKB_UTCL1_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKB_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_INST_BANKB_BANK_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_TAG_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_HIT_FIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_MISS_FIFO,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_सूचीTY_BIT_RAM,
	TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_BANK_RAM,
	TA_RAS_BLOCK__GFX_SQC_INDEX2_END =
		TA_RAS_BLOCK__GFX_SQC_DATA_BANKB_BANK_RAM,
	TA_RAS_BLOCK__GFX_SQC_INDEX_END = TA_RAS_BLOCK__GFX_SQC_INDEX2_END,
	/* TA*/
	TA_RAS_BLOCK__GFX_TA_INDEX_START,
	TA_RAS_BLOCK__GFX_TA_FS_DFIFO = TA_RAS_BLOCK__GFX_TA_INDEX_START,
	TA_RAS_BLOCK__GFX_TA_FS_AFIFO,
	TA_RAS_BLOCK__GFX_TA_FL_LFIFO,
	TA_RAS_BLOCK__GFX_TA_FX_LFIFO,
	TA_RAS_BLOCK__GFX_TA_FS_CFIFO,
	TA_RAS_BLOCK__GFX_TA_INDEX_END = TA_RAS_BLOCK__GFX_TA_FS_CFIFO,
	/* TCA*/
	TA_RAS_BLOCK__GFX_TCA_INDEX_START,
	TA_RAS_BLOCK__GFX_TCA_HOLE_FIFO = TA_RAS_BLOCK__GFX_TCA_INDEX_START,
	TA_RAS_BLOCK__GFX_TCA_REQ_FIFO,
	TA_RAS_BLOCK__GFX_TCA_INDEX_END = TA_RAS_BLOCK__GFX_TCA_REQ_FIFO,
	/* TCC (5 sub-ranges)*/
	TA_RAS_BLOCK__GFX_TCC_INDEX_START,
	/* TCC range 0*/
	TA_RAS_BLOCK__GFX_TCC_INDEX0_START = TA_RAS_BLOCK__GFX_TCC_INDEX_START,
	TA_RAS_BLOCK__GFX_TCC_CACHE_DATA = TA_RAS_BLOCK__GFX_TCC_INDEX0_START,
	TA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_0_1,
	TA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_1_0,
	TA_RAS_BLOCK__GFX_TCC_CACHE_DATA_BANK_1_1,
	TA_RAS_BLOCK__GFX_TCC_CACHE_सूचीTY_BANK_0,
	TA_RAS_BLOCK__GFX_TCC_CACHE_सूचीTY_BANK_1,
	TA_RAS_BLOCK__GFX_TCC_HIGH_RATE_TAG,
	TA_RAS_BLOCK__GFX_TCC_LOW_RATE_TAG,
	TA_RAS_BLOCK__GFX_TCC_INDEX0_END = TA_RAS_BLOCK__GFX_TCC_LOW_RATE_TAG,
	/* TCC range 1*/
	TA_RAS_BLOCK__GFX_TCC_INDEX1_START,
	TA_RAS_BLOCK__GFX_TCC_IN_USE_DEC = TA_RAS_BLOCK__GFX_TCC_INDEX1_START,
	TA_RAS_BLOCK__GFX_TCC_IN_USE_TRANSFER,
	TA_RAS_BLOCK__GFX_TCC_INDEX1_END =
		TA_RAS_BLOCK__GFX_TCC_IN_USE_TRANSFER,
	/* TCC range 2*/
	TA_RAS_BLOCK__GFX_TCC_INDEX2_START,
	TA_RAS_BLOCK__GFX_TCC_RETURN_DATA = TA_RAS_BLOCK__GFX_TCC_INDEX2_START,
	TA_RAS_BLOCK__GFX_TCC_RETURN_CONTROL,
	TA_RAS_BLOCK__GFX_TCC_UC_ATOMIC_FIFO,
	TA_RAS_BLOCK__GFX_TCC_WRITE_RETURN,
	TA_RAS_BLOCK__GFX_TCC_WRITE_CACHE_READ,
	TA_RAS_BLOCK__GFX_TCC_SRC_FIFO,
	TA_RAS_BLOCK__GFX_TCC_SRC_FIFO_NEXT_RAM,
	TA_RAS_BLOCK__GFX_TCC_CACHE_TAG_PROBE_FIFO,
	TA_RAS_BLOCK__GFX_TCC_INDEX2_END =
		TA_RAS_BLOCK__GFX_TCC_CACHE_TAG_PROBE_FIFO,
	/* TCC range 3*/
	TA_RAS_BLOCK__GFX_TCC_INDEX3_START,
	TA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO = TA_RAS_BLOCK__GFX_TCC_INDEX3_START,
	TA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO_NEXT_RAM,
	TA_RAS_BLOCK__GFX_TCC_INDEX3_END =
		TA_RAS_BLOCK__GFX_TCC_LATENCY_FIFO_NEXT_RAM,
	/* TCC range 4*/
	TA_RAS_BLOCK__GFX_TCC_INDEX4_START,
	TA_RAS_BLOCK__GFX_TCC_WRRET_TAG_WRITE_RETURN =
		TA_RAS_BLOCK__GFX_TCC_INDEX4_START,
	TA_RAS_BLOCK__GFX_TCC_ATOMIC_RETURN_BUFFER,
	TA_RAS_BLOCK__GFX_TCC_INDEX4_END =
		TA_RAS_BLOCK__GFX_TCC_ATOMIC_RETURN_BUFFER,
	TA_RAS_BLOCK__GFX_TCC_INDEX_END = TA_RAS_BLOCK__GFX_TCC_INDEX4_END,
	/* TCI*/
	TA_RAS_BLOCK__GFX_TCI_WRITE_RAM,
	/* TCP*/
	TA_RAS_BLOCK__GFX_TCP_INDEX_START,
	TA_RAS_BLOCK__GFX_TCP_CACHE_RAM = TA_RAS_BLOCK__GFX_TCP_INDEX_START,
	TA_RAS_BLOCK__GFX_TCP_LFIFO_RAM,
	TA_RAS_BLOCK__GFX_TCP_CMD_FIFO,
	TA_RAS_BLOCK__GFX_TCP_VM_FIFO,
	TA_RAS_BLOCK__GFX_TCP_DB_RAM,
	TA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO0,
	TA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO1,
	TA_RAS_BLOCK__GFX_TCP_INDEX_END = TA_RAS_BLOCK__GFX_TCP_UTCL1_LFIFO1,
	/* TD*/
	TA_RAS_BLOCK__GFX_TD_INDEX_START,
	TA_RAS_BLOCK__GFX_TD_SS_FIFO_LO = TA_RAS_BLOCK__GFX_TD_INDEX_START,
	TA_RAS_BLOCK__GFX_TD_SS_FIFO_HI,
	TA_RAS_BLOCK__GFX_TD_CS_FIFO,
	TA_RAS_BLOCK__GFX_TD_INDEX_END = TA_RAS_BLOCK__GFX_TD_CS_FIFO,
	/* EA (3 sub-ranges)*/
	TA_RAS_BLOCK__GFX_EA_INDEX_START,
	/* EA range 0*/
	TA_RAS_BLOCK__GFX_EA_INDEX0_START = TA_RAS_BLOCK__GFX_EA_INDEX_START,
	TA_RAS_BLOCK__GFX_EA_DRAMRD_CMDMEM = TA_RAS_BLOCK__GFX_EA_INDEX0_START,
	TA_RAS_BLOCK__GFX_EA_DRAMWR_CMDMEM,
	TA_RAS_BLOCK__GFX_EA_DRAMWR_DATAMEM,
	TA_RAS_BLOCK__GFX_EA_RRET_TAGMEM,
	TA_RAS_BLOCK__GFX_EA_WRET_TAGMEM,
	TA_RAS_BLOCK__GFX_EA_GMIRD_CMDMEM,
	TA_RAS_BLOCK__GFX_EA_GMIWR_CMDMEM,
	TA_RAS_BLOCK__GFX_EA_GMIWR_DATAMEM,
	TA_RAS_BLOCK__GFX_EA_INDEX0_END = TA_RAS_BLOCK__GFX_EA_GMIWR_DATAMEM,
	/* EA range 1*/
	TA_RAS_BLOCK__GFX_EA_INDEX1_START,
	TA_RAS_BLOCK__GFX_EA_DRAMRD_PAGEMEM = TA_RAS_BLOCK__GFX_EA_INDEX1_START,
	TA_RAS_BLOCK__GFX_EA_DRAMWR_PAGEMEM,
	TA_RAS_BLOCK__GFX_EA_IORD_CMDMEM,
	TA_RAS_BLOCK__GFX_EA_IOWR_CMDMEM,
	TA_RAS_BLOCK__GFX_EA_IOWR_DATAMEM,
	TA_RAS_BLOCK__GFX_EA_GMIRD_PAGEMEM,
	TA_RAS_BLOCK__GFX_EA_GMIWR_PAGEMEM,
	TA_RAS_BLOCK__GFX_EA_INDEX1_END = TA_RAS_BLOCK__GFX_EA_GMIWR_PAGEMEM,
	/* EA range 2*/
	TA_RAS_BLOCK__GFX_EA_INDEX2_START,
	TA_RAS_BLOCK__GFX_EA_MAM_D0MEM = TA_RAS_BLOCK__GFX_EA_INDEX2_START,
	TA_RAS_BLOCK__GFX_EA_MAM_D1MEM,
	TA_RAS_BLOCK__GFX_EA_MAM_D2MEM,
	TA_RAS_BLOCK__GFX_EA_MAM_D3MEM,
	TA_RAS_BLOCK__GFX_EA_INDEX2_END = TA_RAS_BLOCK__GFX_EA_MAM_D3MEM,
	TA_RAS_BLOCK__GFX_EA_INDEX_END = TA_RAS_BLOCK__GFX_EA_INDEX2_END,
	/* UTC VM L2 bank*/
	TA_RAS_BLOCK__UTC_VML2_BANK_CACHE,
	/* UTC VM walker*/
	TA_RAS_BLOCK__UTC_VML2_WALKER,
	/* UTC ATC L2 2MB cache*/
	TA_RAS_BLOCK__UTC_ATCL2_CACHE_2M_BANK,
	/* UTC ATC L2 4KB cache*/
	TA_RAS_BLOCK__UTC_ATCL2_CACHE_4K_BANK,
	TA_RAS_BLOCK__GFX_MAX
पूर्ण;

काष्ठा ras_gfx_subblock अणु
	अचिन्हित अक्षर *name;
	पूर्णांक ta_subblock;
	पूर्णांक hw_supported_error_type;
	पूर्णांक sw_supported_error_type;
पूर्ण;

#घोषणा AMDGPU_RAS_SUB_BLOCK(subblock, a, b, c, d, e, f, g, h)                             \
	[AMDGPU_RAS_BLOCK__##subblock] = अणु                                     \
		#subblock,                                                     \
		TA_RAS_BLOCK__##subblock,                                      \
		((a) | ((b) << 1) | ((c) << 2) | ((d) << 3)),                  \
		(((e) << 1) | ((f) << 3) | (g) | ((h) << 2)),                  \
	पूर्ण

अटल स्थिर काष्ठा ras_gfx_subblock ras_gfx_subblocks[] = अणु
	AMDGPU_RAS_SUB_BLOCK(GFX_CPC_SCRATCH, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPC_UCODE, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_STATE_ME1, 1, 0, 0, 1, 0, 0, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_CSINVOC_ME1, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_RESTORE_ME1, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_STATE_ME2, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_CSINVOC_ME2, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_DC_RESTORE_ME2, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPF_ROQ_ME2, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPF_ROQ_ME1, 1, 0, 0, 1, 0, 0, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPF_TAG, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPG_DMA_ROQ, 1, 0, 0, 1, 0, 0, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPG_DMA_TAG, 0, 1, 1, 1, 0, 1, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_CPG_TAG, 0, 1, 1, 1, 1, 1, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_GDS_MEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_GDS_INPUT_QUEUE, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PHY_CMD_RAM_MEM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PHY_DATA_RAM_MEM, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_GDS_OA_PIPE_MEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SPI_SR_MEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQ_SGPR, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQ_LDS_D, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQ_LDS_I, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQ_VGPR, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU0_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU0_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU1_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU1_UTCL1_LFIFO, 0, 1, 1, 1, 1, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU2_WRITE_DATA_BUF, 0, 1, 1, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_CU2_UTCL1_LFIFO, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_TAG_RAM, 0, 1, 1, 1, 1, 0, 0,
			     1),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_UTCL1_MISS_FIFO, 1, 0, 0, 1, 0,
			     0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKA_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_TAG_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_HIT_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_सूचीTY_BIT_RAM, 1, 0, 0, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKA_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_TAG_RAM, 0, 1, 1, 1, 1, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_UTCL1_MISS_FIFO, 1, 0, 0, 1, 0,
			     0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_INST_BANKB_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_TAG_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_HIT_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_MISS_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_सूचीTY_BIT_RAM, 1, 0, 0, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_SQC_DATA_BANKB_BANK_RAM, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_DFIFO, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_AFIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TA_FL_LFIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TA_FX_LFIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TA_FS_CFIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCA_HOLE_FIFO, 1, 0, 0, 1, 0, 1, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCA_REQ_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_0_1, 0, 1, 1, 1, 1, 0, 0,
			     1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_1_0, 0, 1, 1, 1, 1, 0, 0,
			     1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_DATA_BANK_1_1, 0, 1, 1, 1, 1, 0, 0,
			     1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_सूचीTY_BANK_0, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_सूचीTY_BANK_1, 0, 1, 1, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_HIGH_RATE_TAG, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_LOW_RATE_TAG, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_IN_USE_DEC, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_IN_USE_TRANSFER, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_RETURN_DATA, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_RETURN_CONTROL, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_UC_ATOMIC_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRITE_RETURN, 1, 0, 0, 1, 0, 1, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRITE_CACHE_READ, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_SRC_FIFO, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_SRC_FIFO_NEXT_RAM, 1, 0, 0, 1, 0, 0, 1, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_CACHE_TAG_PROBE_FIFO, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_LATENCY_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_LATENCY_FIFO_NEXT_RAM, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_WRRET_TAG_WRITE_RETURN, 1, 0, 0, 1, 0, 0,
			     0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCC_ATOMIC_RETURN_BUFFER, 1, 0, 0, 1, 0, 0, 0,
			     0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCI_WRITE_RAM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_CACHE_RAM, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_LFIFO_RAM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_CMD_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_VM_FIFO, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_DB_RAM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_UTCL1_LFIFO0, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TCP_UTCL1_LFIFO1, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TD_SS_FIFO_LO, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_TD_SS_FIFO_HI, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_TD_CS_FIFO, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMRD_CMDMEM, 0, 1, 1, 1, 1, 0, 0, 1),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_DATAMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_RRET_TAGMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_WRET_TAGMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIRD_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_CMDMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_DATAMEM, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMRD_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_DRAMWR_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_IORD_CMDMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_IOWR_CMDMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_IOWR_DATAMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIRD_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_GMIWR_PAGEMEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D0MEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D1MEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D2MEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(GFX_EA_MAM_D3MEM, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(UTC_VML2_BANK_CACHE, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(UTC_VML2_WALKER, 0, 1, 1, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(UTC_ATCL2_CACHE_2M_BANK, 1, 0, 0, 1, 0, 0, 0, 0),
	AMDGPU_RAS_SUB_BLOCK(UTC_ATCL2_CACHE_4K_BANK, 0, 1, 1, 1, 0, 0, 0, 0),
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_0[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000400),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG3, 0x80000000, 0x80000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSH_MEM_CONFIG, 0x00001000, 0x00001000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_0, 0x0007ffff, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_1, 0x0007ffff, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_0, 0x01ffffff, 0x00ffff87),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_1, 0x01ffffff, 0x00ffff8f),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSQC_CONFIG, 0x03000000, 0x020a2000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x4a2c0e68),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0xb5d3f197),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000003ff),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_0_vg10[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0x0000f000, 0x00012107),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x2a114042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x2a114042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0x00008000, 0x00048000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00020000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0x0000000f, 0x01000107),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x00001800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x08000000, 0x08000080)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_0_vg20[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0x0f000080, 0x04000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0x0f000000, 0x0a000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xf3e777ff, 0x22014042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xf3e777ff, 0x22014042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0x00003e00, 0x00000400),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xff840000, 0x04040000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00030000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0xffff010f, 0x01000107),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0x000b0000, 0x000b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01000000, 0x01000000)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_1[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000420),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00003120),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000000ff),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x08000000, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_1_rv1[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_3, 0x30000000, 0x10000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x24000042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x24000042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04048000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_MODE_CNTL_1, 0x06000000, 0x06000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRMI_UTCL1_CNTL2, 0x00030000, 0x00020000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x00000800)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_1_rv2[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0xff7fffff, 0x04000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0xff7fffff, 0x0a000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPC_UTCL1_CNTL, 0x7f0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPF_UTCL1_CNTL, 0xff8fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCPG_UTCL1_CNTL, 0x7f8fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x26013041),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x26013041),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmIA_UTCL1_CNTL, 0x3f8fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_0, 0xff0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_1, 0xff0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_GPM_UTCL1_CNTL_2, 0xff0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_PREWALKER_UTCL1_CNTL, 0xff0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmRLC_SPM_UTCL1_CNTL, 0xff0fffff, 0x08000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00000010),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x01000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmWD_UTCL1_CNTL, 0x3f8fffff, 0x08000080),
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_1_rn[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0xff7fffff, 0x0a000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000400),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xf3e777ff, 0x24000042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xf3e777ff, 0x24000042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x00003120),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGCEA_PROBE_MAP, 0xffffffff, 0x0000cccc),
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_x_common[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_SD_CNTL, 0xffffffff, 0x000001ff),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGRBM_CAM_INDEX, 0xffffffff, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGRBM_CAM_DATA, 0xffffffff, 0x2544c382)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_2_1[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmDB_DEBUG2, 0xf00fffff, 0x00000420),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_GPU_ID, 0x0000000f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_BINNER_EVENT_CNTL_3, 0x00000003, 0x82400024),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE, 0x3fffffff, 0x00000001),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSH_MEM_CONFIG, 0x00001000, 0x00001000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_0, 0x0007ffff, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_CU_1, 0x0007ffff, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_0, 0x01ffffff, 0x0000ff87),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_RESOURCE_RESERVE_EN_CU_1, 0x01ffffff, 0x0000ff8f),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSQC_CONFIG, 0x03000000, 0x020a2000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x010b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x4a2c0e68),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0xb5d3f197),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_CACHE_INVALIDATION, 0x3fff3af3, 0x19200000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmVGT_GS_MAX_WAVE_ID, 0x00000fff, 0x000003ff)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_2_1_vg12[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_DCC_CONFIG, 0x00000080, 0x04000080),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL, 0xfffdf3cf, 0x00014104),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCB_HW_CONTROL_2, 0x0f000000, 0x0a000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x24104041),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG_READ, 0xffff77ff, 0x24104041),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmPA_SC_ENHANCE_1, 0xffffffff, 0x04040000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSPI_CONFIG_CNTL_1, 0xffff03ff, 0x01000107),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_LO, 0xffffffff, 0x76325410),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTD_CNTL, 0x01bd9f33, 0x01000000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC1_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_MEC2_F32_INT_DIS, 0x00000800, 0x00000800),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmCP_DEBUG, 0x00008000, 0x00008000)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_golden golden_settings_gc_9_4_1_arct[] =
अणु
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmGB_ADDR_CONFIG, 0xffff77ff, 0x2a114042),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTA_CNTL_AUX, 0xfffffeef, 0x10b0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_0_ARCT, 0x3fffffff, 0x346f0a4e),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_1_ARCT, 0x3fffffff, 0x1c642ca),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_2_ARCT, 0x3fffffff, 0x26f45098),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_3_ARCT, 0x3fffffff, 0x2ebd9fe3),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_4_ARCT, 0x3fffffff, 0xb90f5b1),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_CHAN_STEER_5_ARCT, 0x3ff, 0x135),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSQ_CONFIG, 0xffffffff, 0x011A0000),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmSQ_FIFO_SIZES, 0xffffffff, 0x00000f00),
	SOC15_REG_GOLDEN_VALUE(GC, 0, mmTCP_UTCL1_CNTL1, 0x30000000, 0x30000000)
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_rlcg rlcg_access_gc_9_0[] = अणु
	अणुSOC15_REG_ENTRY(GC, 0, mmGRBM_GFX_INDEX)पूर्ण,
	अणुSOC15_REG_ENTRY(GC, 0, mmSQ_IND_INDEX)पूर्ण,
पूर्ण;

अटल स्थिर u32 GFX_RLC_SRM_INDEX_CNTL_ADDR_OFFSETS[] =
अणु
	mmRLC_SRM_INDEX_CNTL_ADDR_0 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_1 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_2 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_3 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_4 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_5 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_6 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
	mmRLC_SRM_INDEX_CNTL_ADDR_7 - mmRLC_SRM_INDEX_CNTL_ADDR_0,
पूर्ण;

अटल स्थिर u32 GFX_RLC_SRM_INDEX_CNTL_DATA_OFFSETS[] =
अणु
	mmRLC_SRM_INDEX_CNTL_DATA_0 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_1 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_2 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_3 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_4 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_5 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_6 - mmRLC_SRM_INDEX_CNTL_DATA_0,
	mmRLC_SRM_INDEX_CNTL_DATA_7 - mmRLC_SRM_INDEX_CNTL_DATA_0,
पूर्ण;

अटल व्योम gfx_v9_0_rlcg_rw(काष्ठा amdgpu_device *adev, u32 offset, u32 v, u32 flag)
अणु
	अटल व्योम *scratch_reg0;
	अटल व्योम *scratch_reg1;
	अटल व्योम *scratch_reg2;
	अटल व्योम *scratch_reg3;
	अटल व्योम *spare_पूर्णांक;
	अटल uपूर्णांक32_t grbm_cntl;
	अटल uपूर्णांक32_t grbm_idx;

	scratch_reg0 = adev->rmmio + (adev->reg_offset[GC_HWIP][0][mmSCRATCH_REG0_BASE_IDX] + mmSCRATCH_REG0)*4;
	scratch_reg1 = adev->rmmio + (adev->reg_offset[GC_HWIP][0][mmSCRATCH_REG1_BASE_IDX] + mmSCRATCH_REG1)*4;
	scratch_reg2 = adev->rmmio + (adev->reg_offset[GC_HWIP][0][mmSCRATCH_REG1_BASE_IDX] + mmSCRATCH_REG2)*4;
	scratch_reg3 = adev->rmmio + (adev->reg_offset[GC_HWIP][0][mmSCRATCH_REG1_BASE_IDX] + mmSCRATCH_REG3)*4;
	spare_पूर्णांक = adev->rmmio + (adev->reg_offset[GC_HWIP][0][mmRLC_SPARE_INT_BASE_IDX] + mmRLC_SPARE_INT)*4;

	grbm_cntl = adev->reg_offset[GC_HWIP][0][mmGRBM_GFX_CNTL_BASE_IDX] + mmGRBM_GFX_CNTL;
	grbm_idx = adev->reg_offset[GC_HWIP][0][mmGRBM_GFX_INDEX_BASE_IDX] + mmGRBM_GFX_INDEX;

	अगर (amdgpu_sriov_runसमय(adev)) अणु
		pr_err("shouldn't call rlcg write register during runtime\n");
		वापस;
	पूर्ण

	अगर (offset == grbm_cntl || offset == grbm_idx) अणु
		अगर (offset  == grbm_cntl)
			ग_लिखोl(v, scratch_reg2);
		अन्यथा अगर (offset == grbm_idx)
			ग_लिखोl(v, scratch_reg3);

		ग_लिखोl(v, ((व्योम __iomem *)adev->rmmio) + (offset * 4));
	पूर्ण अन्यथा अणु
		uपूर्णांक32_t i = 0;
		uपूर्णांक32_t retries = 50000;

		ग_लिखोl(v, scratch_reg0);
		ग_लिखोl(offset | 0x80000000, scratch_reg1);
		ग_लिखोl(1, spare_पूर्णांक);
		क्रम (i = 0; i < retries; i++) अणु
			u32 पंचांगp;

			पंचांगp = पढ़ोl(scratch_reg1);
			अगर (!(पंचांगp & 0x80000000))
				अवरोध;

			udelay(10);
		पूर्ण
		अगर (i >= retries)
			pr_err("timeout: rlcg program reg:0x%05x failed !\n", offset);
	पूर्ण

पूर्ण

अटल व्योम gfx_v9_0_rlcg_wreg(काष्ठा amdgpu_device *adev, u32 offset, u32 v, u32 flag)
अणु
	अगर (amdgpu_sriov_fullaccess(adev)) अणु
		gfx_v9_0_rlcg_rw(adev, offset, v, flag);

		वापस;
	पूर्ण

	अगर (flag & AMDGPU_REGS_NO_KIQ)
		WREG32_NO_KIQ(offset, v);
	अन्यथा
		WREG32(offset, v);
पूर्ण

#घोषणा VEGA10_GB_ADDR_CONFIG_GOLDEN 0x2a114042
#घोषणा VEGA12_GB_ADDR_CONFIG_GOLDEN 0x24104041
#घोषणा RAVEN_GB_ADDR_CONFIG_GOLDEN 0x24000042
#घोषणा RAVEN2_GB_ADDR_CONFIG_GOLDEN 0x26013041

अटल व्योम gfx_v9_0_set_ring_funcs(काष्ठा amdgpu_device *adev);
अटल व्योम gfx_v9_0_set_irq_funcs(काष्ठा amdgpu_device *adev);
अटल व्योम gfx_v9_0_set_gds_init(काष्ठा amdgpu_device *adev);
अटल व्योम gfx_v9_0_set_rlc_funcs(काष्ठा amdgpu_device *adev);
अटल पूर्णांक gfx_v9_0_get_cu_info(काष्ठा amdgpu_device *adev,
				काष्ठा amdgpu_cu_info *cu_info);
अटल uपूर्णांक64_t gfx_v9_0_get_gpu_घड़ी_counter(काष्ठा amdgpu_device *adev);
अटल व्योम gfx_v9_0_ring_emit_de_meta(काष्ठा amdgpu_ring *ring);
अटल u64 gfx_v9_0_ring_get_rptr_compute(काष्ठा amdgpu_ring *ring);
अटल पूर्णांक gfx_v9_0_query_ras_error_count(काष्ठा amdgpu_device *adev,
					  व्योम *ras_error_status);
अटल पूर्णांक gfx_v9_0_ras_error_inject(काष्ठा amdgpu_device *adev,
				     व्योम *inject_अगर);
अटल व्योम gfx_v9_0_reset_ras_error_count(काष्ठा amdgpu_device *adev);

अटल व्योम gfx_v9_0_kiq_set_resources(काष्ठा amdgpu_ring *kiq_ring,
				uपूर्णांक64_t queue_mask)
अणु
	amdgpu_ring_ग_लिखो(kiq_ring, PACKET3(PACKET3_SET_RESOURCES, 6));
	amdgpu_ring_ग_लिखो(kiq_ring,
		PACKET3_SET_RESOURCES_VMID_MASK(0) |
		/* vmid_mask:0* queue_type:0 (KIQ) */
		PACKET3_SET_RESOURCES_QUEUE_TYPE(0));
	amdgpu_ring_ग_लिखो(kiq_ring,
			lower_32_bits(queue_mask));	/* queue mask lo */
	amdgpu_ring_ग_लिखो(kiq_ring,
			upper_32_bits(queue_mask));	/* queue mask hi */
	amdgpu_ring_ग_लिखो(kiq_ring, 0);	/* gws mask lo */
	amdgpu_ring_ग_लिखो(kiq_ring, 0);	/* gws mask hi */
	amdgpu_ring_ग_लिखो(kiq_ring, 0);	/* oac mask */
	amdgpu_ring_ग_लिखो(kiq_ring, 0);	/* gds heap base:0, gds heap size:0 */
पूर्ण

अटल व्योम gfx_v9_0_kiq_map_queues(काष्ठा amdgpu_ring *kiq_ring,
				 काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = kiq_ring->adev;
	uपूर्णांक64_t mqd_addr = amdgpu_bo_gpu_offset(ring->mqd_obj);
	uपूर्णांक64_t wptr_addr = adev->wb.gpu_addr + (ring->wptr_offs * 4);
	uपूर्णांक32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;

	amdgpu_ring_ग_लिखो(kiq_ring, PACKET3(PACKET3_MAP_QUEUES, 5));
	/* Q_sel:0, vmid:0, vidmem: 1, engine:0, num_Q:1*/
	amdgpu_ring_ग_लिखो(kiq_ring, /* Q_sel: 0, vmid: 0, engine: 0, num_Q: 1 */
			 PACKET3_MAP_QUEUES_QUEUE_SEL(0) | /* Queue_Sel */
			 PACKET3_MAP_QUEUES_VMID(0) | /* VMID */
			 PACKET3_MAP_QUEUES_QUEUE(ring->queue) |
			 PACKET3_MAP_QUEUES_PIPE(ring->pipe) |
			 PACKET3_MAP_QUEUES_ME((ring->me == 1 ? 0 : 1)) |
			 /*queue_type: normal compute queue */
			 PACKET3_MAP_QUEUES_QUEUE_TYPE(0) |
			 /* alloc क्रमmat: all_on_one_pipe */
			 PACKET3_MAP_QUEUES_ALLOC_FORMAT(0) |
			 PACKET3_MAP_QUEUES_ENGINE_SEL(eng_sel) |
			 /* num_queues: must be 1 */
			 PACKET3_MAP_QUEUES_NUM_QUEUES(1));
	amdgpu_ring_ग_लिखो(kiq_ring,
			PACKET3_MAP_QUEUES_DOORBELL_OFFSET(ring->करोorbell_index));
	amdgpu_ring_ग_लिखो(kiq_ring, lower_32_bits(mqd_addr));
	amdgpu_ring_ग_लिखो(kiq_ring, upper_32_bits(mqd_addr));
	amdgpu_ring_ग_लिखो(kiq_ring, lower_32_bits(wptr_addr));
	amdgpu_ring_ग_लिखो(kiq_ring, upper_32_bits(wptr_addr));
पूर्ण

अटल व्योम gfx_v9_0_kiq_unmap_queues(काष्ठा amdgpu_ring *kiq_ring,
				   काष्ठा amdgpu_ring *ring,
				   क्रमागत amdgpu_unmap_queues_action action,
				   u64 gpu_addr, u64 seq)
अणु
	uपूर्णांक32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;

	amdgpu_ring_ग_लिखो(kiq_ring, PACKET3(PACKET3_UNMAP_QUEUES, 4));
	amdgpu_ring_ग_लिखो(kiq_ring, /* Q_sel: 0, vmid: 0, engine: 0, num_Q: 1 */
			  PACKET3_UNMAP_QUEUES_ACTION(action) |
			  PACKET3_UNMAP_QUEUES_QUEUE_SEL(0) |
			  PACKET3_UNMAP_QUEUES_ENGINE_SEL(eng_sel) |
			  PACKET3_UNMAP_QUEUES_NUM_QUEUES(1));
	amdgpu_ring_ग_लिखो(kiq_ring,
			PACKET3_UNMAP_QUEUES_DOORBELL_OFFSET0(ring->करोorbell_index));

	अगर (action == PREEMPT_QUEUES_NO_UNMAP) अणु
		amdgpu_ring_ग_लिखो(kiq_ring, lower_32_bits(gpu_addr));
		amdgpu_ring_ग_लिखो(kiq_ring, upper_32_bits(gpu_addr));
		amdgpu_ring_ग_लिखो(kiq_ring, seq);
	पूर्ण अन्यथा अणु
		amdgpu_ring_ग_लिखो(kiq_ring, 0);
		amdgpu_ring_ग_लिखो(kiq_ring, 0);
		amdgpu_ring_ग_लिखो(kiq_ring, 0);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_kiq_query_status(काष्ठा amdgpu_ring *kiq_ring,
				   काष्ठा amdgpu_ring *ring,
				   u64 addr,
				   u64 seq)
अणु
	uपूर्णांक32_t eng_sel = ring->funcs->type == AMDGPU_RING_TYPE_GFX ? 4 : 0;

	amdgpu_ring_ग_लिखो(kiq_ring, PACKET3(PACKET3_QUERY_STATUS, 5));
	amdgpu_ring_ग_लिखो(kiq_ring,
			  PACKET3_QUERY_STATUS_CONTEXT_ID(0) |
			  PACKET3_QUERY_STATUS_INTERRUPT_SEL(0) |
			  PACKET3_QUERY_STATUS_COMMAND(2));
	/* Q_sel: 0, vmid: 0, engine: 0, num_Q: 1 */
	amdgpu_ring_ग_लिखो(kiq_ring,
			PACKET3_QUERY_STATUS_DOORBELL_OFFSET(ring->करोorbell_index) |
			PACKET3_QUERY_STATUS_ENG_SEL(eng_sel));
	amdgpu_ring_ग_लिखो(kiq_ring, lower_32_bits(addr));
	amdgpu_ring_ग_लिखो(kiq_ring, upper_32_bits(addr));
	amdgpu_ring_ग_लिखो(kiq_ring, lower_32_bits(seq));
	amdgpu_ring_ग_लिखो(kiq_ring, upper_32_bits(seq));
पूर्ण

अटल व्योम gfx_v9_0_kiq_invalidate_tlbs(काष्ठा amdgpu_ring *kiq_ring,
				uपूर्णांक16_t pasid, uपूर्णांक32_t flush_type,
				bool all_hub)
अणु
	amdgpu_ring_ग_लिखो(kiq_ring, PACKET3(PACKET3_INVALIDATE_TLBS, 0));
	amdgpu_ring_ग_लिखो(kiq_ring,
			PACKET3_INVALIDATE_TLBS_DST_SEL(1) |
			PACKET3_INVALIDATE_TLBS_ALL_HUB(all_hub) |
			PACKET3_INVALIDATE_TLBS_PASID(pasid) |
			PACKET3_INVALIDATE_TLBS_FLUSH_TYPE(flush_type));
पूर्ण

अटल स्थिर काष्ठा kiq_pm4_funcs gfx_v9_0_kiq_pm4_funcs = अणु
	.kiq_set_resources = gfx_v9_0_kiq_set_resources,
	.kiq_map_queues = gfx_v9_0_kiq_map_queues,
	.kiq_unmap_queues = gfx_v9_0_kiq_unmap_queues,
	.kiq_query_status = gfx_v9_0_kiq_query_status,
	.kiq_invalidate_tlbs = gfx_v9_0_kiq_invalidate_tlbs,
	.set_resources_size = 8,
	.map_queues_size = 7,
	.unmap_queues_size = 6,
	.query_status_size = 7,
	.invalidate_tlbs_size = 2,
पूर्ण;

अटल व्योम gfx_v9_0_set_kiq_pm4_funcs(काष्ठा amdgpu_device *adev)
अणु
	adev->gfx.kiq.pmf = &gfx_v9_0_kiq_pm4_funcs;
पूर्ण

अटल व्योम gfx_v9_0_init_golden_रेजिस्टरs(काष्ठा amdgpu_device *adev)
अणु
	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_0,
						ARRAY_SIZE(golden_settings_gc_9_0));
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_0_vg10,
						ARRAY_SIZE(golden_settings_gc_9_0_vg10));
		अवरोध;
	हाल CHIP_VEGA12:
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_2_1,
						ARRAY_SIZE(golden_settings_gc_9_2_1));
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_2_1_vg12,
						ARRAY_SIZE(golden_settings_gc_9_2_1_vg12));
		अवरोध;
	हाल CHIP_VEGA20:
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_0,
						ARRAY_SIZE(golden_settings_gc_9_0));
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_0_vg20,
						ARRAY_SIZE(golden_settings_gc_9_0_vg20));
		अवरोध;
	हाल CHIP_ARCTURUS:
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_4_1_arct,
						ARRAY_SIZE(golden_settings_gc_9_4_1_arct));
		अवरोध;
	हाल CHIP_RAVEN:
		soc15_program_रेजिस्टर_sequence(adev, golden_settings_gc_9_1,
						ARRAY_SIZE(golden_settings_gc_9_1));
		अगर (adev->apu_flags & AMD_APU_IS_RAVEN2)
			soc15_program_रेजिस्टर_sequence(adev,
							golden_settings_gc_9_1_rv2,
							ARRAY_SIZE(golden_settings_gc_9_1_rv2));
		अन्यथा
			soc15_program_रेजिस्टर_sequence(adev,
							golden_settings_gc_9_1_rv1,
							ARRAY_SIZE(golden_settings_gc_9_1_rv1));
		अवरोध;
	 हाल CHIP_RENOIR:
		soc15_program_रेजिस्टर_sequence(adev,
						golden_settings_gc_9_1_rn,
						ARRAY_SIZE(golden_settings_gc_9_1_rn));
		वापस; /* क्रम renoir, करोn't need common goldensetting */
	हाल CHIP_ALDEBARAN:
		gfx_v9_4_2_init_golden_रेजिस्टरs(adev,
						 adev->smuio.funcs->get_die_id(adev));
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	अगर ((adev->asic_type != CHIP_ARCTURUS) &&
	    (adev->asic_type != CHIP_ALDEBARAN))
		soc15_program_रेजिस्टर_sequence(adev, golden_settings_gc_9_x_common,
						(स्थिर u32)ARRAY_SIZE(golden_settings_gc_9_x_common));
पूर्ण

अटल व्योम gfx_v9_0_scratch_init(काष्ठा amdgpu_device *adev)
अणु
	adev->gfx.scratch.num_reg = 8;
	adev->gfx.scratch.reg_base = SOC15_REG_OFFSET(GC, 0, mmSCRATCH_REG0);
	adev->gfx.scratch.मुक्त_mask = (1u << adev->gfx.scratch.num_reg) - 1;
पूर्ण

अटल व्योम gfx_v9_0_ग_लिखो_data_to_reg(काष्ठा amdgpu_ring *ring, पूर्णांक eng_sel,
				       bool wc, uपूर्णांक32_t reg, uपूर्णांक32_t val)
अणु
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, 3));
	amdgpu_ring_ग_लिखो(ring, WRITE_DATA_ENGINE_SEL(eng_sel) |
				WRITE_DATA_DST_SEL(0) |
				(wc ? WR_CONFIRM : 0));
	amdgpu_ring_ग_लिखो(ring, reg);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, val);
पूर्ण

अटल व्योम gfx_v9_0_रुको_reg_mem(काष्ठा amdgpu_ring *ring, पूर्णांक eng_sel,
				  पूर्णांक mem_space, पूर्णांक opt, uपूर्णांक32_t addr0,
				  uपूर्णांक32_t addr1, uपूर्णांक32_t ref, uपूर्णांक32_t mask,
				  uपूर्णांक32_t inv)
अणु
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));
	amdgpu_ring_ग_लिखो(ring,
				 /* memory (1) or रेजिस्टर (0) */
				 (WAIT_REG_MEM_MEM_SPACE(mem_space) |
				 WAIT_REG_MEM_OPERATION(opt) | /* रुको */
				 WAIT_REG_MEM_FUNCTION(3) |  /* equal */
				 WAIT_REG_MEM_ENGINE(eng_sel)));

	अगर (mem_space)
		BUG_ON(addr0 & 0x3); /* Dword align */
	amdgpu_ring_ग_लिखो(ring, addr0);
	amdgpu_ring_ग_लिखो(ring, addr1);
	amdgpu_ring_ग_लिखो(ring, ref);
	amdgpu_ring_ग_लिखो(ring, mask);
	amdgpu_ring_ग_लिखो(ring, inv); /* poll पूर्णांकerval */
पूर्ण

अटल पूर्णांक gfx_v9_0_ring_test_ring(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	uपूर्णांक32_t scratch;
	uपूर्णांक32_t पंचांगp = 0;
	अचिन्हित i;
	पूर्णांक r;

	r = amdgpu_gfx_scratch_get(adev, &scratch);
	अगर (r)
		वापस r;

	WREG32(scratch, 0xCAFEDEAD);
	r = amdgpu_ring_alloc(ring, 3);
	अगर (r)
		जाओ error_मुक्त_scratch;

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));
	amdgpu_ring_ग_लिखो(ring, (scratch - PACKET3_SET_UCONFIG_REG_START));
	amdgpu_ring_ग_लिखो(ring, 0xDEADBEEF);
	amdgpu_ring_commit(ring);

	क्रम (i = 0; i < adev->usec_समयout; i++) अणु
		पंचांगp = RREG32(scratch);
		अगर (पंचांगp == 0xDEADBEEF)
			अवरोध;
		udelay(1);
	पूर्ण

	अगर (i >= adev->usec_समयout)
		r = -ETIMEDOUT;

error_मुक्त_scratch:
	amdgpu_gfx_scratch_मुक्त(adev, scratch);
	वापस r;
पूर्ण

अटल पूर्णांक gfx_v9_0_ring_test_ib(काष्ठा amdgpu_ring *ring, दीर्घ समयout)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	काष्ठा amdgpu_ib ib;
	काष्ठा dma_fence *f = शून्य;

	अचिन्हित index;
	uपूर्णांक64_t gpu_addr;
	uपूर्णांक32_t पंचांगp;
	दीर्घ r;

	r = amdgpu_device_wb_get(adev, &index);
	अगर (r)
		वापस r;

	gpu_addr = adev->wb.gpu_addr + (index * 4);
	adev->wb.wb[index] = cpu_to_le32(0xCAFEDEAD);
	स_रखो(&ib, 0, माप(ib));
	r = amdgpu_ib_get(adev, शून्य, 16,
					AMDGPU_IB_POOL_सूचीECT, &ib);
	अगर (r)
		जाओ err1;

	ib.ptr[0] = PACKET3(PACKET3_WRITE_DATA, 3);
	ib.ptr[1] = WRITE_DATA_DST_SEL(5) | WR_CONFIRM;
	ib.ptr[2] = lower_32_bits(gpu_addr);
	ib.ptr[3] = upper_32_bits(gpu_addr);
	ib.ptr[4] = 0xDEADBEEF;
	ib.length_dw = 5;

	r = amdgpu_ib_schedule(ring, 1, &ib, शून्य, &f);
	अगर (r)
		जाओ err2;

	r = dma_fence_रुको_समयout(f, false, समयout);
	अगर (r == 0) अणु
		r = -ETIMEDOUT;
		जाओ err2;
	पूर्ण अन्यथा अगर (r < 0) अणु
		जाओ err2;
	पूर्ण

	पंचांगp = adev->wb.wb[index];
	अगर (पंचांगp == 0xDEADBEEF)
		r = 0;
	अन्यथा
		r = -EINVAL;

err2:
	amdgpu_ib_मुक्त(adev, &ib, शून्य);
	dma_fence_put(f);
err1:
	amdgpu_device_wb_मुक्त(adev, index);
	वापस r;
पूर्ण


अटल व्योम gfx_v9_0_मुक्त_microcode(काष्ठा amdgpu_device *adev)
अणु
	release_firmware(adev->gfx.pfp_fw);
	adev->gfx.pfp_fw = शून्य;
	release_firmware(adev->gfx.me_fw);
	adev->gfx.me_fw = शून्य;
	release_firmware(adev->gfx.ce_fw);
	adev->gfx.ce_fw = शून्य;
	release_firmware(adev->gfx.rlc_fw);
	adev->gfx.rlc_fw = शून्य;
	release_firmware(adev->gfx.mec_fw);
	adev->gfx.mec_fw = शून्य;
	release_firmware(adev->gfx.mec2_fw);
	adev->gfx.mec2_fw = शून्य;

	kमुक्त(adev->gfx.rlc.रेजिस्टर_list_क्रमmat);
पूर्ण

अटल व्योम gfx_v9_0_init_rlc_ext_microcode(काष्ठा amdgpu_device *adev)
अणु
	स्थिर काष्ठा rlc_firmware_header_v2_1 *rlc_hdr;

	rlc_hdr = (स्थिर काष्ठा rlc_firmware_header_v2_1 *)adev->gfx.rlc_fw->data;
	adev->gfx.rlc_srlc_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_cntl_ucode_ver);
	adev->gfx.rlc_srlc_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_cntl_feature_ver);
	adev->gfx.rlc.save_restore_list_cntl_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_cntl_size_bytes);
	adev->gfx.rlc.save_restore_list_cntl = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_cntl_offset_bytes);
	adev->gfx.rlc_srlg_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_gpm_ucode_ver);
	adev->gfx.rlc_srlg_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_gpm_feature_ver);
	adev->gfx.rlc.save_restore_list_gpm_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_gpm_size_bytes);
	adev->gfx.rlc.save_restore_list_gpm = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_gpm_offset_bytes);
	adev->gfx.rlc_srls_fw_version = le32_to_cpu(rlc_hdr->save_restore_list_srm_ucode_ver);
	adev->gfx.rlc_srls_feature_version = le32_to_cpu(rlc_hdr->save_restore_list_srm_feature_ver);
	adev->gfx.rlc.save_restore_list_srm_size_bytes = le32_to_cpu(rlc_hdr->save_restore_list_srm_size_bytes);
	adev->gfx.rlc.save_restore_list_srm = (u8 *)rlc_hdr + le32_to_cpu(rlc_hdr->save_restore_list_srm_offset_bytes);
	adev->gfx.rlc.reg_list_क्रमmat_direct_reg_list_length =
			le32_to_cpu(rlc_hdr->reg_list_क्रमmat_direct_reg_list_length);
पूर्ण

अटल व्योम gfx_v9_0_check_fw_ग_लिखो_रुको(काष्ठा amdgpu_device *adev)
अणु
	adev->gfx.me_fw_ग_लिखो_रुको = false;
	adev->gfx.mec_fw_ग_लिखो_रुको = false;

	अगर ((adev->asic_type != CHIP_ARCTURUS) &&
	    ((adev->gfx.mec_fw_version < 0x000001a5) ||
	    (adev->gfx.mec_feature_version < 46) ||
	    (adev->gfx.pfp_fw_version < 0x000000b7) ||
	    (adev->gfx.pfp_feature_version < 46)))
		DRM_WARN_ONCE("CP firmware version too old, please update!");

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
		अगर ((adev->gfx.me_fw_version >= 0x0000009c) &&
		    (adev->gfx.me_feature_version >= 42) &&
		    (adev->gfx.pfp_fw_version >=  0x000000b1) &&
		    (adev->gfx.pfp_feature_version >= 42))
			adev->gfx.me_fw_ग_लिखो_रुको = true;

		अगर ((adev->gfx.mec_fw_version >=  0x00000193) &&
		    (adev->gfx.mec_feature_version >= 42))
			adev->gfx.mec_fw_ग_लिखो_रुको = true;
		अवरोध;
	हाल CHIP_VEGA12:
		अगर ((adev->gfx.me_fw_version >= 0x0000009c) &&
		    (adev->gfx.me_feature_version >= 44) &&
		    (adev->gfx.pfp_fw_version >=  0x000000b2) &&
		    (adev->gfx.pfp_feature_version >= 44))
			adev->gfx.me_fw_ग_लिखो_रुको = true;

		अगर ((adev->gfx.mec_fw_version >=  0x00000196) &&
		    (adev->gfx.mec_feature_version >= 44))
			adev->gfx.mec_fw_ग_लिखो_रुको = true;
		अवरोध;
	हाल CHIP_VEGA20:
		अगर ((adev->gfx.me_fw_version >= 0x0000009c) &&
		    (adev->gfx.me_feature_version >= 44) &&
		    (adev->gfx.pfp_fw_version >=  0x000000b2) &&
		    (adev->gfx.pfp_feature_version >= 44))
			adev->gfx.me_fw_ग_लिखो_रुको = true;

		अगर ((adev->gfx.mec_fw_version >=  0x00000197) &&
		    (adev->gfx.mec_feature_version >= 44))
			adev->gfx.mec_fw_ग_लिखो_रुको = true;
		अवरोध;
	हाल CHIP_RAVEN:
		अगर ((adev->gfx.me_fw_version >= 0x0000009c) &&
		    (adev->gfx.me_feature_version >= 42) &&
		    (adev->gfx.pfp_fw_version >=  0x000000b1) &&
		    (adev->gfx.pfp_feature_version >= 42))
			adev->gfx.me_fw_ग_लिखो_रुको = true;

		अगर ((adev->gfx.mec_fw_version >=  0x00000192) &&
		    (adev->gfx.mec_feature_version >= 42))
			adev->gfx.mec_fw_ग_लिखो_रुको = true;
		अवरोध;
	शेष:
		adev->gfx.me_fw_ग_लिखो_रुको = true;
		adev->gfx.mec_fw_ग_लिखो_रुको = true;
		अवरोध;
	पूर्ण
पूर्ण

काष्ठा amdgpu_gfxoff_quirk अणु
	u16 chip_venकरोr;
	u16 chip_device;
	u16 subsys_venकरोr;
	u16 subsys_device;
	u8 revision;
पूर्ण;

अटल स्थिर काष्ठा amdgpu_gfxoff_quirk amdgpu_gfxoff_quirk_list[] = अणु
	/* https://bugzilla.kernel.org/show_bug.cgi?id=204689 */
	अणु 0x1002, 0x15dd, 0x1002, 0x15dd, 0xc8 पूर्ण,
	/* https://bugzilla.kernel.org/show_bug.cgi?id=207171 */
	अणु 0x1002, 0x15dd, 0x103c, 0x83e7, 0xd3 पूर्ण,
	/* GFXOFF is unstable on C6 parts with a VBIOS 113-RAVEN-114 */
	अणु 0x1002, 0x15dd, 0x1002, 0x15dd, 0xc6 पूर्ण,
	अणु 0, 0, 0, 0, 0 पूर्ण,
पूर्ण;

अटल bool gfx_v9_0_should_disable_gfxoff(काष्ठा pci_dev *pdev)
अणु
	स्थिर काष्ठा amdgpu_gfxoff_quirk *p = amdgpu_gfxoff_quirk_list;

	जबतक (p && p->chip_device != 0) अणु
		अगर (pdev->venकरोr == p->chip_venकरोr &&
		    pdev->device == p->chip_device &&
		    pdev->subप्रणाली_venकरोr == p->subsys_venकरोr &&
		    pdev->subप्रणाली_device == p->subsys_device &&
		    pdev->revision == p->revision) अणु
			वापस true;
		पूर्ण
		++p;
	पूर्ण
	वापस false;
पूर्ण

अटल bool is_raven_kicker(काष्ठा amdgpu_device *adev)
अणु
	अगर (adev->pm.fw_version >= 0x41e2b)
		वापस true;
	अन्यथा
		वापस false;
पूर्ण

अटल व्योम gfx_v9_0_check_अगर_need_gfxoff(काष्ठा amdgpu_device *adev)
अणु
	अगर (gfx_v9_0_should_disable_gfxoff(adev->pdev))
		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA12:
	हाल CHIP_VEGA20:
		अवरोध;
	हाल CHIP_RAVEN:
		अगर (!((adev->apu_flags & AMD_APU_IS_RAVEN2) ||
		      (adev->apu_flags & AMD_APU_IS_PICASSO)) &&
		    ((!is_raven_kicker(adev) &&
		      adev->gfx.rlc_fw_version < 531) ||
		     (adev->gfx.rlc_feature_version < 1) ||
		     !adev->gfx.rlc.is_rlc_v2_1))
			adev->pm.pp_feature &= ~PP_GFXOFF_MASK;

		अगर (adev->pm.pp_feature & PP_GFXOFF_MASK)
			adev->pg_flags |= AMD_PG_SUPPORT_GFX_PG |
				AMD_PG_SUPPORT_CP |
				AMD_PG_SUPPORT_RLC_SMU_HS;
		अवरोध;
	हाल CHIP_RENOIR:
		अगर (adev->pm.pp_feature & PP_GFXOFF_MASK)
			adev->pg_flags |= AMD_PG_SUPPORT_GFX_PG |
				AMD_PG_SUPPORT_CP |
				AMD_PG_SUPPORT_RLC_SMU_HS;
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल पूर्णांक gfx_v9_0_init_cp_gfx_microcode(काष्ठा amdgpu_device *adev,
					  स्थिर अक्षर *chip_name)
अणु
	अक्षर fw_name[30];
	पूर्णांक err;
	काष्ठा amdgpu_firmware_info *info = शून्य;
	स्थिर काष्ठा common_firmware_header *header = शून्य;
	स्थिर काष्ठा gfx_firmware_header_v1_0 *cp_hdr;

	snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_pfp.bin", chip_name);
	err = request_firmware(&adev->gfx.pfp_fw, fw_name, adev->dev);
	अगर (err)
		जाओ out;
	err = amdgpu_ucode_validate(adev->gfx.pfp_fw);
	अगर (err)
		जाओ out;
	cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.pfp_fw->data;
	adev->gfx.pfp_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);
	adev->gfx.pfp_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);

	snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_me.bin", chip_name);
	err = request_firmware(&adev->gfx.me_fw, fw_name, adev->dev);
	अगर (err)
		जाओ out;
	err = amdgpu_ucode_validate(adev->gfx.me_fw);
	अगर (err)
		जाओ out;
	cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.me_fw->data;
	adev->gfx.me_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);
	adev->gfx.me_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);

	snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_ce.bin", chip_name);
	err = request_firmware(&adev->gfx.ce_fw, fw_name, adev->dev);
	अगर (err)
		जाओ out;
	err = amdgpu_ucode_validate(adev->gfx.ce_fw);
	अगर (err)
		जाओ out;
	cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.ce_fw->data;
	adev->gfx.ce_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);
	adev->gfx.ce_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);

	अगर (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) अणु
		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_PFP];
		info->ucode_id = AMDGPU_UCODE_ID_CP_PFP;
		info->fw = adev->gfx.pfp_fw;
		header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);

		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_ME];
		info->ucode_id = AMDGPU_UCODE_ID_CP_ME;
		info->fw = adev->gfx.me_fw;
		header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);

		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_CE];
		info->ucode_id = AMDGPU_UCODE_ID_CP_CE;
		info->fw = adev->gfx.ce_fw;
		header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);
	पूर्ण

out:
	अगर (err) अणु
		dev_err(adev->dev,
			"gfx9: Failed to load firmware \"%s\"\n",
			fw_name);
		release_firmware(adev->gfx.pfp_fw);
		adev->gfx.pfp_fw = शून्य;
		release_firmware(adev->gfx.me_fw);
		adev->gfx.me_fw = शून्य;
		release_firmware(adev->gfx.ce_fw);
		adev->gfx.ce_fw = शून्य;
	पूर्ण
	वापस err;
पूर्ण

अटल पूर्णांक gfx_v9_0_init_rlc_microcode(काष्ठा amdgpu_device *adev,
					  स्थिर अक्षर *chip_name)
अणु
	अक्षर fw_name[30];
	पूर्णांक err;
	काष्ठा amdgpu_firmware_info *info = शून्य;
	स्थिर काष्ठा common_firmware_header *header = शून्य;
	स्थिर काष्ठा rlc_firmware_header_v2_0 *rlc_hdr;
	अचिन्हित पूर्णांक *पंचांगp = शून्य;
	अचिन्हित पूर्णांक i = 0;
	uपूर्णांक16_t version_major;
	uपूर्णांक16_t version_minor;
	uपूर्णांक32_t smu_version;

	/*
	 * For Picasso && AM4 SOCKET board, we use picasso_rlc_am4.bin
	 * instead of picasso_rlc.bin.
	 * Judgment method:
	 * PCO AM4: revision >= 0xC8 && revision <= 0xCF
	 *          or revision >= 0xD8 && revision <= 0xDF
	 * otherwise is PCO FP5
	 */
	अगर (!म_भेद(chip_name, "picasso") &&
		(((adev->pdev->revision >= 0xC8) && (adev->pdev->revision <= 0xCF)) ||
		((adev->pdev->revision >= 0xD8) && (adev->pdev->revision <= 0xDF))))
		snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_rlc_am4.bin", chip_name);
	अन्यथा अगर (!म_भेद(chip_name, "raven") && (amdgpu_pm_load_smu_firmware(adev, &smu_version) == 0) &&
		(smu_version >= 0x41e2b))
		/**
		*SMC is loaded by SBIOS on APU and it's able to get the SMU version directly.
		*/
		snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_kicker_rlc.bin", chip_name);
	अन्यथा
		snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_rlc.bin", chip_name);
	err = request_firmware(&adev->gfx.rlc_fw, fw_name, adev->dev);
	अगर (err)
		जाओ out;
	err = amdgpu_ucode_validate(adev->gfx.rlc_fw);
	rlc_hdr = (स्थिर काष्ठा rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;

	version_major = le16_to_cpu(rlc_hdr->header.header_version_major);
	version_minor = le16_to_cpu(rlc_hdr->header.header_version_minor);
	अगर (version_major == 2 && version_minor == 1)
		adev->gfx.rlc.is_rlc_v2_1 = true;

	adev->gfx.rlc_fw_version = le32_to_cpu(rlc_hdr->header.ucode_version);
	adev->gfx.rlc_feature_version = le32_to_cpu(rlc_hdr->ucode_feature_version);
	adev->gfx.rlc.save_and_restore_offset =
			le32_to_cpu(rlc_hdr->save_and_restore_offset);
	adev->gfx.rlc.clear_state_descriptor_offset =
			le32_to_cpu(rlc_hdr->clear_state_descriptor_offset);
	adev->gfx.rlc.avail_scratch_ram_locations =
			le32_to_cpu(rlc_hdr->avail_scratch_ram_locations);
	adev->gfx.rlc.reg_restore_list_size =
			le32_to_cpu(rlc_hdr->reg_restore_list_size);
	adev->gfx.rlc.reg_list_क्रमmat_start =
			le32_to_cpu(rlc_hdr->reg_list_क्रमmat_start);
	adev->gfx.rlc.reg_list_क्रमmat_separate_start =
			le32_to_cpu(rlc_hdr->reg_list_क्रमmat_separate_start);
	adev->gfx.rlc.starting_offsets_start =
			le32_to_cpu(rlc_hdr->starting_offsets_start);
	adev->gfx.rlc.reg_list_क्रमmat_size_bytes =
			le32_to_cpu(rlc_hdr->reg_list_क्रमmat_size_bytes);
	adev->gfx.rlc.reg_list_size_bytes =
			le32_to_cpu(rlc_hdr->reg_list_size_bytes);
	adev->gfx.rlc.रेजिस्टर_list_क्रमmat =
			kदो_स्मृति(adev->gfx.rlc.reg_list_क्रमmat_size_bytes +
				adev->gfx.rlc.reg_list_size_bytes, GFP_KERNEL);
	अगर (!adev->gfx.rlc.रेजिस्टर_list_क्रमmat) अणु
		err = -ENOMEM;
		जाओ out;
	पूर्ण

	पंचांगp = (अचिन्हित पूर्णांक *)((uपूर्णांकptr_t)rlc_hdr +
			le32_to_cpu(rlc_hdr->reg_list_क्रमmat_array_offset_bytes));
	क्रम (i = 0 ; i < (adev->gfx.rlc.reg_list_क्रमmat_size_bytes >> 2); i++)
		adev->gfx.rlc.रेजिस्टर_list_क्रमmat[i] =	le32_to_cpu(पंचांगp[i]);

	adev->gfx.rlc.रेजिस्टर_restore = adev->gfx.rlc.रेजिस्टर_list_क्रमmat + i;

	पंचांगp = (अचिन्हित पूर्णांक *)((uपूर्णांकptr_t)rlc_hdr +
			le32_to_cpu(rlc_hdr->reg_list_array_offset_bytes));
	क्रम (i = 0 ; i < (adev->gfx.rlc.reg_list_size_bytes >> 2); i++)
		adev->gfx.rlc.रेजिस्टर_restore[i] = le32_to_cpu(पंचांगp[i]);

	अगर (adev->gfx.rlc.is_rlc_v2_1)
		gfx_v9_0_init_rlc_ext_microcode(adev);

	अगर (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) अणु
		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_G];
		info->ucode_id = AMDGPU_UCODE_ID_RLC_G;
		info->fw = adev->gfx.rlc_fw;
		header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);

		अगर (adev->gfx.rlc.is_rlc_v2_1 &&
		    adev->gfx.rlc.save_restore_list_cntl_size_bytes &&
		    adev->gfx.rlc.save_restore_list_gpm_size_bytes &&
		    adev->gfx.rlc.save_restore_list_srm_size_bytes) अणु
			info = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL];
			info->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_CNTL;
			info->fw = adev->gfx.rlc_fw;
			adev->firmware.fw_size +=
				ALIGN(adev->gfx.rlc.save_restore_list_cntl_size_bytes, PAGE_SIZE);

			info = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM];
			info->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_GPM_MEM;
			info->fw = adev->gfx.rlc_fw;
			adev->firmware.fw_size +=
				ALIGN(adev->gfx.rlc.save_restore_list_gpm_size_bytes, PAGE_SIZE);

			info = &adev->firmware.ucode[AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM];
			info->ucode_id = AMDGPU_UCODE_ID_RLC_RESTORE_LIST_SRM_MEM;
			info->fw = adev->gfx.rlc_fw;
			adev->firmware.fw_size +=
				ALIGN(adev->gfx.rlc.save_restore_list_srm_size_bytes, PAGE_SIZE);
		पूर्ण
	पूर्ण

out:
	अगर (err) अणु
		dev_err(adev->dev,
			"gfx9: Failed to load firmware \"%s\"\n",
			fw_name);
		release_firmware(adev->gfx.rlc_fw);
		adev->gfx.rlc_fw = शून्य;
	पूर्ण
	वापस err;
पूर्ण

अटल bool gfx_v9_0_load_mec2_fw_bin_support(काष्ठा amdgpu_device *adev)
अणु
	अगर (adev->asic_type == CHIP_ALDEBARAN ||
	    adev->asic_type == CHIP_ARCTURUS ||
	    adev->asic_type == CHIP_RENOIR)
		वापस false;

	वापस true;
पूर्ण

अटल पूर्णांक gfx_v9_0_init_cp_compute_microcode(काष्ठा amdgpu_device *adev,
					  स्थिर अक्षर *chip_name)
अणु
	अक्षर fw_name[30];
	पूर्णांक err;
	काष्ठा amdgpu_firmware_info *info = शून्य;
	स्थिर काष्ठा common_firmware_header *header = शून्य;
	स्थिर काष्ठा gfx_firmware_header_v1_0 *cp_hdr;

	snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_mec.bin", chip_name);
	err = request_firmware(&adev->gfx.mec_fw, fw_name, adev->dev);
	अगर (err)
		जाओ out;
	err = amdgpu_ucode_validate(adev->gfx.mec_fw);
	अगर (err)
		जाओ out;
	cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;
	adev->gfx.mec_fw_version = le32_to_cpu(cp_hdr->header.ucode_version);
	adev->gfx.mec_feature_version = le32_to_cpu(cp_hdr->ucode_feature_version);


	अगर (gfx_v9_0_load_mec2_fw_bin_support(adev)) अणु
		snम_लिखो(fw_name, माप(fw_name), "amdgpu/%s_mec2.bin", chip_name);
		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
		अगर (!err) अणु
			err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
			अगर (err)
				जाओ out;
			cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)
			adev->gfx.mec2_fw->data;
			adev->gfx.mec2_fw_version =
			le32_to_cpu(cp_hdr->header.ucode_version);
			adev->gfx.mec2_feature_version =
			le32_to_cpu(cp_hdr->ucode_feature_version);
		पूर्ण अन्यथा अणु
			err = 0;
			adev->gfx.mec2_fw = शून्य;
		पूर्ण
	पूर्ण अन्यथा अणु
		adev->gfx.mec2_fw_version = adev->gfx.mec_fw_version;
		adev->gfx.mec2_feature_version = adev->gfx.mec_feature_version;
	पूर्ण

	अगर (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) अणु
		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC1];
		info->ucode_id = AMDGPU_UCODE_ID_CP_MEC1;
		info->fw = adev->gfx.mec_fw;
		header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
		cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)info->fw->data;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(header->ucode_size_bytes) - le32_to_cpu(cp_hdr->jt_size) * 4, PAGE_SIZE);

		info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC1_JT];
		info->ucode_id = AMDGPU_UCODE_ID_CP_MEC1_JT;
		info->fw = adev->gfx.mec_fw;
		adev->firmware.fw_size +=
			ALIGN(le32_to_cpu(cp_hdr->jt_size) * 4, PAGE_SIZE);

		अगर (adev->gfx.mec2_fw) अणु
			info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC2];
			info->ucode_id = AMDGPU_UCODE_ID_CP_MEC2;
			info->fw = adev->gfx.mec2_fw;
			header = (स्थिर काष्ठा common_firmware_header *)info->fw->data;
			cp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)info->fw->data;
			adev->firmware.fw_size +=
				ALIGN(le32_to_cpu(header->ucode_size_bytes) - le32_to_cpu(cp_hdr->jt_size) * 4, PAGE_SIZE);

			/* TODO: Determine अगर MEC2 JT FW loading can be हटाओd
				 क्रम all GFX V9 asic and above */
			अगर (gfx_v9_0_load_mec2_fw_bin_support(adev)) अणु
				info = &adev->firmware.ucode[AMDGPU_UCODE_ID_CP_MEC2_JT];
				info->ucode_id = AMDGPU_UCODE_ID_CP_MEC2_JT;
				info->fw = adev->gfx.mec2_fw;
				adev->firmware.fw_size +=
					ALIGN(le32_to_cpu(cp_hdr->jt_size) * 4,
					PAGE_SIZE);
			पूर्ण
		पूर्ण
	पूर्ण

out:
	gfx_v9_0_check_अगर_need_gfxoff(adev);
	gfx_v9_0_check_fw_ग_लिखो_रुको(adev);
	अगर (err) अणु
		dev_err(adev->dev,
			"gfx9: Failed to load firmware \"%s\"\n",
			fw_name);
		release_firmware(adev->gfx.mec_fw);
		adev->gfx.mec_fw = शून्य;
		release_firmware(adev->gfx.mec2_fw);
		adev->gfx.mec2_fw = शून्य;
	पूर्ण
	वापस err;
पूर्ण

अटल पूर्णांक gfx_v9_0_init_microcode(काष्ठा amdgpu_device *adev)
अणु
	स्थिर अक्षर *chip_name;
	पूर्णांक r;

	DRM_DEBUG("\n");

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
		chip_name = "vega10";
		अवरोध;
	हाल CHIP_VEGA12:
		chip_name = "vega12";
		अवरोध;
	हाल CHIP_VEGA20:
		chip_name = "vega20";
		अवरोध;
	हाल CHIP_RAVEN:
		अगर (adev->apu_flags & AMD_APU_IS_RAVEN2)
			chip_name = "raven2";
		अन्यथा अगर (adev->apu_flags & AMD_APU_IS_PICASSO)
			chip_name = "picasso";
		अन्यथा
			chip_name = "raven";
		अवरोध;
	हाल CHIP_ARCTURUS:
		chip_name = "arcturus";
		अवरोध;
	हाल CHIP_RENOIR:
		अगर (adev->apu_flags & AMD_APU_IS_RENOIR)
			chip_name = "renoir";
		अन्यथा
			chip_name = "green_sardine";
		अवरोध;
	हाल CHIP_ALDEBARAN:
		chip_name = "aldebaran";
		अवरोध;
	शेष:
		BUG();
	पूर्ण

	/* No CPG in Arcturus */
	अगर (adev->gfx.num_gfx_rings) अणु
		r = gfx_v9_0_init_cp_gfx_microcode(adev, chip_name);
		अगर (r)
			वापस r;
	पूर्ण

	r = gfx_v9_0_init_rlc_microcode(adev, chip_name);
	अगर (r)
		वापस r;

	r = gfx_v9_0_init_cp_compute_microcode(adev, chip_name);
	अगर (r)
		वापस r;

	वापस r;
पूर्ण

अटल u32 gfx_v9_0_get_csb_size(काष्ठा amdgpu_device *adev)
अणु
	u32 count = 0;
	स्थिर काष्ठा cs_section_def *sect = शून्य;
	स्थिर काष्ठा cs_extent_def *ext = शून्य;

	/* begin clear state */
	count += 2;
	/* context control state */
	count += 3;

	क्रम (sect = gfx9_cs_data; sect->section != शून्य; ++sect) अणु
		क्रम (ext = sect->section; ext->extent != शून्य; ++ext) अणु
			अगर (sect->id == SECT_CONTEXT)
				count += 2 + ext->reg_count;
			अन्यथा
				वापस 0;
		पूर्ण
	पूर्ण

	/* end clear state */
	count += 2;
	/* clear state */
	count += 2;

	वापस count;
पूर्ण

अटल व्योम gfx_v9_0_get_csb_buffer(काष्ठा amdgpu_device *adev,
				    अस्थिर u32 *buffer)
अणु
	u32 count = 0, i;
	स्थिर काष्ठा cs_section_def *sect = शून्य;
	स्थिर काष्ठा cs_extent_def *ext = शून्य;

	अगर (adev->gfx.rlc.cs_data == शून्य)
		वापस;
	अगर (buffer == शून्य)
		वापस;

	buffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));
	buffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);

	buffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));
	buffer[count++] = cpu_to_le32(0x80000000);
	buffer[count++] = cpu_to_le32(0x80000000);

	क्रम (sect = adev->gfx.rlc.cs_data; sect->section != शून्य; ++sect) अणु
		क्रम (ext = sect->section; ext->extent != शून्य; ++ext) अणु
			अगर (sect->id == SECT_CONTEXT) अणु
				buffer[count++] =
					cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));
				buffer[count++] = cpu_to_le32(ext->reg_index -
						PACKET3_SET_CONTEXT_REG_START);
				क्रम (i = 0; i < ext->reg_count; i++)
					buffer[count++] = cpu_to_le32(ext->extent[i]);
			पूर्ण अन्यथा अणु
				वापस;
			पूर्ण
		पूर्ण
	पूर्ण

	buffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));
	buffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);

	buffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));
	buffer[count++] = cpu_to_le32(0);
पूर्ण

अटल व्योम gfx_v9_0_init_always_on_cu_mask(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_cu_info *cu_info = &adev->gfx.cu_info;
	uपूर्णांक32_t pg_always_on_cu_num = 2;
	uपूर्णांक32_t always_on_cu_num;
	uपूर्णांक32_t i, j, k;
	uपूर्णांक32_t mask, cu_biपंचांगap, counter;

	अगर (adev->flags & AMD_IS_APU)
		always_on_cu_num = 4;
	अन्यथा अगर (adev->asic_type == CHIP_VEGA12)
		always_on_cu_num = 8;
	अन्यथा
		always_on_cu_num = 12;

	mutex_lock(&adev->grbm_idx_mutex);
	क्रम (i = 0; i < adev->gfx.config.max_shader_engines; i++) अणु
		क्रम (j = 0; j < adev->gfx.config.max_sh_per_se; j++) अणु
			mask = 1;
			cu_biपंचांगap = 0;
			counter = 0;
			gfx_v9_0_select_se_sh(adev, i, j, 0xffffffff);

			क्रम (k = 0; k < adev->gfx.config.max_cu_per_sh; k ++) अणु
				अगर (cu_info->biपंचांगap[i][j] & mask) अणु
					अगर (counter == pg_always_on_cu_num)
						WREG32_SOC15(GC, 0, mmRLC_PG_ALWAYS_ON_CU_MASK, cu_biपंचांगap);
					अगर (counter < always_on_cu_num)
						cu_biपंचांगap |= mask;
					अन्यथा
						अवरोध;
					counter++;
				पूर्ण
				mask <<= 1;
			पूर्ण

			WREG32_SOC15(GC, 0, mmRLC_LB_ALWAYS_ACTIVE_CU_MASK, cu_biपंचांगap);
			cu_info->ao_cu_biपंचांगap[i][j] = cu_biपंचांगap;
		पूर्ण
	पूर्ण
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	mutex_unlock(&adev->grbm_idx_mutex);
पूर्ण

अटल व्योम gfx_v9_0_init_lbpw(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t data;

	/* set mmRLC_LB_THR_CONFIG_1/2/3/4 */
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_1, 0x0000007F);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_2, 0x0333A5A7);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_3, 0x00000077);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_4, (0x30 | 0x40 << 8 | 0x02FA << 16));

	/* set mmRLC_LB_CNTR_INIT = 0x0000_0000 */
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTR_INIT, 0x00000000);

	/* set mmRLC_LB_CNTR_MAX = 0x0000_0500 */
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTR_MAX, 0x00000500);

	mutex_lock(&adev->grbm_idx_mutex);
	/* set mmRLC_LB_INIT_CU_MASK thru broadcast mode to enable all SE/SH*/
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	WREG32_SOC15(GC, 0, mmRLC_LB_INIT_CU_MASK, 0xffffffff);

	/* set mmRLC_LB_PARAMS = 0x003F_1006 */
	data = REG_SET_FIELD(0, RLC_LB_PARAMS, FIFO_SAMPLES, 0x0003);
	data |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLES, 0x0010);
	data |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLE_INTERVAL, 0x033F);
	WREG32_SOC15(GC, 0, mmRLC_LB_PARAMS, data);

	/* set mmRLC_GPM_GENERAL_7[31-16] = 0x00C0 */
	data = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7);
	data &= 0x0000FFFF;
	data |= 0x00C00000;
	WREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7, data);

	/*
	 * RLC_LB_ALWAYS_ACTIVE_CU_MASK = 0xF (4 CUs AON क्रम Raven),
	 * programmed in gfx_v9_0_init_always_on_cu_mask()
	 */

	/* set RLC_LB_CNTL = 0x8000_0095, 31 bit is reserved,
	 * but used क्रम RLC_LB_CNTL configuration */
	data = RLC_LB_CNTL__LB_CNT_SPIM_ACTIVE_MASK;
	data |= REG_SET_FIELD(data, RLC_LB_CNTL, CU_MASK_USED_OFF_HYST, 0x09);
	data |= REG_SET_FIELD(data, RLC_LB_CNTL, RESERVED, 0x80000);
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTL, data);
	mutex_unlock(&adev->grbm_idx_mutex);

	gfx_v9_0_init_always_on_cu_mask(adev);
पूर्ण

अटल व्योम gfx_v9_4_init_lbpw(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t data;

	/* set mmRLC_LB_THR_CONFIG_1/2/3/4 */
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_1, 0x0000007F);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_2, 0x033388F8);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_3, 0x00000077);
	WREG32_SOC15(GC, 0, mmRLC_LB_THR_CONFIG_4, (0x10 | 0x27 << 8 | 0x02FA << 16));

	/* set mmRLC_LB_CNTR_INIT = 0x0000_0000 */
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTR_INIT, 0x00000000);

	/* set mmRLC_LB_CNTR_MAX = 0x0000_0500 */
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTR_MAX, 0x00000800);

	mutex_lock(&adev->grbm_idx_mutex);
	/* set mmRLC_LB_INIT_CU_MASK thru broadcast mode to enable all SE/SH*/
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	WREG32_SOC15(GC, 0, mmRLC_LB_INIT_CU_MASK, 0xffffffff);

	/* set mmRLC_LB_PARAMS = 0x003F_1006 */
	data = REG_SET_FIELD(0, RLC_LB_PARAMS, FIFO_SAMPLES, 0x0003);
	data |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLES, 0x0010);
	data |= REG_SET_FIELD(data, RLC_LB_PARAMS, PG_IDLE_SAMPLE_INTERVAL, 0x033F);
	WREG32_SOC15(GC, 0, mmRLC_LB_PARAMS, data);

	/* set mmRLC_GPM_GENERAL_7[31-16] = 0x00C0 */
	data = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7);
	data &= 0x0000FFFF;
	data |= 0x00C00000;
	WREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_7, data);

	/*
	 * RLC_LB_ALWAYS_ACTIVE_CU_MASK = 0xFFF (12 CUs AON),
	 * programmed in gfx_v9_0_init_always_on_cu_mask()
	 */

	/* set RLC_LB_CNTL = 0x8000_0095, 31 bit is reserved,
	 * but used क्रम RLC_LB_CNTL configuration */
	data = RLC_LB_CNTL__LB_CNT_SPIM_ACTIVE_MASK;
	data |= REG_SET_FIELD(data, RLC_LB_CNTL, CU_MASK_USED_OFF_HYST, 0x09);
	data |= REG_SET_FIELD(data, RLC_LB_CNTL, RESERVED, 0x80000);
	WREG32_SOC15(GC, 0, mmRLC_LB_CNTL, data);
	mutex_unlock(&adev->grbm_idx_mutex);

	gfx_v9_0_init_always_on_cu_mask(adev);
पूर्ण

अटल व्योम gfx_v9_0_enable_lbpw(काष्ठा amdgpu_device *adev, bool enable)
अणु
	WREG32_FIELD15(GC, 0, RLC_LB_CNTL, LOAD_BALANCE_ENABLE, enable ? 1 : 0);
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_jump_table_num(काष्ठा amdgpu_device *adev)
अणु
	अगर (gfx_v9_0_load_mec2_fw_bin_support(adev))
		वापस 5;
	अन्यथा
		वापस 4;
पूर्ण

अटल पूर्णांक gfx_v9_0_rlc_init(काष्ठा amdgpu_device *adev)
अणु
	स्थिर काष्ठा cs_section_def *cs_data;
	पूर्णांक r;

	adev->gfx.rlc.cs_data = gfx9_cs_data;

	cs_data = adev->gfx.rlc.cs_data;

	अगर (cs_data) अणु
		/* init clear state block */
		r = amdgpu_gfx_rlc_init_csb(adev);
		अगर (r)
			वापस r;
	पूर्ण

	अगर (adev->flags & AMD_IS_APU) अणु
		/* TODO: द्विगुन check the cp_table_size क्रम RV */
		adev->gfx.rlc.cp_table_size = ALIGN(96 * 5 * 4, 2048) + (64 * 1024); /* JT + GDS */
		r = amdgpu_gfx_rlc_init_cpt(adev);
		अगर (r)
			वापस r;
	पूर्ण

	चयन (adev->asic_type) अणु
	हाल CHIP_RAVEN:
		gfx_v9_0_init_lbpw(adev);
		अवरोध;
	हाल CHIP_VEGA20:
		gfx_v9_4_init_lbpw(adev);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	/* init spm vmid with 0xf */
	अगर (adev->gfx.rlc.funcs->update_spm_vmid)
		adev->gfx.rlc.funcs->update_spm_vmid(adev, 0xf);

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_mec_fini(काष्ठा amdgpu_device *adev)
अणु
	amdgpu_bo_मुक्त_kernel(&adev->gfx.mec.hpd_eop_obj, शून्य, शून्य);
	amdgpu_bo_मुक्त_kernel(&adev->gfx.mec.mec_fw_obj, शून्य, शून्य);
पूर्ण

अटल पूर्णांक gfx_v9_0_mec_init(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक r;
	u32 *hpd;
	स्थिर __le32 *fw_data;
	अचिन्हित fw_size;
	u32 *fw;
	माप_प्रकार mec_hpd_size;

	स्थिर काष्ठा gfx_firmware_header_v1_0 *mec_hdr;

	biपंचांगap_zero(adev->gfx.mec.queue_biपंचांगap, AMDGPU_MAX_COMPUTE_QUEUES);

	/* take ownership of the relevant compute queues */
	amdgpu_gfx_compute_queue_acquire(adev);
	mec_hpd_size = adev->gfx.num_compute_rings * GFX9_MEC_HPD_SIZE;
	अगर (mec_hpd_size) अणु
		r = amdgpu_bo_create_reserved(adev, mec_hpd_size, PAGE_SIZE,
					      AMDGPU_GEM_DOMAIN_VRAM,
					      &adev->gfx.mec.hpd_eop_obj,
					      &adev->gfx.mec.hpd_eop_gpu_addr,
					      (व्योम **)&hpd);
		अगर (r) अणु
			dev_warn(adev->dev, "(%d) create HDP EOP bo failed\n", r);
			gfx_v9_0_mec_fini(adev);
			वापस r;
		पूर्ण

		स_रखो(hpd, 0, mec_hpd_size);

		amdgpu_bo_kunmap(adev->gfx.mec.hpd_eop_obj);
		amdgpu_bo_unreserve(adev->gfx.mec.hpd_eop_obj);
	पूर्ण

	mec_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;

	fw_data = (स्थिर __le32 *)
		(adev->gfx.mec_fw->data +
		 le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));
	fw_size = le32_to_cpu(mec_hdr->header.ucode_size_bytes);

	r = amdgpu_bo_create_reserved(adev, mec_hdr->header.ucode_size_bytes,
				      PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,
				      &adev->gfx.mec.mec_fw_obj,
				      &adev->gfx.mec.mec_fw_gpu_addr,
				      (व्योम **)&fw);
	अगर (r) अणु
		dev_warn(adev->dev, "(%d) create mec firmware bo failed\n", r);
		gfx_v9_0_mec_fini(adev);
		वापस r;
	पूर्ण

	स_नकल(fw, fw_data, fw_size);

	amdgpu_bo_kunmap(adev->gfx.mec.mec_fw_obj);
	amdgpu_bo_unreserve(adev->gfx.mec.mec_fw_obj);

	वापस 0;
पूर्ण

अटल uपूर्णांक32_t wave_पढ़ो_ind(काष्ठा amdgpu_device *adev, uपूर्णांक32_t simd, uपूर्णांक32_t wave, uपूर्णांक32_t address)
अणु
	WREG32_SOC15_RLC(GC, 0, mmSQ_IND_INDEX,
		(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |
		(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |
		(address << SQ_IND_INDEX__INDEX__SHIFT) |
		(SQ_IND_INDEX__FORCE_READ_MASK));
	वापस RREG32_SOC15(GC, 0, mmSQ_IND_DATA);
पूर्ण

अटल व्योम wave_पढ़ो_regs(काष्ठा amdgpu_device *adev, uपूर्णांक32_t simd,
			   uपूर्णांक32_t wave, uपूर्णांक32_t thपढ़ो,
			   uपूर्णांक32_t regno, uपूर्णांक32_t num, uपूर्णांक32_t *out)
अणु
	WREG32_SOC15_RLC(GC, 0, mmSQ_IND_INDEX,
		(wave << SQ_IND_INDEX__WAVE_ID__SHIFT) |
		(simd << SQ_IND_INDEX__SIMD_ID__SHIFT) |
		(regno << SQ_IND_INDEX__INDEX__SHIFT) |
		(thपढ़ो << SQ_IND_INDEX__THREAD_ID__SHIFT) |
		(SQ_IND_INDEX__FORCE_READ_MASK) |
		(SQ_IND_INDEX__AUTO_INCR_MASK));
	जबतक (num--)
		*(out++) = RREG32_SOC15(GC, 0, mmSQ_IND_DATA);
पूर्ण

अटल व्योम gfx_v9_0_पढ़ो_wave_data(काष्ठा amdgpu_device *adev, uपूर्णांक32_t simd, uपूर्णांक32_t wave, uपूर्णांक32_t *dst, पूर्णांक *no_fields)
अणु
	/* type 1 wave data */
	dst[(*no_fields)++] = 1;
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_STATUS);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_PC_LO);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_PC_HI);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_EXEC_LO);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_EXEC_HI);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_HW_ID);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_INST_DW0);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_INST_DW1);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_GPR_ALLOC);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_LDS_ALLOC);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_TRAPSTS);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_IB_STS);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_IB_DBG0);
	dst[(*no_fields)++] = wave_पढ़ो_ind(adev, simd, wave, ixSQ_WAVE_M0);
पूर्ण

अटल व्योम gfx_v9_0_पढ़ो_wave_sgprs(काष्ठा amdgpu_device *adev, uपूर्णांक32_t simd,
				     uपूर्णांक32_t wave, uपूर्णांक32_t start,
				     uपूर्णांक32_t size, uपूर्णांक32_t *dst)
अणु
	wave_पढ़ो_regs(
		adev, simd, wave, 0,
		start + SQIND_WAVE_SGPRS_OFFSET, size, dst);
पूर्ण

अटल व्योम gfx_v9_0_पढ़ो_wave_vgprs(काष्ठा amdgpu_device *adev, uपूर्णांक32_t simd,
				     uपूर्णांक32_t wave, uपूर्णांक32_t thपढ़ो,
				     uपूर्णांक32_t start, uपूर्णांक32_t size,
				     uपूर्णांक32_t *dst)
अणु
	wave_पढ़ो_regs(
		adev, simd, wave, thपढ़ो,
		start + SQIND_WAVE_VGPRS_OFFSET, size, dst);
पूर्ण

अटल व्योम gfx_v9_0_select_me_pipe_q(काष्ठा amdgpu_device *adev,
				  u32 me, u32 pipe, u32 q, u32 vm)
अणु
	soc15_grbm_select(adev, me, pipe, q, vm);
पूर्ण

अटल स्थिर काष्ठा amdgpu_gfx_funcs gfx_v9_0_gfx_funcs = अणु
        .get_gpu_घड़ी_counter = &gfx_v9_0_get_gpu_घड़ी_counter,
        .select_se_sh = &gfx_v9_0_select_se_sh,
        .पढ़ो_wave_data = &gfx_v9_0_पढ़ो_wave_data,
        .पढ़ो_wave_sgprs = &gfx_v9_0_पढ़ो_wave_sgprs,
        .पढ़ो_wave_vgprs = &gfx_v9_0_पढ़ो_wave_vgprs,
        .select_me_pipe_q = &gfx_v9_0_select_me_pipe_q,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_gfx_ras_funcs gfx_v9_0_ras_funcs = अणु
	.ras_late_init = amdgpu_gfx_ras_late_init,
	.ras_fini = amdgpu_gfx_ras_fini,
	.ras_error_inject = &gfx_v9_0_ras_error_inject,
	.query_ras_error_count = &gfx_v9_0_query_ras_error_count,
	.reset_ras_error_count = &gfx_v9_0_reset_ras_error_count,
पूर्ण;

अटल पूर्णांक gfx_v9_0_gpu_early_init(काष्ठा amdgpu_device *adev)
अणु
	u32 gb_addr_config;
	पूर्णांक err;

	adev->gfx.funcs = &gfx_v9_0_gfx_funcs;

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = VEGA10_GB_ADDR_CONFIG_GOLDEN;
		अवरोध;
	हाल CHIP_VEGA12:
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = VEGA12_GB_ADDR_CONFIG_GOLDEN;
		DRM_INFO("fix gfx.config for vega12\n");
		अवरोध;
	हाल CHIP_VEGA20:
		adev->gfx.ras_funcs = &gfx_v9_0_ras_funcs;
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);
		gb_addr_config &= ~0xf3e777ff;
		gb_addr_config |= 0x22014042;
		/* check vbios table अगर gpu info is not available */
		err = amdgpu_atomfirmware_get_gfx_info(adev);
		अगर (err)
			वापस err;
		अवरोध;
	हाल CHIP_RAVEN:
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		अगर (adev->apu_flags & AMD_APU_IS_RAVEN2)
			gb_addr_config = RAVEN2_GB_ADDR_CONFIG_GOLDEN;
		अन्यथा
			gb_addr_config = RAVEN_GB_ADDR_CONFIG_GOLDEN;
		अवरोध;
	हाल CHIP_ARCTURUS:
		adev->gfx.ras_funcs = &gfx_v9_4_ras_funcs;
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);
		gb_addr_config &= ~0xf3e777ff;
		gb_addr_config |= 0x22014042;
		अवरोध;
	हाल CHIP_RENOIR:
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x80;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);
		gb_addr_config &= ~0xf3e777ff;
		gb_addr_config |= 0x22010042;
		अवरोध;
	हाल CHIP_ALDEBARAN:
		adev->gfx.ras_funcs = &gfx_v9_4_2_ras_funcs;
		adev->gfx.config.max_hw_contexts = 8;
		adev->gfx.config.sc_prim_fअगरo_size_frontend = 0x20;
		adev->gfx.config.sc_prim_fअगरo_size_backend = 0x100;
		adev->gfx.config.sc_hiz_tile_fअगरo_size = 0x30;
		adev->gfx.config.sc_earlyz_tile_fअगरo_size = 0x4C0;
		gb_addr_config = RREG32_SOC15(GC, 0, mmGB_ADDR_CONFIG);
		gb_addr_config &= ~0xf3e777ff;
		gb_addr_config |= 0x22014042;
		/* check vbios table अगर gpu info is not available */
		err = amdgpu_atomfirmware_get_gfx_info(adev);
		अगर (err)
			वापस err;
		अवरोध;
	शेष:
		BUG();
		अवरोध;
	पूर्ण

	adev->gfx.config.gb_addr_config = gb_addr_config;

	adev->gfx.config.gb_addr_config_fields.num_pipes = 1 <<
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					NUM_PIPES);

	adev->gfx.config.max_tile_pipes =
		adev->gfx.config.gb_addr_config_fields.num_pipes;

	adev->gfx.config.gb_addr_config_fields.num_banks = 1 <<
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					NUM_BANKS);
	adev->gfx.config.gb_addr_config_fields.max_compress_frags = 1 <<
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					MAX_COMPRESSED_FRAGS);
	adev->gfx.config.gb_addr_config_fields.num_rb_per_se = 1 <<
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					NUM_RB_PER_SE);
	adev->gfx.config.gb_addr_config_fields.num_se = 1 <<
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					NUM_SHADER_ENGINES);
	adev->gfx.config.gb_addr_config_fields.pipe_पूर्णांकerleave_size = 1 << (8 +
			REG_GET_FIELD(
					adev->gfx.config.gb_addr_config,
					GB_ADDR_CONFIG,
					PIPE_INTERLEAVE_SIZE));

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_compute_ring_init(काष्ठा amdgpu_device *adev, पूर्णांक ring_id,
				      पूर्णांक mec, पूर्णांक pipe, पूर्णांक queue)
अणु
	अचिन्हित irq_type;
	काष्ठा amdgpu_ring *ring = &adev->gfx.compute_ring[ring_id];
	अचिन्हित पूर्णांक hw_prio;

	ring = &adev->gfx.compute_ring[ring_id];

	/* mec0 is me1 */
	ring->me = mec + 1;
	ring->pipe = pipe;
	ring->queue = queue;

	ring->ring_obj = शून्य;
	ring->use_करोorbell = true;
	ring->करोorbell_index = (adev->करोorbell_index.mec_ring0 + ring_id) << 1;
	ring->eop_gpu_addr = adev->gfx.mec.hpd_eop_gpu_addr
				+ (ring_id * GFX9_MEC_HPD_SIZE);
	प्र_लिखो(ring->name, "comp_%d.%d.%d", ring->me, ring->pipe, ring->queue);

	irq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP
		+ ((ring->me - 1) * adev->gfx.mec.num_pipe_per_mec)
		+ ring->pipe;
	hw_prio = amdgpu_gfx_is_high_priority_compute_queue(adev, ring) ?
			AMDGPU_GFX_PIPE_PRIO_HIGH : AMDGPU_GFX_PIPE_PRIO_NORMAL;
	/* type-2 packets are deprecated on MEC, use type-3 instead */
	वापस amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq, irq_type,
				hw_prio, शून्य);
पूर्ण

अटल पूर्णांक gfx_v9_0_sw_init(व्योम *handle)
अणु
	पूर्णांक i, j, k, r, ring_id;
	काष्ठा amdgpu_ring *ring;
	काष्ठा amdgpu_kiq *kiq;
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA12:
	हाल CHIP_VEGA20:
	हाल CHIP_RAVEN:
	हाल CHIP_ARCTURUS:
	हाल CHIP_RENOIR:
	हाल CHIP_ALDEBARAN:
		adev->gfx.mec.num_mec = 2;
		अवरोध;
	शेष:
		adev->gfx.mec.num_mec = 1;
		अवरोध;
	पूर्ण

	adev->gfx.mec.num_pipe_per_mec = 4;
	adev->gfx.mec.num_queue_per_pipe = 8;

	/* EOP Event */
	r = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_EOP_INTERRUPT, &adev->gfx.eop_irq);
	अगर (r)
		वापस r;

	/* Privileged reg */
	r = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_PRIV_REG_FAULT,
			      &adev->gfx.priv_reg_irq);
	अगर (r)
		वापस r;

	/* Privileged inst */
	r = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_PRIV_INSTR_FAULT,
			      &adev->gfx.priv_inst_irq);
	अगर (r)
		वापस r;

	/* ECC error */
	r = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_ECC_ERROR,
			      &adev->gfx.cp_ecc_error_irq);
	अगर (r)
		वापस r;

	/* FUE error */
	r = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_GRBM_CP, GFX_9_0__SRCID__CP_FUE_ERROR,
			      &adev->gfx.cp_ecc_error_irq);
	अगर (r)
		वापस r;

	adev->gfx.gfx_current_status = AMDGPU_GFX_NORMAL_MODE;

	gfx_v9_0_scratch_init(adev);

	r = gfx_v9_0_init_microcode(adev);
	अगर (r) अणु
		DRM_ERROR("Failed to load gfx firmware!\n");
		वापस r;
	पूर्ण

	r = adev->gfx.rlc.funcs->init(adev);
	अगर (r) अणु
		DRM_ERROR("Failed to init rlc BOs!\n");
		वापस r;
	पूर्ण

	r = gfx_v9_0_mec_init(adev);
	अगर (r) अणु
		DRM_ERROR("Failed to init MEC BOs!\n");
		वापस r;
	पूर्ण

	/* set up the gfx ring */
	क्रम (i = 0; i < adev->gfx.num_gfx_rings; i++) अणु
		ring = &adev->gfx.gfx_ring[i];
		ring->ring_obj = शून्य;
		अगर (!i)
			प्र_लिखो(ring->name, "gfx");
		अन्यथा
			प्र_लिखो(ring->name, "gfx_%d", i);
		ring->use_करोorbell = true;
		ring->करोorbell_index = adev->करोorbell_index.gfx_ring0 << 1;
		r = amdgpu_ring_init(adev, ring, 1024, &adev->gfx.eop_irq,
				     AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP,
				     AMDGPU_RING_PRIO_DEFAULT, शून्य);
		अगर (r)
			वापस r;
	पूर्ण

	/* set up the compute queues - allocate horizontally across pipes */
	ring_id = 0;
	क्रम (i = 0; i < adev->gfx.mec.num_mec; ++i) अणु
		क्रम (j = 0; j < adev->gfx.mec.num_queue_per_pipe; j++) अणु
			क्रम (k = 0; k < adev->gfx.mec.num_pipe_per_mec; k++) अणु
				अगर (!amdgpu_gfx_is_mec_queue_enabled(adev, i, k, j))
					जारी;

				r = gfx_v9_0_compute_ring_init(adev,
							       ring_id,
							       i, k, j);
				अगर (r)
					वापस r;

				ring_id++;
			पूर्ण
		पूर्ण
	पूर्ण

	r = amdgpu_gfx_kiq_init(adev, GFX9_MEC_HPD_SIZE);
	अगर (r) अणु
		DRM_ERROR("Failed to init KIQ BOs!\n");
		वापस r;
	पूर्ण

	kiq = &adev->gfx.kiq;
	r = amdgpu_gfx_kiq_init_ring(adev, &kiq->ring, &kiq->irq);
	अगर (r)
		वापस r;

	/* create MQD क्रम all compute queues as wel as KIQ क्रम SRIOV हाल */
	r = amdgpu_gfx_mqd_sw_init(adev, माप(काष्ठा v9_mqd_allocation));
	अगर (r)
		वापस r;

	adev->gfx.ce_ram_size = 0x8000;

	r = gfx_v9_0_gpu_early_init(adev);
	अगर (r)
		वापस r;

	वापस 0;
पूर्ण


अटल पूर्णांक gfx_v9_0_sw_fini(व्योम *handle)
अणु
	पूर्णांक i;
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	अगर (adev->gfx.ras_funcs &&
	    adev->gfx.ras_funcs->ras_fini)
		adev->gfx.ras_funcs->ras_fini(adev);

	क्रम (i = 0; i < adev->gfx.num_gfx_rings; i++)
		amdgpu_ring_fini(&adev->gfx.gfx_ring[i]);
	क्रम (i = 0; i < adev->gfx.num_compute_rings; i++)
		amdgpu_ring_fini(&adev->gfx.compute_ring[i]);

	amdgpu_gfx_mqd_sw_fini(adev);
	amdgpu_gfx_kiq_मुक्त_ring(&adev->gfx.kiq.ring);
	amdgpu_gfx_kiq_fini(adev);

	gfx_v9_0_mec_fini(adev);
	amdgpu_bo_unref(&adev->gfx.rlc.clear_state_obj);
	अगर (adev->flags & AMD_IS_APU) अणु
		amdgpu_bo_मुक्त_kernel(&adev->gfx.rlc.cp_table_obj,
				&adev->gfx.rlc.cp_table_gpu_addr,
				(व्योम **)&adev->gfx.rlc.cp_table_ptr);
	पूर्ण
	gfx_v9_0_मुक्त_microcode(adev);

	वापस 0;
पूर्ण


अटल व्योम gfx_v9_0_tiling_mode_table_init(काष्ठा amdgpu_device *adev)
अणु
	/* TODO */
पूर्ण

व्योम gfx_v9_0_select_se_sh(काष्ठा amdgpu_device *adev, u32 se_num, u32 sh_num,
			   u32 instance)
अणु
	u32 data;

	अगर (instance == 0xffffffff)
		data = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES, 1);
	अन्यथा
		data = REG_SET_FIELD(0, GRBM_GFX_INDEX, INSTANCE_INDEX, instance);

	अगर (se_num == 0xffffffff)
		data = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_BROADCAST_WRITES, 1);
	अन्यथा
		data = REG_SET_FIELD(data, GRBM_GFX_INDEX, SE_INDEX, se_num);

	अगर (sh_num == 0xffffffff)
		data = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_BROADCAST_WRITES, 1);
	अन्यथा
		data = REG_SET_FIELD(data, GRBM_GFX_INDEX, SH_INDEX, sh_num);

	WREG32_SOC15_RLC_SHADOW(GC, 0, mmGRBM_GFX_INDEX, data);
पूर्ण

अटल u32 gfx_v9_0_get_rb_active_biपंचांगap(काष्ठा amdgpu_device *adev)
अणु
	u32 data, mask;

	data = RREG32_SOC15(GC, 0, mmCC_RB_BACKEND_DISABLE);
	data |= RREG32_SOC15(GC, 0, mmGC_USER_RB_BACKEND_DISABLE);

	data &= CC_RB_BACKEND_DISABLE__BACKEND_DISABLE_MASK;
	data >>= GC_USER_RB_BACKEND_DISABLE__BACKEND_DISABLE__SHIFT;

	mask = amdgpu_gfx_create_biपंचांगask(adev->gfx.config.max_backends_per_se /
					 adev->gfx.config.max_sh_per_se);

	वापस (~data) & mask;
पूर्ण

अटल व्योम gfx_v9_0_setup_rb(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक i, j;
	u32 data;
	u32 active_rbs = 0;
	u32 rb_biपंचांगap_width_per_sh = adev->gfx.config.max_backends_per_se /
					adev->gfx.config.max_sh_per_se;

	mutex_lock(&adev->grbm_idx_mutex);
	क्रम (i = 0; i < adev->gfx.config.max_shader_engines; i++) अणु
		क्रम (j = 0; j < adev->gfx.config.max_sh_per_se; j++) अणु
			gfx_v9_0_select_se_sh(adev, i, j, 0xffffffff);
			data = gfx_v9_0_get_rb_active_biपंचांगap(adev);
			active_rbs |= data << ((i * adev->gfx.config.max_sh_per_se + j) *
					       rb_biपंचांगap_width_per_sh);
		पूर्ण
	पूर्ण
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	mutex_unlock(&adev->grbm_idx_mutex);

	adev->gfx.config.backend_enable_mask = active_rbs;
	adev->gfx.config.num_rbs = hweight32(active_rbs);
पूर्ण

#घोषणा DEFAULT_SH_MEM_BASES	(0x6000)
अटल व्योम gfx_v9_0_init_compute_vmid(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक i;
	uपूर्णांक32_t sh_mem_config;
	uपूर्णांक32_t sh_mem_bases;

	/*
	 * Configure apertures:
	 * LDS:         0x60000000'00000000 - 0x60000001'00000000 (4GB)
	 * Scratch:     0x60000001'00000000 - 0x60000002'00000000 (4GB)
	 * GPUVM:       0x60010000'00000000 - 0x60020000'00000000 (1TB)
	 */
	sh_mem_bases = DEFAULT_SH_MEM_BASES | (DEFAULT_SH_MEM_BASES << 16);

	sh_mem_config = SH_MEM_ADDRESS_MODE_64 |
			SH_MEM_ALIGNMENT_MODE_UNALIGNED <<
			SH_MEM_CONFIG__ALIGNMENT_MODE__SHIFT;

	mutex_lock(&adev->srbm_mutex);
	क्रम (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) अणु
		soc15_grbm_select(adev, 0, 0, 0, i);
		/* CP and shaders */
		WREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, sh_mem_config);
		WREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, sh_mem_bases);
	पूर्ण
	soc15_grbm_select(adev, 0, 0, 0, 0);
	mutex_unlock(&adev->srbm_mutex);

	/* Initialize all compute VMIDs to have no GDS, GWS, or OA
	   acccess. These should be enabled by FW क्रम target VMIDs. */
	क्रम (i = adev->vm_manager.first_kfd_vmid; i < AMDGPU_NUM_VMID; i++) अणु
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_BASE, 2 * i, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_SIZE, 2 * i, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_GWS_VMID0, i, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_OA_VMID0, i, 0);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_init_gds_vmid(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक vmid;

	/*
	 * Initialize all compute and user-gfx VMIDs to have no GDS, GWS, or OA
	 * access. Compute VMIDs should be enabled by FW क्रम target VMIDs,
	 * the driver can enable them क्रम graphics. VMID0 should मुख्यtain
	 * access so that HWS firmware can save/restore entries.
	 */
	क्रम (vmid = 1; vmid < AMDGPU_NUM_VMID; vmid++) अणु
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_BASE, 2 * vmid, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_VMID0_SIZE, 2 * vmid, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_GWS_VMID0, vmid, 0);
		WREG32_SOC15_OFFSET(GC, 0, mmGDS_OA_VMID0, vmid, 0);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_init_sq_config(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t पंचांगp;

	चयन (adev->asic_type) अणु
	हाल CHIP_ARCTURUS:
		पंचांगp = RREG32_SOC15(GC, 0, mmSQ_CONFIG);
		पंचांगp = REG_SET_FIELD(पंचांगp, SQ_CONFIG,
					DISABLE_BARRIER_WAITCNT, 1);
		WREG32_SOC15(GC, 0, mmSQ_CONFIG, पंचांगp);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_स्थिरants_init(काष्ठा amdgpu_device *adev)
अणु
	u32 पंचांगp;
	पूर्णांक i;

	WREG32_FIELD15_RLC(GC, 0, GRBM_CNTL, READ_TIMEOUT, 0xff);

	gfx_v9_0_tiling_mode_table_init(adev);

	gfx_v9_0_setup_rb(adev);
	gfx_v9_0_get_cu_info(adev, &adev->gfx.cu_info);
	adev->gfx.config.db_debug2 = RREG32_SOC15(GC, 0, mmDB_DEBUG2);

	/* XXX SH_MEM regs */
	/* where to put LDS, scratch, GPUVM in FSA64 space */
	mutex_lock(&adev->srbm_mutex);
	क्रम (i = 0; i < adev->vm_manager.id_mgr[AMDGPU_GFXHUB_0].num_ids; i++) अणु
		soc15_grbm_select(adev, 0, 0, 0, i);
		/* CP and shaders */
		अगर (i == 0) अणु
			पंचांगp = REG_SET_FIELD(0, SH_MEM_CONFIG, ALIGNMENT_MODE,
					    SH_MEM_ALIGNMENT_MODE_UNALIGNED);
			पंचांगp = REG_SET_FIELD(पंचांगp, SH_MEM_CONFIG, RETRY_DISABLE,
					    !!adev->gmc.noretry);
			WREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, पंचांगp);
			WREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, 0);
		पूर्ण अन्यथा अणु
			पंचांगp = REG_SET_FIELD(0, SH_MEM_CONFIG, ALIGNMENT_MODE,
					    SH_MEM_ALIGNMENT_MODE_UNALIGNED);
			पंचांगp = REG_SET_FIELD(पंचांगp, SH_MEM_CONFIG, RETRY_DISABLE,
					    !!adev->gmc.noretry);
			WREG32_SOC15_RLC(GC, 0, mmSH_MEM_CONFIG, पंचांगp);
			पंचांगp = REG_SET_FIELD(0, SH_MEM_BASES, PRIVATE_BASE,
				(adev->gmc.निजी_aperture_start >> 48));
			पंचांगp = REG_SET_FIELD(पंचांगp, SH_MEM_BASES, SHARED_BASE,
				(adev->gmc.shared_aperture_start >> 48));
			WREG32_SOC15_RLC(GC, 0, mmSH_MEM_BASES, पंचांगp);
		पूर्ण
	पूर्ण
	soc15_grbm_select(adev, 0, 0, 0, 0);

	mutex_unlock(&adev->srbm_mutex);

	gfx_v9_0_init_compute_vmid(adev);
	gfx_v9_0_init_gds_vmid(adev);
	gfx_v9_0_init_sq_config(adev);
पूर्ण

अटल व्योम gfx_v9_0_रुको_क्रम_rlc_serdes(काष्ठा amdgpu_device *adev)
अणु
	u32 i, j, k;
	u32 mask;

	mutex_lock(&adev->grbm_idx_mutex);
	क्रम (i = 0; i < adev->gfx.config.max_shader_engines; i++) अणु
		क्रम (j = 0; j < adev->gfx.config.max_sh_per_se; j++) अणु
			gfx_v9_0_select_se_sh(adev, i, j, 0xffffffff);
			क्रम (k = 0; k < adev->usec_समयout; k++) अणु
				अगर (RREG32_SOC15(GC, 0, mmRLC_SERDES_CU_MASTER_BUSY) == 0)
					अवरोध;
				udelay(1);
			पूर्ण
			अगर (k == adev->usec_समयout) अणु
				gfx_v9_0_select_se_sh(adev, 0xffffffff,
						      0xffffffff, 0xffffffff);
				mutex_unlock(&adev->grbm_idx_mutex);
				DRM_INFO("Timeout wait for RLC serdes %u,%u\n",
					 i, j);
				वापस;
			पूर्ण
		पूर्ण
	पूर्ण
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	mutex_unlock(&adev->grbm_idx_mutex);

	mask = RLC_SERDES_NONCU_MASTER_BUSY__SE_MASTER_BUSY_MASK |
		RLC_SERDES_NONCU_MASTER_BUSY__GC_MASTER_BUSY_MASK |
		RLC_SERDES_NONCU_MASTER_BUSY__TC0_MASTER_BUSY_MASK |
		RLC_SERDES_NONCU_MASTER_BUSY__TC1_MASTER_BUSY_MASK;
	क्रम (k = 0; k < adev->usec_समयout; k++) अणु
		अगर ((RREG32_SOC15(GC, 0, mmRLC_SERDES_NONCU_MASTER_BUSY) & mask) == 0)
			अवरोध;
		udelay(1);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_enable_gui_idle_पूर्णांकerrupt(काष्ठा amdgpu_device *adev,
					       bool enable)
अणु
	u32 पंचांगp;

	/* These पूर्णांकerrupts should be enabled to drive DS घड़ी */

	पंचांगp= RREG32_SOC15(GC, 0, mmCP_INT_CNTL_RING0);

	पंचांगp = REG_SET_FIELD(पंचांगp, CP_INT_CNTL_RING0, CNTX_BUSY_INT_ENABLE, enable ? 1 : 0);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_INT_CNTL_RING0, CNTX_EMPTY_INT_ENABLE, enable ? 1 : 0);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_INT_CNTL_RING0, CMP_BUSY_INT_ENABLE, enable ? 1 : 0);
	अगर(adev->gfx.num_gfx_rings)
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_INT_CNTL_RING0, GFX_IDLE_INT_ENABLE, enable ? 1 : 0);

	WREG32_SOC15(GC, 0, mmCP_INT_CNTL_RING0, पंचांगp);
पूर्ण

अटल व्योम gfx_v9_0_init_csb(काष्ठा amdgpu_device *adev)
अणु
	adev->gfx.rlc.funcs->get_csb_buffer(adev, adev->gfx.rlc.cs_ptr);
	/* csib */
	WREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_ADDR_HI),
			adev->gfx.rlc.clear_state_gpu_addr >> 32);
	WREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_ADDR_LO),
			adev->gfx.rlc.clear_state_gpu_addr & 0xfffffffc);
	WREG32_RLC(SOC15_REG_OFFSET(GC, 0, mmRLC_CSIB_LENGTH),
			adev->gfx.rlc.clear_state_size);
पूर्ण

अटल व्योम gfx_v9_1_parse_ind_reg_list(पूर्णांक *रेजिस्टर_list_क्रमmat,
				पूर्णांक indirect_offset,
				पूर्णांक list_size,
				पूर्णांक *unique_indirect_regs,
				पूर्णांक unique_indirect_reg_count,
				पूर्णांक *indirect_start_offsets,
				पूर्णांक *indirect_start_offsets_count,
				पूर्णांक max_start_offsets_count)
अणु
	पूर्णांक idx;

	क्रम (; indirect_offset < list_size; indirect_offset++) अणु
		WARN_ON(*indirect_start_offsets_count >= max_start_offsets_count);
		indirect_start_offsets[*indirect_start_offsets_count] = indirect_offset;
		*indirect_start_offsets_count = *indirect_start_offsets_count + 1;

		जबतक (रेजिस्टर_list_क्रमmat[indirect_offset] != 0xFFFFFFFF) अणु
			indirect_offset += 2;

			/* look क्रम the matching indice */
			क्रम (idx = 0; idx < unique_indirect_reg_count; idx++) अणु
				अगर (unique_indirect_regs[idx] ==
					रेजिस्टर_list_क्रमmat[indirect_offset] ||
					!unique_indirect_regs[idx])
					अवरोध;
			पूर्ण

			BUG_ON(idx >= unique_indirect_reg_count);

			अगर (!unique_indirect_regs[idx])
				unique_indirect_regs[idx] = रेजिस्टर_list_क्रमmat[indirect_offset];

			indirect_offset++;
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक gfx_v9_1_init_rlc_save_restore_list(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक unique_indirect_regs[] = अणु0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0पूर्ण;
	पूर्णांक unique_indirect_reg_count = 0;

	पूर्णांक indirect_start_offsets[] = अणु0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0पूर्ण;
	पूर्णांक indirect_start_offsets_count = 0;

	पूर्णांक list_size = 0;
	पूर्णांक i = 0, j = 0;
	u32 पंचांगp = 0;

	u32 *रेजिस्टर_list_क्रमmat =
		kmemdup(adev->gfx.rlc.रेजिस्टर_list_क्रमmat,
			adev->gfx.rlc.reg_list_क्रमmat_size_bytes, GFP_KERNEL);
	अगर (!रेजिस्टर_list_क्रमmat)
		वापस -ENOMEM;

	/* setup unique_indirect_regs array and indirect_start_offsets array */
	unique_indirect_reg_count = ARRAY_SIZE(unique_indirect_regs);
	gfx_v9_1_parse_ind_reg_list(रेजिस्टर_list_क्रमmat,
				    adev->gfx.rlc.reg_list_क्रमmat_direct_reg_list_length,
				    adev->gfx.rlc.reg_list_क्रमmat_size_bytes >> 2,
				    unique_indirect_regs,
				    unique_indirect_reg_count,
				    indirect_start_offsets,
				    &indirect_start_offsets_count,
				    ARRAY_SIZE(indirect_start_offsets));

	/* enable स्वतः inc in हाल it is disabled */
	पंचांगp = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_CNTL));
	पंचांगp |= RLC_SRM_CNTL__AUTO_INCR_ADDR_MASK;
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_CNTL), पंचांगp);

	/* ग_लिखो रेजिस्टर_restore table to offset 0x0 using RLC_SRM_ARAM_ADDR/DATA */
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_ARAM_ADDR),
		RLC_SAVE_RESTORE_ADDR_STARTING_OFFSET);
	क्रम (i = 0; i < adev->gfx.rlc.reg_list_size_bytes >> 2; i++)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_ARAM_DATA),
			adev->gfx.rlc.रेजिस्टर_restore[i]);

	/* load indirect रेजिस्टर */
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),
		adev->gfx.rlc.reg_list_क्रमmat_start);

	/* direct रेजिस्टर portion */
	क्रम (i = 0; i < adev->gfx.rlc.reg_list_क्रमmat_direct_reg_list_length; i++)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA),
			रेजिस्टर_list_क्रमmat[i]);

	/* indirect रेजिस्टर portion */
	जबतक (i < (adev->gfx.rlc.reg_list_क्रमmat_size_bytes >> 2)) अणु
		अगर (रेजिस्टर_list_क्रमmat[i] == 0xFFFFFFFF) अणु
			WREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, रेजिस्टर_list_क्रमmat[i++]);
			जारी;
		पूर्ण

		WREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, रेजिस्टर_list_क्रमmat[i++]);
		WREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, रेजिस्टर_list_क्रमmat[i++]);

		क्रम (j = 0; j < unique_indirect_reg_count; j++) अणु
			अगर (रेजिस्टर_list_क्रमmat[i] == unique_indirect_regs[j]) अणु
				WREG32_SOC15(GC, 0, mmRLC_GPM_SCRATCH_DATA, j);
				अवरोध;
			पूर्ण
		पूर्ण

		BUG_ON(j >= unique_indirect_reg_count);

		i++;
	पूर्ण

	/* set save/restore list size */
	list_size = adev->gfx.rlc.reg_list_size_bytes >> 2;
	list_size = list_size >> 1;
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),
		adev->gfx.rlc.reg_restore_list_size);
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA), list_size);

	/* ग_लिखो the starting offsets to RLC scratch ram */
	WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_ADDR),
		adev->gfx.rlc.starting_offsets_start);
	क्रम (i = 0; i < ARRAY_SIZE(indirect_start_offsets); i++)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_GPM_SCRATCH_DATA),
		       indirect_start_offsets[i]);

	/* load unique indirect regs*/
	क्रम (i = 0; i < ARRAY_SIZE(unique_indirect_regs); i++) अणु
		अगर (unique_indirect_regs[i] != 0) अणु
			WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_INDEX_CNTL_ADDR_0)
			       + GFX_RLC_SRM_INDEX_CNTL_ADDR_OFFSETS[i],
			       unique_indirect_regs[i] & 0x3FFFF);

			WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_SRM_INDEX_CNTL_DATA_0)
			       + GFX_RLC_SRM_INDEX_CNTL_DATA_OFFSETS[i],
			       unique_indirect_regs[i] >> 20);
		पूर्ण
	पूर्ण

	kमुक्त(रेजिस्टर_list_क्रमmat);
	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_enable_save_restore_machine(काष्ठा amdgpu_device *adev)
अणु
	WREG32_FIELD15(GC, 0, RLC_SRM_CNTL, SRM_ENABLE, 1);
पूर्ण

अटल व्योम pwr_10_0_gfxip_control_over_cgpg(काष्ठा amdgpu_device *adev,
					     bool enable)
अणु
	uपूर्णांक32_t data = 0;
	uपूर्णांक32_t शेष_data = 0;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS));
	अगर (enable) अणु
		/* enable GFXIP control over CGPG */
		data |= PWR_MISC_CNTL_STATUS__PWR_GFX_RLC_CGPG_EN_MASK;
		अगर(शेष_data != data)
			WREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);

		/* update status */
		data &= ~PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS_MASK;
		data |= (2 << PWR_MISC_CNTL_STATUS__PWR_GFXOFF_STATUS__SHIFT);
		अगर(शेष_data != data)
			WREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);
	पूर्ण अन्यथा अणु
		/* restore GFXIP control over GCPG */
		data &= ~PWR_MISC_CNTL_STATUS__PWR_GFX_RLC_CGPG_EN_MASK;
		अगर(शेष_data != data)
			WREG32(SOC15_REG_OFFSET(PWR, 0, mmPWR_MISC_CNTL_STATUS), data);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_init_gfx_घातer_gating(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t data = 0;

	अगर (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |
			      AMD_PG_SUPPORT_GFX_SMG |
			      AMD_PG_SUPPORT_GFX_DMG)) अणु
		/* init IDLE_POLL_COUNT = 60 */
		data = RREG32(SOC15_REG_OFFSET(GC, 0, mmCP_RB_WPTR_POLL_CNTL));
		data &= ~CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT_MASK;
		data |= (0x60 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);
		WREG32(SOC15_REG_OFFSET(GC, 0, mmCP_RB_WPTR_POLL_CNTL), data);

		/* init RLC PG Delay */
		data = 0;
		data |= (0x10 << RLC_PG_DELAY__POWER_UP_DELAY__SHIFT);
		data |= (0x10 << RLC_PG_DELAY__POWER_DOWN_DELAY__SHIFT);
		data |= (0x10 << RLC_PG_DELAY__CMD_PROPAGATE_DELAY__SHIFT);
		data |= (0x40 << RLC_PG_DELAY__MEM_SLEEP_DELAY__SHIFT);
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY), data);

		data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_2));
		data &= ~RLC_PG_DELAY_2__SERDES_CMD_DELAY_MASK;
		data |= (0x4 << RLC_PG_DELAY_2__SERDES_CMD_DELAY__SHIFT);
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_2), data);

		data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_3));
		data &= ~RLC_PG_DELAY_3__CGCG_ACTIVE_BEFORE_CGPG_MASK;
		data |= (0xff << RLC_PG_DELAY_3__CGCG_ACTIVE_BEFORE_CGPG__SHIFT);
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_DELAY_3), data);

		data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_AUTO_PG_CTRL));
		data &= ~RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD_MASK;

		/* program GRBM_REG_SAVE_GFX_IDLE_THRESHOLD to 0x55f0 */
		data |= (0x55f0 << RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD__SHIFT);
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_AUTO_PG_CTRL), data);
		अगर (adev->asic_type != CHIP_RENOIR)
			pwr_10_0_gfxip_control_over_cgpg(adev, true);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_enable_sck_slow_करोwn_on_घातer_up(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	uपूर्णांक32_t data = 0;
	uपूर्णांक32_t शेष_data = 0;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     SMU_CLK_SLOWDOWN_ON_PU_ENABLE,
			     enable ? 1 : 0);
	अगर (शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_enable_sck_slow_करोwn_on_घातer_करोwn(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	uपूर्णांक32_t data = 0;
	uपूर्णांक32_t शेष_data = 0;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     SMU_CLK_SLOWDOWN_ON_PD_ENABLE,
			     enable ? 1 : 0);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_enable_cp_घातer_gating(काष्ठा amdgpu_device *adev,
					bool enable)
अणु
	uपूर्णांक32_t data = 0;
	uपूर्णांक32_t शेष_data = 0;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     CP_PG_DISABLE,
			     enable ? 0 : 1);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_enable_gfx_cg_घातer_gating(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	uपूर्णांक32_t data, शेष_data;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     GFX_POWER_GATING_ENABLE,
			     enable ? 1 : 0);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_enable_gfx_pipeline_घातergating(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	uपूर्णांक32_t data, शेष_data;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     GFX_PIPELINE_PG_ENABLE,
			     enable ? 1 : 0);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);

	अगर (!enable)
		/* पढ़ो any GFX रेजिस्टर to wake up GFX */
		data = RREG32(SOC15_REG_OFFSET(GC, 0, mmDB_RENDER_CONTROL));
पूर्ण

अटल व्योम gfx_v9_0_enable_gfx_अटल_mg_घातer_gating(काष्ठा amdgpu_device *adev,
						       bool enable)
अणु
	uपूर्णांक32_t data, शेष_data;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     STATIC_PER_CU_PG_ENABLE,
			     enable ? 1 : 0);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_enable_gfx_dynamic_mg_घातer_gating(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	uपूर्णांक32_t data, शेष_data;

	शेष_data = data = RREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL));
	data = REG_SET_FIELD(data, RLC_PG_CNTL,
			     DYN_PER_CU_PG_ENABLE,
			     enable ? 1 : 0);
	अगर(शेष_data != data)
		WREG32(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_CNTL), data);
पूर्ण

अटल व्योम gfx_v9_0_init_pg(काष्ठा amdgpu_device *adev)
अणु
	gfx_v9_0_init_csb(adev);

	/*
	 * Rlc save restore list is workable since v2_1.
	 * And it's needed by gfxoff feature.
	 */
	अगर (adev->gfx.rlc.is_rlc_v2_1) अणु
		अगर (adev->asic_type == CHIP_VEGA12 ||
		    (adev->apu_flags & AMD_APU_IS_RAVEN2))
			gfx_v9_1_init_rlc_save_restore_list(adev);
		gfx_v9_0_enable_save_restore_machine(adev);
	पूर्ण

	अगर (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |
			      AMD_PG_SUPPORT_GFX_SMG |
			      AMD_PG_SUPPORT_GFX_DMG |
			      AMD_PG_SUPPORT_CP |
			      AMD_PG_SUPPORT_GDS |
			      AMD_PG_SUPPORT_RLC_SMU_HS)) अणु
		WREG32(mmRLC_JUMP_TABLE_RESTORE,
		       adev->gfx.rlc.cp_table_gpu_addr >> 8);
		gfx_v9_0_init_gfx_घातer_gating(adev);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_rlc_stop(काष्ठा amdgpu_device *adev)
अणु
	WREG32_FIELD15(GC, 0, RLC_CNTL, RLC_ENABLE_F32, 0);
	gfx_v9_0_enable_gui_idle_पूर्णांकerrupt(adev, false);
	gfx_v9_0_रुको_क्रम_rlc_serdes(adev);
पूर्ण

अटल व्योम gfx_v9_0_rlc_reset(काष्ठा amdgpu_device *adev)
अणु
	WREG32_FIELD15(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 1);
	udelay(50);
	WREG32_FIELD15(GC, 0, GRBM_SOFT_RESET, SOFT_RESET_RLC, 0);
	udelay(50);
पूर्ण

अटल व्योम gfx_v9_0_rlc_start(काष्ठा amdgpu_device *adev)
अणु
#अगर_घोषित AMDGPU_RLC_DEBUG_RETRY
	u32 rlc_ucode_ver;
#पूर्ण_अगर

	WREG32_FIELD15(GC, 0, RLC_CNTL, RLC_ENABLE_F32, 1);
	udelay(50);

	/* carrizo करो enable cp पूर्णांकerrupt after cp inited */
	अगर (!(adev->flags & AMD_IS_APU)) अणु
		gfx_v9_0_enable_gui_idle_पूर्णांकerrupt(adev, true);
		udelay(50);
	पूर्ण

#अगर_घोषित AMDGPU_RLC_DEBUG_RETRY
	/* RLC_GPM_GENERAL_6 : RLC Ucode version */
	rlc_ucode_ver = RREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_6);
	अगर(rlc_ucode_ver == 0x108) अणु
		DRM_INFO("Using rlc debug ucode. mmRLC_GPM_GENERAL_6 ==0x08%x / fw_ver == %i \n",
				rlc_ucode_ver, adev->gfx.rlc_fw_version);
		/* RLC_GPM_TIMER_INT_3 : Timer पूर्णांकerval in RefCLK cycles,
		 * शेष is 0x9C4 to create a 100us पूर्णांकerval */
		WREG32_SOC15(GC, 0, mmRLC_GPM_TIMER_INT_3, 0x9C4);
		/* RLC_GPM_GENERAL_12 : Minimum gap between wptr and rptr
		 * to disable the page fault retry पूर्णांकerrupts, शेष is
		 * 0x100 (256) */
		WREG32_SOC15(GC, 0, mmRLC_GPM_GENERAL_12, 0x100);
	पूर्ण
#पूर्ण_अगर
पूर्ण

अटल पूर्णांक gfx_v9_0_rlc_load_microcode(काष्ठा amdgpu_device *adev)
अणु
	स्थिर काष्ठा rlc_firmware_header_v2_0 *hdr;
	स्थिर __le32 *fw_data;
	अचिन्हित i, fw_size;

	अगर (!adev->gfx.rlc_fw)
		वापस -EINVAL;

	hdr = (स्थिर काष्ठा rlc_firmware_header_v2_0 *)adev->gfx.rlc_fw->data;
	amdgpu_ucode_prपूर्णांक_rlc_hdr(&hdr->header);

	fw_data = (स्थिर __le32 *)(adev->gfx.rlc_fw->data +
			   le32_to_cpu(hdr->header.ucode_array_offset_bytes));
	fw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;

	WREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_ADDR,
			RLCG_UCODE_LOADING_START_ADDRESS);
	क्रम (i = 0; i < fw_size; i++)
		WREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_DATA, le32_to_cpup(fw_data++));
	WREG32_SOC15(GC, 0, mmRLC_GPM_UCODE_ADDR, adev->gfx.rlc_fw_version);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_rlc_resume(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक r;

	अगर (amdgpu_sriov_vf(adev)) अणु
		gfx_v9_0_init_csb(adev);
		वापस 0;
	पूर्ण

	adev->gfx.rlc.funcs->stop(adev);

	/* disable CG */
	WREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, 0);

	gfx_v9_0_init_pg(adev);

	अगर (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) अणु
		/* legacy rlc firmware loading */
		r = gfx_v9_0_rlc_load_microcode(adev);
		अगर (r)
			वापस r;
	पूर्ण

	चयन (adev->asic_type) अणु
	हाल CHIP_RAVEN:
		अगर (amdgpu_lbpw == 0)
			gfx_v9_0_enable_lbpw(adev, false);
		अन्यथा
			gfx_v9_0_enable_lbpw(adev, true);
		अवरोध;
	हाल CHIP_VEGA20:
		अगर (amdgpu_lbpw > 0)
			gfx_v9_0_enable_lbpw(adev, true);
		अन्यथा
			gfx_v9_0_enable_lbpw(adev, false);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	adev->gfx.rlc.funcs->start(adev);

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_cp_gfx_enable(काष्ठा amdgpu_device *adev, bool enable)
अणु
	u32 पंचांगp = RREG32_SOC15(GC, 0, mmCP_ME_CNTL);

	पंचांगp = REG_SET_FIELD(पंचांगp, CP_ME_CNTL, ME_HALT, enable ? 0 : 1);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_ME_CNTL, PFP_HALT, enable ? 0 : 1);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_ME_CNTL, CE_HALT, enable ? 0 : 1);
	WREG32_SOC15_RLC(GC, 0, mmCP_ME_CNTL, पंचांगp);
	udelay(50);
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_gfx_load_microcode(काष्ठा amdgpu_device *adev)
अणु
	स्थिर काष्ठा gfx_firmware_header_v1_0 *pfp_hdr;
	स्थिर काष्ठा gfx_firmware_header_v1_0 *ce_hdr;
	स्थिर काष्ठा gfx_firmware_header_v1_0 *me_hdr;
	स्थिर __le32 *fw_data;
	अचिन्हित i, fw_size;

	अगर (!adev->gfx.me_fw || !adev->gfx.pfp_fw || !adev->gfx.ce_fw)
		वापस -EINVAL;

	pfp_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)
		adev->gfx.pfp_fw->data;
	ce_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)
		adev->gfx.ce_fw->data;
	me_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)
		adev->gfx.me_fw->data;

	amdgpu_ucode_prपूर्णांक_gfx_hdr(&pfp_hdr->header);
	amdgpu_ucode_prपूर्णांक_gfx_hdr(&ce_hdr->header);
	amdgpu_ucode_prपूर्णांक_gfx_hdr(&me_hdr->header);

	gfx_v9_0_cp_gfx_enable(adev, false);

	/* PFP */
	fw_data = (स्थिर __le32 *)
		(adev->gfx.pfp_fw->data +
		 le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));
	fw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;
	WREG32_SOC15(GC, 0, mmCP_PFP_UCODE_ADDR, 0);
	क्रम (i = 0; i < fw_size; i++)
		WREG32_SOC15(GC, 0, mmCP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));
	WREG32_SOC15(GC, 0, mmCP_PFP_UCODE_ADDR, adev->gfx.pfp_fw_version);

	/* CE */
	fw_data = (स्थिर __le32 *)
		(adev->gfx.ce_fw->data +
		 le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));
	fw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;
	WREG32_SOC15(GC, 0, mmCP_CE_UCODE_ADDR, 0);
	क्रम (i = 0; i < fw_size; i++)
		WREG32_SOC15(GC, 0, mmCP_CE_UCODE_DATA, le32_to_cpup(fw_data++));
	WREG32_SOC15(GC, 0, mmCP_CE_UCODE_ADDR, adev->gfx.ce_fw_version);

	/* ME */
	fw_data = (स्थिर __le32 *)
		(adev->gfx.me_fw->data +
		 le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));
	fw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;
	WREG32_SOC15(GC, 0, mmCP_ME_RAM_WADDR, 0);
	क्रम (i = 0; i < fw_size; i++)
		WREG32_SOC15(GC, 0, mmCP_ME_RAM_DATA, le32_to_cpup(fw_data++));
	WREG32_SOC15(GC, 0, mmCP_ME_RAM_WADDR, adev->gfx.me_fw_version);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_gfx_start(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring = &adev->gfx.gfx_ring[0];
	स्थिर काष्ठा cs_section_def *sect = शून्य;
	स्थिर काष्ठा cs_extent_def *ext = शून्य;
	पूर्णांक r, i, पंचांगp;

	/* init the CP */
	WREG32_SOC15(GC, 0, mmCP_MAX_CONTEXT, adev->gfx.config.max_hw_contexts - 1);
	WREG32_SOC15(GC, 0, mmCP_DEVICE_ID, 1);

	gfx_v9_0_cp_gfx_enable(adev, true);

	r = amdgpu_ring_alloc(ring, gfx_v9_0_get_csb_size(adev) + 4 + 3);
	अगर (r) अणु
		DRM_ERROR("amdgpu: cp failed to lock ring (%d).\n", r);
		वापस r;
	पूर्ण

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));
	amdgpu_ring_ग_लिखो(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));
	amdgpu_ring_ग_लिखो(ring, 0x80000000);
	amdgpu_ring_ग_लिखो(ring, 0x80000000);

	क्रम (sect = gfx9_cs_data; sect->section != शून्य; ++sect) अणु
		क्रम (ext = sect->section; ext->extent != शून्य; ++ext) अणु
			अगर (sect->id == SECT_CONTEXT) अणु
				amdgpu_ring_ग_लिखो(ring,
				       PACKET3(PACKET3_SET_CONTEXT_REG,
					       ext->reg_count));
				amdgpu_ring_ग_लिखो(ring,
				       ext->reg_index - PACKET3_SET_CONTEXT_REG_START);
				क्रम (i = 0; i < ext->reg_count; i++)
					amdgpu_ring_ग_लिखो(ring, ext->extent[i]);
			पूर्ण
		पूर्ण
	पूर्ण

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));
	amdgpu_ring_ग_लिखो(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_CLEAR_STATE, 0));
	amdgpu_ring_ग_लिखो(ring, 0);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_SET_BASE, 2));
	amdgpu_ring_ग_लिखो(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));
	amdgpu_ring_ग_लिखो(ring, 0x8000);
	amdgpu_ring_ग_लिखो(ring, 0x8000);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_SET_UCONFIG_REG,1));
	पंचांगp = (PACKET3_SET_UCONFIG_REG_INDEX_TYPE |
		(SOC15_REG_OFFSET(GC, 0, mmVGT_INDEX_TYPE) - PACKET3_SET_UCONFIG_REG_START));
	amdgpu_ring_ग_लिखो(ring, पंचांगp);
	amdgpu_ring_ग_लिखो(ring, 0);

	amdgpu_ring_commit(ring);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_gfx_resume(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring;
	u32 पंचांगp;
	u32 rb_bufsz;
	u64 rb_addr, rptr_addr, wptr_gpu_addr;

	/* Set the ग_लिखो poपूर्णांकer delay */
	WREG32_SOC15(GC, 0, mmCP_RB_WPTR_DELAY, 0);

	/* set the RB to use vmid 0 */
	WREG32_SOC15(GC, 0, mmCP_RB_VMID, 0);

	/* Set ring buffer size */
	ring = &adev->gfx.gfx_ring[0];
	rb_bufsz = order_base_2(ring->ring_size / 8);
	पंचांगp = REG_SET_FIELD(0, CP_RB0_CNTL, RB_BUFSZ, rb_bufsz);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_RB0_CNTL, RB_BLKSZ, rb_bufsz - 2);
#अगर_घोषित __BIG_ENDIAN
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_RB0_CNTL, BUF_SWAP, 1);
#पूर्ण_अगर
	WREG32_SOC15(GC, 0, mmCP_RB0_CNTL, पंचांगp);

	/* Initialize the ring buffer's ग_लिखो poपूर्णांकers */
	ring->wptr = 0;
	WREG32_SOC15(GC, 0, mmCP_RB0_WPTR, lower_32_bits(ring->wptr));
	WREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI, upper_32_bits(ring->wptr));

	/* set the wb address wether it's enabled or not */
	rptr_addr = adev->wb.gpu_addr + (ring->rptr_offs * 4);
	WREG32_SOC15(GC, 0, mmCP_RB0_RPTR_ADDR, lower_32_bits(rptr_addr));
	WREG32_SOC15(GC, 0, mmCP_RB0_RPTR_ADDR_HI, upper_32_bits(rptr_addr) & CP_RB_RPTR_ADDR_HI__RB_RPTR_ADDR_HI_MASK);

	wptr_gpu_addr = adev->wb.gpu_addr + (ring->wptr_offs * 4);
	WREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_ADDR_LO, lower_32_bits(wptr_gpu_addr));
	WREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_ADDR_HI, upper_32_bits(wptr_gpu_addr));

	mdelay(1);
	WREG32_SOC15(GC, 0, mmCP_RB0_CNTL, पंचांगp);

	rb_addr = ring->gpu_addr >> 8;
	WREG32_SOC15(GC, 0, mmCP_RB0_BASE, rb_addr);
	WREG32_SOC15(GC, 0, mmCP_RB0_BASE_HI, upper_32_bits(rb_addr));

	पंचांगp = RREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_CONTROL);
	अगर (ring->use_करोorbell) अणु
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_RB_DOORBELL_CONTROL,
				    DOORBELL_OFFSET, ring->करोorbell_index);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_RB_DOORBELL_CONTROL,
				    DOORBELL_EN, 1);
	पूर्ण अन्यथा अणु
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_RB_DOORBELL_CONTROL, DOORBELL_EN, 0);
	पूर्ण
	WREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_CONTROL, पंचांगp);

	पंचांगp = REG_SET_FIELD(0, CP_RB_DOORBELL_RANGE_LOWER,
			DOORBELL_RANGE_LOWER, ring->करोorbell_index);
	WREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_RANGE_LOWER, पंचांगp);

	WREG32_SOC15(GC, 0, mmCP_RB_DOORBELL_RANGE_UPPER,
		       CP_RB_DOORBELL_RANGE_UPPER__DOORBELL_RANGE_UPPER_MASK);


	/* start the ring */
	gfx_v9_0_cp_gfx_start(adev);
	ring->sched.पढ़ोy = true;

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_cp_compute_enable(काष्ठा amdgpu_device *adev, bool enable)
अणु
	अगर (enable) अणु
		WREG32_SOC15_RLC(GC, 0, mmCP_MEC_CNTL, 0);
	पूर्ण अन्यथा अणु
		WREG32_SOC15_RLC(GC, 0, mmCP_MEC_CNTL,
			(CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK));
		adev->gfx.kiq.ring.sched.पढ़ोy = false;
	पूर्ण
	udelay(50);
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_compute_load_microcode(काष्ठा amdgpu_device *adev)
अणु
	स्थिर काष्ठा gfx_firmware_header_v1_0 *mec_hdr;
	स्थिर __le32 *fw_data;
	अचिन्हित i;
	u32 पंचांगp;

	अगर (!adev->gfx.mec_fw)
		वापस -EINVAL;

	gfx_v9_0_cp_compute_enable(adev, false);

	mec_hdr = (स्थिर काष्ठा gfx_firmware_header_v1_0 *)adev->gfx.mec_fw->data;
	amdgpu_ucode_prपूर्णांक_gfx_hdr(&mec_hdr->header);

	fw_data = (स्थिर __le32 *)
		(adev->gfx.mec_fw->data +
		 le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));
	पंचांगp = 0;
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_CPC_IC_BASE_CNTL, VMID, 0);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);
	WREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_CNTL, पंचांगp);

	WREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_LO,
		adev->gfx.mec.mec_fw_gpu_addr & 0xFFFFF000);
	WREG32_SOC15(GC, 0, mmCP_CPC_IC_BASE_HI,
		upper_32_bits(adev->gfx.mec.mec_fw_gpu_addr));

	/* MEC1 */
	WREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_ADDR,
			 mec_hdr->jt_offset);
	क्रम (i = 0; i < mec_hdr->jt_size; i++)
		WREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_DATA,
			le32_to_cpup(fw_data + mec_hdr->jt_offset + i));

	WREG32_SOC15(GC, 0, mmCP_MEC_ME1_UCODE_ADDR,
			adev->gfx.mec_fw_version);
	/* Toकरो : Loading MEC2 firmware is only necessary अगर MEC2 should run dअगरferent microcode than MEC1. */

	वापस 0;
पूर्ण

/* KIQ functions */
अटल व्योम gfx_v9_0_kiq_setting(काष्ठा amdgpu_ring *ring)
अणु
	uपूर्णांक32_t पंचांगp;
	काष्ठा amdgpu_device *adev = ring->adev;

	/* tell RLC which is KIQ queue */
	पंचांगp = RREG32_SOC15(GC, 0, mmRLC_CP_SCHEDULERS);
	पंचांगp &= 0xffffff00;
	पंचांगp |= (ring->me << 5) | (ring->pipe << 3) | (ring->queue);
	WREG32_SOC15_RLC(GC, 0, mmRLC_CP_SCHEDULERS, पंचांगp);
	पंचांगp |= 0x80;
	WREG32_SOC15_RLC(GC, 0, mmRLC_CP_SCHEDULERS, पंचांगp);
पूर्ण

अटल व्योम gfx_v9_0_mqd_set_priority(काष्ठा amdgpu_ring *ring, काष्ठा v9_mqd *mqd)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	अगर (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) अणु
		अगर (amdgpu_gfx_is_high_priority_compute_queue(adev, ring)) अणु
			mqd->cp_hqd_pipe_priority = AMDGPU_GFX_PIPE_PRIO_HIGH;
			mqd->cp_hqd_queue_priority =
				AMDGPU_GFX_QUEUE_PRIORITY_MAXIMUM;
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक gfx_v9_0_mqd_init(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	काष्ठा v9_mqd *mqd = ring->mqd_ptr;
	uपूर्णांक64_t hqd_gpu_addr, wb_gpu_addr, eop_base_addr;
	uपूर्णांक32_t पंचांगp;

	mqd->header = 0xC0310800;
	mqd->compute_pipelinestat_enable = 0x00000001;
	mqd->compute_अटल_thपढ़ो_mgmt_se0 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se1 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se2 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se3 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se4 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se5 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se6 = 0xffffffff;
	mqd->compute_अटल_thपढ़ो_mgmt_se7 = 0xffffffff;
	mqd->compute_misc_reserved = 0x00000003;

	mqd->dynamic_cu_mask_addr_lo =
		lower_32_bits(ring->mqd_gpu_addr
			      + दुरत्व(काष्ठा v9_mqd_allocation, dynamic_cu_mask));
	mqd->dynamic_cu_mask_addr_hi =
		upper_32_bits(ring->mqd_gpu_addr
			      + दुरत्व(काष्ठा v9_mqd_allocation, dynamic_cu_mask));

	eop_base_addr = ring->eop_gpu_addr >> 8;
	mqd->cp_hqd_eop_base_addr_lo = eop_base_addr;
	mqd->cp_hqd_eop_base_addr_hi = upper_32_bits(eop_base_addr);

	/* set the EOP size, रेजिस्टर value is 2^(EOP_SIZE+1) dwords */
	पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_EOP_CONTROL);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_EOP_CONTROL, EOP_SIZE,
			(order_base_2(GFX9_MEC_HPD_SIZE / 4) - 1));

	mqd->cp_hqd_eop_control = पंचांगp;

	/* enable करोorbell? */
	पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL);

	अगर (ring->use_करोorbell) अणु
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
				    DOORBELL_OFFSET, ring->करोorbell_index);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
				    DOORBELL_EN, 1);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
				    DOORBELL_SOURCE, 0);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
				    DOORBELL_HIT, 0);
	पूर्ण अन्यथा अणु
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
					 DOORBELL_EN, 0);
	पूर्ण

	mqd->cp_hqd_pq_करोorbell_control = पंचांगp;

	/* disable the queue अगर it's active */
	ring->wptr = 0;
	mqd->cp_hqd_dequeue_request = 0;
	mqd->cp_hqd_pq_rptr = 0;
	mqd->cp_hqd_pq_wptr_lo = 0;
	mqd->cp_hqd_pq_wptr_hi = 0;

	/* set the poपूर्णांकer to the MQD */
	mqd->cp_mqd_base_addr_lo = ring->mqd_gpu_addr & 0xfffffffc;
	mqd->cp_mqd_base_addr_hi = upper_32_bits(ring->mqd_gpu_addr);

	/* set MQD vmid to 0 */
	पंचांगp = RREG32_SOC15(GC, 0, mmCP_MQD_CONTROL);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_MQD_CONTROL, VMID, 0);
	mqd->cp_mqd_control = पंचांगp;

	/* set the poपूर्णांकer to the HQD, this is similar CP_RB0_BASE/_HI */
	hqd_gpu_addr = ring->gpu_addr >> 8;
	mqd->cp_hqd_pq_base_lo = hqd_gpu_addr;
	mqd->cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);

	/* set up the HQD, this is similar to CP_RB0_CNTL */
	पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_CONTROL);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, QUEUE_SIZE,
			    (order_base_2(ring->ring_size / 4) - 1));
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, RPTR_BLOCK_SIZE,
			((order_base_2(AMDGPU_GPU_PAGE_SIZE / 4) - 1) << 8));
#अगर_घोषित __BIG_ENDIAN
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, ENDIAN_SWAP, 1);
#पूर्ण_अगर
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, UNORD_DISPATCH, 0);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, ROQ_PQ_IB_FLIP, 0);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, PRIV_STATE, 1);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_CONTROL, KMD_QUEUE, 1);
	mqd->cp_hqd_pq_control = पंचांगp;

	/* set the wb address whether it's enabled or not */
	wb_gpu_addr = adev->wb.gpu_addr + (ring->rptr_offs * 4);
	mqd->cp_hqd_pq_rptr_report_addr_lo = wb_gpu_addr & 0xfffffffc;
	mqd->cp_hqd_pq_rptr_report_addr_hi =
		upper_32_bits(wb_gpu_addr) & 0xffff;

	/* only used अगर CP_PQ_WPTR_POLL_CNTL.CP_PQ_WPTR_POLL_CNTL__EN_MASK=1 */
	wb_gpu_addr = adev->wb.gpu_addr + (ring->wptr_offs * 4);
	mqd->cp_hqd_pq_wptr_poll_addr_lo = wb_gpu_addr & 0xfffffffc;
	mqd->cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;

	पंचांगp = 0;
	/* enable the करोorbell अगर requested */
	अगर (ring->use_करोorbell) अणु
		पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
				DOORBELL_OFFSET, ring->करोorbell_index);

		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
					 DOORBELL_EN, 1);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
					 DOORBELL_SOURCE, 0);
		पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PQ_DOORBELL_CONTROL,
					 DOORBELL_HIT, 0);
	पूर्ण

	mqd->cp_hqd_pq_करोorbell_control = पंचांगp;

	/* reset पढ़ो and ग_लिखो poपूर्णांकers, similar to CP_RB0_WPTR/_RPTR */
	ring->wptr = 0;
	mqd->cp_hqd_pq_rptr = RREG32_SOC15(GC, 0, mmCP_HQD_PQ_RPTR);

	/* set the vmid क्रम the queue */
	mqd->cp_hqd_vmid = 0;

	पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_PERSISTENT_STATE);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_PERSISTENT_STATE, PRELOAD_SIZE, 0x53);
	mqd->cp_hqd_persistent_state = पंचांगp;

	/* set MIN_IB_AVAIL_SIZE */
	पंचांगp = RREG32_SOC15(GC, 0, mmCP_HQD_IB_CONTROL);
	पंचांगp = REG_SET_FIELD(पंचांगp, CP_HQD_IB_CONTROL, MIN_IB_AVAIL_SIZE, 3);
	mqd->cp_hqd_ib_control = पंचांगp;

	/* set अटल priority क्रम a queue/ring */
	gfx_v9_0_mqd_set_priority(ring, mqd);
	mqd->cp_hqd_quantum = RREG32(mmCP_HQD_QUANTUM);

	/* map_queues packet करोesn't need activate the queue,
	 * so only kiq need set this field.
	 */
	अगर (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)
		mqd->cp_hqd_active = 1;

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kiq_init_रेजिस्टर(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	काष्ठा v9_mqd *mqd = ring->mqd_ptr;
	पूर्णांक j;

	/* disable wptr polling */
	WREG32_FIELD15(GC, 0, CP_PQ_WPTR_POLL_CNTL, EN, 0);

	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_BASE_ADDR,
	       mqd->cp_hqd_eop_base_addr_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_BASE_ADDR_HI,
	       mqd->cp_hqd_eop_base_addr_hi);

	/* set the EOP size, रेजिस्टर value is 2^(EOP_SIZE+1) dwords */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_EOP_CONTROL,
	       mqd->cp_hqd_eop_control);

	/* enable करोorbell? */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL,
	       mqd->cp_hqd_pq_करोorbell_control);

	/* disable the queue अगर it's active */
	अगर (RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1) अणु
		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST, 1);
		क्रम (j = 0; j < adev->usec_समयout; j++) अणु
			अगर (!(RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1))
				अवरोध;
			udelay(1);
		पूर्ण
		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST,
		       mqd->cp_hqd_dequeue_request);
		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR,
		       mqd->cp_hqd_pq_rptr);
		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO,
		       mqd->cp_hqd_pq_wptr_lo);
		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI,
		       mqd->cp_hqd_pq_wptr_hi);
	पूर्ण

	/* set the poपूर्णांकer to the MQD */
	WREG32_SOC15_RLC(GC, 0, mmCP_MQD_BASE_ADDR,
	       mqd->cp_mqd_base_addr_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_MQD_BASE_ADDR_HI,
	       mqd->cp_mqd_base_addr_hi);

	/* set MQD vmid to 0 */
	WREG32_SOC15_RLC(GC, 0, mmCP_MQD_CONTROL,
	       mqd->cp_mqd_control);

	/* set the poपूर्णांकer to the HQD, this is similar CP_RB0_BASE/_HI */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_BASE,
	       mqd->cp_hqd_pq_base_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_BASE_HI,
	       mqd->cp_hqd_pq_base_hi);

	/* set up the HQD, this is similar to CP_RB0_CNTL */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_CONTROL,
	       mqd->cp_hqd_pq_control);

	/* set the wb address whether it's enabled or not */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR_REPORT_ADDR,
				mqd->cp_hqd_pq_rptr_report_addr_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR_REPORT_ADDR_HI,
				mqd->cp_hqd_pq_rptr_report_addr_hi);

	/* only used अगर CP_PQ_WPTR_POLL_CNTL.CP_PQ_WPTR_POLL_CNTL__EN_MASK=1 */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_POLL_ADDR,
	       mqd->cp_hqd_pq_wptr_poll_addr_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_POLL_ADDR_HI,
	       mqd->cp_hqd_pq_wptr_poll_addr_hi);

	/* enable the करोorbell अगर requested */
	अगर (ring->use_करोorbell) अणु
		WREG32_SOC15(GC, 0, mmCP_MEC_DOORBELL_RANGE_LOWER,
					(adev->करोorbell_index.kiq * 2) << 2);
		/* If GC has entered CGPG, ringing करोorbell > first page करोesn't
		 * wakeup GC. Enlarge CP_MEC_DOORBELL_RANGE_UPPER to workaround
		 * this issue.
		 */
		WREG32_SOC15(GC, 0, mmCP_MEC_DOORBELL_RANGE_UPPER,
					(adev->करोorbell.size - 4));
	पूर्ण

	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL,
	       mqd->cp_hqd_pq_करोorbell_control);

	/* reset पढ़ो and ग_लिखो poपूर्णांकers, similar to CP_RB0_WPTR/_RPTR */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO,
	       mqd->cp_hqd_pq_wptr_lo);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI,
	       mqd->cp_hqd_pq_wptr_hi);

	/* set the vmid क्रम the queue */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_VMID, mqd->cp_hqd_vmid);

	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PERSISTENT_STATE,
	       mqd->cp_hqd_persistent_state);

	/* activate the queue */
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_ACTIVE,
	       mqd->cp_hqd_active);

	अगर (ring->use_करोorbell)
		WREG32_FIELD15(GC, 0, CP_PQ_STATUS, DOORBELL_ENABLE, 1);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kiq_fini_रेजिस्टर(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	पूर्णांक j;

	/* disable the queue अगर it's active */
	अगर (RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1) अणु

		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST, 1);

		क्रम (j = 0; j < adev->usec_समयout; j++) अणु
			अगर (!(RREG32_SOC15(GC, 0, mmCP_HQD_ACTIVE) & 1))
				अवरोध;
			udelay(1);
		पूर्ण

		अगर (j == AMDGPU_MAX_USEC_TIMEOUT) अणु
			DRM_DEBUG("KIQ dequeue request failed.\n");

			/* Manual disable अगर dequeue request बार out */
			WREG32_SOC15_RLC(GC, 0, mmCP_HQD_ACTIVE, 0);
		पूर्ण

		WREG32_SOC15_RLC(GC, 0, mmCP_HQD_DEQUEUE_REQUEST,
		      0);
	पूर्ण

	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_IQ_TIMER, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_IB_CONTROL, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PERSISTENT_STATE, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL, 0x40000000);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_DOORBELL_CONTROL, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_RPTR, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_HI, 0);
	WREG32_SOC15_RLC(GC, 0, mmCP_HQD_PQ_WPTR_LO, 0);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kiq_init_queue(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	काष्ठा v9_mqd *mqd = ring->mqd_ptr;
	पूर्णांक mqd_idx = AMDGPU_MAX_COMPUTE_RINGS;
	काष्ठा v9_mqd *पंचांगp_mqd;

	gfx_v9_0_kiq_setting(ring);

	/* GPU could be in bad state during probe, driver trigger the reset
	 * after load the SMU, in this हाल , the mqd is not be initialized.
	 * driver need to re-init the mqd.
	 * check mqd->cp_hqd_pq_control since this value should not be 0
	 */
	पंचांगp_mqd = (काष्ठा v9_mqd *)adev->gfx.mec.mqd_backup[mqd_idx];
	अगर (amdgpu_in_reset(adev) && पंचांगp_mqd->cp_hqd_pq_control)अणु
		/* क्रम GPU_RESET हाल , reset MQD to a clean status */
		अगर (adev->gfx.mec.mqd_backup[mqd_idx])
			स_नकल(mqd, adev->gfx.mec.mqd_backup[mqd_idx], माप(काष्ठा v9_mqd_allocation));

		/* reset ring buffer */
		ring->wptr = 0;
		amdgpu_ring_clear_ring(ring);

		mutex_lock(&adev->srbm_mutex);
		soc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);
		gfx_v9_0_kiq_init_रेजिस्टर(ring);
		soc15_grbm_select(adev, 0, 0, 0, 0);
		mutex_unlock(&adev->srbm_mutex);
	पूर्ण अन्यथा अणु
		स_रखो((व्योम *)mqd, 0, माप(काष्ठा v9_mqd_allocation));
		((काष्ठा v9_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;
		((काष्ठा v9_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;
		mutex_lock(&adev->srbm_mutex);
		soc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);
		gfx_v9_0_mqd_init(ring);
		gfx_v9_0_kiq_init_रेजिस्टर(ring);
		soc15_grbm_select(adev, 0, 0, 0, 0);
		mutex_unlock(&adev->srbm_mutex);

		अगर (adev->gfx.mec.mqd_backup[mqd_idx])
			स_नकल(adev->gfx.mec.mqd_backup[mqd_idx], mqd, माप(काष्ठा v9_mqd_allocation));
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kcq_init_queue(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	काष्ठा v9_mqd *mqd = ring->mqd_ptr;
	पूर्णांक mqd_idx = ring - &adev->gfx.compute_ring[0];
	काष्ठा v9_mqd *पंचांगp_mqd;

	/* Same as above kiq init, driver need to re-init the mqd अगर mqd->cp_hqd_pq_control
	 * is not be initialized beक्रमe
	 */
	पंचांगp_mqd = (काष्ठा v9_mqd *)adev->gfx.mec.mqd_backup[mqd_idx];

	अगर (!पंचांगp_mqd->cp_hqd_pq_control ||
	    (!amdgpu_in_reset(adev) && !adev->in_suspend)) अणु
		स_रखो((व्योम *)mqd, 0, माप(काष्ठा v9_mqd_allocation));
		((काष्ठा v9_mqd_allocation *)mqd)->dynamic_cu_mask = 0xFFFFFFFF;
		((काष्ठा v9_mqd_allocation *)mqd)->dynamic_rb_mask = 0xFFFFFFFF;
		mutex_lock(&adev->srbm_mutex);
		soc15_grbm_select(adev, ring->me, ring->pipe, ring->queue, 0);
		gfx_v9_0_mqd_init(ring);
		soc15_grbm_select(adev, 0, 0, 0, 0);
		mutex_unlock(&adev->srbm_mutex);

		अगर (adev->gfx.mec.mqd_backup[mqd_idx])
			स_नकल(adev->gfx.mec.mqd_backup[mqd_idx], mqd, माप(काष्ठा v9_mqd_allocation));
	पूर्ण अन्यथा अगर (amdgpu_in_reset(adev)) अणु /* क्रम GPU_RESET हाल */
		/* reset MQD to a clean status */
		अगर (adev->gfx.mec.mqd_backup[mqd_idx])
			स_नकल(mqd, adev->gfx.mec.mqd_backup[mqd_idx], माप(काष्ठा v9_mqd_allocation));

		/* reset ring buffer */
		ring->wptr = 0;
		atomic64_set((atomic64_t *)&adev->wb.wb[ring->wptr_offs], 0);
		amdgpu_ring_clear_ring(ring);
	पूर्ण अन्यथा अणु
		amdgpu_ring_clear_ring(ring);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kiq_resume(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring;
	पूर्णांक r;

	ring = &adev->gfx.kiq.ring;

	r = amdgpu_bo_reserve(ring->mqd_obj, false);
	अगर (unlikely(r != 0))
		वापस r;

	r = amdgpu_bo_kmap(ring->mqd_obj, (व्योम **)&ring->mqd_ptr);
	अगर (unlikely(r != 0))
		वापस r;

	gfx_v9_0_kiq_init_queue(ring);
	amdgpu_bo_kunmap(ring->mqd_obj);
	ring->mqd_ptr = शून्य;
	amdgpu_bo_unreserve(ring->mqd_obj);
	ring->sched.पढ़ोy = true;
	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_kcq_resume(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring = शून्य;
	पूर्णांक r = 0, i;

	gfx_v9_0_cp_compute_enable(adev, true);

	क्रम (i = 0; i < adev->gfx.num_compute_rings; i++) अणु
		ring = &adev->gfx.compute_ring[i];

		r = amdgpu_bo_reserve(ring->mqd_obj, false);
		अगर (unlikely(r != 0))
			जाओ करोne;
		r = amdgpu_bo_kmap(ring->mqd_obj, (व्योम **)&ring->mqd_ptr);
		अगर (!r) अणु
			r = gfx_v9_0_kcq_init_queue(ring);
			amdgpu_bo_kunmap(ring->mqd_obj);
			ring->mqd_ptr = शून्य;
		पूर्ण
		amdgpu_bo_unreserve(ring->mqd_obj);
		अगर (r)
			जाओ करोne;
	पूर्ण

	r = amdgpu_gfx_enable_kcq(adev);
करोne:
	वापस r;
पूर्ण

अटल पूर्णांक gfx_v9_0_cp_resume(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक r, i;
	काष्ठा amdgpu_ring *ring;

	अगर (!(adev->flags & AMD_IS_APU))
		gfx_v9_0_enable_gui_idle_पूर्णांकerrupt(adev, false);

	अगर (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) अणु
		अगर (adev->gfx.num_gfx_rings) अणु
			/* legacy firmware loading */
			r = gfx_v9_0_cp_gfx_load_microcode(adev);
			अगर (r)
				वापस r;
		पूर्ण

		r = gfx_v9_0_cp_compute_load_microcode(adev);
		अगर (r)
			वापस r;
	पूर्ण

	r = gfx_v9_0_kiq_resume(adev);
	अगर (r)
		वापस r;

	अगर (adev->gfx.num_gfx_rings) अणु
		r = gfx_v9_0_cp_gfx_resume(adev);
		अगर (r)
			वापस r;
	पूर्ण

	r = gfx_v9_0_kcq_resume(adev);
	अगर (r)
		वापस r;

	अगर (adev->gfx.num_gfx_rings) अणु
		ring = &adev->gfx.gfx_ring[0];
		r = amdgpu_ring_test_helper(ring);
		अगर (r)
			वापस r;
	पूर्ण

	क्रम (i = 0; i < adev->gfx.num_compute_rings; i++) अणु
		ring = &adev->gfx.compute_ring[i];
		amdgpu_ring_test_helper(ring);
	पूर्ण

	gfx_v9_0_enable_gui_idle_पूर्णांकerrupt(adev, true);

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_init_tcp_config(काष्ठा amdgpu_device *adev)
अणु
	u32 पंचांगp;

	अगर (adev->asic_type != CHIP_ARCTURUS)
		वापस;

	पंचांगp = RREG32_SOC15(GC, 0, mmTCP_ADDR_CONFIG);
	पंचांगp = REG_SET_FIELD(पंचांगp, TCP_ADDR_CONFIG, ENABLE64KHASH,
				adev->df.hash_status.hash_64k);
	पंचांगp = REG_SET_FIELD(पंचांगp, TCP_ADDR_CONFIG, ENABLE2MHASH,
				adev->df.hash_status.hash_2m);
	पंचांगp = REG_SET_FIELD(पंचांगp, TCP_ADDR_CONFIG, ENABLE1GHASH,
				adev->df.hash_status.hash_1g);
	WREG32_SOC15(GC, 0, mmTCP_ADDR_CONFIG, पंचांगp);
पूर्ण

अटल व्योम gfx_v9_0_cp_enable(काष्ठा amdgpu_device *adev, bool enable)
अणु
	अगर (adev->gfx.num_gfx_rings)
		gfx_v9_0_cp_gfx_enable(adev, enable);
	gfx_v9_0_cp_compute_enable(adev, enable);
पूर्ण

अटल पूर्णांक gfx_v9_0_hw_init(व्योम *handle)
अणु
	पूर्णांक r;
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	अगर (!amdgpu_sriov_vf(adev))
		gfx_v9_0_init_golden_रेजिस्टरs(adev);

	gfx_v9_0_स्थिरants_init(adev);

	gfx_v9_0_init_tcp_config(adev);

	r = adev->gfx.rlc.funcs->resume(adev);
	अगर (r)
		वापस r;

	r = gfx_v9_0_cp_resume(adev);
	अगर (r)
		वापस r;

	अगर (adev->asic_type == CHIP_ALDEBARAN)
		gfx_v9_4_2_set_घातer_brake_sequence(adev);

	वापस r;
पूर्ण

अटल पूर्णांक gfx_v9_0_hw_fini(व्योम *handle)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	amdgpu_irq_put(adev, &adev->gfx.cp_ecc_error_irq, 0);
	amdgpu_irq_put(adev, &adev->gfx.priv_reg_irq, 0);
	amdgpu_irq_put(adev, &adev->gfx.priv_inst_irq, 0);

	/* DF मुक्तze and kcq disable will fail */
	अगर (!amdgpu_ras_पूर्णांकr_triggered())
		/* disable KCQ to aव्योम CPC touch memory not valid anymore */
		amdgpu_gfx_disable_kcq(adev);

	अगर (amdgpu_sriov_vf(adev)) अणु
		gfx_v9_0_cp_gfx_enable(adev, false);
		/* must disable polling क्रम SRIOV when hw finished, otherwise
		 * CPC engine may still keep fetching WB address which is alपढ़ोy
		 * invalid after sw finished and trigger DMAR पढ़ोing error in
		 * hypervisor side.
		 */
		WREG32_FIELD15(GC, 0, CP_PQ_WPTR_POLL_CNTL, EN, 0);
		वापस 0;
	पूर्ण

	/* Use deinitialize sequence from CAIL when unbinding device from driver,
	 * otherwise KIQ is hanging when binding back
	 */
	अगर (!amdgpu_in_reset(adev) && !adev->in_suspend) अणु
		mutex_lock(&adev->srbm_mutex);
		soc15_grbm_select(adev, adev->gfx.kiq.ring.me,
				adev->gfx.kiq.ring.pipe,
				adev->gfx.kiq.ring.queue, 0);
		gfx_v9_0_kiq_fini_रेजिस्टर(&adev->gfx.kiq.ring);
		soc15_grbm_select(adev, 0, 0, 0, 0);
		mutex_unlock(&adev->srbm_mutex);
	पूर्ण

	gfx_v9_0_cp_enable(adev, false);

	/* Skip suspend with A+A reset */
	अगर (adev->gmc.xgmi.connected_to_cpu && amdgpu_in_reset(adev)) अणु
		dev_dbg(adev->dev, "Device in reset. Skipping RLC halt\n");
		वापस 0;
	पूर्ण

	adev->gfx.rlc.funcs->stop(adev);
	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_suspend(व्योम *handle)
अणु
	वापस gfx_v9_0_hw_fini(handle);
पूर्ण

अटल पूर्णांक gfx_v9_0_resume(व्योम *handle)
अणु
	वापस gfx_v9_0_hw_init(handle);
पूर्ण

अटल bool gfx_v9_0_is_idle(व्योम *handle)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	अगर (REG_GET_FIELD(RREG32_SOC15(GC, 0, mmGRBM_STATUS),
				GRBM_STATUS, GUI_ACTIVE))
		वापस false;
	अन्यथा
		वापस true;
पूर्ण

अटल पूर्णांक gfx_v9_0_रुको_क्रम_idle(व्योम *handle)
अणु
	अचिन्हित i;
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	क्रम (i = 0; i < adev->usec_समयout; i++) अणु
		अगर (gfx_v9_0_is_idle(handle))
			वापस 0;
		udelay(1);
	पूर्ण
	वापस -ETIMEDOUT;
पूर्ण

अटल पूर्णांक gfx_v9_0_soft_reset(व्योम *handle)
अणु
	u32 grbm_soft_reset = 0;
	u32 पंचांगp;
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	/* GRBM_STATUS */
	पंचांगp = RREG32_SOC15(GC, 0, mmGRBM_STATUS);
	अगर (पंचांगp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |
		   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |
		   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |
		   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |
		   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |
		   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK)) अणु
		grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,
						GRBM_SOFT_RESET, SOFT_RESET_CP, 1);
		grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,
						GRBM_SOFT_RESET, SOFT_RESET_GFX, 1);
	पूर्ण

	अगर (पंचांगp & (GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK)) अणु
		grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,
						GRBM_SOFT_RESET, SOFT_RESET_CP, 1);
	पूर्ण

	/* GRBM_STATUS2 */
	पंचांगp = RREG32_SOC15(GC, 0, mmGRBM_STATUS2);
	अगर (REG_GET_FIELD(पंचांगp, GRBM_STATUS2, RLC_BUSY))
		grbm_soft_reset = REG_SET_FIELD(grbm_soft_reset,
						GRBM_SOFT_RESET, SOFT_RESET_RLC, 1);


	अगर (grbm_soft_reset) अणु
		/* stop the rlc */
		adev->gfx.rlc.funcs->stop(adev);

		अगर (adev->gfx.num_gfx_rings)
			/* Disable GFX parsing/prefetching */
			gfx_v9_0_cp_gfx_enable(adev, false);

		/* Disable MEC parsing/prefetching */
		gfx_v9_0_cp_compute_enable(adev, false);

		अगर (grbm_soft_reset) अणु
			पंचांगp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);
			पंचांगp |= grbm_soft_reset;
			dev_info(adev->dev, "GRBM_SOFT_RESET=0x%08X\n", पंचांगp);
			WREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET, पंचांगp);
			पंचांगp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);

			udelay(50);

			पंचांगp &= ~grbm_soft_reset;
			WREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET, पंचांगp);
			पंचांगp = RREG32_SOC15(GC, 0, mmGRBM_SOFT_RESET);
		पूर्ण

		/* Wait a little क्रम things to settle करोwn */
		udelay(50);
	पूर्ण
	वापस 0;
पूर्ण

अटल uपूर्णांक64_t gfx_v9_0_kiq_पढ़ो_घड़ी(काष्ठा amdgpu_device *adev)
अणु
	चिन्हित दीर्घ r, cnt = 0;
	अचिन्हित दीर्घ flags;
	uपूर्णांक32_t seq, reg_val_offs = 0;
	uपूर्णांक64_t value = 0;
	काष्ठा amdgpu_kiq *kiq = &adev->gfx.kiq;
	काष्ठा amdgpu_ring *ring = &kiq->ring;

	BUG_ON(!ring->funcs->emit_rreg);

	spin_lock_irqsave(&kiq->ring_lock, flags);
	अगर (amdgpu_device_wb_get(adev, &reg_val_offs)) अणु
		pr_err("critical bug! too many kiq readers\n");
		जाओ failed_unlock;
	पूर्ण
	amdgpu_ring_alloc(ring, 32);
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_COPY_DATA, 4));
	amdgpu_ring_ग_लिखो(ring, 9 |	/* src: रेजिस्टर*/
				(5 << 8) |	/* dst: memory */
				(1 << 16) |	/* count sel */
				(1 << 20));	/* ग_लिखो confirm */
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(adev->wb.gpu_addr +
				reg_val_offs * 4));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(adev->wb.gpu_addr +
				reg_val_offs * 4));
	r = amdgpu_fence_emit_polling(ring, &seq, MAX_KIQ_REG_WAIT);
	अगर (r)
		जाओ failed_unकरो;

	amdgpu_ring_commit(ring);
	spin_unlock_irqrestore(&kiq->ring_lock, flags);

	r = amdgpu_fence_रुको_polling(ring, seq, MAX_KIQ_REG_WAIT);

	/* करोn't रुको anymore क्रम gpu reset हाल because this way may
	 * block gpu_recover() routine क्रमever, e.g. this virt_kiq_rreg
	 * is triggered in TTM and tपंचांग_bo_lock_delayed_workqueue() will
	 * never वापस अगर we keep रुकोing in virt_kiq_rreg, which cause
	 * gpu_recover() hang there.
	 *
	 * also करोn't रुको anymore क्रम IRQ context
	 * */
	अगर (r < 1 && (amdgpu_in_reset(adev)))
		जाओ failed_kiq_पढ़ो;

	might_sleep();
	जबतक (r < 1 && cnt++ < MAX_KIQ_REG_TRY) अणु
		msleep(MAX_KIQ_REG_BAILOUT_INTERVAL);
		r = amdgpu_fence_रुको_polling(ring, seq, MAX_KIQ_REG_WAIT);
	पूर्ण

	अगर (cnt > MAX_KIQ_REG_TRY)
		जाओ failed_kiq_पढ़ो;

	mb();
	value = (uपूर्णांक64_t)adev->wb.wb[reg_val_offs] |
		(uपूर्णांक64_t)adev->wb.wb[reg_val_offs + 1 ] << 32ULL;
	amdgpu_device_wb_मुक्त(adev, reg_val_offs);
	वापस value;

failed_unकरो:
	amdgpu_ring_unकरो(ring);
failed_unlock:
	spin_unlock_irqrestore(&kiq->ring_lock, flags);
failed_kiq_पढ़ो:
	अगर (reg_val_offs)
		amdgpu_device_wb_मुक्त(adev, reg_val_offs);
	pr_err("failed to read gpu clock\n");
	वापस ~0;
पूर्ण

अटल uपूर्णांक64_t gfx_v9_0_get_gpu_घड़ी_counter(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक64_t घड़ी;

	amdgpu_gfx_off_ctrl(adev, false);
	mutex_lock(&adev->gfx.gpu_घड़ी_mutex);
	अगर (adev->asic_type == CHIP_VEGA10 && amdgpu_sriov_runसमय(adev)) अणु
		घड़ी = gfx_v9_0_kiq_पढ़ो_घड़ी(adev);
	पूर्ण अन्यथा अणु
		WREG32_SOC15(GC, 0, mmRLC_CAPTURE_GPU_CLOCK_COUNT, 1);
		घड़ी = (uपूर्णांक64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_LSB) |
			((uपूर्णांक64_t)RREG32_SOC15(GC, 0, mmRLC_GPU_CLOCK_COUNT_MSB) << 32ULL);
	पूर्ण
	mutex_unlock(&adev->gfx.gpu_घड़ी_mutex);
	amdgpu_gfx_off_ctrl(adev, true);
	वापस घड़ी;
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_gds_चयन(काष्ठा amdgpu_ring *ring,
					  uपूर्णांक32_t vmid,
					  uपूर्णांक32_t gds_base, uपूर्णांक32_t gds_size,
					  uपूर्णांक32_t gws_base, uपूर्णांक32_t gws_size,
					  uपूर्णांक32_t oa_base, uपूर्णांक32_t oa_size)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	/* GDS Base */
	gfx_v9_0_ग_लिखो_data_to_reg(ring, 0, false,
				   SOC15_REG_OFFSET(GC, 0, mmGDS_VMID0_BASE) + 2 * vmid,
				   gds_base);

	/* GDS Size */
	gfx_v9_0_ग_लिखो_data_to_reg(ring, 0, false,
				   SOC15_REG_OFFSET(GC, 0, mmGDS_VMID0_SIZE) + 2 * vmid,
				   gds_size);

	/* GWS */
	gfx_v9_0_ग_लिखो_data_to_reg(ring, 0, false,
				   SOC15_REG_OFFSET(GC, 0, mmGDS_GWS_VMID0) + vmid,
				   gws_size << GDS_GWS_VMID0__SIZE__SHIFT | gws_base);

	/* OA */
	gfx_v9_0_ग_लिखो_data_to_reg(ring, 0, false,
				   SOC15_REG_OFFSET(GC, 0, mmGDS_OA_VMID0) + vmid,
				   (1 << (oa_size + oa_base)) - (1 << oa_base));
पूर्ण

अटल स्थिर u32 vgpr_init_compute_shader[] =
अणु
	0xb07c0000, 0xbe8000ff,
	0x000000f8, 0xbf110800,
	0x7e000280, 0x7e020280,
	0x7e040280, 0x7e060280,
	0x7e080280, 0x7e0a0280,
	0x7e0c0280, 0x7e0e0280,
	0x80808800, 0xbe803200,
	0xbf84fff5, 0xbf9c0000,
	0xd28c0001, 0x0001007f,
	0xd28d0001, 0x0002027e,
	0x10020288, 0xb8810904,
	0xb7814000, 0xd1196a01,
	0x00000301, 0xbe800087,
	0xbefc00c1, 0xd89c4000,
	0x00020201, 0xd89cc080,
	0x00040401, 0x320202ff,
	0x00000800, 0x80808100,
	0xbf84fff8, 0x7e020280,
	0xbf810000, 0x00000000,
पूर्ण;

अटल स्थिर u32 sgpr_init_compute_shader[] =
अणु
	0xb07c0000, 0xbe8000ff,
	0x0000005f, 0xbee50080,
	0xbe812c65, 0xbe822c65,
	0xbe832c65, 0xbe842c65,
	0xbe852c65, 0xb77c0005,
	0x80808500, 0xbf84fff8,
	0xbe800080, 0xbf810000,
पूर्ण;

अटल स्थिर u32 vgpr_init_compute_shader_arcturus[] = अणु
	0xd3d94000, 0x18000080, 0xd3d94001, 0x18000080, 0xd3d94002, 0x18000080,
	0xd3d94003, 0x18000080, 0xd3d94004, 0x18000080, 0xd3d94005, 0x18000080,
	0xd3d94006, 0x18000080, 0xd3d94007, 0x18000080, 0xd3d94008, 0x18000080,
	0xd3d94009, 0x18000080, 0xd3d9400a, 0x18000080, 0xd3d9400b, 0x18000080,
	0xd3d9400c, 0x18000080, 0xd3d9400d, 0x18000080, 0xd3d9400e, 0x18000080,
	0xd3d9400f, 0x18000080, 0xd3d94010, 0x18000080, 0xd3d94011, 0x18000080,
	0xd3d94012, 0x18000080, 0xd3d94013, 0x18000080, 0xd3d94014, 0x18000080,
	0xd3d94015, 0x18000080, 0xd3d94016, 0x18000080, 0xd3d94017, 0x18000080,
	0xd3d94018, 0x18000080, 0xd3d94019, 0x18000080, 0xd3d9401a, 0x18000080,
	0xd3d9401b, 0x18000080, 0xd3d9401c, 0x18000080, 0xd3d9401d, 0x18000080,
	0xd3d9401e, 0x18000080, 0xd3d9401f, 0x18000080, 0xd3d94020, 0x18000080,
	0xd3d94021, 0x18000080, 0xd3d94022, 0x18000080, 0xd3d94023, 0x18000080,
	0xd3d94024, 0x18000080, 0xd3d94025, 0x18000080, 0xd3d94026, 0x18000080,
	0xd3d94027, 0x18000080, 0xd3d94028, 0x18000080, 0xd3d94029, 0x18000080,
	0xd3d9402a, 0x18000080, 0xd3d9402b, 0x18000080, 0xd3d9402c, 0x18000080,
	0xd3d9402d, 0x18000080, 0xd3d9402e, 0x18000080, 0xd3d9402f, 0x18000080,
	0xd3d94030, 0x18000080, 0xd3d94031, 0x18000080, 0xd3d94032, 0x18000080,
	0xd3d94033, 0x18000080, 0xd3d94034, 0x18000080, 0xd3d94035, 0x18000080,
	0xd3d94036, 0x18000080, 0xd3d94037, 0x18000080, 0xd3d94038, 0x18000080,
	0xd3d94039, 0x18000080, 0xd3d9403a, 0x18000080, 0xd3d9403b, 0x18000080,
	0xd3d9403c, 0x18000080, 0xd3d9403d, 0x18000080, 0xd3d9403e, 0x18000080,
	0xd3d9403f, 0x18000080, 0xd3d94040, 0x18000080, 0xd3d94041, 0x18000080,
	0xd3d94042, 0x18000080, 0xd3d94043, 0x18000080, 0xd3d94044, 0x18000080,
	0xd3d94045, 0x18000080, 0xd3d94046, 0x18000080, 0xd3d94047, 0x18000080,
	0xd3d94048, 0x18000080, 0xd3d94049, 0x18000080, 0xd3d9404a, 0x18000080,
	0xd3d9404b, 0x18000080, 0xd3d9404c, 0x18000080, 0xd3d9404d, 0x18000080,
	0xd3d9404e, 0x18000080, 0xd3d9404f, 0x18000080, 0xd3d94050, 0x18000080,
	0xd3d94051, 0x18000080, 0xd3d94052, 0x18000080, 0xd3d94053, 0x18000080,
	0xd3d94054, 0x18000080, 0xd3d94055, 0x18000080, 0xd3d94056, 0x18000080,
	0xd3d94057, 0x18000080, 0xd3d94058, 0x18000080, 0xd3d94059, 0x18000080,
	0xd3d9405a, 0x18000080, 0xd3d9405b, 0x18000080, 0xd3d9405c, 0x18000080,
	0xd3d9405d, 0x18000080, 0xd3d9405e, 0x18000080, 0xd3d9405f, 0x18000080,
	0xd3d94060, 0x18000080, 0xd3d94061, 0x18000080, 0xd3d94062, 0x18000080,
	0xd3d94063, 0x18000080, 0xd3d94064, 0x18000080, 0xd3d94065, 0x18000080,
	0xd3d94066, 0x18000080, 0xd3d94067, 0x18000080, 0xd3d94068, 0x18000080,
	0xd3d94069, 0x18000080, 0xd3d9406a, 0x18000080, 0xd3d9406b, 0x18000080,
	0xd3d9406c, 0x18000080, 0xd3d9406d, 0x18000080, 0xd3d9406e, 0x18000080,
	0xd3d9406f, 0x18000080, 0xd3d94070, 0x18000080, 0xd3d94071, 0x18000080,
	0xd3d94072, 0x18000080, 0xd3d94073, 0x18000080, 0xd3d94074, 0x18000080,
	0xd3d94075, 0x18000080, 0xd3d94076, 0x18000080, 0xd3d94077, 0x18000080,
	0xd3d94078, 0x18000080, 0xd3d94079, 0x18000080, 0xd3d9407a, 0x18000080,
	0xd3d9407b, 0x18000080, 0xd3d9407c, 0x18000080, 0xd3d9407d, 0x18000080,
	0xd3d9407e, 0x18000080, 0xd3d9407f, 0x18000080, 0xd3d94080, 0x18000080,
	0xd3d94081, 0x18000080, 0xd3d94082, 0x18000080, 0xd3d94083, 0x18000080,
	0xd3d94084, 0x18000080, 0xd3d94085, 0x18000080, 0xd3d94086, 0x18000080,
	0xd3d94087, 0x18000080, 0xd3d94088, 0x18000080, 0xd3d94089, 0x18000080,
	0xd3d9408a, 0x18000080, 0xd3d9408b, 0x18000080, 0xd3d9408c, 0x18000080,
	0xd3d9408d, 0x18000080, 0xd3d9408e, 0x18000080, 0xd3d9408f, 0x18000080,
	0xd3d94090, 0x18000080, 0xd3d94091, 0x18000080, 0xd3d94092, 0x18000080,
	0xd3d94093, 0x18000080, 0xd3d94094, 0x18000080, 0xd3d94095, 0x18000080,
	0xd3d94096, 0x18000080, 0xd3d94097, 0x18000080, 0xd3d94098, 0x18000080,
	0xd3d94099, 0x18000080, 0xd3d9409a, 0x18000080, 0xd3d9409b, 0x18000080,
	0xd3d9409c, 0x18000080, 0xd3d9409d, 0x18000080, 0xd3d9409e, 0x18000080,
	0xd3d9409f, 0x18000080, 0xd3d940a0, 0x18000080, 0xd3d940a1, 0x18000080,
	0xd3d940a2, 0x18000080, 0xd3d940a3, 0x18000080, 0xd3d940a4, 0x18000080,
	0xd3d940a5, 0x18000080, 0xd3d940a6, 0x18000080, 0xd3d940a7, 0x18000080,
	0xd3d940a8, 0x18000080, 0xd3d940a9, 0x18000080, 0xd3d940aa, 0x18000080,
	0xd3d940ab, 0x18000080, 0xd3d940ac, 0x18000080, 0xd3d940ad, 0x18000080,
	0xd3d940ae, 0x18000080, 0xd3d940af, 0x18000080, 0xd3d940b0, 0x18000080,
	0xd3d940b1, 0x18000080, 0xd3d940b2, 0x18000080, 0xd3d940b3, 0x18000080,
	0xd3d940b4, 0x18000080, 0xd3d940b5, 0x18000080, 0xd3d940b6, 0x18000080,
	0xd3d940b7, 0x18000080, 0xd3d940b8, 0x18000080, 0xd3d940b9, 0x18000080,
	0xd3d940ba, 0x18000080, 0xd3d940bb, 0x18000080, 0xd3d940bc, 0x18000080,
	0xd3d940bd, 0x18000080, 0xd3d940be, 0x18000080, 0xd3d940bf, 0x18000080,
	0xd3d940c0, 0x18000080, 0xd3d940c1, 0x18000080, 0xd3d940c2, 0x18000080,
	0xd3d940c3, 0x18000080, 0xd3d940c4, 0x18000080, 0xd3d940c5, 0x18000080,
	0xd3d940c6, 0x18000080, 0xd3d940c7, 0x18000080, 0xd3d940c8, 0x18000080,
	0xd3d940c9, 0x18000080, 0xd3d940ca, 0x18000080, 0xd3d940cb, 0x18000080,
	0xd3d940cc, 0x18000080, 0xd3d940cd, 0x18000080, 0xd3d940ce, 0x18000080,
	0xd3d940cf, 0x18000080, 0xd3d940d0, 0x18000080, 0xd3d940d1, 0x18000080,
	0xd3d940d2, 0x18000080, 0xd3d940d3, 0x18000080, 0xd3d940d4, 0x18000080,
	0xd3d940d5, 0x18000080, 0xd3d940d6, 0x18000080, 0xd3d940d7, 0x18000080,
	0xd3d940d8, 0x18000080, 0xd3d940d9, 0x18000080, 0xd3d940da, 0x18000080,
	0xd3d940db, 0x18000080, 0xd3d940dc, 0x18000080, 0xd3d940dd, 0x18000080,
	0xd3d940de, 0x18000080, 0xd3d940df, 0x18000080, 0xd3d940e0, 0x18000080,
	0xd3d940e1, 0x18000080, 0xd3d940e2, 0x18000080, 0xd3d940e3, 0x18000080,
	0xd3d940e4, 0x18000080, 0xd3d940e5, 0x18000080, 0xd3d940e6, 0x18000080,
	0xd3d940e7, 0x18000080, 0xd3d940e8, 0x18000080, 0xd3d940e9, 0x18000080,
	0xd3d940ea, 0x18000080, 0xd3d940eb, 0x18000080, 0xd3d940ec, 0x18000080,
	0xd3d940ed, 0x18000080, 0xd3d940ee, 0x18000080, 0xd3d940ef, 0x18000080,
	0xd3d940f0, 0x18000080, 0xd3d940f1, 0x18000080, 0xd3d940f2, 0x18000080,
	0xd3d940f3, 0x18000080, 0xd3d940f4, 0x18000080, 0xd3d940f5, 0x18000080,
	0xd3d940f6, 0x18000080, 0xd3d940f7, 0x18000080, 0xd3d940f8, 0x18000080,
	0xd3d940f9, 0x18000080, 0xd3d940fa, 0x18000080, 0xd3d940fb, 0x18000080,
	0xd3d940fc, 0x18000080, 0xd3d940fd, 0x18000080, 0xd3d940fe, 0x18000080,
	0xd3d940ff, 0x18000080, 0xb07c0000, 0xbe8a00ff, 0x000000f8, 0xbf11080a,
	0x7e000280, 0x7e020280, 0x7e040280, 0x7e060280, 0x7e080280, 0x7e0a0280,
	0x7e0c0280, 0x7e0e0280, 0x808a880a, 0xbe80320a, 0xbf84fff5, 0xbf9c0000,
	0xd28c0001, 0x0001007f, 0xd28d0001, 0x0002027e, 0x10020288, 0xb88b0904,
	0xb78b4000, 0xd1196a01, 0x00001701, 0xbe8a0087, 0xbefc00c1, 0xd89c4000,
	0x00020201, 0xd89cc080, 0x00040401, 0x320202ff, 0x00000800, 0x808a810a,
	0xbf84fff8, 0xbf810000,
पूर्ण;

/* When below रेजिस्टर arrays changed, please update gpr_reg_size,
  and sec_ded_counter_reg_size in function gfx_v9_0_करो_edc_gpr_workarounds,
  to cover all gfx9 ASICs */
अटल स्थिर काष्ठा soc15_reg_entry vgpr_init_regs[] = अणु
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 4 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x3f पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x400000 पूर्ण,  /* 64KB LDS */
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0xffffffff पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_entry vgpr_init_regs_arcturus[] = अणु
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 4 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0xbf पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x400000 पूर्ण,  /* 64KB LDS */
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0xffffffff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0xffffffff पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_entry sgpr1_init_regs[] = अणु
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 8 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x240 पूर्ण, /* (80 GPRS) */
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x0 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0x000000ff पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0x000000ff पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_entry sgpr2_init_regs[] = अणु
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_RESOURCE_LIMITS), 0x0000000 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_X), 0x40 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Y), 8 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_NUM_THREAD_Z), 1 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC1), 0x240 पूर्ण, /* (80 GPRS) */
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_PGM_RSRC2), 0x0 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE0), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE1), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE2), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE3), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE4), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE5), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE6), 0x0000ff00 पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCOMPUTE_STATIC_THREAD_MGMT_SE7), 0x0000ff00 पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा soc15_reg_entry gfx_v9_0_edc_counter_regs[] = अणु
   अणु SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_SCRATCH_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_UCODE_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_TAG_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_TAG_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmDC_EDC_CSINVOC_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmDC_EDC_RESTORE_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmDC_EDC_STATE_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_GRBM_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_DED), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSPI_EDC_CNT), 0, 4, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT), 0, 4, 6पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_DED_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_INFO), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_SEC_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT), 0, 1, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCP_ATC_EDC_GATCL1_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2), 0, 4, 6पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT), 0, 4, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT), 0, 1, 1पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT), 0, 1, 32पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2), 0, 1, 32पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCI_EDC_CNT), 0, 1, 72पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2), 0, 1, 16पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT), 0, 1, 2पूर्ण,
   अणु SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3), 0, 4, 6पूर्ण,
पूर्ण;

अटल पूर्णांक gfx_v9_0_करो_edc_gds_workarounds(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring = &adev->gfx.compute_ring[0];
	पूर्णांक i, r;

	/* only support when RAS is enabled */
	अगर (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))
		वापस 0;

	r = amdgpu_ring_alloc(ring, 7);
	अगर (r) अणु
		DRM_ERROR("amdgpu: GDS workarounds failed to lock ring %s (%d).\n",
			ring->name, r);
		वापस r;
	पूर्ण

	WREG32_SOC15(GC, 0, mmGDS_VMID0_BASE, 0x00000000);
	WREG32_SOC15(GC, 0, mmGDS_VMID0_SIZE, adev->gds.gds_size);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_DMA_DATA, 5));
	amdgpu_ring_ग_लिखो(ring, (PACKET3_DMA_DATA_CP_SYNC |
				PACKET3_DMA_DATA_DST_SEL(1) |
				PACKET3_DMA_DATA_SRC_SEL(2) |
				PACKET3_DMA_DATA_ENGINE(0)));
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, PACKET3_DMA_DATA_CMD_RAW_WAIT |
				adev->gds.gds_size);

	amdgpu_ring_commit(ring);

	क्रम (i = 0; i < adev->usec_समयout; i++) अणु
		अगर (ring->wptr == gfx_v9_0_ring_get_rptr_compute(ring))
			अवरोध;
		udelay(1);
	पूर्ण

	अगर (i >= adev->usec_समयout)
		r = -ETIMEDOUT;

	WREG32_SOC15(GC, 0, mmGDS_VMID0_SIZE, 0x00000000);

	वापस r;
पूर्ण

अटल पूर्णांक gfx_v9_0_करो_edc_gpr_workarounds(काष्ठा amdgpu_device *adev)
अणु
	काष्ठा amdgpu_ring *ring = &adev->gfx.compute_ring[0];
	काष्ठा amdgpu_ib ib;
	काष्ठा dma_fence *f = शून्य;
	पूर्णांक r, i;
	अचिन्हित total_size, vgpr_offset, sgpr_offset;
	u64 gpu_addr;

	पूर्णांक compute_dim_x = adev->gfx.config.max_shader_engines *
						adev->gfx.config.max_cu_per_sh *
						adev->gfx.config.max_sh_per_se;
	पूर्णांक sgpr_work_group_size = 5;
	पूर्णांक gpr_reg_size = adev->gfx.config.max_shader_engines + 6;
	पूर्णांक vgpr_init_shader_size;
	स्थिर u32 *vgpr_init_shader_ptr;
	स्थिर काष्ठा soc15_reg_entry *vgpr_init_regs_ptr;

	/* only support when RAS is enabled */
	अगर (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))
		वापस 0;

	/* bail अगर the compute ring is not पढ़ोy */
	अगर (!ring->sched.पढ़ोy)
		वापस 0;

	अगर (adev->asic_type == CHIP_ARCTURUS ||
	    adev->asic_type == CHIP_ALDEBARAN) अणु
		vgpr_init_shader_ptr = vgpr_init_compute_shader_arcturus;
		vgpr_init_shader_size = माप(vgpr_init_compute_shader_arcturus);
		vgpr_init_regs_ptr = vgpr_init_regs_arcturus;
	पूर्ण अन्यथा अणु
		vgpr_init_shader_ptr = vgpr_init_compute_shader;
		vgpr_init_shader_size = माप(vgpr_init_compute_shader);
		vgpr_init_regs_ptr = vgpr_init_regs;
	पूर्ण

	total_size =
		(gpr_reg_size * 3 + 4 + 5 + 2) * 4; /* VGPRS */
	total_size +=
		(gpr_reg_size * 3 + 4 + 5 + 2) * 4; /* SGPRS1 */
	total_size +=
		(gpr_reg_size * 3 + 4 + 5 + 2) * 4; /* SGPRS2 */
	total_size = ALIGN(total_size, 256);
	vgpr_offset = total_size;
	total_size += ALIGN(vgpr_init_shader_size, 256);
	sgpr_offset = total_size;
	total_size += माप(sgpr_init_compute_shader);

	/* allocate an indirect buffer to put the commands in */
	स_रखो(&ib, 0, माप(ib));
	r = amdgpu_ib_get(adev, शून्य, total_size,
					AMDGPU_IB_POOL_सूचीECT, &ib);
	अगर (r) अणु
		DRM_ERROR("amdgpu: failed to get ib (%d).\n", r);
		वापस r;
	पूर्ण

	/* load the compute shaders */
	क्रम (i = 0; i < vgpr_init_shader_size/माप(u32); i++)
		ib.ptr[i + (vgpr_offset / 4)] = vgpr_init_shader_ptr[i];

	क्रम (i = 0; i < ARRAY_SIZE(sgpr_init_compute_shader); i++)
		ib.ptr[i + (sgpr_offset / 4)] = sgpr_init_compute_shader[i];

	/* init the ib length to 0 */
	ib.length_dw = 0;

	/* VGPR */
	/* ग_लिखो the रेजिस्टर state क्रम the compute dispatch */
	क्रम (i = 0; i < gpr_reg_size; i++) अणु
		ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);
		ib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(vgpr_init_regs_ptr[i])
								- PACKET3_SET_SH_REG_START;
		ib.ptr[ib.length_dw++] = vgpr_init_regs_ptr[i].reg_value;
	पूर्ण
	/* ग_लिखो the shader start address: mmCOMPUTE_PGM_LO, mmCOMPUTE_PGM_HI */
	gpu_addr = (ib.gpu_addr + (u64)vgpr_offset) >> 8;
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);
	ib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)
							- PACKET3_SET_SH_REG_START;
	ib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);
	ib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);

	/* ग_लिखो dispatch packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_सूचीECT, 3);
	ib.ptr[ib.length_dw++] = compute_dim_x * 2; /* x */
	ib.ptr[ib.length_dw++] = 1; /* y */
	ib.ptr[ib.length_dw++] = 1; /* z */
	ib.ptr[ib.length_dw++] =
		REG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);

	/* ग_लिखो CS partial flush packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);
	ib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);

	/* SGPR1 */
	/* ग_लिखो the रेजिस्टर state क्रम the compute dispatch */
	क्रम (i = 0; i < gpr_reg_size; i++) अणु
		ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);
		ib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(sgpr1_init_regs[i])
								- PACKET3_SET_SH_REG_START;
		ib.ptr[ib.length_dw++] = sgpr1_init_regs[i].reg_value;
	पूर्ण
	/* ग_लिखो the shader start address: mmCOMPUTE_PGM_LO, mmCOMPUTE_PGM_HI */
	gpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);
	ib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)
							- PACKET3_SET_SH_REG_START;
	ib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);
	ib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);

	/* ग_लिखो dispatch packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_सूचीECT, 3);
	ib.ptr[ib.length_dw++] = compute_dim_x / 2 * sgpr_work_group_size; /* x */
	ib.ptr[ib.length_dw++] = 1; /* y */
	ib.ptr[ib.length_dw++] = 1; /* z */
	ib.ptr[ib.length_dw++] =
		REG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);

	/* ग_लिखो CS partial flush packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);
	ib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);

	/* SGPR2 */
	/* ग_लिखो the रेजिस्टर state क्रम the compute dispatch */
	क्रम (i = 0; i < gpr_reg_size; i++) अणु
		ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 1);
		ib.ptr[ib.length_dw++] = SOC15_REG_ENTRY_OFFSET(sgpr2_init_regs[i])
								- PACKET3_SET_SH_REG_START;
		ib.ptr[ib.length_dw++] = sgpr2_init_regs[i].reg_value;
	पूर्ण
	/* ग_लिखो the shader start address: mmCOMPUTE_PGM_LO, mmCOMPUTE_PGM_HI */
	gpu_addr = (ib.gpu_addr + (u64)sgpr_offset) >> 8;
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_SET_SH_REG, 2);
	ib.ptr[ib.length_dw++] = SOC15_REG_OFFSET(GC, 0, mmCOMPUTE_PGM_LO)
							- PACKET3_SET_SH_REG_START;
	ib.ptr[ib.length_dw++] = lower_32_bits(gpu_addr);
	ib.ptr[ib.length_dw++] = upper_32_bits(gpu_addr);

	/* ग_लिखो dispatch packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_DISPATCH_सूचीECT, 3);
	ib.ptr[ib.length_dw++] = compute_dim_x / 2 * sgpr_work_group_size; /* x */
	ib.ptr[ib.length_dw++] = 1; /* y */
	ib.ptr[ib.length_dw++] = 1; /* z */
	ib.ptr[ib.length_dw++] =
		REG_SET_FIELD(0, COMPUTE_DISPATCH_INITIATOR, COMPUTE_SHADER_EN, 1);

	/* ग_लिखो CS partial flush packet */
	ib.ptr[ib.length_dw++] = PACKET3(PACKET3_EVENT_WRITE, 0);
	ib.ptr[ib.length_dw++] = EVENT_TYPE(7) | EVENT_INDEX(4);

	/* shedule the ib on the ring */
	r = amdgpu_ib_schedule(ring, 1, &ib, शून्य, &f);
	अगर (r) अणु
		DRM_ERROR("amdgpu: ib submit failed (%d).\n", r);
		जाओ fail;
	पूर्ण

	/* रुको क्रम the GPU to finish processing the IB */
	r = dma_fence_रुको(f, false);
	अगर (r) अणु
		DRM_ERROR("amdgpu: fence wait failed (%d).\n", r);
		जाओ fail;
	पूर्ण

fail:
	amdgpu_ib_मुक्त(adev, &ib, शून्य);
	dma_fence_put(f);

	वापस r;
पूर्ण

अटल पूर्णांक gfx_v9_0_early_init(व्योम *handle)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	अगर (adev->asic_type == CHIP_ARCTURUS ||
	    adev->asic_type == CHIP_ALDEBARAN)
		adev->gfx.num_gfx_rings = 0;
	अन्यथा
		adev->gfx.num_gfx_rings = GFX9_NUM_GFX_RINGS;
	adev->gfx.num_compute_rings = min(amdgpu_gfx_get_num_kcq(adev),
					  AMDGPU_MAX_COMPUTE_RINGS);
	gfx_v9_0_set_kiq_pm4_funcs(adev);
	gfx_v9_0_set_ring_funcs(adev);
	gfx_v9_0_set_irq_funcs(adev);
	gfx_v9_0_set_gds_init(adev);
	gfx_v9_0_set_rlc_funcs(adev);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_ecc_late_init(व्योम *handle)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;
	पूर्णांक r;

	/*
	 * Temp workaround to fix the issue that CP firmware fails to
	 * update पढ़ो poपूर्णांकer when CPDMA is writing clearing operation
	 * to GDS in suspend/resume sequence on several cards. So just
	 * limit this operation in cold boot sequence.
	 */
	अगर ((!adev->in_suspend) &&
	    (adev->gds.gds_size)) अणु
		r = gfx_v9_0_करो_edc_gds_workarounds(adev);
		अगर (r)
			वापस r;
	पूर्ण

	/* requires IBs so करो in late init after IB pool is initialized */
	r = gfx_v9_0_करो_edc_gpr_workarounds(adev);
	अगर (r)
		वापस r;

	अगर (adev->gfx.ras_funcs &&
	    adev->gfx.ras_funcs->ras_late_init) अणु
		r = adev->gfx.ras_funcs->ras_late_init(adev);
		अगर (r)
			वापस r;
	पूर्ण

	अगर (adev->gfx.ras_funcs &&
	    adev->gfx.ras_funcs->enable_watchकरोg_समयr)
		adev->gfx.ras_funcs->enable_watchकरोg_समयr(adev);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_late_init(व्योम *handle)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;
	पूर्णांक r;

	r = amdgpu_irq_get(adev, &adev->gfx.priv_reg_irq, 0);
	अगर (r)
		वापस r;

	r = amdgpu_irq_get(adev, &adev->gfx.priv_inst_irq, 0);
	अगर (r)
		वापस r;

	r = gfx_v9_0_ecc_late_init(handle);
	अगर (r)
		वापस r;

	वापस 0;
पूर्ण

अटल bool gfx_v9_0_is_rlc_enabled(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t rlc_setting;

	/* अगर RLC is not enabled, करो nothing */
	rlc_setting = RREG32_SOC15(GC, 0, mmRLC_CNTL);
	अगर (!(rlc_setting & RLC_CNTL__RLC_ENABLE_F32_MASK))
		वापस false;

	वापस true;
पूर्ण

अटल व्योम gfx_v9_0_set_safe_mode(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t data;
	अचिन्हित i;

	data = RLC_SAFE_MODE__CMD_MASK;
	data |= (1 << RLC_SAFE_MODE__MESSAGE__SHIFT);
	WREG32_SOC15(GC, 0, mmRLC_SAFE_MODE, data);

	/* रुको क्रम RLC_SAFE_MODE */
	क्रम (i = 0; i < adev->usec_समयout; i++) अणु
		अगर (!REG_GET_FIELD(RREG32_SOC15(GC, 0, mmRLC_SAFE_MODE), RLC_SAFE_MODE, CMD))
			अवरोध;
		udelay(1);
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_unset_safe_mode(काष्ठा amdgpu_device *adev)
अणु
	uपूर्णांक32_t data;

	data = RLC_SAFE_MODE__CMD_MASK;
	WREG32_SOC15(GC, 0, mmRLC_SAFE_MODE, data);
पूर्ण

अटल व्योम gfx_v9_0_update_gfx_cg_घातer_gating(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	amdgpu_gfx_rlc_enter_safe_mode(adev);

	अगर ((adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) && enable) अणु
		gfx_v9_0_enable_gfx_cg_घातer_gating(adev, true);
		अगर (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)
			gfx_v9_0_enable_gfx_pipeline_घातergating(adev, true);
	पूर्ण अन्यथा अणु
		gfx_v9_0_enable_gfx_cg_घातer_gating(adev, false);
		अगर (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)
			gfx_v9_0_enable_gfx_pipeline_घातergating(adev, false);
	पूर्ण

	amdgpu_gfx_rlc_निकास_safe_mode(adev);
पूर्ण

अटल व्योम gfx_v9_0_update_gfx_mg_घातer_gating(काष्ठा amdgpu_device *adev,
						bool enable)
अणु
	/* TODO: द्विगुन check अगर we need to perक्रमm under safe mode */
	/* gfx_v9_0_enter_rlc_safe_mode(adev); */

	अगर ((adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG) && enable)
		gfx_v9_0_enable_gfx_अटल_mg_घातer_gating(adev, true);
	अन्यथा
		gfx_v9_0_enable_gfx_अटल_mg_घातer_gating(adev, false);

	अगर ((adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG) && enable)
		gfx_v9_0_enable_gfx_dynamic_mg_घातer_gating(adev, true);
	अन्यथा
		gfx_v9_0_enable_gfx_dynamic_mg_घातer_gating(adev, false);

	/* gfx_v9_0_निकास_rlc_safe_mode(adev); */
पूर्ण

अटल व्योम gfx_v9_0_update_medium_grain_घड़ी_gating(काष्ठा amdgpu_device *adev,
						      bool enable)
अणु
	uपूर्णांक32_t data, def;

	amdgpu_gfx_rlc_enter_safe_mode(adev);

	/* It is disabled by HW by शेष */
	अगर (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGCG)) अणु
		/* 1 - RLC_CGTT_MGCG_OVERRIDE */
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);

		अगर (adev->asic_type != CHIP_VEGA12)
			data &= ~RLC_CGTT_MGCG_OVERRIDE__CPF_CGTT_SCLK_OVERRIDE_MASK;

		data &= ~(RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |
			  RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK |
			  RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGLS_OVERRIDE_MASK);

		/* only क्रम Vega10 & Raven1 */
		data |= RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK;

		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);

		/* MGLS is a global flag to control all MGLS in GFX */
		अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_MGLS) अणु
			/* 2 - RLC memory Light sleep */
			अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_RLC_LS) अणु
				def = data = RREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL);
				data |= RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;
				अगर (def != data)
					WREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL, data);
			पूर्ण
			/* 3 - CP memory Light sleep */
			अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_CP_LS) अणु
				def = data = RREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL);
				data |= CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;
				अगर (def != data)
					WREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL, data);
			पूर्ण
		पूर्ण
	पूर्ण अन्यथा अणु
		/* 1 - MGCG_OVERRIDE */
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);

		अगर (adev->asic_type != CHIP_VEGA12)
			data |= RLC_CGTT_MGCG_OVERRIDE__CPF_CGTT_SCLK_OVERRIDE_MASK;

		data |= (RLC_CGTT_MGCG_OVERRIDE__RLC_CGTT_SCLK_OVERRIDE_MASK |
			 RLC_CGTT_MGCG_OVERRIDE__GRBM_CGTT_SCLK_OVERRIDE_MASK |
			 RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK |
			 RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGLS_OVERRIDE_MASK);

		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);

		/* 2 - disable MGLS in RLC */
		data = RREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL);
		अगर (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK) अणु
			data &= ~RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK;
			WREG32_SOC15(GC, 0, mmRLC_MEM_SLP_CNTL, data);
		पूर्ण

		/* 3 - disable MGLS in CP */
		data = RREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL);
		अगर (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK) अणु
			data &= ~CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK;
			WREG32_SOC15(GC, 0, mmCP_MEM_SLP_CNTL, data);
		पूर्ण
	पूर्ण

	amdgpu_gfx_rlc_निकास_safe_mode(adev);
पूर्ण

अटल व्योम gfx_v9_0_update_3d_घड़ी_gating(काष्ठा amdgpu_device *adev,
					   bool enable)
अणु
	uपूर्णांक32_t data, def;

	अगर (!adev->gfx.num_gfx_rings)
		वापस;

	amdgpu_gfx_rlc_enter_safe_mode(adev);

	/* Enable 3D CGCG/CGLS */
	अगर (enable) अणु
		/* ग_लिखो cmd to clear cgcg/cgls ov */
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);
		/* unset CGCG override */
		data &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_GFX3D_CG_OVERRIDE_MASK;
		/* update CGCG and CGLS override bits */
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);

		/* enable 3Dcgcg FSM(0x0000363f) */
		def = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D);

		अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGCG)
			data = (0x36 << RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |
				RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK;
		अन्यथा
			data = 0x0 << RLC_CGCG_CGLS_CTRL_3D__CGCG_GFX_IDLE_THRESHOLD__SHIFT;

		अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_3D_CGLS)
			data |= (0x000F << RLC_CGCG_CGLS_CTRL_3D__CGLS_REP_COMPANSAT_DELAY__SHIFT) |
				RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK;
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D, data);

		/* set IDLE_POLL_COUNT(0x00900100) */
		def = RREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL);
		data = (0x0100 << CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY__SHIFT) |
			(0x0090 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL, data);
	पूर्ण अन्यथा अणु
		/* Disable CGCG/CGLS */
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D);
		/* disable cgcg, cgls should be disabled */
		data &= ~(RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK |
			  RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK);
		/* disable cgcg and cgls in FSM */
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D, data);
	पूर्ण

	amdgpu_gfx_rlc_निकास_safe_mode(adev);
पूर्ण

अटल व्योम gfx_v9_0_update_coarse_grain_घड़ी_gating(काष्ठा amdgpu_device *adev,
						      bool enable)
अणु
	uपूर्णांक32_t def, data;

	amdgpu_gfx_rlc_enter_safe_mode(adev);

	अगर (enable && (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGCG)) अणु
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE);
		/* unset CGCG override */
		data &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGCG_OVERRIDE_MASK;
		अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)
			data &= ~RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGLS_OVERRIDE_MASK;
		अन्यथा
			data |= RLC_CGTT_MGCG_OVERRIDE__GFXIP_CGLS_OVERRIDE_MASK;
		/* update CGCG and CGLS override bits */
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE, data);

		/* enable cgcg FSM(0x0000363F) */
		def = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL);

		अगर (adev->asic_type == CHIP_ARCTURUS)
			data = (0x2000 << RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |
				RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;
		अन्यथा
			data = (0x36 << RLC_CGCG_CGLS_CTRL__CGCG_GFX_IDLE_THRESHOLD__SHIFT) |
				RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK;
		अगर (adev->cg_flags & AMD_CG_SUPPORT_GFX_CGLS)
			data |= (0x000F << RLC_CGCG_CGLS_CTRL__CGLS_REP_COMPANSAT_DELAY__SHIFT) |
				RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK;
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, data);

		/* set IDLE_POLL_COUNT(0x00900100) */
		def = RREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL);
		data = (0x0100 << CP_RB_WPTR_POLL_CNTL__POLL_FREQUENCY__SHIFT) |
			(0x0090 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmCP_RB_WPTR_POLL_CNTL, data);
	पूर्ण अन्यथा अणु
		def = data = RREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL);
		/* reset CGCG/CGLS bits */
		data &= ~(RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK | RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK);
		/* disable cgcg and cgls in FSM */
		अगर (def != data)
			WREG32_SOC15(GC, 0, mmRLC_CGCG_CGLS_CTRL, data);
	पूर्ण

	amdgpu_gfx_rlc_निकास_safe_mode(adev);
पूर्ण

अटल पूर्णांक gfx_v9_0_update_gfx_घड़ी_gating(काष्ठा amdgpu_device *adev,
					    bool enable)
अणु
	अगर (enable) अणु
		/* CGCG/CGLS should be enabled after MGCG/MGLS
		 * ===  MGCG + MGLS ===
		 */
		gfx_v9_0_update_medium_grain_घड़ी_gating(adev, enable);
		/* ===  CGCG /CGLS क्रम GFX 3D Only === */
		gfx_v9_0_update_3d_घड़ी_gating(adev, enable);
		/* ===  CGCG + CGLS === */
		gfx_v9_0_update_coarse_grain_घड़ी_gating(adev, enable);
	पूर्ण अन्यथा अणु
		/* CGCG/CGLS should be disabled beक्रमe MGCG/MGLS
		 * ===  CGCG + CGLS ===
		 */
		gfx_v9_0_update_coarse_grain_घड़ी_gating(adev, enable);
		/* ===  CGCG /CGLS क्रम GFX 3D Only === */
		gfx_v9_0_update_3d_घड़ी_gating(adev, enable);
		/* ===  MGCG + MGLS === */
		gfx_v9_0_update_medium_grain_घड़ी_gating(adev, enable);
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_update_spm_vmid(काष्ठा amdgpu_device *adev, अचिन्हित vmid)
अणु
	u32 reg, data;

	reg = SOC15_REG_OFFSET(GC, 0, mmRLC_SPM_MC_CNTL);
	अगर (amdgpu_sriov_is_pp_one_vf(adev))
		data = RREG32_NO_KIQ(reg);
	अन्यथा
		data = RREG32(reg);

	data &= ~RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK;
	data |= (vmid & RLC_SPM_MC_CNTL__RLC_SPM_VMID_MASK) << RLC_SPM_MC_CNTL__RLC_SPM_VMID__SHIFT;

	अगर (amdgpu_sriov_is_pp_one_vf(adev))
		WREG32_SOC15_NO_KIQ(GC, 0, mmRLC_SPM_MC_CNTL, data);
	अन्यथा
		WREG32_SOC15(GC, 0, mmRLC_SPM_MC_CNTL, data);
पूर्ण

अटल bool gfx_v9_0_check_rlcg_range(काष्ठा amdgpu_device *adev,
					uपूर्णांक32_t offset,
					काष्ठा soc15_reg_rlcg *entries, पूर्णांक arr_size)
अणु
	पूर्णांक i;
	uपूर्णांक32_t reg;

	अगर (!entries)
		वापस false;

	क्रम (i = 0; i < arr_size; i++) अणु
		स्थिर काष्ठा soc15_reg_rlcg *entry;

		entry = &entries[i];
		reg = adev->reg_offset[entry->hwip][entry->instance][entry->segment] + entry->reg;
		अगर (offset == reg)
			वापस true;
	पूर्ण

	वापस false;
पूर्ण

अटल bool gfx_v9_0_is_rlcg_access_range(काष्ठा amdgpu_device *adev, u32 offset)
अणु
	वापस gfx_v9_0_check_rlcg_range(adev, offset,
					(व्योम *)rlcg_access_gc_9_0,
					ARRAY_SIZE(rlcg_access_gc_9_0));
पूर्ण

अटल स्थिर काष्ठा amdgpu_rlc_funcs gfx_v9_0_rlc_funcs = अणु
	.is_rlc_enabled = gfx_v9_0_is_rlc_enabled,
	.set_safe_mode = gfx_v9_0_set_safe_mode,
	.unset_safe_mode = gfx_v9_0_unset_safe_mode,
	.init = gfx_v9_0_rlc_init,
	.get_csb_size = gfx_v9_0_get_csb_size,
	.get_csb_buffer = gfx_v9_0_get_csb_buffer,
	.get_cp_table_num = gfx_v9_0_cp_jump_table_num,
	.resume = gfx_v9_0_rlc_resume,
	.stop = gfx_v9_0_rlc_stop,
	.reset = gfx_v9_0_rlc_reset,
	.start = gfx_v9_0_rlc_start,
	.update_spm_vmid = gfx_v9_0_update_spm_vmid,
	.rlcg_wreg = gfx_v9_0_rlcg_wreg,
	.is_rlcg_access_range = gfx_v9_0_is_rlcg_access_range,
पूर्ण;

अटल पूर्णांक gfx_v9_0_set_घातergating_state(व्योम *handle,
					  क्रमागत amd_घातergating_state state)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;
	bool enable = (state == AMD_PG_STATE_GATE);

	चयन (adev->asic_type) अणु
	हाल CHIP_RAVEN:
	हाल CHIP_RENOIR:
		अगर (!enable)
			amdgpu_gfx_off_ctrl(adev, false);

		अगर (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS) अणु
			gfx_v9_0_enable_sck_slow_करोwn_on_घातer_up(adev, true);
			gfx_v9_0_enable_sck_slow_करोwn_on_घातer_करोwn(adev, true);
		पूर्ण अन्यथा अणु
			gfx_v9_0_enable_sck_slow_करोwn_on_घातer_up(adev, false);
			gfx_v9_0_enable_sck_slow_करोwn_on_घातer_करोwn(adev, false);
		पूर्ण

		अगर (adev->pg_flags & AMD_PG_SUPPORT_CP)
			gfx_v9_0_enable_cp_घातer_gating(adev, true);
		अन्यथा
			gfx_v9_0_enable_cp_घातer_gating(adev, false);

		/* update gfx cgpg state */
		gfx_v9_0_update_gfx_cg_घातer_gating(adev, enable);

		/* update mgcg state */
		gfx_v9_0_update_gfx_mg_घातer_gating(adev, enable);

		अगर (enable)
			amdgpu_gfx_off_ctrl(adev, true);
		अवरोध;
	हाल CHIP_VEGA12:
		amdgpu_gfx_off_ctrl(adev, enable);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_set_घड़ीgating_state(व्योम *handle,
					  क्रमागत amd_घड़ीgating_state state)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;

	अगर (amdgpu_sriov_vf(adev))
		वापस 0;

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA12:
	हाल CHIP_VEGA20:
	हाल CHIP_RAVEN:
	हाल CHIP_ARCTURUS:
	हाल CHIP_RENOIR:
	हाल CHIP_ALDEBARAN:
		gfx_v9_0_update_gfx_घड़ी_gating(adev,
						 state == AMD_CG_STATE_GATE);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_get_घड़ीgating_state(व्योम *handle, u32 *flags)
अणु
	काष्ठा amdgpu_device *adev = (काष्ठा amdgpu_device *)handle;
	पूर्णांक data;

	अगर (amdgpu_sriov_vf(adev))
		*flags = 0;

	/* AMD_CG_SUPPORT_GFX_MGCG */
	data = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGTT_MGCG_OVERRIDE));
	अगर (!(data & RLC_CGTT_MGCG_OVERRIDE__GFXIP_MGCG_OVERRIDE_MASK))
		*flags |= AMD_CG_SUPPORT_GFX_MGCG;

	/* AMD_CG_SUPPORT_GFX_CGCG */
	data = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGCG_CGLS_CTRL));
	अगर (data & RLC_CGCG_CGLS_CTRL__CGCG_EN_MASK)
		*flags |= AMD_CG_SUPPORT_GFX_CGCG;

	/* AMD_CG_SUPPORT_GFX_CGLS */
	अगर (data & RLC_CGCG_CGLS_CTRL__CGLS_EN_MASK)
		*flags |= AMD_CG_SUPPORT_GFX_CGLS;

	/* AMD_CG_SUPPORT_GFX_RLC_LS */
	data = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_MEM_SLP_CNTL));
	अगर (data & RLC_MEM_SLP_CNTL__RLC_MEM_LS_EN_MASK)
		*flags |= AMD_CG_SUPPORT_GFX_RLC_LS | AMD_CG_SUPPORT_GFX_MGLS;

	/* AMD_CG_SUPPORT_GFX_CP_LS */
	data = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmCP_MEM_SLP_CNTL));
	अगर (data & CP_MEM_SLP_CNTL__CP_MEM_LS_EN_MASK)
		*flags |= AMD_CG_SUPPORT_GFX_CP_LS | AMD_CG_SUPPORT_GFX_MGLS;

	अगर (adev->asic_type != CHIP_ARCTURUS) अणु
		/* AMD_CG_SUPPORT_GFX_3D_CGCG */
		data = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_CGCG_CGLS_CTRL_3D));
		अगर (data & RLC_CGCG_CGLS_CTRL_3D__CGCG_EN_MASK)
			*flags |= AMD_CG_SUPPORT_GFX_3D_CGCG;

		/* AMD_CG_SUPPORT_GFX_3D_CGLS */
		अगर (data & RLC_CGCG_CGLS_CTRL_3D__CGLS_EN_MASK)
			*flags |= AMD_CG_SUPPORT_GFX_3D_CGLS;
	पूर्ण
पूर्ण

अटल u64 gfx_v9_0_ring_get_rptr_gfx(काष्ठा amdgpu_ring *ring)
अणु
	वापस ring->adev->wb.wb[ring->rptr_offs]; /* gfx9 is 32bit rptr*/
पूर्ण

अटल u64 gfx_v9_0_ring_get_wptr_gfx(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	u64 wptr;

	/* XXX check अगर swapping is necessary on BE */
	अगर (ring->use_करोorbell) अणु
		wptr = atomic64_पढ़ो((atomic64_t *)&adev->wb.wb[ring->wptr_offs]);
	पूर्ण अन्यथा अणु
		wptr = RREG32_SOC15(GC, 0, mmCP_RB0_WPTR);
		wptr += (u64)RREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI) << 32;
	पूर्ण

	वापस wptr;
पूर्ण

अटल व्योम gfx_v9_0_ring_set_wptr_gfx(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	अगर (ring->use_करोorbell) अणु
		/* XXX check अगर swapping is necessary on BE */
		atomic64_set((atomic64_t *)&adev->wb.wb[ring->wptr_offs], ring->wptr);
		WDOORBELL64(ring->करोorbell_index, ring->wptr);
	पूर्ण अन्यथा अणु
		WREG32_SOC15(GC, 0, mmCP_RB0_WPTR, lower_32_bits(ring->wptr));
		WREG32_SOC15(GC, 0, mmCP_RB0_WPTR_HI, upper_32_bits(ring->wptr));
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_hdp_flush(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	u32 ref_and_mask, reg_mem_engine;
	स्थिर काष्ठा nbio_hdp_flush_reg *nbio_hf_reg = adev->nbपन.सdp_flush_reg;

	अगर (ring->funcs->type == AMDGPU_RING_TYPE_COMPUTE) अणु
		चयन (ring->me) अणु
		हाल 1:
			ref_and_mask = nbio_hf_reg->ref_and_mask_cp2 << ring->pipe;
			अवरोध;
		हाल 2:
			ref_and_mask = nbio_hf_reg->ref_and_mask_cp6 << ring->pipe;
			अवरोध;
		शेष:
			वापस;
		पूर्ण
		reg_mem_engine = 0;
	पूर्ण अन्यथा अणु
		ref_and_mask = nbio_hf_reg->ref_and_mask_cp0;
		reg_mem_engine = 1; /* pfp */
	पूर्ण

	gfx_v9_0_रुको_reg_mem(ring, reg_mem_engine, 0, 1,
			      adev->nbio.funcs->get_hdp_flush_req_offset(adev),
			      adev->nbio.funcs->get_hdp_flush_करोne_offset(adev),
			      ref_and_mask, ref_and_mask, 0x20);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_ib_gfx(काष्ठा amdgpu_ring *ring,
					काष्ठा amdgpu_job *job,
					काष्ठा amdgpu_ib *ib,
					uपूर्णांक32_t flags)
अणु
	अचिन्हित vmid = AMDGPU_JOB_GET_VMID(job);
	u32 header, control = 0;

	अगर (ib->flags & AMDGPU_IB_FLAG_CE)
		header = PACKET3(PACKET3_INसूचीECT_BUFFER_CONST, 2);
	अन्यथा
		header = PACKET3(PACKET3_INसूचीECT_BUFFER, 2);

	control |= ib->length_dw | (vmid << 24);

	अगर (amdgpu_sriov_vf(ring->adev) && (ib->flags & AMDGPU_IB_FLAG_PREEMPT)) अणु
		control |= INसूचीECT_BUFFER_PRE_ENB(1);

		अगर (!(ib->flags & AMDGPU_IB_FLAG_CE) && vmid)
			gfx_v9_0_ring_emit_de_meta(ring);
	पूर्ण

	amdgpu_ring_ग_लिखो(ring, header);
	BUG_ON(ib->gpu_addr & 0x3); /* Dword align */
	amdgpu_ring_ग_लिखो(ring,
#अगर_घोषित __BIG_ENDIAN
		(2 << 0) |
#पूर्ण_अगर
		lower_32_bits(ib->gpu_addr));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(ib->gpu_addr));
	amdgpu_ring_ग_लिखो(ring, control);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_ib_compute(काष्ठा amdgpu_ring *ring,
					  काष्ठा amdgpu_job *job,
					  काष्ठा amdgpu_ib *ib,
					  uपूर्णांक32_t flags)
अणु
	अचिन्हित vmid = AMDGPU_JOB_GET_VMID(job);
	u32 control = INसूचीECT_BUFFER_VALID | ib->length_dw | (vmid << 24);

	/* Currently, there is a high possibility to get wave ID mismatch
	 * between ME and GDS, leading to a hw deadlock, because ME generates
	 * dअगरferent wave IDs than the GDS expects. This situation happens
	 * अक्रमomly when at least 5 compute pipes use GDS ordered append.
	 * The wave IDs generated by ME are also wrong after suspend/resume.
	 * Those are probably bugs somewhere अन्यथा in the kernel driver.
	 *
	 * Writing GDS_COMPUTE_MAX_WAVE_ID resets wave ID counters in ME and
	 * GDS to 0 क्रम this ring (me/pipe).
	 */
	अगर (ib->flags & AMDGPU_IB_FLAG_RESET_GDS_MAX_WAVE_ID) अणु
		amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));
		amdgpu_ring_ग_लिखो(ring, mmGDS_COMPUTE_MAX_WAVE_ID);
		amdgpu_ring_ग_लिखो(ring, ring->adev->gds.gds_compute_max_wave_id);
	पूर्ण

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_INसूचीECT_BUFFER, 2));
	BUG_ON(ib->gpu_addr & 0x3); /* Dword align */
	amdgpu_ring_ग_लिखो(ring,
#अगर_घोषित __BIG_ENDIAN
				(2 << 0) |
#पूर्ण_अगर
				lower_32_bits(ib->gpu_addr));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(ib->gpu_addr));
	amdgpu_ring_ग_लिखो(ring, control);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_fence(काष्ठा amdgpu_ring *ring, u64 addr,
				     u64 seq, अचिन्हित flags)
अणु
	bool ग_लिखो64bit = flags & AMDGPU_FENCE_FLAG_64BIT;
	bool पूर्णांक_sel = flags & AMDGPU_FENCE_FLAG_INT;
	bool ग_लिखोback = flags & AMDGPU_FENCE_FLAG_TC_WB_ONLY;

	/* RELEASE_MEM - flush caches, send पूर्णांक */
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_RELEASE_MEM, 6));
	amdgpu_ring_ग_लिखो(ring, ((ग_लिखोback ? (EOP_TC_WB_ACTION_EN |
					       EOP_TC_NC_ACTION_EN) :
					      (EOP_TCL1_ACTION_EN |
					       EOP_TC_ACTION_EN |
					       EOP_TC_WB_ACTION_EN |
					       EOP_TC_MD_ACTION_EN)) |
				 EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |
				 EVENT_INDEX(5)));
	amdgpu_ring_ग_लिखो(ring, DATA_SEL(ग_लिखो64bit ? 2 : 1) | INT_SEL(पूर्णांक_sel ? 2 : 0));

	/*
	 * the address should be Qword aligned अगर 64bit ग_लिखो, Dword
	 * aligned अगर only send 32bit data low (discard data high)
	 */
	अगर (ग_लिखो64bit)
		BUG_ON(addr & 0x7);
	अन्यथा
		BUG_ON(addr & 0x3);
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(addr));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(addr));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(seq));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(seq));
	amdgpu_ring_ग_लिखो(ring, 0);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_pipeline_sync(काष्ठा amdgpu_ring *ring)
अणु
	पूर्णांक usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);
	uपूर्णांक32_t seq = ring->fence_drv.sync_seq;
	uपूर्णांक64_t addr = ring->fence_drv.gpu_addr;

	gfx_v9_0_रुको_reg_mem(ring, usepfp, 1, 0,
			      lower_32_bits(addr), upper_32_bits(addr),
			      seq, 0xffffffff, 4);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_vm_flush(काष्ठा amdgpu_ring *ring,
					अचिन्हित vmid, uपूर्णांक64_t pd_addr)
अणु
	amdgpu_gmc_emit_flush_gpu_tlb(ring, vmid, pd_addr);

	/* compute करोesn't have PFP */
	अगर (ring->funcs->type == AMDGPU_RING_TYPE_GFX) अणु
		/* sync PFP to ME, otherwise we might get invalid PFP पढ़ोs */
		amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));
		amdgpu_ring_ग_लिखो(ring, 0x0);
	पूर्ण
पूर्ण

अटल u64 gfx_v9_0_ring_get_rptr_compute(काष्ठा amdgpu_ring *ring)
अणु
	वापस ring->adev->wb.wb[ring->rptr_offs]; /* gfx9 hardware is 32bit rptr */
पूर्ण

अटल u64 gfx_v9_0_ring_get_wptr_compute(काष्ठा amdgpu_ring *ring)
अणु
	u64 wptr;

	/* XXX check अगर swapping is necessary on BE */
	अगर (ring->use_करोorbell)
		wptr = atomic64_पढ़ो((atomic64_t *)&ring->adev->wb.wb[ring->wptr_offs]);
	अन्यथा
		BUG();
	वापस wptr;
पूर्ण

अटल व्योम gfx_v9_0_ring_set_wptr_compute(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	/* XXX check अगर swapping is necessary on BE */
	अगर (ring->use_करोorbell) अणु
		atomic64_set((atomic64_t *)&adev->wb.wb[ring->wptr_offs], ring->wptr);
		WDOORBELL64(ring->करोorbell_index, ring->wptr);
	पूर्ण अन्यथाअणु
		BUG(); /* only DOORBELL method supported on gfx9 now */
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_fence_kiq(काष्ठा amdgpu_ring *ring, u64 addr,
					 u64 seq, अचिन्हित पूर्णांक flags)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	/* we only allocate 32bit क्रम each seq wb address */
	BUG_ON(flags & AMDGPU_FENCE_FLAG_64BIT);

	/* ग_लिखो fence seq to the "addr" */
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, 3));
	amdgpu_ring_ग_लिखो(ring, (WRITE_DATA_ENGINE_SEL(0) |
				 WRITE_DATA_DST_SEL(5) | WR_CONFIRM));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(addr));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(addr));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(seq));

	अगर (flags & AMDGPU_FENCE_FLAG_INT) अणु
		/* set रेजिस्टर to trigger INT */
		amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, 3));
		amdgpu_ring_ग_लिखो(ring, (WRITE_DATA_ENGINE_SEL(0) |
					 WRITE_DATA_DST_SEL(0) | WR_CONFIRM));
		amdgpu_ring_ग_लिखो(ring, SOC15_REG_OFFSET(GC, 0, mmCPC_INT_STATUS));
		amdgpu_ring_ग_लिखो(ring, 0);
		amdgpu_ring_ग_लिखो(ring, 0x20000000); /* src_id is 178 */
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_ring_emit_sb(काष्ठा amdgpu_ring *ring)
अणु
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));
	amdgpu_ring_ग_लिखो(ring, 0);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_ce_meta(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा v9_ce_ib_state ce_payload = अणु0पूर्ण;
	uपूर्णांक64_t csa_addr;
	पूर्णांक cnt;

	cnt = (माप(ce_payload) >> 2) + 4 - 2;
	csa_addr = amdgpu_csa_vaddr(ring->adev);

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, cnt));
	amdgpu_ring_ग_लिखो(ring, (WRITE_DATA_ENGINE_SEL(2) |
				 WRITE_DATA_DST_SEL(8) |
				 WR_CONFIRM) |
				 WRITE_DATA_CACHE_POLICY(0));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(csa_addr + दुरत्व(काष्ठा v9_gfx_meta_data, ce_payload)));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(csa_addr + दुरत्व(काष्ठा v9_gfx_meta_data, ce_payload)));
	amdgpu_ring_ग_लिखो_multiple(ring, (व्योम *)&ce_payload, माप(ce_payload) >> 2);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_de_meta(काष्ठा amdgpu_ring *ring)
अणु
	काष्ठा v9_de_ib_state de_payload = अणु0पूर्ण;
	uपूर्णांक64_t csa_addr, gds_addr;
	पूर्णांक cnt;

	csa_addr = amdgpu_csa_vaddr(ring->adev);
	gds_addr = csa_addr + 4096;
	de_payload.gds_backup_addrlo = lower_32_bits(gds_addr);
	de_payload.gds_backup_addrhi = upper_32_bits(gds_addr);

	cnt = (माप(de_payload) >> 2) + 4 - 2;
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, cnt));
	amdgpu_ring_ग_लिखो(ring, (WRITE_DATA_ENGINE_SEL(1) |
				 WRITE_DATA_DST_SEL(8) |
				 WR_CONFIRM) |
				 WRITE_DATA_CACHE_POLICY(0));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(csa_addr + दुरत्व(काष्ठा v9_gfx_meta_data, de_payload)));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(csa_addr + दुरत्व(काष्ठा v9_gfx_meta_data, de_payload)));
	amdgpu_ring_ग_लिखो_multiple(ring, (व्योम *)&de_payload, माप(de_payload) >> 2);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_frame_cntl(काष्ठा amdgpu_ring *ring, bool start,
				   bool secure)
अणु
	uपूर्णांक32_t v = secure ? FRAME_TMZ : 0;

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_FRAME_CONTROL, 0));
	amdgpu_ring_ग_लिखो(ring, v | FRAME_CMD(start ? 0 : 1));
पूर्ण

अटल व्योम gfx_v9_ring_emit_cntxcntl(काष्ठा amdgpu_ring *ring, uपूर्णांक32_t flags)
अणु
	uपूर्णांक32_t dw2 = 0;

	अगर (amdgpu_sriov_vf(ring->adev))
		gfx_v9_0_ring_emit_ce_meta(ring);

	dw2 |= 0x80000000; /* set load_enable otherwise this package is just NOPs */
	अगर (flags & AMDGPU_HAVE_CTX_SWITCH) अणु
		/* set load_global_config & load_global_uconfig */
		dw2 |= 0x8001;
		/* set load_cs_sh_regs */
		dw2 |= 0x01000000;
		/* set load_per_context_state & load_gfx_sh_regs क्रम GFX */
		dw2 |= 0x10002;

		/* set load_ce_ram अगर preamble presented */
		अगर (AMDGPU_PREAMBLE_IB_PRESENT & flags)
			dw2 |= 0x10000000;
	पूर्ण अन्यथा अणु
		/* still load_ce_ram अगर this is the first समय preamble presented
		 * although there is no context चयन happens.
		 */
		अगर (AMDGPU_PREAMBLE_IB_PRESENT_FIRST & flags)
			dw2 |= 0x10000000;
	पूर्ण

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));
	amdgpu_ring_ग_लिखो(ring, dw2);
	amdgpu_ring_ग_लिखो(ring, 0);
पूर्ण

अटल अचिन्हित gfx_v9_0_ring_emit_init_cond_exec(काष्ठा amdgpu_ring *ring)
अणु
	अचिन्हित ret;
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_COND_EXEC, 3));
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(ring->cond_exe_gpu_addr));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(ring->cond_exe_gpu_addr));
	amdgpu_ring_ग_लिखो(ring, 0); /* discard following DWs अगर *cond_exec_gpu_addr==0 */
	ret = ring->wptr & ring->buf_mask;
	amdgpu_ring_ग_लिखो(ring, 0x55aa55aa); /* patch dummy value later */
	वापस ret;
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_patch_cond_exec(काष्ठा amdgpu_ring *ring, अचिन्हित offset)
अणु
	अचिन्हित cur;
	BUG_ON(offset > ring->buf_mask);
	BUG_ON(ring->ring[offset] != 0x55aa55aa);

	cur = (ring->wptr & ring->buf_mask) - 1;
	अगर (likely(cur > offset))
		ring->ring[offset] = cur - offset;
	अन्यथा
		ring->ring[offset] = (ring->ring_size>>2) - offset + cur;
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_rreg(काष्ठा amdgpu_ring *ring, uपूर्णांक32_t reg,
				    uपूर्णांक32_t reg_val_offs)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;

	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_COPY_DATA, 4));
	amdgpu_ring_ग_लिखो(ring, 0 |	/* src: रेजिस्टर*/
				(5 << 8) |	/* dst: memory */
				(1 << 20));	/* ग_लिखो confirm */
	amdgpu_ring_ग_लिखो(ring, reg);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, lower_32_bits(adev->wb.gpu_addr +
				reg_val_offs * 4));
	amdgpu_ring_ग_लिखो(ring, upper_32_bits(adev->wb.gpu_addr +
				reg_val_offs * 4));
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_wreg(काष्ठा amdgpu_ring *ring, uपूर्णांक32_t reg,
				    uपूर्णांक32_t val)
अणु
	uपूर्णांक32_t cmd = 0;

	चयन (ring->funcs->type) अणु
	हाल AMDGPU_RING_TYPE_GFX:
		cmd = WRITE_DATA_ENGINE_SEL(1) | WR_CONFIRM;
		अवरोध;
	हाल AMDGPU_RING_TYPE_KIQ:
		cmd = (1 << 16); /* no inc addr */
		अवरोध;
	शेष:
		cmd = WR_CONFIRM;
		अवरोध;
	पूर्ण
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_WRITE_DATA, 3));
	amdgpu_ring_ग_लिखो(ring, cmd);
	amdgpu_ring_ग_लिखो(ring, reg);
	amdgpu_ring_ग_लिखो(ring, 0);
	amdgpu_ring_ग_लिखो(ring, val);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_reg_रुको(काष्ठा amdgpu_ring *ring, uपूर्णांक32_t reg,
					uपूर्णांक32_t val, uपूर्णांक32_t mask)
अणु
	gfx_v9_0_रुको_reg_mem(ring, 0, 0, 0, reg, 0, val, mask, 0x20);
पूर्ण

अटल व्योम gfx_v9_0_ring_emit_reg_ग_लिखो_reg_रुको(काष्ठा amdgpu_ring *ring,
						  uपूर्णांक32_t reg0, uपूर्णांक32_t reg1,
						  uपूर्णांक32_t ref, uपूर्णांक32_t mask)
अणु
	पूर्णांक usepfp = (ring->funcs->type == AMDGPU_RING_TYPE_GFX);
	काष्ठा amdgpu_device *adev = ring->adev;
	bool fw_version_ok = (ring->funcs->type == AMDGPU_RING_TYPE_GFX) ?
		adev->gfx.me_fw_ग_लिखो_रुको : adev->gfx.mec_fw_ग_लिखो_रुको;

	अगर (fw_version_ok)
		gfx_v9_0_रुको_reg_mem(ring, usepfp, 0, 1, reg0, reg1,
				      ref, mask, 0x20);
	अन्यथा
		amdgpu_ring_emit_reg_ग_लिखो_reg_रुको_helper(ring, reg0, reg1,
							   ref, mask);
पूर्ण

अटल व्योम gfx_v9_0_ring_soft_recovery(काष्ठा amdgpu_ring *ring, अचिन्हित vmid)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	uपूर्णांक32_t value = 0;

	value = REG_SET_FIELD(value, SQ_CMD, CMD, 0x03);
	value = REG_SET_FIELD(value, SQ_CMD, MODE, 0x01);
	value = REG_SET_FIELD(value, SQ_CMD, CHECK_VMID, 1);
	value = REG_SET_FIELD(value, SQ_CMD, VM_ID, vmid);
	WREG32_SOC15(GC, 0, mmSQ_CMD, value);
पूर्ण

अटल व्योम gfx_v9_0_set_gfx_eop_पूर्णांकerrupt_state(काष्ठा amdgpu_device *adev,
						 क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	चयन (state) अणु
	हाल AMDGPU_IRQ_STATE_DISABLE:
	हाल AMDGPU_IRQ_STATE_ENABLE:
		WREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,
			       TIME_STAMP_INT_ENABLE,
			       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(काष्ठा amdgpu_device *adev,
						     पूर्णांक me, पूर्णांक pipe,
						     क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	u32 mec_पूर्णांक_cntl, mec_पूर्णांक_cntl_reg;

	/*
	 * amdgpu controls only the first MEC. That's why this function only
	 * handles the setting of पूर्णांकerrupts क्रम this specअगरic MEC. All other
	 * pipes' पूर्णांकerrupts are set by amdkfd.
	 */

	अगर (me == 1) अणु
		चयन (pipe) अणु
		हाल 0:
			mec_पूर्णांक_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE0_INT_CNTL);
			अवरोध;
		हाल 1:
			mec_पूर्णांक_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE1_INT_CNTL);
			अवरोध;
		हाल 2:
			mec_पूर्णांक_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE2_INT_CNTL);
			अवरोध;
		हाल 3:
			mec_पूर्णांक_cntl_reg = SOC15_REG_OFFSET(GC, 0, mmCP_ME1_PIPE3_INT_CNTL);
			अवरोध;
		शेष:
			DRM_DEBUG("invalid pipe %d\n", pipe);
			वापस;
		पूर्ण
	पूर्ण अन्यथा अणु
		DRM_DEBUG("invalid me %d\n", me);
		वापस;
	पूर्ण

	चयन (state) अणु
	हाल AMDGPU_IRQ_STATE_DISABLE:
		mec_पूर्णांक_cntl = RREG32(mec_पूर्णांक_cntl_reg);
		mec_पूर्णांक_cntl = REG_SET_FIELD(mec_पूर्णांक_cntl, CP_ME1_PIPE0_INT_CNTL,
					     TIME_STAMP_INT_ENABLE, 0);
		WREG32(mec_पूर्णांक_cntl_reg, mec_पूर्णांक_cntl);
		अवरोध;
	हाल AMDGPU_IRQ_STATE_ENABLE:
		mec_पूर्णांक_cntl = RREG32(mec_पूर्णांक_cntl_reg);
		mec_पूर्णांक_cntl = REG_SET_FIELD(mec_पूर्णांक_cntl, CP_ME1_PIPE0_INT_CNTL,
					     TIME_STAMP_INT_ENABLE, 1);
		WREG32(mec_पूर्णांक_cntl_reg, mec_पूर्णांक_cntl);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल पूर्णांक gfx_v9_0_set_priv_reg_fault_state(काष्ठा amdgpu_device *adev,
					     काष्ठा amdgpu_irq_src *source,
					     अचिन्हित type,
					     क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	चयन (state) अणु
	हाल AMDGPU_IRQ_STATE_DISABLE:
	हाल AMDGPU_IRQ_STATE_ENABLE:
		WREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,
			       PRIV_REG_INT_ENABLE,
			       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_set_priv_inst_fault_state(काष्ठा amdgpu_device *adev,
					      काष्ठा amdgpu_irq_src *source,
					      अचिन्हित type,
					      क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	चयन (state) अणु
	हाल AMDGPU_IRQ_STATE_DISABLE:
	हाल AMDGPU_IRQ_STATE_ENABLE:
		WREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,
			       PRIV_INSTR_INT_ENABLE,
			       state == AMDGPU_IRQ_STATE_ENABLE ? 1 : 0);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	वापस 0;
पूर्ण

#घोषणा ENABLE_ECC_ON_ME_PIPE(me, pipe)				\
	WREG32_FIELD15(GC, 0, CP_ME##me##_PIPE##pipe##_INT_CNTL,\
			CP_ECC_ERROR_INT_ENABLE, 1)

#घोषणा DISABLE_ECC_ON_ME_PIPE(me, pipe)			\
	WREG32_FIELD15(GC, 0, CP_ME##me##_PIPE##pipe##_INT_CNTL,\
			CP_ECC_ERROR_INT_ENABLE, 0)

अटल पूर्णांक gfx_v9_0_set_cp_ecc_error_state(काष्ठा amdgpu_device *adev,
					      काष्ठा amdgpu_irq_src *source,
					      अचिन्हित type,
					      क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	चयन (state) अणु
	हाल AMDGPU_IRQ_STATE_DISABLE:
		WREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,
				CP_ECC_ERROR_INT_ENABLE, 0);
		DISABLE_ECC_ON_ME_PIPE(1, 0);
		DISABLE_ECC_ON_ME_PIPE(1, 1);
		DISABLE_ECC_ON_ME_PIPE(1, 2);
		DISABLE_ECC_ON_ME_PIPE(1, 3);
		अवरोध;

	हाल AMDGPU_IRQ_STATE_ENABLE:
		WREG32_FIELD15(GC, 0, CP_INT_CNTL_RING0,
				CP_ECC_ERROR_INT_ENABLE, 1);
		ENABLE_ECC_ON_ME_PIPE(1, 0);
		ENABLE_ECC_ON_ME_PIPE(1, 1);
		ENABLE_ECC_ON_ME_PIPE(1, 2);
		ENABLE_ECC_ON_ME_PIPE(1, 3);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	वापस 0;
पूर्ण


अटल पूर्णांक gfx_v9_0_set_eop_पूर्णांकerrupt_state(काष्ठा amdgpu_device *adev,
					    काष्ठा amdgpu_irq_src *src,
					    अचिन्हित type,
					    क्रमागत amdgpu_पूर्णांकerrupt_state state)
अणु
	चयन (type) अणु
	हाल AMDGPU_CP_IRQ_GFX_ME0_PIPE0_EOP:
		gfx_v9_0_set_gfx_eop_पूर्णांकerrupt_state(adev, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 1, 0, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE1_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 1, 1, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE2_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 1, 2, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE3_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 1, 3, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE0_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 2, 0, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE1_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 2, 1, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE2_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 2, 2, state);
		अवरोध;
	हाल AMDGPU_CP_IRQ_COMPUTE_MEC2_PIPE3_EOP:
		gfx_v9_0_set_compute_eop_पूर्णांकerrupt_state(adev, 2, 3, state);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_eop_irq(काष्ठा amdgpu_device *adev,
			    काष्ठा amdgpu_irq_src *source,
			    काष्ठा amdgpu_iv_entry *entry)
अणु
	पूर्णांक i;
	u8 me_id, pipe_id, queue_id;
	काष्ठा amdgpu_ring *ring;

	DRM_DEBUG("IH: CP EOP\n");
	me_id = (entry->ring_id & 0x0c) >> 2;
	pipe_id = (entry->ring_id & 0x03) >> 0;
	queue_id = (entry->ring_id & 0x70) >> 4;

	चयन (me_id) अणु
	हाल 0:
		amdgpu_fence_process(&adev->gfx.gfx_ring[0]);
		अवरोध;
	हाल 1:
	हाल 2:
		क्रम (i = 0; i < adev->gfx.num_compute_rings; i++) अणु
			ring = &adev->gfx.compute_ring[i];
			/* Per-queue पूर्णांकerrupt is supported क्रम MEC starting from VI.
			  * The पूर्णांकerrupt can only be enabled/disabled per pipe instead of per queue.
			  */
			अगर ((ring->me == me_id) && (ring->pipe == pipe_id) && (ring->queue == queue_id))
				amdgpu_fence_process(ring);
		पूर्ण
		अवरोध;
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_fault(काष्ठा amdgpu_device *adev,
			   काष्ठा amdgpu_iv_entry *entry)
अणु
	u8 me_id, pipe_id, queue_id;
	काष्ठा amdgpu_ring *ring;
	पूर्णांक i;

	me_id = (entry->ring_id & 0x0c) >> 2;
	pipe_id = (entry->ring_id & 0x03) >> 0;
	queue_id = (entry->ring_id & 0x70) >> 4;

	चयन (me_id) अणु
	हाल 0:
		drm_sched_fault(&adev->gfx.gfx_ring[0].sched);
		अवरोध;
	हाल 1:
	हाल 2:
		क्रम (i = 0; i < adev->gfx.num_compute_rings; i++) अणु
			ring = &adev->gfx.compute_ring[i];
			अगर (ring->me == me_id && ring->pipe == pipe_id &&
			    ring->queue == queue_id)
				drm_sched_fault(&ring->sched);
		पूर्ण
		अवरोध;
	पूर्ण
पूर्ण

अटल पूर्णांक gfx_v9_0_priv_reg_irq(काष्ठा amdgpu_device *adev,
				 काष्ठा amdgpu_irq_src *source,
				 काष्ठा amdgpu_iv_entry *entry)
अणु
	DRM_ERROR("Illegal register access in command stream\n");
	gfx_v9_0_fault(adev, entry);
	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_priv_inst_irq(काष्ठा amdgpu_device *adev,
				  काष्ठा amdgpu_irq_src *source,
				  काष्ठा amdgpu_iv_entry *entry)
अणु
	DRM_ERROR("Illegal instruction in command stream\n");
	gfx_v9_0_fault(adev, entry);
	वापस 0;
पूर्ण


अटल स्थिर काष्ठा soc15_ras_field_entry gfx_v9_0_ras_fields[] = अणु
	अणु "CPC_SCRATCH", SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_SCRATCH_CNT),
	  SOC15_REG_FIELD(CPC_EDC_SCRATCH_CNT, SEC_COUNT),
	  SOC15_REG_FIELD(CPC_EDC_SCRATCH_CNT, DED_COUNT)
	पूर्ण,
	अणु "CPC_UCODE", SOC15_REG_ENTRY(GC, 0, mmCPC_EDC_UCODE_CNT),
	  SOC15_REG_FIELD(CPC_EDC_UCODE_CNT, SEC_COUNT),
	  SOC15_REG_FIELD(CPC_EDC_UCODE_CNT, DED_COUNT)
	पूर्ण,
	अणु "CPF_ROQ_ME1", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT),
	  SOC15_REG_FIELD(CPF_EDC_ROQ_CNT, COUNT_ME1),
	  0, 0
	पूर्ण,
	अणु "CPF_ROQ_ME2", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_ROQ_CNT),
	  SOC15_REG_FIELD(CPF_EDC_ROQ_CNT, COUNT_ME2),
	  0, 0
	पूर्ण,
	अणु "CPF_TAG", SOC15_REG_ENTRY(GC, 0, mmCPF_EDC_TAG_CNT),
	  SOC15_REG_FIELD(CPF_EDC_TAG_CNT, SEC_COUNT),
	  SOC15_REG_FIELD(CPF_EDC_TAG_CNT, DED_COUNT)
	पूर्ण,
	अणु "CPG_DMA_ROQ", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT),
	  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, ROQ_COUNT),
	  0, 0
	पूर्ण,
	अणु "CPG_DMA_TAG", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_DMA_CNT),
	  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, TAG_SEC_COUNT),
	  SOC15_REG_FIELD(CPG_EDC_DMA_CNT, TAG_DED_COUNT)
	पूर्ण,
	अणु "CPG_TAG", SOC15_REG_ENTRY(GC, 0, mmCPG_EDC_TAG_CNT),
	  SOC15_REG_FIELD(CPG_EDC_TAG_CNT, SEC_COUNT),
	  SOC15_REG_FIELD(CPG_EDC_TAG_CNT, DED_COUNT)
	पूर्ण,
	अणु "DC_CSINVOC", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_CSINVOC_CNT),
	  SOC15_REG_FIELD(DC_EDC_CSINVOC_CNT, COUNT_ME1),
	  0, 0
	पूर्ण,
	अणु "DC_RESTORE", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_RESTORE_CNT),
	  SOC15_REG_FIELD(DC_EDC_RESTORE_CNT, COUNT_ME1),
	  0, 0
	पूर्ण,
	अणु "DC_STATE", SOC15_REG_ENTRY(GC, 0, mmDC_EDC_STATE_CNT),
	  SOC15_REG_FIELD(DC_EDC_STATE_CNT, COUNT_ME1),
	  0, 0
	पूर्ण,
	अणु "GDS_MEM", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT),
	  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_MEM_DED)
	पूर्ण,
	अणु "GDS_INPUT_QUEUE", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_CNT),
	  SOC15_REG_FIELD(GDS_EDC_CNT, GDS_INPUT_QUEUE_SED),
	  0, 0
	पूर्ण,
	अणु "GDS_ME0_CS_PIPE_MEM", SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, ME0_CS_PIPE_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, ME0_CS_PIPE_MEM_DED)
	पूर्ण,
	अणु "GDS_OA_PHY_PHY_CMD_RAM_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_CMD_RAM_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_CMD_RAM_MEM_DED)
	पूर्ण,
	अणु "GDS_OA_PHY_PHY_DATA_RAM_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PHY_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PHY_CNT, PHY_DATA_RAM_MEM_SED),
	  0, 0
	पूर्ण,
	अणु "GDS_OA_PIPE_ME1_PIPE0_PIPE_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE0_PIPE_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE0_PIPE_MEM_DED)
	पूर्ण,
	अणु "GDS_OA_PIPE_ME1_PIPE1_PIPE_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE1_PIPE_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE1_PIPE_MEM_DED)
	पूर्ण,
	अणु "GDS_OA_PIPE_ME1_PIPE2_PIPE_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE2_PIPE_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE2_PIPE_MEM_DED)
	पूर्ण,
	अणु "GDS_OA_PIPE_ME1_PIPE3_PIPE_MEM",
	  SOC15_REG_ENTRY(GC, 0, mmGDS_EDC_OA_PIPE_CNT),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE3_PIPE_MEM_SEC),
	  SOC15_REG_FIELD(GDS_EDC_OA_PIPE_CNT, ME1_PIPE3_PIPE_MEM_DED)
	पूर्ण,
	अणु "SPI_SR_MEM", SOC15_REG_ENTRY(GC, 0, mmSPI_EDC_CNT),
	  SOC15_REG_FIELD(SPI_EDC_CNT, SPI_SR_MEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TA_FS_DFIFO", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_DFIFO_SEC_COUNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_DFIFO_DED_COUNT)
	पूर्ण,
	अणु "TA_FS_AFIFO", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_AFIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TA_FL_LFIFO", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FL_LFIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TA_FX_LFIFO", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FX_LFIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TA_FS_CFIFO", SOC15_REG_ENTRY(GC, 0, mmTA_EDC_CNT),
	  SOC15_REG_FIELD(TA_EDC_CNT, TA_FS_CFIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCA_HOLE_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT),
	  SOC15_REG_FIELD(TCA_EDC_CNT, HOLE_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCA_REQ_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCA_EDC_CNT),
	  SOC15_REG_FIELD(TCA_EDC_CNT, REQ_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_CACHE_DATA", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DATA_SEC_COUNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_DATA_DED_COUNT)
	पूर्ण,
	अणु "TCC_CACHE_DIRTY", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_सूचीTY_SEC_COUNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, CACHE_सूचीTY_DED_COUNT)
	पूर्ण,
	अणु "TCC_HIGH_RATE_TAG", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, HIGH_RATE_TAG_SEC_COUNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, HIGH_RATE_TAG_DED_COUNT)
	पूर्ण,
	अणु "TCC_LOW_RATE_TAG", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, LOW_RATE_TAG_SEC_COUNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, LOW_RATE_TAG_DED_COUNT)
	पूर्ण,
	अणु "TCC_SRC_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, SRC_FIFO_SEC_COUNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, SRC_FIFO_DED_COUNT)
	पूर्ण,
	अणु "TCC_IN_USE_DEC", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, IN_USE_DEC_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_IN_USE_TRANSFER", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, IN_USE_TRANSFER_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_LATENCY_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, LATENCY_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_RETURN_DATA", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, RETURN_DATA_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_RETURN_CONTROL", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, RETURN_CONTROL_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_UC_ATOMIC_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT),
	  SOC15_REG_FIELD(TCC_EDC_CNT, UC_ATOMIC_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_WRITE_RETURN", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, WRITE_RETURN_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_WRITE_CACHE_READ", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, WRITE_CACHE_READ_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_SRC_FIFO_NEXT_RAM", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, SRC_FIFO_NEXT_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_LATENCY_FIFO_NEXT_RAM", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, LATENCY_FIFO_NEXT_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_CACHE_TAG_PROBE_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, CACHE_TAG_PROBE_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_WRRET_TAG_WRITE_RETURN", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, WRRET_TAG_WRITE_RETURN_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCC_ATOMIC_RETURN_BUFFER", SOC15_REG_ENTRY(GC, 0, mmTCC_EDC_CNT2),
	  SOC15_REG_FIELD(TCC_EDC_CNT2, ATOMIC_RETURN_BUFFER_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCI_WRITE_RAM", SOC15_REG_ENTRY(GC, 0, mmTCI_EDC_CNT),
	  SOC15_REG_FIELD(TCI_EDC_CNT, WRITE_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCP_CACHE_RAM", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CACHE_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CACHE_RAM_DED_COUNT)
	पूर्ण,
	अणु "TCP_LFIFO_RAM", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, LFIFO_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, LFIFO_RAM_DED_COUNT)
	पूर्ण,
	अणु "TCP_CMD_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, CMD_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCP_VM_FIFO", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, VM_FIFO_SEC_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCP_DB_RAM", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, DB_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "TCP_UTCL1_LFIFO0", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO0_SEC_COUNT),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO0_DED_COUNT)
	पूर्ण,
	अणु "TCP_UTCL1_LFIFO1", SOC15_REG_ENTRY(GC, 0, mmTCP_EDC_CNT_NEW),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO1_SEC_COUNT),
	  SOC15_REG_FIELD(TCP_EDC_CNT_NEW, UTCL1_LFIFO1_DED_COUNT)
	पूर्ण,
	अणु "TD_SS_FIFO_LO", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),
	  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_LO_SEC_COUNT),
	  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_LO_DED_COUNT)
	पूर्ण,
	अणु "TD_SS_FIFO_HI", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),
	  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_HI_SEC_COUNT),
	  SOC15_REG_FIELD(TD_EDC_CNT, SS_FIFO_HI_DED_COUNT)
	पूर्ण,
	अणु "TD_CS_FIFO", SOC15_REG_ENTRY(GC, 0, mmTD_EDC_CNT),
	  SOC15_REG_FIELD(TD_EDC_CNT, CS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQ_LDS_D", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_D_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_D_DED_COUNT)
	पूर्ण,
	अणु "SQ_LDS_I", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_I_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, LDS_I_DED_COUNT)
	पूर्ण,
	अणु "SQ_SGPR", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, SGPR_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, SGPR_DED_COUNT)
	पूर्ण,
	अणु "SQ_VGPR0", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR0_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR0_DED_COUNT)
	पूर्ण,
	अणु "SQ_VGPR1", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR1_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR1_DED_COUNT)
	पूर्ण,
	अणु "SQ_VGPR2", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR2_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR2_DED_COUNT)
	पूर्ण,
	अणु "SQ_VGPR3", SOC15_REG_ENTRY(GC, 0, mmSQ_EDC_CNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR3_SEC_COUNT),
	  SOC15_REG_FIELD(SQ_EDC_CNT, VGPR3_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU0_WRITE_DATA_BUF", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_WRITE_DATA_BUF_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_WRITE_DATA_BUF_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU0_UTCL1_LFIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_UTCL1_LFIFO_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU0_UTCL1_LFIFO_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU1_WRITE_DATA_BUF", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_WRITE_DATA_BUF_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_WRITE_DATA_BUF_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU1_UTCL1_LFIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_UTCL1_LFIFO_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU1_UTCL1_LFIFO_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU2_WRITE_DATA_BUF", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_WRITE_DATA_BUF_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_WRITE_DATA_BUF_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_CU2_UTCL1_LFIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_UTCL1_LFIFO_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT, DATA_CU2_UTCL1_LFIFO_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKA_TAG_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_TAG_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_TAG_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKA_BANK_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_BANK_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_BANK_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_BANKA_TAG_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_TAG_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_TAG_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_BANKA_BANK_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_BANK_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_BANK_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKA_UTCL1_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_UTCL1_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_INST_BANKA_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_BANKA_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKA_HIT_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_HIT_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKA_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKA_DIRTY_BIT_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, DATA_BANKA_सूचीTY_BIT_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_INST_UTCL1_LFIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT2),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_UTCL1_LFIFO_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT2, INST_UTCL1_LFIFO_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKB_TAG_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_TAG_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_TAG_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKB_BANK_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_BANK_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_BANK_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_BANKB_TAG_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_TAG_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_TAG_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_DATA_BANKB_BANK_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_BANK_RAM_SEC_COUNT),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_BANK_RAM_DED_COUNT)
	पूर्ण,
	अणु "SQC_INST_BANKB_UTCL1_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_UTCL1_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_INST_BANKB_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, INST_BANKB_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKB_HIT_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_HIT_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKB_MISS_FIFO", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_MISS_FIFO_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "SQC_DATA_BANKB_DIRTY_BIT_RAM", SOC15_REG_ENTRY(GC, 0, mmSQC_EDC_CNT3),
	  SOC15_REG_FIELD(SQC_EDC_CNT3, DATA_BANKB_सूचीTY_BIT_RAM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "EA_DRAMRD_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_CMDMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_CMDMEM_DED_COUNT)
	पूर्ण,
	अणु "EA_DRAMWR_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_CMDMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_CMDMEM_DED_COUNT)
	पूर्ण,
	अणु "EA_DRAMWR_DATAMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_DATAMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_DATAMEM_DED_COUNT)
	पूर्ण,
	अणु "EA_RRET_TAGMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, RRET_TAGMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, RRET_TAGMEM_DED_COUNT)
	पूर्ण,
	अणु "EA_WRET_TAGMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, WRET_TAGMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, WRET_TAGMEM_DED_COUNT)
	पूर्ण,
	अणु "EA_DRAMRD_PAGEMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMRD_PAGEMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "EA_DRAMWR_PAGEMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, DRAMWR_PAGEMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "EA_IORD_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, IORD_CMDMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "EA_IOWR_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, IOWR_CMDMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "EA_IOWR_DATAMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT, IOWR_DATAMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "GMIRD_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_CMDMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_CMDMEM_DED_COUNT)
	पूर्ण,
	अणु "GMIWR_CMDMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_CMDMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_CMDMEM_DED_COUNT)
	पूर्ण,
	अणु "GMIWR_DATAMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_DATAMEM_SEC_COUNT),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_DATAMEM_DED_COUNT)
	पूर्ण,
	अणु "GMIRD_PAGEMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIRD_PAGEMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "GMIWR_PAGEMEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, GMIWR_PAGEMEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "MAM_D0MEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D0MEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "MAM_D1MEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D1MEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "MAM_D2MEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D2MEM_SED_COUNT),
	  0, 0
	पूर्ण,
	अणु "MAM_D3MEM", SOC15_REG_ENTRY(GC, 0, mmGCEA_EDC_CNT2),
	  SOC15_REG_FIELD(GCEA_EDC_CNT2, MAM_D3MEM_SED_COUNT),
	  0, 0
	पूर्ण
पूर्ण;

अटल पूर्णांक gfx_v9_0_ras_error_inject(काष्ठा amdgpu_device *adev,
				     व्योम *inject_अगर)
अणु
	काष्ठा ras_inject_अगर *info = (काष्ठा ras_inject_अगर *)inject_अगर;
	पूर्णांक ret;
	काष्ठा ta_ras_trigger_error_input block_info = अणु 0 पूर्ण;

	अगर (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))
		वापस -EINVAL;

	अगर (info->head.sub_block_index >= ARRAY_SIZE(ras_gfx_subblocks))
		वापस -EINVAL;

	अगर (!ras_gfx_subblocks[info->head.sub_block_index].name)
		वापस -EPERM;

	अगर (!(ras_gfx_subblocks[info->head.sub_block_index].hw_supported_error_type &
	      info->head.type)) अणु
		DRM_ERROR("GFX Subblock %s, hardware do not support type 0x%x\n",
			ras_gfx_subblocks[info->head.sub_block_index].name,
			info->head.type);
		वापस -EPERM;
	पूर्ण

	अगर (!(ras_gfx_subblocks[info->head.sub_block_index].sw_supported_error_type &
	      info->head.type)) अणु
		DRM_ERROR("GFX Subblock %s, driver do not support type 0x%x\n",
			ras_gfx_subblocks[info->head.sub_block_index].name,
			info->head.type);
		वापस -EPERM;
	पूर्ण

	block_info.block_id = amdgpu_ras_block_to_ta(info->head.block);
	block_info.sub_block_index =
		ras_gfx_subblocks[info->head.sub_block_index].ta_subblock;
	block_info.inject_error_type = amdgpu_ras_error_to_ta(info->head.type);
	block_info.address = info->address;
	block_info.value = info->value;

	mutex_lock(&adev->grbm_idx_mutex);
	ret = psp_ras_trigger_error(&adev->psp, &block_info);
	mutex_unlock(&adev->grbm_idx_mutex);

	वापस ret;
पूर्ण

अटल स्थिर अक्षर *vml2_mems[] = अणु
	"UTC_VML2_BANK_CACHE_0_BIGK_MEM0",
	"UTC_VML2_BANK_CACHE_0_BIGK_MEM1",
	"UTC_VML2_BANK_CACHE_0_4K_MEM0",
	"UTC_VML2_BANK_CACHE_0_4K_MEM1",
	"UTC_VML2_BANK_CACHE_1_BIGK_MEM0",
	"UTC_VML2_BANK_CACHE_1_BIGK_MEM1",
	"UTC_VML2_BANK_CACHE_1_4K_MEM0",
	"UTC_VML2_BANK_CACHE_1_4K_MEM1",
	"UTC_VML2_BANK_CACHE_2_BIGK_MEM0",
	"UTC_VML2_BANK_CACHE_2_BIGK_MEM1",
	"UTC_VML2_BANK_CACHE_2_4K_MEM0",
	"UTC_VML2_BANK_CACHE_2_4K_MEM1",
	"UTC_VML2_BANK_CACHE_3_BIGK_MEM0",
	"UTC_VML2_BANK_CACHE_3_BIGK_MEM1",
	"UTC_VML2_BANK_CACHE_3_4K_MEM0",
	"UTC_VML2_BANK_CACHE_3_4K_MEM1",
पूर्ण;

अटल स्थिर अक्षर *vml2_walker_mems[] = अणु
	"UTC_VML2_CACHE_PDE0_MEM0",
	"UTC_VML2_CACHE_PDE0_MEM1",
	"UTC_VML2_CACHE_PDE1_MEM0",
	"UTC_VML2_CACHE_PDE1_MEM1",
	"UTC_VML2_CACHE_PDE2_MEM0",
	"UTC_VML2_CACHE_PDE2_MEM1",
	"UTC_VML2_RDIF_LOG_FIFO",
पूर्ण;

अटल स्थिर अक्षर *atc_l2_cache_2m_mems[] = अणु
	"UTC_ATCL2_CACHE_2M_BANK0_WAY0_MEM",
	"UTC_ATCL2_CACHE_2M_BANK0_WAY1_MEM",
	"UTC_ATCL2_CACHE_2M_BANK1_WAY0_MEM",
	"UTC_ATCL2_CACHE_2M_BANK1_WAY1_MEM",
पूर्ण;

अटल स्थिर अक्षर *atc_l2_cache_4k_mems[] = अणु
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM0",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM1",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM2",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM3",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM4",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM5",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM6",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY0_MEM7",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM0",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM1",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM2",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM3",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM4",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM5",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM6",
	"UTC_ATCL2_CACHE_4K_BANK0_WAY1_MEM7",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM0",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM1",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM2",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM3",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM4",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM5",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM6",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY0_MEM7",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM0",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM1",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM2",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM3",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM4",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM5",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM6",
	"UTC_ATCL2_CACHE_4K_BANK1_WAY1_MEM7",
पूर्ण;

अटल पूर्णांक gfx_v9_0_query_utc_edc_status(काष्ठा amdgpu_device *adev,
					 काष्ठा ras_err_data *err_data)
अणु
	uपूर्णांक32_t i, data;
	uपूर्णांक32_t sec_count, ded_count;

	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT, 0);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT, 0);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT, 0);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT, 0);

	क्रम (i = 0; i < ARRAY_SIZE(vml2_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, i);
		data = RREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT);

		sec_count = REG_GET_FIELD(data, VM_L2_MEM_ECC_CNT, SEC_COUNT);
		अगर (sec_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"SEC %d\n", i, vml2_mems[i], sec_count);
			err_data->ce_count += sec_count;
		पूर्ण

		ded_count = REG_GET_FIELD(data, VM_L2_MEM_ECC_CNT, DED_COUNT);
		अगर (ded_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"DED %d\n", i, vml2_mems[i], ded_count);
			err_data->ue_count += ded_count;
		पूर्ण
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(vml2_walker_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, i);
		data = RREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT);

		sec_count = REG_GET_FIELD(data, VM_L2_WALKER_MEM_ECC_CNT,
						SEC_COUNT);
		अगर (sec_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"SEC %d\n", i, vml2_walker_mems[i], sec_count);
			err_data->ce_count += sec_count;
		पूर्ण

		ded_count = REG_GET_FIELD(data, VM_L2_WALKER_MEM_ECC_CNT,
						DED_COUNT);
		अगर (ded_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"DED %d\n", i, vml2_walker_mems[i], ded_count);
			err_data->ue_count += ded_count;
		पूर्ण
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(atc_l2_cache_2m_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, i);
		data = RREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT);

		sec_count = (data & 0x00006000L) >> 0xd;
		अगर (sec_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"SEC %d\n", i, atc_l2_cache_2m_mems[i],
				sec_count);
			err_data->ce_count += sec_count;
		पूर्ण
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(atc_l2_cache_4k_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, i);
		data = RREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT);

		sec_count = (data & 0x00006000L) >> 0xd;
		अगर (sec_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"SEC %d\n", i, atc_l2_cache_4k_mems[i],
				sec_count);
			err_data->ce_count += sec_count;
		पूर्ण

		ded_count = (data & 0x00018000L) >> 0xf;
		अगर (ded_count) अणु
			dev_info(adev->dev, "Instance[%d]: SubBlock %s, "
				"DED %d\n", i, atc_l2_cache_4k_mems[i],
				ded_count);
			err_data->ue_count += ded_count;
		पूर्ण
	पूर्ण

	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);

	वापस 0;
पूर्ण

अटल पूर्णांक gfx_v9_0_ras_error_count(काष्ठा amdgpu_device *adev,
	स्थिर काष्ठा soc15_reg_entry *reg,
	uपूर्णांक32_t se_id, uपूर्णांक32_t inst_id, uपूर्णांक32_t value,
	uपूर्णांक32_t *sec_count, uपूर्णांक32_t *ded_count)
अणु
	uपूर्णांक32_t i;
	uपूर्णांक32_t sec_cnt, ded_cnt;

	क्रम (i = 0; i < ARRAY_SIZE(gfx_v9_0_ras_fields); i++) अणु
		अगर(gfx_v9_0_ras_fields[i].reg_offset != reg->reg_offset ||
			gfx_v9_0_ras_fields[i].seg != reg->seg ||
			gfx_v9_0_ras_fields[i].inst != reg->inst)
			जारी;

		sec_cnt = (value &
				gfx_v9_0_ras_fields[i].sec_count_mask) >>
				gfx_v9_0_ras_fields[i].sec_count_shअगरt;
		अगर (sec_cnt) अणु
			dev_info(adev->dev, "GFX SubBlock %s, "
				"Instance[%d][%d], SEC %d\n",
				gfx_v9_0_ras_fields[i].name,
				se_id, inst_id,
				sec_cnt);
			*sec_count += sec_cnt;
		पूर्ण

		ded_cnt = (value &
				gfx_v9_0_ras_fields[i].ded_count_mask) >>
				gfx_v9_0_ras_fields[i].ded_count_shअगरt;
		अगर (ded_cnt) अणु
			dev_info(adev->dev, "GFX SubBlock %s, "
				"Instance[%d][%d], DED %d\n",
				gfx_v9_0_ras_fields[i].name,
				se_id, inst_id,
				ded_cnt);
			*ded_count += ded_cnt;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_reset_ras_error_count(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक i, j, k;

	अगर (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))
		वापस;

	/* पढ़ो back रेजिस्टरs to clear the counters */
	mutex_lock(&adev->grbm_idx_mutex);
	क्रम (i = 0; i < ARRAY_SIZE(gfx_v9_0_edc_counter_regs); i++) अणु
		क्रम (j = 0; j < gfx_v9_0_edc_counter_regs[i].se_num; j++) अणु
			क्रम (k = 0; k < gfx_v9_0_edc_counter_regs[i].instance; k++) अणु
				gfx_v9_0_select_se_sh(adev, j, 0x0, k);
				RREG32(SOC15_REG_ENTRY_OFFSET(gfx_v9_0_edc_counter_regs[i]));
			पूर्ण
		पूर्ण
	पूर्ण
	WREG32_SOC15(GC, 0, mmGRBM_GFX_INDEX, 0xe0000000);
	mutex_unlock(&adev->grbm_idx_mutex);

	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT, 0);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT, 0);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT, 0);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT, 0);

	क्रम (i = 0; i < ARRAY_SIZE(vml2_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, i);
		RREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_CNT);
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(vml2_walker_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, i);
		RREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_CNT);
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(atc_l2_cache_2m_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, i);
		RREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_CNT);
	पूर्ण

	क्रम (i = 0; i < ARRAY_SIZE(atc_l2_cache_4k_mems); i++) अणु
		WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, i);
		RREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_CNT);
	पूर्ण

	WREG32_SOC15(GC, 0, mmVM_L2_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmVM_L2_WALKER_MEM_ECC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_2M_EDC_INDEX, 255);
	WREG32_SOC15(GC, 0, mmATC_L2_CACHE_4K_EDC_INDEX, 255);
पूर्ण

अटल पूर्णांक gfx_v9_0_query_ras_error_count(काष्ठा amdgpu_device *adev,
					  व्योम *ras_error_status)
अणु
	काष्ठा ras_err_data *err_data = (काष्ठा ras_err_data *)ras_error_status;
	uपूर्णांक32_t sec_count = 0, ded_count = 0;
	uपूर्णांक32_t i, j, k;
	uपूर्णांक32_t reg_value;

	अगर (!amdgpu_ras_is_supported(adev, AMDGPU_RAS_BLOCK__GFX))
		वापस -EINVAL;

	err_data->ue_count = 0;
	err_data->ce_count = 0;

	mutex_lock(&adev->grbm_idx_mutex);

	क्रम (i = 0; i < ARRAY_SIZE(gfx_v9_0_edc_counter_regs); i++) अणु
		क्रम (j = 0; j < gfx_v9_0_edc_counter_regs[i].se_num; j++) अणु
			क्रम (k = 0; k < gfx_v9_0_edc_counter_regs[i].instance; k++) अणु
				gfx_v9_0_select_se_sh(adev, j, 0, k);
				reg_value =
					RREG32(SOC15_REG_ENTRY_OFFSET(gfx_v9_0_edc_counter_regs[i]));
				अगर (reg_value)
					gfx_v9_0_ras_error_count(adev,
						&gfx_v9_0_edc_counter_regs[i],
						j, k, reg_value,
						&sec_count, &ded_count);
			पूर्ण
		पूर्ण
	पूर्ण

	err_data->ce_count += sec_count;
	err_data->ue_count += ded_count;

	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	mutex_unlock(&adev->grbm_idx_mutex);

	gfx_v9_0_query_utc_edc_status(adev, err_data);

	वापस 0;
पूर्ण

अटल व्योम gfx_v9_0_emit_mem_sync(काष्ठा amdgpu_ring *ring)
अणु
	स्थिर अचिन्हित पूर्णांक cp_coher_cntl =
			PACKET3_ACQUIRE_MEM_CP_COHER_CNTL_SH_ICACHE_ACTION_ENA(1) |
			PACKET3_ACQUIRE_MEM_CP_COHER_CNTL_SH_KCACHE_ACTION_ENA(1) |
			PACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TC_ACTION_ENA(1) |
			PACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TCL1_ACTION_ENA(1) |
			PACKET3_ACQUIRE_MEM_CP_COHER_CNTL_TC_WB_ACTION_ENA(1);

	/* ACQUIRE_MEM -make one or more surfaces valid क्रम use by the subsequent operations */
	amdgpu_ring_ग_लिखो(ring, PACKET3(PACKET3_ACQUIRE_MEM, 5));
	amdgpu_ring_ग_लिखो(ring, cp_coher_cntl); /* CP_COHER_CNTL */
	amdgpu_ring_ग_लिखो(ring, 0xffffffff);  /* CP_COHER_SIZE */
	amdgpu_ring_ग_लिखो(ring, 0xffffff);  /* CP_COHER_SIZE_HI */
	amdgpu_ring_ग_लिखो(ring, 0); /* CP_COHER_BASE */
	amdgpu_ring_ग_लिखो(ring, 0);  /* CP_COHER_BASE_HI */
	amdgpu_ring_ग_लिखो(ring, 0x0000000A); /* POLL_INTERVAL */
पूर्ण

अटल व्योम gfx_v9_0_emit_wave_limit_cs(काष्ठा amdgpu_ring *ring,
					uपूर्णांक32_t pipe, bool enable)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	uपूर्णांक32_t val;
	uपूर्णांक32_t wcl_cs_reg;

	/* mmSPI_WCL_PIPE_PERCENT_CS[0-7]_DEFAULT values are same */
	val = enable ? 0x1 : mmSPI_WCL_PIPE_PERCENT_CS0_DEFAULT;

	चयन (pipe) अणु
	हाल 0:
		wcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS0);
		अवरोध;
	हाल 1:
		wcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS1);
		अवरोध;
	हाल 2:
		wcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS2);
		अवरोध;
	हाल 3:
		wcl_cs_reg = SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_CS3);
		अवरोध;
	शेष:
		DRM_DEBUG("invalid pipe %d\n", pipe);
		वापस;
	पूर्ण

	amdgpu_ring_emit_wreg(ring, wcl_cs_reg, val);

पूर्ण
अटल व्योम gfx_v9_0_emit_wave_limit(काष्ठा amdgpu_ring *ring, bool enable)
अणु
	काष्ठा amdgpu_device *adev = ring->adev;
	uपूर्णांक32_t val;
	पूर्णांक i;


	/* mmSPI_WCL_PIPE_PERCENT_GFX is 7 bit multiplier रेजिस्टर to limit
	 * number of gfx waves. Setting 5 bit will make sure gfx only माला_लो
	 * around 25% of gpu resources.
	 */
	val = enable ? 0x1f : mmSPI_WCL_PIPE_PERCENT_GFX_DEFAULT;
	amdgpu_ring_emit_wreg(ring,
			      SOC15_REG_OFFSET(GC, 0, mmSPI_WCL_PIPE_PERCENT_GFX),
			      val);

	/* Restrict waves क्रम normal/low priority compute queues as well
	 * to get best QoS क्रम high priority compute jobs.
	 *
	 * amdgpu controls only 1st ME(0-3 CS pipes).
	 */
	क्रम (i = 0; i < adev->gfx.mec.num_pipe_per_mec; i++) अणु
		अगर (i != ring->pipe)
			gfx_v9_0_emit_wave_limit_cs(ring, i, enable);

	पूर्ण
पूर्ण

अटल स्थिर काष्ठा amd_ip_funcs gfx_v9_0_ip_funcs = अणु
	.name = "gfx_v9_0",
	.early_init = gfx_v9_0_early_init,
	.late_init = gfx_v9_0_late_init,
	.sw_init = gfx_v9_0_sw_init,
	.sw_fini = gfx_v9_0_sw_fini,
	.hw_init = gfx_v9_0_hw_init,
	.hw_fini = gfx_v9_0_hw_fini,
	.suspend = gfx_v9_0_suspend,
	.resume = gfx_v9_0_resume,
	.is_idle = gfx_v9_0_is_idle,
	.रुको_क्रम_idle = gfx_v9_0_रुको_क्रम_idle,
	.soft_reset = gfx_v9_0_soft_reset,
	.set_घड़ीgating_state = gfx_v9_0_set_घड़ीgating_state,
	.set_घातergating_state = gfx_v9_0_set_घातergating_state,
	.get_घड़ीgating_state = gfx_v9_0_get_घड़ीgating_state,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_ring_funcs gfx_v9_0_ring_funcs_gfx = अणु
	.type = AMDGPU_RING_TYPE_GFX,
	.align_mask = 0xff,
	.nop = PACKET3(PACKET3_NOP, 0x3FFF),
	.support_64bit_ptrs = true,
	.vmhub = AMDGPU_GFXHUB_0,
	.get_rptr = gfx_v9_0_ring_get_rptr_gfx,
	.get_wptr = gfx_v9_0_ring_get_wptr_gfx,
	.set_wptr = gfx_v9_0_ring_set_wptr_gfx,
	.emit_frame_size = /* totally 242 maximum अगर 16 IBs */
		5 +  /* COND_EXEC */
		7 +  /* PIPELINE_SYNC */
		SOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +
		SOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +
		2 + /* VM_FLUSH */
		8 +  /* FENCE क्रम VM_FLUSH */
		20 + /* GDS चयन */
		4 + /* द्विगुन SWITCH_BUFFER,
		       the first COND_EXEC jump to the place just
			   prior to this द्विगुन SWITCH_BUFFER  */
		5 + /* COND_EXEC */
		7 +	 /*	HDP_flush */
		4 +	 /*	VGT_flush */
		14 + /*	CE_META */
		31 + /*	DE_META */
		3 + /* CNTX_CTRL */
		5 + /* HDP_INVL */
		8 + 8 + /* FENCE x2 */
		2 + /* SWITCH_BUFFER */
		7, /* gfx_v9_0_emit_mem_sync */
	.emit_ib_size =	4, /* gfx_v9_0_ring_emit_ib_gfx */
	.emit_ib = gfx_v9_0_ring_emit_ib_gfx,
	.emit_fence = gfx_v9_0_ring_emit_fence,
	.emit_pipeline_sync = gfx_v9_0_ring_emit_pipeline_sync,
	.emit_vm_flush = gfx_v9_0_ring_emit_vm_flush,
	.emit_gds_चयन = gfx_v9_0_ring_emit_gds_चयन,
	.emit_hdp_flush = gfx_v9_0_ring_emit_hdp_flush,
	.test_ring = gfx_v9_0_ring_test_ring,
	.test_ib = gfx_v9_0_ring_test_ib,
	.insert_nop = amdgpu_ring_insert_nop,
	.pad_ib = amdgpu_ring_generic_pad_ib,
	.emit_चयन_buffer = gfx_v9_ring_emit_sb,
	.emit_cntxcntl = gfx_v9_ring_emit_cntxcntl,
	.init_cond_exec = gfx_v9_0_ring_emit_init_cond_exec,
	.patch_cond_exec = gfx_v9_0_ring_emit_patch_cond_exec,
	.emit_frame_cntl = gfx_v9_0_ring_emit_frame_cntl,
	.emit_wreg = gfx_v9_0_ring_emit_wreg,
	.emit_reg_रुको = gfx_v9_0_ring_emit_reg_रुको,
	.emit_reg_ग_लिखो_reg_रुको = gfx_v9_0_ring_emit_reg_ग_लिखो_reg_रुको,
	.soft_recovery = gfx_v9_0_ring_soft_recovery,
	.emit_mem_sync = gfx_v9_0_emit_mem_sync,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_ring_funcs gfx_v9_0_ring_funcs_compute = अणु
	.type = AMDGPU_RING_TYPE_COMPUTE,
	.align_mask = 0xff,
	.nop = PACKET3(PACKET3_NOP, 0x3FFF),
	.support_64bit_ptrs = true,
	.vmhub = AMDGPU_GFXHUB_0,
	.get_rptr = gfx_v9_0_ring_get_rptr_compute,
	.get_wptr = gfx_v9_0_ring_get_wptr_compute,
	.set_wptr = gfx_v9_0_ring_set_wptr_compute,
	.emit_frame_size =
		20 + /* gfx_v9_0_ring_emit_gds_चयन */
		7 + /* gfx_v9_0_ring_emit_hdp_flush */
		5 + /* hdp invalidate */
		7 + /* gfx_v9_0_ring_emit_pipeline_sync */
		SOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +
		SOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +
		2 + /* gfx_v9_0_ring_emit_vm_flush */
		8 + 8 + 8 + /* gfx_v9_0_ring_emit_fence x3 क्रम user fence, vm fence */
		7 + /* gfx_v9_0_emit_mem_sync */
		5 + /* gfx_v9_0_emit_wave_limit क्रम updating mmSPI_WCL_PIPE_PERCENT_GFX रेजिस्टर */
		15, /* क्रम updating 3 mmSPI_WCL_PIPE_PERCENT_CS रेजिस्टरs */
	.emit_ib_size =	7, /* gfx_v9_0_ring_emit_ib_compute */
	.emit_ib = gfx_v9_0_ring_emit_ib_compute,
	.emit_fence = gfx_v9_0_ring_emit_fence,
	.emit_pipeline_sync = gfx_v9_0_ring_emit_pipeline_sync,
	.emit_vm_flush = gfx_v9_0_ring_emit_vm_flush,
	.emit_gds_चयन = gfx_v9_0_ring_emit_gds_चयन,
	.emit_hdp_flush = gfx_v9_0_ring_emit_hdp_flush,
	.test_ring = gfx_v9_0_ring_test_ring,
	.test_ib = gfx_v9_0_ring_test_ib,
	.insert_nop = amdgpu_ring_insert_nop,
	.pad_ib = amdgpu_ring_generic_pad_ib,
	.emit_wreg = gfx_v9_0_ring_emit_wreg,
	.emit_reg_रुको = gfx_v9_0_ring_emit_reg_रुको,
	.emit_reg_ग_लिखो_reg_रुको = gfx_v9_0_ring_emit_reg_ग_लिखो_reg_रुको,
	.emit_mem_sync = gfx_v9_0_emit_mem_sync,
	.emit_wave_limit = gfx_v9_0_emit_wave_limit,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_ring_funcs gfx_v9_0_ring_funcs_kiq = अणु
	.type = AMDGPU_RING_TYPE_KIQ,
	.align_mask = 0xff,
	.nop = PACKET3(PACKET3_NOP, 0x3FFF),
	.support_64bit_ptrs = true,
	.vmhub = AMDGPU_GFXHUB_0,
	.get_rptr = gfx_v9_0_ring_get_rptr_compute,
	.get_wptr = gfx_v9_0_ring_get_wptr_compute,
	.set_wptr = gfx_v9_0_ring_set_wptr_compute,
	.emit_frame_size =
		20 + /* gfx_v9_0_ring_emit_gds_चयन */
		7 + /* gfx_v9_0_ring_emit_hdp_flush */
		5 + /* hdp invalidate */
		7 + /* gfx_v9_0_ring_emit_pipeline_sync */
		SOC15_FLUSH_GPU_TLB_NUM_WREG * 5 +
		SOC15_FLUSH_GPU_TLB_NUM_REG_WAIT * 7 +
		2 + /* gfx_v9_0_ring_emit_vm_flush */
		8 + 8 + 8, /* gfx_v9_0_ring_emit_fence_kiq x3 क्रम user fence, vm fence */
	.emit_ib_size =	7, /* gfx_v9_0_ring_emit_ib_compute */
	.emit_fence = gfx_v9_0_ring_emit_fence_kiq,
	.test_ring = gfx_v9_0_ring_test_ring,
	.insert_nop = amdgpu_ring_insert_nop,
	.pad_ib = amdgpu_ring_generic_pad_ib,
	.emit_rreg = gfx_v9_0_ring_emit_rreg,
	.emit_wreg = gfx_v9_0_ring_emit_wreg,
	.emit_reg_रुको = gfx_v9_0_ring_emit_reg_रुको,
	.emit_reg_ग_लिखो_reg_रुको = gfx_v9_0_ring_emit_reg_ग_लिखो_reg_रुको,
पूर्ण;

अटल व्योम gfx_v9_0_set_ring_funcs(काष्ठा amdgpu_device *adev)
अणु
	पूर्णांक i;

	adev->gfx.kiq.ring.funcs = &gfx_v9_0_ring_funcs_kiq;

	क्रम (i = 0; i < adev->gfx.num_gfx_rings; i++)
		adev->gfx.gfx_ring[i].funcs = &gfx_v9_0_ring_funcs_gfx;

	क्रम (i = 0; i < adev->gfx.num_compute_rings; i++)
		adev->gfx.compute_ring[i].funcs = &gfx_v9_0_ring_funcs_compute;
पूर्ण

अटल स्थिर काष्ठा amdgpu_irq_src_funcs gfx_v9_0_eop_irq_funcs = अणु
	.set = gfx_v9_0_set_eop_पूर्णांकerrupt_state,
	.process = gfx_v9_0_eop_irq,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_irq_src_funcs gfx_v9_0_priv_reg_irq_funcs = अणु
	.set = gfx_v9_0_set_priv_reg_fault_state,
	.process = gfx_v9_0_priv_reg_irq,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_irq_src_funcs gfx_v9_0_priv_inst_irq_funcs = अणु
	.set = gfx_v9_0_set_priv_inst_fault_state,
	.process = gfx_v9_0_priv_inst_irq,
पूर्ण;

अटल स्थिर काष्ठा amdgpu_irq_src_funcs gfx_v9_0_cp_ecc_error_irq_funcs = अणु
	.set = gfx_v9_0_set_cp_ecc_error_state,
	.process = amdgpu_gfx_cp_ecc_error_irq,
पूर्ण;


अटल व्योम gfx_v9_0_set_irq_funcs(काष्ठा amdgpu_device *adev)
अणु
	adev->gfx.eop_irq.num_types = AMDGPU_CP_IRQ_LAST;
	adev->gfx.eop_irq.funcs = &gfx_v9_0_eop_irq_funcs;

	adev->gfx.priv_reg_irq.num_types = 1;
	adev->gfx.priv_reg_irq.funcs = &gfx_v9_0_priv_reg_irq_funcs;

	adev->gfx.priv_inst_irq.num_types = 1;
	adev->gfx.priv_inst_irq.funcs = &gfx_v9_0_priv_inst_irq_funcs;

	adev->gfx.cp_ecc_error_irq.num_types = 2; /*C5 ECC error and C9 FUE error*/
	adev->gfx.cp_ecc_error_irq.funcs = &gfx_v9_0_cp_ecc_error_irq_funcs;
पूर्ण

अटल व्योम gfx_v9_0_set_rlc_funcs(काष्ठा amdgpu_device *adev)
अणु
	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA12:
	हाल CHIP_VEGA20:
	हाल CHIP_RAVEN:
	हाल CHIP_ARCTURUS:
	हाल CHIP_RENOIR:
	हाल CHIP_ALDEBARAN:
		adev->gfx.rlc.funcs = &gfx_v9_0_rlc_funcs;
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल व्योम gfx_v9_0_set_gds_init(काष्ठा amdgpu_device *adev)
अणु
	/* init asci gds info */
	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA12:
	हाल CHIP_VEGA20:
		adev->gds.gds_size = 0x10000;
		अवरोध;
	हाल CHIP_RAVEN:
	हाल CHIP_ARCTURUS:
		adev->gds.gds_size = 0x1000;
		अवरोध;
	हाल CHIP_ALDEBARAN:
		/* aldebaran हटाओd all the GDS पूर्णांकernal memory,
		 * only support GWS opcode in kernel, like barrier
		 * semaphore.etc */
		adev->gds.gds_size = 0;
		अवरोध;
	शेष:
		adev->gds.gds_size = 0x10000;
		अवरोध;
	पूर्ण

	चयन (adev->asic_type) अणु
	हाल CHIP_VEGA10:
	हाल CHIP_VEGA20:
		adev->gds.gds_compute_max_wave_id = 0x7ff;
		अवरोध;
	हाल CHIP_VEGA12:
		adev->gds.gds_compute_max_wave_id = 0x27f;
		अवरोध;
	हाल CHIP_RAVEN:
		अगर (adev->apu_flags & AMD_APU_IS_RAVEN2)
			adev->gds.gds_compute_max_wave_id = 0x77; /* raven2 */
		अन्यथा
			adev->gds.gds_compute_max_wave_id = 0x15f; /* raven1 */
		अवरोध;
	हाल CHIP_ARCTURUS:
		adev->gds.gds_compute_max_wave_id = 0xfff;
		अवरोध;
	हाल CHIP_ALDEBARAN:
		/* deprecated क्रम Aldebaran, no usage at all */
		adev->gds.gds_compute_max_wave_id = 0;
		अवरोध;
	शेष:
		/* this really depends on the chip */
		adev->gds.gds_compute_max_wave_id = 0x7ff;
		अवरोध;
	पूर्ण

	adev->gds.gws_size = 64;
	adev->gds.oa_size = 16;
पूर्ण

अटल व्योम gfx_v9_0_set_user_cu_inactive_biपंचांगap(काष्ठा amdgpu_device *adev,
						 u32 biपंचांगap)
अणु
	u32 data;

	अगर (!biपंचांगap)
		वापस;

	data = biपंचांगap << GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;
	data &= GC_USER_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;

	WREG32_SOC15(GC, 0, mmGC_USER_SHADER_ARRAY_CONFIG, data);
पूर्ण

अटल u32 gfx_v9_0_get_cu_active_biपंचांगap(काष्ठा amdgpu_device *adev)
अणु
	u32 data, mask;

	data = RREG32_SOC15(GC, 0, mmCC_GC_SHADER_ARRAY_CONFIG);
	data |= RREG32_SOC15(GC, 0, mmGC_USER_SHADER_ARRAY_CONFIG);

	data &= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS_MASK;
	data >>= CC_GC_SHADER_ARRAY_CONFIG__INACTIVE_CUS__SHIFT;

	mask = amdgpu_gfx_create_biपंचांगask(adev->gfx.config.max_cu_per_sh);

	वापस (~data) & mask;
पूर्ण

अटल पूर्णांक gfx_v9_0_get_cu_info(काष्ठा amdgpu_device *adev,
				 काष्ठा amdgpu_cu_info *cu_info)
अणु
	पूर्णांक i, j, k, counter, active_cu_number = 0;
	u32 mask, biपंचांगap, ao_biपंचांगap, ao_cu_mask = 0;
	अचिन्हित disable_masks[4 * 4];

	अगर (!adev || !cu_info)
		वापस -EINVAL;

	/*
	 * 16 comes from biपंचांगap array size 4*4, and it can cover all gfx9 ASICs
	 */
	अगर (adev->gfx.config.max_shader_engines *
		adev->gfx.config.max_sh_per_se > 16)
		वापस -EINVAL;

	amdgpu_gfx_parse_disable_cu(disable_masks,
				    adev->gfx.config.max_shader_engines,
				    adev->gfx.config.max_sh_per_se);

	mutex_lock(&adev->grbm_idx_mutex);
	क्रम (i = 0; i < adev->gfx.config.max_shader_engines; i++) अणु
		क्रम (j = 0; j < adev->gfx.config.max_sh_per_se; j++) अणु
			mask = 1;
			ao_biपंचांगap = 0;
			counter = 0;
			gfx_v9_0_select_se_sh(adev, i, j, 0xffffffff);
			gfx_v9_0_set_user_cu_inactive_biपंचांगap(
				adev, disable_masks[i * adev->gfx.config.max_sh_per_se + j]);
			biपंचांगap = gfx_v9_0_get_cu_active_biपंचांगap(adev);

			/*
			 * The biपंचांगap(and ao_cu_biपंचांगap) in cu_info काष्ठाure is
			 * 4x4 size array, and it's usually suitable क्रम Vega
			 * ASICs which has 4*2 SE/SH layout.
			 * But क्रम Arcturus, SE/SH layout is changed to 8*1.
			 * To mostly reduce the impact, we make it compatible
			 * with current biपंचांगap array as below:
			 *    SE4,SH0 --> biपंचांगap[0][1]
			 *    SE5,SH0 --> biपंचांगap[1][1]
			 *    SE6,SH0 --> biपंचांगap[2][1]
			 *    SE7,SH0 --> biपंचांगap[3][1]
			 */
			cu_info->biपंचांगap[i % 4][j + i / 4] = biपंचांगap;

			क्रम (k = 0; k < adev->gfx.config.max_cu_per_sh; k ++) अणु
				अगर (biपंचांगap & mask) अणु
					अगर (counter < adev->gfx.config.max_cu_per_sh)
						ao_biपंचांगap |= mask;
					counter ++;
				पूर्ण
				mask <<= 1;
			पूर्ण
			active_cu_number += counter;
			अगर (i < 2 && j < 2)
				ao_cu_mask |= (ao_biपंचांगap << (i * 16 + j * 8));
			cu_info->ao_cu_biपंचांगap[i % 4][j + i / 4] = ao_biपंचांगap;
		पूर्ण
	पूर्ण
	gfx_v9_0_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
	mutex_unlock(&adev->grbm_idx_mutex);

	cu_info->number = active_cu_number;
	cu_info->ao_cu_mask = ao_cu_mask;
	cu_info->simd_per_cu = NUM_SIMD_PER_CU;

	वापस 0;
पूर्ण

स्थिर काष्ठा amdgpu_ip_block_version gfx_v9_0_ip_block =
अणु
	.type = AMD_IP_BLOCK_TYPE_GFX,
	.major = 9,
	.minor = 0,
	.rev = 0,
	.funcs = &gfx_v9_0_ip_funcs,
पूर्ण;
