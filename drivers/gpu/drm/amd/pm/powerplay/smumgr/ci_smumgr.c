<शैली गुरु>
/*
 * Copyright 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modअगरy, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to करो so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */
#समावेश <linux/module.h>
#समावेश <linux/slab.h>
#समावेश <linux/fb.h>
#समावेश "linux/delay.h"
#समावेश <linux/types.h>
#समावेश <linux/pci.h>

#समावेश "smumgr.h"
#समावेश "pp_debug.h"
#समावेश "ci_smumgr.h"
#समावेश "ppsmc.h"
#समावेश "smu7_hwmgr.h"
#समावेश "hardwaremanager.h"
#समावेश "ppatomctrl.h"
#समावेश "cgs_common.h"
#समावेश "atombios.h"
#समावेश "pppcielanes.h"
#समावेश "smu7_smumgr.h"

#समावेश "smu/smu_7_0_1_d.h"
#समावेश "smu/smu_7_0_1_sh_mask.h"

#समावेश "dce/dce_8_0_d.h"
#समावेश "dce/dce_8_0_sh_mask.h"

#समावेश "bif/bif_4_1_d.h"
#समावेश "bif/bif_4_1_sh_mask.h"

#समावेश "gca/gfx_7_2_d.h"
#समावेश "gca/gfx_7_2_sh_mask.h"

#समावेश "gmc/gmc_7_1_d.h"
#समावेश "gmc/gmc_7_1_sh_mask.h"

#समावेश "processpptables.h"

#घोषणा MC_CG_ARB_FREQ_F0           0x0a
#घोषणा MC_CG_ARB_FREQ_F1           0x0b
#घोषणा MC_CG_ARB_FREQ_F2           0x0c
#घोषणा MC_CG_ARB_FREQ_F3           0x0d

#घोषणा SMC_RAM_END 0x40000

#घोषणा CISLAND_MINIMUM_ENGINE_CLOCK 800
#घोषणा CISLAND_MAX_DEEPSLEEP_DIVIDER_ID 5

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_hawaii_xt = अणु
	1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0xB0000,
	अणु 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  पूर्ण,
	अणु 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_hawaii_pro = अणु
	1, 0xF, 0xFD, 0x19, 5, 0x14, 0, 0x65062,
	अणु 0x2E,  0x00,  0x00,  0x88,  0x00,  0x00,  0x72,  0x60,  0x51,  0xA7,  0x79,  0x6B,  0x90,  0xBD,  0x79  पूर्ण,
	अणु 0x217, 0x217, 0x217, 0x242, 0x242, 0x242, 0x269, 0x269, 0x269, 0x2A1, 0x2A1, 0x2A1, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;

अटल स्थिर काष्ठा ci_pt_शेषs शेषs_bonaire_xt = अणु
	1, 0xF, 0xFD, 0x19, 5, 45, 0, 0xB0000,
	अणु 0x79,  0x253, 0x25D, 0xAE,  0x72,  0x80,  0x83,  0x86,  0x6F,  0xC8,  0xC9,  0xC9,  0x2F,  0x4D,  0x61  पूर्ण,
	अणु 0x17C, 0x172, 0x180, 0x1BC, 0x1B3, 0x1BD, 0x206, 0x200, 0x203, 0x25D, 0x25A, 0x255, 0x2C3, 0x2C5, 0x2B4 पूर्ण
पूर्ण;


अटल स्थिर काष्ठा ci_pt_शेषs शेषs_saturn_xt = अणु
	1, 0xF, 0xFD, 0x19, 5, 55, 0, 0x70000,
	अणु 0x8C,  0x247, 0x249, 0xA6,  0x80,  0x81,  0x8B,  0x89,  0x86,  0xC9,  0xCA,  0xC9,  0x4D,  0x4D,  0x4D  पूर्ण,
	अणु 0x187, 0x187, 0x187, 0x1C7, 0x1C7, 0x1C7, 0x210, 0x210, 0x210, 0x266, 0x266, 0x266, 0x2C9, 0x2C9, 0x2C9 पूर्ण
पूर्ण;


अटल पूर्णांक ci_set_smc_sram_address(काष्ठा pp_hwmgr *hwmgr,
					uपूर्णांक32_t smc_addr, uपूर्णांक32_t limit)
अणु
	अगर ((0 != (3 & smc_addr))
		|| ((smc_addr + 3) >= limit)) अणु
		pr_err("smc_addr invalid \n");
		वापस -EINVAL;
	पूर्ण

	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_IND_INDEX_0, smc_addr);
	PHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);
	वापस 0;
पूर्ण

अटल पूर्णांक ci_copy_bytes_to_smc(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t smc_start_address,
				स्थिर uपूर्णांक8_t *src, uपूर्णांक32_t byte_count, uपूर्णांक32_t limit)
अणु
	पूर्णांक result;
	uपूर्णांक32_t data = 0;
	uपूर्णांक32_t original_data;
	uपूर्णांक32_t addr = 0;
	uपूर्णांक32_t extra_shअगरt;

	अगर ((3 & smc_start_address)
		|| ((smc_start_address + byte_count) >= limit)) अणु
		pr_err("smc_start_address invalid \n");
		वापस -EINVAL;
	पूर्ण

	addr = smc_start_address;

	जबतक (byte_count >= 4) अणु
	/* Bytes are written पूर्णांकo the SMC address space with the MSB first. */
		data = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];

		result = ci_set_smc_sram_address(hwmgr, addr, limit);

		अगर (0 != result)
			वापस result;

		cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_IND_DATA_0, data);

		src += 4;
		byte_count -= 4;
		addr += 4;
	पूर्ण

	अगर (0 != byte_count) अणु

		data = 0;

		result = ci_set_smc_sram_address(hwmgr, addr, limit);

		अगर (0 != result)
			वापस result;


		original_data = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmSMC_IND_DATA_0);

		extra_shअगरt = 8 * (4 - byte_count);

		जबतक (byte_count > 0) अणु
			/* Bytes are written पूर्णांकo the SMC addres space with the MSB first. */
			data = (0x100 * data) + *src++;
			byte_count--;
		पूर्ण

		data <<= extra_shअगरt;

		data |= (original_data & ~((~0UL) << extra_shअगरt));

		result = ci_set_smc_sram_address(hwmgr, addr, limit);

		अगर (0 != result)
			वापस result;

		cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_IND_DATA_0, data);
	पूर्ण

	वापस 0;
पूर्ण


अटल पूर्णांक ci_program_jump_on_start(काष्ठा pp_hwmgr *hwmgr)
अणु
	अटल स्थिर अचिन्हित अक्षर data[4] = अणु 0xE0, 0x00, 0x80, 0x40 पूर्ण;

	ci_copy_bytes_to_smc(hwmgr, 0x0, data, 4, माप(data)+1);

	वापस 0;
पूर्ण

अटल bool ci_is_smc_ram_running(काष्ठा pp_hwmgr *hwmgr)
अणु
	वापस ((0 == PHM_READ_VFPF_INसूचीECT_FIELD(hwmgr->device,
			CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable))
	&& (0x20100 <= cgs_पढ़ो_ind_रेजिस्टर(hwmgr->device,
			CGS_IND_REG__SMC, ixSMC_PC_C)));
पूर्ण

अटल पूर्णांक ci_पढ़ो_smc_sram_dword(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t smc_addr,
				uपूर्णांक32_t *value, uपूर्णांक32_t limit)
अणु
	पूर्णांक result;

	result = ci_set_smc_sram_address(hwmgr, smc_addr, limit);

	अगर (result)
		वापस result;

	*value = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmSMC_IND_DATA_0);
	वापस 0;
पूर्ण

अटल पूर्णांक ci_send_msg_to_smc(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक16_t msg)
अणु
	पूर्णांक ret;

	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_RESP_0, 0);
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_MESSAGE_0, msg);

	PHM_WAIT_FIELD_UNEQUAL(hwmgr, SMC_RESP_0, SMC_RESP, 0);

	ret = PHM_READ_FIELD(hwmgr->device, SMC_RESP_0, SMC_RESP);

	अगर (ret != 1)
		pr_info("\n failed to send message %x ret is %d\n",  msg, ret);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_send_msg_to_smc_with_parameter(काष्ठा pp_hwmgr *hwmgr,
					uपूर्णांक16_t msg, uपूर्णांक32_t parameter)
अणु
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_MSG_ARG_0, parameter);
	वापस ci_send_msg_to_smc(hwmgr, msg);
पूर्ण

अटल व्योम ci_initialize_घातer_tune_शेषs(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	काष्ठा amdgpu_device *adev = hwmgr->adev;
	uपूर्णांक32_t dev_id;

	dev_id = adev->pdev->device;

	चयन (dev_id) अणु
	हाल 0x67BA:
	हाल 0x67B1:
		smu_data->घातer_tune_शेषs = &शेषs_hawaii_pro;
		अवरोध;
	हाल 0x67B8:
	हाल 0x66B0:
		smu_data->घातer_tune_शेषs = &शेषs_hawaii_xt;
		अवरोध;
	हाल 0x6640:
	हाल 0x6641:
	हाल 0x6646:
	हाल 0x6647:
		smu_data->घातer_tune_शेषs = &शेषs_saturn_xt;
		अवरोध;
	हाल 0x6649:
	हाल 0x6650:
	हाल 0x6651:
	हाल 0x6658:
	हाल 0x665C:
	हाल 0x665D:
	हाल 0x67A0:
	हाल 0x67A1:
	हाल 0x67A2:
	हाल 0x67A8:
	हाल 0x67A9:
	हाल 0x67AA:
	हाल 0x67B9:
	हाल 0x67BE:
	शेष:
		smu_data->घातer_tune_शेषs = &शेषs_bonaire_xt;
		अवरोध;
	पूर्ण
पूर्ण

अटल पूर्णांक ci_get_dependency_volt_by_clk(काष्ठा pp_hwmgr *hwmgr,
	काष्ठा phm_घड़ी_voltage_dependency_table *allowed_घड़ी_voltage_table,
	uपूर्णांक32_t घड़ी, uपूर्णांक32_t *vol)
अणु
	uपूर्णांक32_t i = 0;

	अगर (allowed_घड़ी_voltage_table->count == 0)
		वापस -EINVAL;

	क्रम (i = 0; i < allowed_घड़ी_voltage_table->count; i++) अणु
		अगर (allowed_घड़ी_voltage_table->entries[i].clk >= घड़ी) अणु
			*vol = allowed_घड़ी_voltage_table->entries[i].v;
			वापस 0;
		पूर्ण
	पूर्ण

	*vol = allowed_घड़ी_voltage_table->entries[i - 1].v;
	वापस 0;
पूर्ण

अटल पूर्णांक ci_calculate_sclk_params(काष्ठा pp_hwmgr *hwmgr,
		uपूर्णांक32_t घड़ी, काष्ठा SMU7_Discrete_GraphicsLevel *sclk)
अणु
	स्थिर काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा pp_atomctrl_घड़ी_भागiders_vi भागiders;
	uपूर्णांक32_t spll_func_cntl            = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL;
	uपूर्णांक32_t spll_func_cntl_3          = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL_3;
	uपूर्णांक32_t spll_func_cntl_4          = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL_4;
	uपूर्णांक32_t cg_spll_spपढ़ो_spectrum   = data->घड़ी_रेजिस्टरs.vCG_SPLL_SPREAD_SPECTRUM;
	uपूर्णांक32_t cg_spll_spपढ़ो_spectrum_2 = data->घड़ी_रेजिस्टरs.vCG_SPLL_SPREAD_SPECTRUM_2;
	uपूर्णांक32_t ref_घड़ी;
	uपूर्णांक32_t ref_भागider;
	uपूर्णांक32_t fbभाग;
	पूर्णांक result;

	/* get the engine घड़ी भागiders क्रम this घड़ी value */
	result = atomctrl_get_engine_pll_भागiders_vi(hwmgr, घड़ी,  &भागiders);

	PP_ASSERT_WITH_CODE(result == 0,
			"Error retrieving Engine Clock dividers from VBIOS.",
			वापस result);

	/* To get FBDIV we need to multiply this by 16384 and भागide it by Fref. */
	ref_घड़ी = atomctrl_get_reference_घड़ी(hwmgr);
	ref_भागider = 1 + भागiders.uc_pll_ref_भाग;

	/* low 14 bits is fraction and high 12 bits is भागider */
	fbभाग = भागiders.ul_fb_भाग.ul_fb_भागider & 0x3FFFFFF;

	/* SPLL_FUNC_CNTL setup */
	spll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,
			SPLL_REF_DIV, भागiders.uc_pll_ref_भाग);
	spll_func_cntl = PHM_SET_FIELD(spll_func_cntl, CG_SPLL_FUNC_CNTL,
			SPLL_PDIV_A,  भागiders.uc_pll_post_भाग);

	/* SPLL_FUNC_CNTL_3 setup*/
	spll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3, CG_SPLL_FUNC_CNTL_3,
			SPLL_FB_DIV, fbभाग);

	/* set to use fractional accumulation*/
	spll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3, CG_SPLL_FUNC_CNTL_3,
			SPLL_DITHEN, 1);

	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
				PHM_Platक्रमmCaps_EngineSpपढ़ोSpectrumSupport)) अणु
		काष्ठा pp_atomctrl_पूर्णांकernal_ss_info ss_info;
		uपूर्णांक32_t vco_freq = घड़ी * भागiders.uc_pll_post_भाग;

		अगर (!atomctrl_get_engine_घड़ी_spपढ़ो_spectrum(hwmgr,
				vco_freq, &ss_info)) अणु
			uपूर्णांक32_t clk_s = ref_घड़ी * 5 /
					(ref_भागider * ss_info.speed_spectrum_rate);
			uपूर्णांक32_t clk_v = 4 * ss_info.speed_spectrum_percentage *
					fbभाग / (clk_s * 10000);

			cg_spll_spपढ़ो_spectrum = PHM_SET_FIELD(cg_spll_spपढ़ो_spectrum,
					CG_SPLL_SPREAD_SPECTRUM, CLKS, clk_s);
			cg_spll_spपढ़ो_spectrum = PHM_SET_FIELD(cg_spll_spपढ़ो_spectrum,
					CG_SPLL_SPREAD_SPECTRUM, SSEN, 1);
			cg_spll_spपढ़ो_spectrum_2 = PHM_SET_FIELD(cg_spll_spपढ़ो_spectrum_2,
					CG_SPLL_SPREAD_SPECTRUM_2, CLKV, clk_v);
		पूर्ण
	पूर्ण

	sclk->SclkFrequency        = घड़ी;
	sclk->CgSpllFuncCntl3      = spll_func_cntl_3;
	sclk->CgSpllFuncCntl4      = spll_func_cntl_4;
	sclk->SpllSpपढ़ोSpectrum   = cg_spll_spपढ़ो_spectrum;
	sclk->SpllSpपढ़ोSpectrum2  = cg_spll_spपढ़ो_spectrum_2;
	sclk->SclkDid              = (uपूर्णांक8_t)भागiders.pll_post_भागider;

	वापस 0;
पूर्ण

अटल व्योम ci_populate_phase_value_based_on_sclk(काष्ठा pp_hwmgr *hwmgr,
				स्थिर काष्ठा phm_phase_shedding_limits_table *pl,
					uपूर्णांक32_t sclk, uपूर्णांक32_t *p_shed)
अणु
	अचिन्हित पूर्णांक i;

	/* use the minimum phase shedding */
	*p_shed = 1;

	क्रम (i = 0; i < pl->count; i++) अणु
		अगर (sclk < pl->entries[i].Sclk) अणु
			*p_shed = i;
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

अटल uपूर्णांक8_t ci_get_sleep_भागider_id_from_घड़ी(uपूर्णांक32_t घड़ी,
			uपूर्णांक32_t घड़ी_insr)
अणु
	uपूर्णांक8_t i;
	uपूर्णांक32_t temp;
	uपूर्णांक32_t min = min_t(uपूर्णांक32_t, घड़ी_insr, CISLAND_MINIMUM_ENGINE_CLOCK);

	अगर (घड़ी < min) अणु
		pr_info("Engine clock can't satisfy stutter requirement!\n");
		वापस 0;
	पूर्ण
	क्रम (i = CISLAND_MAX_DEEPSLEEP_DIVIDER_ID;  ; i--) अणु
		temp = घड़ी >> i;

		अगर (temp >= min || i == 0)
			अवरोध;
	पूर्ण
	वापस i;
पूर्ण

अटल पूर्णांक ci_populate_single_graphic_level(काष्ठा pp_hwmgr *hwmgr,
		uपूर्णांक32_t घड़ी, काष्ठा SMU7_Discrete_GraphicsLevel *level)
अणु
	पूर्णांक result;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);


	result = ci_calculate_sclk_params(hwmgr, घड़ी, level);

	/* populate graphics levels */
	result = ci_get_dependency_volt_by_clk(hwmgr,
			hwmgr->dyn_state.vddc_dependency_on_sclk, घड़ी,
			(uपूर्णांक32_t *)(&level->MinVddc));
	अगर (result) अणु
		pr_err("vdd_dep_on_sclk table is NULL\n");
		वापस result;
	पूर्ण

	level->SclkFrequency = घड़ी;
	level->MinVddcPhases = 1;

	अगर (data->vddc_phase_shed_control)
		ci_populate_phase_value_based_on_sclk(hwmgr,
				hwmgr->dyn_state.vddc_phase_shed_limits_table,
				घड़ी,
				&level->MinVddcPhases);

	level->ActivityLevel = data->current_profile_setting.sclk_activity;
	level->CcPwrDynRm = 0;
	level->CcPwrDynRm1 = 0;
	level->EnabledForActivity = 0;
	/* this level can be used क्रम throttling.*/
	level->EnabledForThrottle = 1;
	level->UpH = data->current_profile_setting.sclk_up_hyst;
	level->DownH = data->current_profile_setting.sclk_करोwn_hyst;
	level->VoltageDownH = 0;
	level->PowerThrottle = 0;


	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_SclkDeepSleep))
		level->DeepSleepDivId =
				ci_get_sleep_भागider_id_from_घड़ी(घड़ी,
						CISLAND_MINIMUM_ENGINE_CLOCK);

	/* Default to slow, highest DPM level will be set to PPSMC_DISPLAY_WATERMARK_LOW later.*/
	level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;

	अगर (0 == result) अणु
		level->MinVddc = PP_HOST_TO_SMC_UL(level->MinVddc * VOLTAGE_SCALE);
		CONVERT_FROM_HOST_TO_SMC_UL(level->MinVddcPhases);
		CONVERT_FROM_HOST_TO_SMC_UL(level->SclkFrequency);
		CONVERT_FROM_HOST_TO_SMC_US(level->ActivityLevel);
		CONVERT_FROM_HOST_TO_SMC_UL(level->CgSpllFuncCntl3);
		CONVERT_FROM_HOST_TO_SMC_UL(level->CgSpllFuncCntl4);
		CONVERT_FROM_HOST_TO_SMC_UL(level->SpllSpपढ़ोSpectrum);
		CONVERT_FROM_HOST_TO_SMC_UL(level->SpllSpपढ़ोSpectrum2);
		CONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm);
		CONVERT_FROM_HOST_TO_SMC_UL(level->CcPwrDynRm1);
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_all_graphic_levels(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	काष्ठा smu7_dpm_table *dpm_table = &data->dpm_table;
	पूर्णांक result = 0;
	uपूर्णांक32_t array = smu_data->dpm_table_start +
			दुरत्व(SMU7_Discrete_DpmTable, GraphicsLevel);
	uपूर्णांक32_t array_size = माप(काष्ठा SMU7_Discrete_GraphicsLevel) *
			SMU7_MAX_LEVELS_GRAPHICS;
	काष्ठा SMU7_Discrete_GraphicsLevel *levels =
			smu_data->smc_state_table.GraphicsLevel;
	uपूर्णांक32_t i;

	क्रम (i = 0; i < dpm_table->sclk_table.count; i++) अणु
		result = ci_populate_single_graphic_level(hwmgr,
				dpm_table->sclk_table.dpm_levels[i].value,
				&levels[i]);
		अगर (result)
			वापस result;
		अगर (i > 1)
			smu_data->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;
		अगर (i == (dpm_table->sclk_table.count - 1))
			smu_data->smc_state_table.GraphicsLevel[i].DisplayWatermark =
				PPSMC_DISPLAY_WATERMARK_HIGH;
	पूर्ण

	smu_data->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;

	smu_data->smc_state_table.GraphicsDpmLevelCount = (u8)dpm_table->sclk_table.count;
	data->dpm_level_enable_mask.sclk_dpm_enable_mask =
		phm_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);

	result = ci_copy_bytes_to_smc(hwmgr, array,
				   (u8 *)levels, array_size,
				   SMC_RAM_END);

	वापस result;

पूर्ण

अटल पूर्णांक ci_populate_svi_load_line(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	स्थिर काष्ठा ci_pt_शेषs *शेषs = smu_data->घातer_tune_शेषs;

	smu_data->घातer_tune_table.SviLoadLineEn = शेषs->svi_load_line_en;
	smu_data->घातer_tune_table.SviLoadLineVddC = शेषs->svi_load_line_vddc;
	smu_data->घातer_tune_table.SviLoadLineTrimVddC = 3;
	smu_data->घातer_tune_table.SviLoadLineOffsetVddC = 0;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_tdc_limit(काष्ठा pp_hwmgr *hwmgr)
अणु
	uपूर्णांक16_t tdc_limit;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	स्थिर काष्ठा ci_pt_शेषs *शेषs = smu_data->घातer_tune_शेषs;

	tdc_limit = (uपूर्णांक16_t)(hwmgr->dyn_state.cac_dtp_table->usTDC * 256);
	smu_data->घातer_tune_table.TDC_VDDC_PkgLimit =
			CONVERT_FROM_HOST_TO_SMC_US(tdc_limit);
	smu_data->घातer_tune_table.TDC_VDDC_ThrottleReleaseLimitPerc =
			शेषs->tdc_vddc_throttle_release_limit_perc;
	smu_data->घातer_tune_table.TDC_MAWt = शेषs->tdc_mawt;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_dw8(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t fuse_table_offset)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	स्थिर काष्ठा ci_pt_शेषs *शेषs = smu_data->घातer_tune_शेषs;
	uपूर्णांक32_t temp;

	अगर (ci_पढ़ो_smc_sram_dword(hwmgr,
			fuse_table_offset +
			दुरत्व(SMU7_Discrete_PmFuses, TdcWaterfallCtl),
			(uपूर्णांक32_t *)&temp, SMC_RAM_END))
		PP_ASSERT_WITH_CODE(false,
				"Attempt to read PmFuses.DW6 (SviLoadLineEn) from SMC Failed!",
				वापस -EINVAL);
	अन्यथा
		smu_data->घातer_tune_table.TdcWaterfallCtl = शेषs->tdc_waterfall_ctl;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_fuzzy_fan(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t fuse_table_offset)
अणु
	uपूर्णांक16_t पंचांगp;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);

	अगर ((hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity & (1 << 15))
		|| 0 == hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity)
		पंचांगp = hwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity;
	अन्यथा
		पंचांगp = hwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity;

	smu_data->घातer_tune_table.FuzzyFan_PwmSetDelta = CONVERT_FROM_HOST_TO_SMC_US(पंचांगp);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_bapm_vddc_vid_sidd(काष्ठा pp_hwmgr *hwmgr)
अणु
	पूर्णांक i;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक8_t *hi_vid = smu_data->घातer_tune_table.BapmVddCVidHiSidd;
	uपूर्णांक8_t *lo_vid = smu_data->घातer_tune_table.BapmVddCVidLoSidd;
	uपूर्णांक8_t *hi2_vid = smu_data->घातer_tune_table.BapmVddCVidHiSidd2;

	PP_ASSERT_WITH_CODE(शून्य != hwmgr->dyn_state.cac_leakage_table,
			    "The CAC Leakage table does not exist!", वापस -EINVAL);
	PP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count <= 8,
			    "There should never be more than 8 entries for BapmVddcVid!!!", वापस -EINVAL);
	PP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count == hwmgr->dyn_state.vddc_dependency_on_sclk->count,
			    "CACLeakageTable->count and VddcDependencyOnSCLk->count not equal", वापस -EINVAL);

	क्रम (i = 0; (uपूर्णांक32_t) i < hwmgr->dyn_state.cac_leakage_table->count; i++) अणु
		अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps, PHM_Platक्रमmCaps_EVV)) अणु
			lo_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc1);
			hi_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc2);
			hi2_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc3);
		पूर्ण अन्यथा अणु
			lo_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc);
			hi_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Leakage);
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_vddc_vid(काष्ठा pp_hwmgr *hwmgr)
अणु
	पूर्णांक i;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक8_t *vid = smu_data->घातer_tune_table.VddCVid;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	PP_ASSERT_WITH_CODE(data->vddc_voltage_table.count <= 8,
		"There should never be more than 8 entries for VddcVid!!!",
		वापस -EINVAL);

	क्रम (i = 0; i < (पूर्णांक)data->vddc_voltage_table.count; i++)
		vid[i] = convert_to_vid(data->vddc_voltage_table.entries[i].value);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	u8 *hi_vid = smu_data->घातer_tune_table.BapmVddCVidHiSidd;
	u8 *lo_vid = smu_data->घातer_tune_table.BapmVddCVidLoSidd;
	पूर्णांक i, min, max;

	min = max = hi_vid[0];
	क्रम (i = 0; i < 8; i++) अणु
		अगर (0 != hi_vid[i]) अणु
			अगर (min > hi_vid[i])
				min = hi_vid[i];
			अगर (max < hi_vid[i])
				max = hi_vid[i];
		पूर्ण

		अगर (0 != lo_vid[i]) अणु
			अगर (min > lo_vid[i])
				min = lo_vid[i];
			अगर (max < lo_vid[i])
				max = lo_vid[i];
		पूर्ण
	पूर्ण

	अगर ((min == 0) || (max == 0))
		वापस -EINVAL;
	smu_data->घातer_tune_table.GnbLPMLMaxVid = (u8)max;
	smu_data->घातer_tune_table.GnbLPMLMinVid = (u8)min;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_bapm_vddc_base_leakage_sidd(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक16_t HiSidd;
	uपूर्णांक16_t LoSidd;
	काष्ठा phm_cac_tdp_table *cac_table = hwmgr->dyn_state.cac_dtp_table;

	HiSidd = (uपूर्णांक16_t)(cac_table->usHighCACLeakage / 100 * 256);
	LoSidd = (uपूर्णांक16_t)(cac_table->usLowCACLeakage / 100 * 256);

	smu_data->घातer_tune_table.BapmVddCBaseLeakageHiSidd =
			CONVERT_FROM_HOST_TO_SMC_US(HiSidd);
	smu_data->घातer_tune_table.BapmVddCBaseLeakageLoSidd =
			CONVERT_FROM_HOST_TO_SMC_US(LoSidd);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_pm_fuses(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक32_t pm_fuse_table_offset;
	पूर्णांक ret = 0;

	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_PowerContainment)) अणु
		अगर (ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, PmFuseTable),
				&pm_fuse_table_offset, SMC_RAM_END)) अणु
			pr_err("Attempt to get pm_fuse_table_offset Failed!\n");
			वापस -EINVAL;
		पूर्ण

		/* DW0 - DW3 */
		ret = ci_populate_bapm_vddc_vid_sidd(hwmgr);
		/* DW4 - DW5 */
		ret |= ci_populate_vddc_vid(hwmgr);
		/* DW6 */
		ret |= ci_populate_svi_load_line(hwmgr);
		/* DW7 */
		ret |= ci_populate_tdc_limit(hwmgr);
		/* DW8 */
		ret |= ci_populate_dw8(hwmgr, pm_fuse_table_offset);

		ret |= ci_populate_fuzzy_fan(hwmgr, pm_fuse_table_offset);

		ret |= ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(hwmgr);

		ret |= ci_populate_bapm_vddc_base_leakage_sidd(hwmgr);
		अगर (ret)
			वापस ret;

		ret = ci_copy_bytes_to_smc(hwmgr, pm_fuse_table_offset,
				(uपूर्णांक8_t *)&smu_data->घातer_tune_table,
				माप(काष्ठा SMU7_Discrete_PmFuses), SMC_RAM_END);
	पूर्ण
	वापस ret;
पूर्ण

अटल पूर्णांक ci_populate_bapm_parameters_in_dpm_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	स्थिर काष्ठा ci_pt_शेषs *शेषs = smu_data->घातer_tune_शेषs;
	SMU7_Discrete_DpmTable  *dpm_table = &(smu_data->smc_state_table);
	काष्ठा phm_cac_tdp_table *cac_dtp_table = hwmgr->dyn_state.cac_dtp_table;
	काष्ठा phm_ppm_table *ppm = hwmgr->dyn_state.ppm_parameter_table;
	स्थिर uपूर्णांक16_t *def1, *def2;
	पूर्णांक i, j, k;

	dpm_table->DefaultTdp = PP_HOST_TO_SMC_US((uपूर्णांक16_t)(cac_dtp_table->usTDP * 256));
	dpm_table->TargetTdp = PP_HOST_TO_SMC_US((uपूर्णांक16_t)(cac_dtp_table->usConfigurableTDP * 256));

	dpm_table->DTETjOffset = 0;
	dpm_table->GpuTjMax = (uपूर्णांक8_t)(data->thermal_temp_setting.temperature_high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES);
	dpm_table->GpuTjHyst = 8;

	dpm_table->DTEAmbientTempBase = शेषs->dte_ambient_temp_base;

	अगर (ppm) अणु
		dpm_table->PPM_PkgPwrLimit = (uपूर्णांक16_t)ppm->dgpu_tdp * 256 / 1000;
		dpm_table->PPM_TemperatureLimit = (uपूर्णांक16_t)ppm->tj_max * 256;
	पूर्ण अन्यथा अणु
		dpm_table->PPM_PkgPwrLimit = 0;
		dpm_table->PPM_TemperatureLimit = 0;
	पूर्ण

	CONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_PkgPwrLimit);
	CONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_TemperatureLimit);

	dpm_table->BAPM_TEMP_GRADIENT = PP_HOST_TO_SMC_UL(शेषs->bapm_temp_gradient);
	def1 = शेषs->bapmti_r;
	def2 = शेषs->bapmti_rc;

	क्रम (i = 0; i < SMU7_DTE_ITERATIONS; i++) अणु
		क्रम (j = 0; j < SMU7_DTE_SOURCES; j++) अणु
			क्रम (k = 0; k < SMU7_DTE_SINKS; k++) अणु
				dpm_table->BAPMTI_R[i][j][k] = PP_HOST_TO_SMC_US(*def1);
				dpm_table->BAPMTI_RC[i][j][k] = PP_HOST_TO_SMC_US(*def2);
				def1++;
				def2++;
			पूर्ण
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_get_std_voltage_value_sidd(काष्ठा pp_hwmgr *hwmgr,
		pp_atomctrl_voltage_table_entry *tab, uपूर्णांक16_t *hi,
		uपूर्णांक16_t *lo)
अणु
	uपूर्णांक16_t v_index;
	bool vol_found = false;
	*hi = tab->value * VOLTAGE_SCALE;
	*lo = tab->value * VOLTAGE_SCALE;

	PP_ASSERT_WITH_CODE(शून्य != hwmgr->dyn_state.vddc_dependency_on_sclk,
			"The SCLK/VDDC Dependency Table does not exist.\n",
			वापस -EINVAL);

	अगर (शून्य == hwmgr->dyn_state.cac_leakage_table) अणु
		pr_warn("CAC Leakage Table does not exist, using vddc.\n");
		वापस 0;
	पूर्ण

	क्रम (v_index = 0; (uपूर्णांक32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) अणु
		अगर (tab->value == hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) अणु
			vol_found = true;
			अगर ((uपूर्णांक32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) अणु
				*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;
				*hi = (uपूर्णांक16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage * VOLTAGE_SCALE);
			पूर्ण अन्यथा अणु
				pr_warn("Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index, using maximum index from CAC table.\n");
				*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;
				*hi = (uपूर्णांक16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);
			पूर्ण
			अवरोध;
		पूर्ण
	पूर्ण

	अगर (!vol_found) अणु
		क्रम (v_index = 0; (uपूर्णांक32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) अणु
			अगर (tab->value <= hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) अणु
				vol_found = true;
				अगर ((uपूर्णांक32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) अणु
					*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;
					*hi = (uपूर्णांक16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage) * VOLTAGE_SCALE;
				पूर्ण अन्यथा अणु
					pr_warn("Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index in second look up, using maximum index from CAC table.");
					*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;
					*hi = (uपूर्णांक16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);
				पूर्ण
				अवरोध;
			पूर्ण
		पूर्ण

		अगर (!vol_found)
			pr_warn("Unable to get std_vddc from SCLK/VDDC Dependency Table, using vddc.\n");
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_voltage_table(काष्ठा pp_hwmgr *hwmgr,
		pp_atomctrl_voltage_table_entry *tab,
		SMU7_Discrete_VoltageLevel *smc_voltage_tab)
अणु
	पूर्णांक result;

	result = ci_get_std_voltage_value_sidd(hwmgr, tab,
			&smc_voltage_tab->StdVoltageHiSidd,
			&smc_voltage_tab->StdVoltageLoSidd);
	अगर (result) अणु
		smc_voltage_tab->StdVoltageHiSidd = tab->value * VOLTAGE_SCALE;
		smc_voltage_tab->StdVoltageLoSidd = tab->value * VOLTAGE_SCALE;
	पूर्ण

	smc_voltage_tab->Voltage = PP_HOST_TO_SMC_US(tab->value * VOLTAGE_SCALE);
	CONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageHiSidd);
	CONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageLoSidd);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_vddc_table(काष्ठा pp_hwmgr *hwmgr,
			SMU7_Discrete_DpmTable *table)
अणु
	अचिन्हित पूर्णांक count;
	पूर्णांक result;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	table->VddcLevelCount = data->vddc_voltage_table.count;
	क्रम (count = 0; count < table->VddcLevelCount; count++) अणु
		result = ci_populate_smc_voltage_table(hwmgr,
				&(data->vddc_voltage_table.entries[count]),
				&(table->VddcLevel[count]));
		PP_ASSERT_WITH_CODE(0 == result, "do not populate SMC VDDC voltage table", वापस -EINVAL);

		/* GPIO voltage control */
		अगर (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control) अणु
			table->VddcLevel[count].Smio = (uपूर्णांक8_t) count;
			table->Smio[count] |= data->vddc_voltage_table.entries[count].smio_low;
			table->SmioMaskVddcVid |= data->vddc_voltage_table.entries[count].smio_low;
		पूर्ण अन्यथा अणु
			table->VddcLevel[count].Smio = 0;
		पूर्ण
	पूर्ण

	CONVERT_FROM_HOST_TO_SMC_UL(table->VddcLevelCount);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_vdd_ci_table(काष्ठा pp_hwmgr *hwmgr,
			SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	uपूर्णांक32_t count;
	पूर्णांक result;

	table->VddciLevelCount = data->vddci_voltage_table.count;

	क्रम (count = 0; count < table->VddciLevelCount; count++) अणु
		result = ci_populate_smc_voltage_table(hwmgr,
				&(data->vddci_voltage_table.entries[count]),
				&(table->VddciLevel[count]));
		PP_ASSERT_WITH_CODE(result == 0, "do not populate SMC VDDCI voltage table", वापस -EINVAL);
		अगर (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) अणु
			table->VddciLevel[count].Smio = (uपूर्णांक8_t) count;
			table->Smio[count] |= data->vddci_voltage_table.entries[count].smio_low;
			table->SmioMaskVddciVid |= data->vddci_voltage_table.entries[count].smio_low;
		पूर्ण अन्यथा अणु
			table->VddciLevel[count].Smio = 0;
		पूर्ण
	पूर्ण

	CONVERT_FROM_HOST_TO_SMC_UL(table->VddciLevelCount);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_mvdd_table(काष्ठा pp_hwmgr *hwmgr,
			SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	uपूर्णांक32_t count;
	पूर्णांक result;

	table->MvddLevelCount = data->mvdd_voltage_table.count;

	क्रम (count = 0; count < table->MvddLevelCount; count++) अणु
		result = ci_populate_smc_voltage_table(hwmgr,
				&(data->mvdd_voltage_table.entries[count]),
				&table->MvddLevel[count]);
		PP_ASSERT_WITH_CODE(result == 0, "do not populate SMC mvdd voltage table", वापस -EINVAL);
		अगर (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) अणु
			table->MvddLevel[count].Smio = (uपूर्णांक8_t) count;
			table->Smio[count] |= data->mvdd_voltage_table.entries[count].smio_low;
			table->SmioMaskMvddVid |= data->mvdd_voltage_table.entries[count].smio_low;
		पूर्ण अन्यथा अणु
			table->MvddLevel[count].Smio = 0;
		पूर्ण
	पूर्ण

	CONVERT_FROM_HOST_TO_SMC_UL(table->MvddLevelCount);

	वापस 0;
पूर्ण


अटल पूर्णांक ci_populate_smc_voltage_tables(काष्ठा pp_hwmgr *hwmgr,
	SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result;

	result = ci_populate_smc_vddc_table(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
			"can not populate VDDC voltage table to SMC", वापस -EINVAL);

	result = ci_populate_smc_vdd_ci_table(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
			"can not populate VDDCI voltage table to SMC", वापस -EINVAL);

	result = ci_populate_smc_mvdd_table(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
			"can not populate MVDD voltage table to SMC", वापस -EINVAL);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_ulv_level(काष्ठा pp_hwmgr *hwmgr,
		काष्ठा SMU7_Discrete_Ulv *state)
अणु
	uपूर्णांक32_t voltage_response_समय, ulv_voltage;
	पूर्णांक result;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	state->CcPwrDynRm = 0;
	state->CcPwrDynRm1 = 0;

	result = pp_tables_get_response_बार(hwmgr, &voltage_response_समय, &ulv_voltage);
	PP_ASSERT_WITH_CODE((0 == result), "can not get ULV voltage value", वापस result;);

	अगर (ulv_voltage == 0) अणु
		data->ulv_supported = false;
		वापस 0;
	पूर्ण

	अगर (data->voltage_control != SMU7_VOLTAGE_CONTROL_BY_SVID2) अणु
		/* use minimum voltage अगर ulv voltage in pptable is bigger than minimum voltage */
		अगर (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)
			state->VddcOffset = 0;
		अन्यथा
			/* used in SMIO Mode. not implemented क्रम now. this is backup only क्रम CI. */
			state->VddcOffset = (uपूर्णांक16_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage);
	पूर्ण अन्यथा अणु
		/* use minimum voltage अगर ulv voltage in pptable is bigger than minimum voltage */
		अगर (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)
			state->VddcOffsetVid = 0;
		अन्यथा  /* used in SVI2 Mode */
			state->VddcOffsetVid = (uपूर्णांक8_t)(
					(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage)
						* VOLTAGE_VID_OFFSET_SCALE2
						/ VOLTAGE_VID_OFFSET_SCALE1);
	पूर्ण
	state->VddcPhase = 1;

	CONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm);
	CONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm1);
	CONVERT_FROM_HOST_TO_SMC_US(state->VddcOffset);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_ulv_state(काष्ठा pp_hwmgr *hwmgr,
		 SMU7_Discrete_Ulv *ulv_level)
अणु
	वापस ci_populate_ulv_level(hwmgr, ulv_level);
पूर्ण

अटल पूर्णांक ci_populate_smc_link_level(काष्ठा pp_hwmgr *hwmgr, SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा smu7_dpm_table *dpm_table = &data->dpm_table;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक32_t i;

/* Index dpm_table->pcie_speed_table.count is reserved क्रम PCIE boot level.*/
	क्रम (i = 0; i <= dpm_table->pcie_speed_table.count; i++) अणु
		table->LinkLevel[i].PcieGenSpeed  =
			(uपूर्णांक8_t)dpm_table->pcie_speed_table.dpm_levels[i].value;
		table->LinkLevel[i].PcieLaneCount =
			(uपूर्णांक8_t)encode_pcie_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);
		table->LinkLevel[i].EnabledForActivity = 1;
		table->LinkLevel[i].DownT = PP_HOST_TO_SMC_UL(5);
		table->LinkLevel[i].UpT = PP_HOST_TO_SMC_UL(30);
	पूर्ण

	smu_data->smc_state_table.LinkLevelCount =
		(uपूर्णांक8_t)dpm_table->pcie_speed_table.count;
	data->dpm_level_enable_mask.pcie_dpm_enable_mask =
		phm_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_calculate_mclk_params(
		काष्ठा pp_hwmgr *hwmgr,
		uपूर्णांक32_t memory_घड़ी,
		SMU7_Discrete_MemoryLevel *mclk,
		bool strobe_mode,
		bool dllStateOn
		)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	uपूर्णांक32_t  dll_cntl = data->घड़ी_रेजिस्टरs.vDLL_CNTL;
	uपूर्णांक32_t  mclk_pwrmgt_cntl = data->घड़ी_रेजिस्टरs.vMCLK_PWRMGT_CNTL;
	uपूर्णांक32_t  mpll_ad_func_cntl = data->घड़ी_रेजिस्टरs.vMPLL_AD_FUNC_CNTL;
	uपूर्णांक32_t  mpll_dq_func_cntl = data->घड़ी_रेजिस्टरs.vMPLL_DQ_FUNC_CNTL;
	uपूर्णांक32_t  mpll_func_cntl = data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL;
	uपूर्णांक32_t  mpll_func_cntl_1 = data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL_1;
	uपूर्णांक32_t  mpll_func_cntl_2 = data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL_2;
	uपूर्णांक32_t  mpll_ss1 = data->घड़ी_रेजिस्टरs.vMPLL_SS1;
	uपूर्णांक32_t  mpll_ss2 = data->घड़ी_रेजिस्टरs.vMPLL_SS2;

	pp_atomctrl_memory_घड़ी_param mpll_param;
	पूर्णांक result;

	result = atomctrl_get_memory_pll_भागiders_si(hwmgr,
				memory_घड़ी, &mpll_param, strobe_mode);
	PP_ASSERT_WITH_CODE(0 == result,
		"Error retrieving Memory Clock Parameters from VBIOS.", वापस result);

	mpll_func_cntl = PHM_SET_FIELD(mpll_func_cntl, MPLL_FUNC_CNTL, BWCTRL, mpll_param.bw_ctrl);

	mpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,
							MPLL_FUNC_CNTL_1, CLKF, mpll_param.mpll_fb_भागider.cl_kf);
	mpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,
							MPLL_FUNC_CNTL_1, CLKFRAC, mpll_param.mpll_fb_भागider.clk_frac);
	mpll_func_cntl_1  = PHM_SET_FIELD(mpll_func_cntl_1,
							MPLL_FUNC_CNTL_1, VCO_MODE, mpll_param.vco_mode);

	mpll_ad_func_cntl = PHM_SET_FIELD(mpll_ad_func_cntl,
							MPLL_AD_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_भागider);

	अगर (data->is_memory_gddr5) अणु
		mpll_dq_func_cntl  = PHM_SET_FIELD(mpll_dq_func_cntl,
								MPLL_DQ_FUNC_CNTL, YCLK_SEL, mpll_param.yclk_sel);
		mpll_dq_func_cntl  = PHM_SET_FIELD(mpll_dq_func_cntl,
								MPLL_DQ_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_भागider);
	पूर्ण

	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_MemorySpपढ़ोSpectrumSupport)) अणु
		pp_atomctrl_पूर्णांकernal_ss_info ss_info;
		uपूर्णांक32_t freq_nom;
		uपूर्णांक32_t पंचांगp;
		uपूर्णांक32_t reference_घड़ी = atomctrl_get_mpll_reference_घड़ी(hwmgr);

		/* क्रम GDDR5 क्रम all modes and DDR3 */
		अगर (1 == mpll_param.qdr)
			freq_nom = memory_घड़ी * 4 * (1 << mpll_param.mpll_post_भागider);
		अन्यथा
			freq_nom = memory_घड़ी * 2 * (1 << mpll_param.mpll_post_भागider);

		/* पंचांगp = (freq_nom / reference_घड़ी * reference_भागider) ^ 2  Note: S.I. reference_भागider = 1*/
		पंचांगp = (freq_nom / reference_घड़ी);
		पंचांगp = पंचांगp * पंचांगp;

		अगर (0 == atomctrl_get_memory_घड़ी_spपढ़ो_spectrum(hwmgr, freq_nom, &ss_info)) अणु
			uपूर्णांक32_t clks = reference_घड़ी * 5 / ss_info.speed_spectrum_rate;
			uपूर्णांक32_t clkv =
				(uपूर्णांक32_t)((((131 * ss_info.speed_spectrum_percentage *
							ss_info.speed_spectrum_rate) / 100) * पंचांगp) / freq_nom);

			mpll_ss1 = PHM_SET_FIELD(mpll_ss1, MPLL_SS1, CLKV, clkv);
			mpll_ss2 = PHM_SET_FIELD(mpll_ss2, MPLL_SS2, CLKS, clks);
		पूर्ण
	पूर्ण

	mclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, DLL_SPEED, mpll_param.dll_speed);
	mclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK0_PDNB, dllStateOn);
	mclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK1_PDNB, dllStateOn);


	mclk->MclkFrequency   = memory_घड़ी;
	mclk->MpllFuncCntl    = mpll_func_cntl;
	mclk->MpllFuncCntl_1  = mpll_func_cntl_1;
	mclk->MpllFuncCntl_2  = mpll_func_cntl_2;
	mclk->MpllAdFuncCntl  = mpll_ad_func_cntl;
	mclk->MpllDqFuncCntl  = mpll_dq_func_cntl;
	mclk->MclkPwrmgtCntl  = mclk_pwrmgt_cntl;
	mclk->DllCntl         = dll_cntl;
	mclk->MpllSs1         = mpll_ss1;
	mclk->MpllSs2         = mpll_ss2;

	वापस 0;
पूर्ण

अटल uपूर्णांक8_t ci_get_mclk_frequency_ratio(uपूर्णांक32_t memory_घड़ी,
		bool strobe_mode)
अणु
	uपूर्णांक8_t mc_para_index;

	अगर (strobe_mode) अणु
		अगर (memory_घड़ी < 12500)
			mc_para_index = 0x00;
		अन्यथा अगर (memory_घड़ी > 47500)
			mc_para_index = 0x0f;
		अन्यथा
			mc_para_index = (uपूर्णांक8_t)((memory_घड़ी - 10000) / 2500);
	पूर्ण अन्यथा अणु
		अगर (memory_घड़ी < 65000)
			mc_para_index = 0x00;
		अन्यथा अगर (memory_घड़ी > 135000)
			mc_para_index = 0x0f;
		अन्यथा
			mc_para_index = (uपूर्णांक8_t)((memory_घड़ी - 60000) / 5000);
	पूर्ण

	वापस mc_para_index;
पूर्ण

अटल uपूर्णांक8_t ci_get_ddr3_mclk_frequency_ratio(uपूर्णांक32_t memory_घड़ी)
अणु
	uपूर्णांक8_t mc_para_index;

	अगर (memory_घड़ी < 10000)
		mc_para_index = 0;
	अन्यथा अगर (memory_घड़ी >= 80000)
		mc_para_index = 0x0f;
	अन्यथा
		mc_para_index = (uपूर्णांक8_t)((memory_घड़ी - 10000) / 5000 + 1);

	वापस mc_para_index;
पूर्ण

अटल पूर्णांक ci_populate_phase_value_based_on_mclk(काष्ठा pp_hwmgr *hwmgr, स्थिर काष्ठा phm_phase_shedding_limits_table *pl,
					uपूर्णांक32_t memory_घड़ी, uपूर्णांक32_t *p_shed)
अणु
	अचिन्हित पूर्णांक i;

	*p_shed = 1;

	क्रम (i = 0; i < pl->count; i++) अणु
		अगर (memory_घड़ी < pl->entries[i].Mclk) अणु
			*p_shed = i;
			अवरोध;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_single_memory_level(
		काष्ठा pp_hwmgr *hwmgr,
		uपूर्णांक32_t memory_घड़ी,
		SMU7_Discrete_MemoryLevel *memory_level
		)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	पूर्णांक result = 0;
	bool dll_state_on;
	uपूर्णांक32_t mclk_edc_wr_enable_threshold = 40000;
	uपूर्णांक32_t mclk_edc_enable_threshold = 40000;
	uपूर्णांक32_t mclk_strobe_mode_threshold = 40000;

	अगर (hwmgr->dyn_state.vddc_dependency_on_mclk != शून्य) अणु
		result = ci_get_dependency_volt_by_clk(hwmgr,
			hwmgr->dyn_state.vddc_dependency_on_mclk, memory_घड़ी, &memory_level->MinVddc);
		PP_ASSERT_WITH_CODE((0 == result),
			"can not find MinVddc voltage value from memory VDDC voltage dependency table", वापस result);
	पूर्ण

	अगर (शून्य != hwmgr->dyn_state.vddci_dependency_on_mclk) अणु
		result = ci_get_dependency_volt_by_clk(hwmgr,
				hwmgr->dyn_state.vddci_dependency_on_mclk,
				memory_घड़ी,
				&memory_level->MinVddci);
		PP_ASSERT_WITH_CODE((0 == result),
			"can not find MinVddci voltage value from memory VDDCI voltage dependency table", वापस result);
	पूर्ण

	अगर (शून्य != hwmgr->dyn_state.mvdd_dependency_on_mclk) अणु
		result = ci_get_dependency_volt_by_clk(hwmgr,
				hwmgr->dyn_state.mvdd_dependency_on_mclk,
				memory_घड़ी,
				&memory_level->MinMvdd);
		PP_ASSERT_WITH_CODE((0 == result),
			"can not find MinVddci voltage value from memory MVDD voltage dependency table", वापस result);
	पूर्ण

	memory_level->MinVddcPhases = 1;

	अगर (data->vddc_phase_shed_control) अणु
		ci_populate_phase_value_based_on_mclk(hwmgr, hwmgr->dyn_state.vddc_phase_shed_limits_table,
				memory_घड़ी, &memory_level->MinVddcPhases);
	पूर्ण

	memory_level->EnabledForThrottle = 1;
	memory_level->EnabledForActivity = 1;
	memory_level->UpH = data->current_profile_setting.mclk_up_hyst;
	memory_level->DownH = data->current_profile_setting.mclk_करोwn_hyst;
	memory_level->VoltageDownH = 0;

	/* Indicates maximum activity level क्रम this perक्रमmance level.*/
	memory_level->ActivityLevel = data->current_profile_setting.mclk_activity;
	memory_level->StutterEnable = 0;
	memory_level->StrobeEnable = 0;
	memory_level->EdcReadEnable = 0;
	memory_level->EdcWriteEnable = 0;
	memory_level->RttEnable = 0;

	/* शेष set to low watermark. Highest level will be set to high later.*/
	memory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;

	data->display_timing.num_existing_displays = hwmgr->display_config->num_display;
	data->display_timing.vrefresh = hwmgr->display_config->vrefresh;

	/* stutter mode not support on ci */

	/* decide strobe mode*/
	memory_level->StrobeEnable = (mclk_strobe_mode_threshold != 0) &&
		(memory_घड़ी <= mclk_strobe_mode_threshold);

	/* decide EDC mode and memory घड़ी ratio*/
	अगर (data->is_memory_gddr5) अणु
		memory_level->StrobeRatio = ci_get_mclk_frequency_ratio(memory_घड़ी,
					memory_level->StrobeEnable);

		अगर ((mclk_edc_enable_threshold != 0) &&
				(memory_घड़ी > mclk_edc_enable_threshold)) अणु
			memory_level->EdcReadEnable = 1;
		पूर्ण

		अगर ((mclk_edc_wr_enable_threshold != 0) &&
				(memory_घड़ी > mclk_edc_wr_enable_threshold)) अणु
			memory_level->EdcWriteEnable = 1;
		पूर्ण

		अगर (memory_level->StrobeEnable) अणु
			अगर (ci_get_mclk_frequency_ratio(memory_घड़ी, 1) >=
					((cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC7) >> 16) & 0xf))
				dll_state_on = ((cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;
			अन्यथा
				dll_state_on = ((cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC6) >> 1) & 0x1) ? 1 : 0;
		पूर्ण अन्यथा
			dll_state_on = data->dll_शेष_on;
	पूर्ण अन्यथा अणु
		memory_level->StrobeRatio =
			ci_get_ddr3_mclk_frequency_ratio(memory_घड़ी);
		dll_state_on = ((cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;
	पूर्ण

	result = ci_calculate_mclk_params(hwmgr,
		memory_घड़ी, memory_level, memory_level->StrobeEnable, dll_state_on);

	अगर (0 == result) अणु
		memory_level->MinVddc = PP_HOST_TO_SMC_UL(memory_level->MinVddc * VOLTAGE_SCALE);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MinVddcPhases);
		memory_level->MinVddci = PP_HOST_TO_SMC_UL(memory_level->MinVddci * VOLTAGE_SCALE);
		memory_level->MinMvdd = PP_HOST_TO_SMC_UL(memory_level->MinMvdd * VOLTAGE_SCALE);
		/* MCLK frequency in units of 10KHz*/
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkFrequency);
		/* Indicates maximum activity level क्रम this perक्रमmance level.*/
		CONVERT_FROM_HOST_TO_SMC_US(memory_level->ActivityLevel);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_1);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_2);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllAdFuncCntl);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllDqFuncCntl);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkPwrmgtCntl);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->DllCntl);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs1);
		CONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs2);
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_all_memory_levels(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	काष्ठा smu7_dpm_table *dpm_table = &data->dpm_table;
	पूर्णांक result;
	काष्ठा amdgpu_device *adev = hwmgr->adev;
	uपूर्णांक32_t dev_id;

	uपूर्णांक32_t level_array_address = smu_data->dpm_table_start + दुरत्व(SMU7_Discrete_DpmTable, MemoryLevel);
	uपूर्णांक32_t level_array_size = माप(SMU7_Discrete_MemoryLevel) * SMU7_MAX_LEVELS_MEMORY;
	SMU7_Discrete_MemoryLevel *levels = smu_data->smc_state_table.MemoryLevel;
	uपूर्णांक32_t i;

	स_रखो(levels, 0x00, level_array_size);

	क्रम (i = 0; i < dpm_table->mclk_table.count; i++) अणु
		PP_ASSERT_WITH_CODE((0 != dpm_table->mclk_table.dpm_levels[i].value),
			"can not populate memory level as memory clock is zero", वापस -EINVAL);
		result = ci_populate_single_memory_level(hwmgr, dpm_table->mclk_table.dpm_levels[i].value,
			&(smu_data->smc_state_table.MemoryLevel[i]));
		अगर (0 != result)
			वापस result;
	पूर्ण

	smu_data->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;

	dev_id = adev->pdev->device;

	अगर ((dpm_table->mclk_table.count >= 2)
		&& ((dev_id == 0x67B0) ||  (dev_id == 0x67B1))) अणु
		smu_data->smc_state_table.MemoryLevel[1].MinVddci =
				smu_data->smc_state_table.MemoryLevel[0].MinVddci;
		smu_data->smc_state_table.MemoryLevel[1].MinMvdd =
				smu_data->smc_state_table.MemoryLevel[0].MinMvdd;
	पूर्ण
	smu_data->smc_state_table.MemoryLevel[0].ActivityLevel = 0x1F;
	CONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.MemoryLevel[0].ActivityLevel);

	smu_data->smc_state_table.MemoryDpmLevelCount = (uपूर्णांक8_t)dpm_table->mclk_table.count;
	data->dpm_level_enable_mask.mclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);
	smu_data->smc_state_table.MemoryLevel[dpm_table->mclk_table.count-1].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;

	result = ci_copy_bytes_to_smc(hwmgr,
		level_array_address, (uपूर्णांक8_t *)levels, (uपूर्णांक32_t)level_array_size,
		SMC_RAM_END);

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_mvdd_value(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t mclk,
					SMU7_Discrete_VoltageLevel *voltage)
अणु
	स्थिर काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	uपूर्णांक32_t i = 0;

	अगर (SMU7_VOLTAGE_CONTROL_NONE != data->mvdd_control) अणु
		/* find mvdd value which घड़ी is more than request */
		क्रम (i = 0; i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count; i++) अणु
			अगर (mclk <= hwmgr->dyn_state.mvdd_dependency_on_mclk->entries[i].clk) अणु
				/* Always round to higher voltage. */
				voltage->Voltage = data->mvdd_voltage_table.entries[i].value;
				अवरोध;
			पूर्ण
		पूर्ण

		PP_ASSERT_WITH_CODE(i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count,
			"MVDD Voltage is outside the supported range.", वापस -EINVAL);

	पूर्ण अन्यथा अणु
		वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_acpi_level(काष्ठा pp_hwmgr *hwmgr,
	SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result = 0;
	स्थिर काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा pp_atomctrl_घड़ी_भागiders_vi भागiders;

	SMU7_Discrete_VoltageLevel voltage_level;
	uपूर्णांक32_t spll_func_cntl    = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL;
	uपूर्णांक32_t spll_func_cntl_2  = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL_2;
	uपूर्णांक32_t dll_cntl          = data->घड़ी_रेजिस्टरs.vDLL_CNTL;
	uपूर्णांक32_t mclk_pwrmgt_cntl  = data->घड़ी_रेजिस्टरs.vMCLK_PWRMGT_CNTL;


	/* The ACPI state should not करो DPM on DC (or ever).*/
	table->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;

	अगर (data->acpi_vddc)
		table->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->acpi_vddc * VOLTAGE_SCALE);
	अन्यथा
		table->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->min_vddc_in_pptable * VOLTAGE_SCALE);

	table->ACPILevel.MinVddcPhases = data->vddc_phase_shed_control ? 0 : 1;
	/* assign zero क्रम now*/
	table->ACPILevel.SclkFrequency = atomctrl_get_reference_घड़ी(hwmgr);

	/* get the engine घड़ी भागiders क्रम this घड़ी value*/
	result = atomctrl_get_engine_pll_भागiders_vi(hwmgr,
		table->ACPILevel.SclkFrequency,  &भागiders);

	PP_ASSERT_WITH_CODE(result == 0,
		"Error retrieving Engine Clock dividers from VBIOS.", वापस result);

	/* भागider ID क्रम required SCLK*/
	table->ACPILevel.SclkDid = (uपूर्णांक8_t)भागiders.pll_post_भागider;
	table->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;
	table->ACPILevel.DeepSleepDivId = 0;

	spll_func_cntl      = PHM_SET_FIELD(spll_func_cntl,
							CG_SPLL_FUNC_CNTL,   SPLL_PWRON,     0);
	spll_func_cntl      = PHM_SET_FIELD(spll_func_cntl,
							CG_SPLL_FUNC_CNTL,   SPLL_RESET,     1);
	spll_func_cntl_2    = PHM_SET_FIELD(spll_func_cntl_2,
							CG_SPLL_FUNC_CNTL_2, SCLK_MUX_SEL,   4);

	table->ACPILevel.CgSpllFuncCntl = spll_func_cntl;
	table->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;
	table->ACPILevel.CgSpllFuncCntl3 = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL_3;
	table->ACPILevel.CgSpllFuncCntl4 = data->घड़ी_रेजिस्टरs.vCG_SPLL_FUNC_CNTL_4;
	table->ACPILevel.SpllSpपढ़ोSpectrum = data->घड़ी_रेजिस्टरs.vCG_SPLL_SPREAD_SPECTRUM;
	table->ACPILevel.SpllSpपढ़ोSpectrum2 = data->घड़ी_रेजिस्टरs.vCG_SPLL_SPREAD_SPECTRUM_2;
	table->ACPILevel.CcPwrDynRm = 0;
	table->ACPILevel.CcPwrDynRm1 = 0;

	/* For various features to be enabled/disabled जबतक this level is active.*/
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.Flags);
	/* SCLK frequency in units of 10KHz*/
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SclkFrequency);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl2);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl3);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl4);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpपढ़ोSpectrum);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpपढ़ोSpectrum2);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm);
	CONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm1);


	/* table->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;*/
	table->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;
	table->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;

	अगर (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)
		table->MemoryACPILevel.MinVddci = table->MemoryACPILevel.MinVddc;
	अन्यथा अणु
		अगर (data->acpi_vddci != 0)
			table->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->acpi_vddci * VOLTAGE_SCALE);
		अन्यथा
			table->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->min_vddci_in_pptable * VOLTAGE_SCALE);
	पूर्ण

	अगर (0 == ci_populate_mvdd_value(hwmgr, 0, &voltage_level))
		table->MemoryACPILevel.MinMvdd =
			PP_HOST_TO_SMC_UL(voltage_level.Voltage * VOLTAGE_SCALE);
	अन्यथा
		table->MemoryACPILevel.MinMvdd = 0;

	/* Force reset on DLL*/
	mclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK0_RESET, 0x1);
	mclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK1_RESET, 0x1);

	/* Disable DLL in ACPIState*/
	mclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK0_PDNB, 0);
	mclk_pwrmgt_cntl    = PHM_SET_FIELD(mclk_pwrmgt_cntl,
		MCLK_PWRMGT_CNTL, MRDCK1_PDNB, 0);

	/* Enable DLL bypass संकेत*/
	dll_cntl            = PHM_SET_FIELD(dll_cntl,
		DLL_CNTL, MRDCK0_BYPASS, 0);
	dll_cntl            = PHM_SET_FIELD(dll_cntl,
		DLL_CNTL, MRDCK1_BYPASS, 0);

	table->MemoryACPILevel.DllCntl            =
		PP_HOST_TO_SMC_UL(dll_cntl);
	table->MemoryACPILevel.MclkPwrmgtCntl     =
		PP_HOST_TO_SMC_UL(mclk_pwrmgt_cntl);
	table->MemoryACPILevel.MpllAdFuncCntl     =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_AD_FUNC_CNTL);
	table->MemoryACPILevel.MpllDqFuncCntl     =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_DQ_FUNC_CNTL);
	table->MemoryACPILevel.MpllFuncCntl       =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL);
	table->MemoryACPILevel.MpllFuncCntl_1     =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL_1);
	table->MemoryACPILevel.MpllFuncCntl_2     =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_FUNC_CNTL_2);
	table->MemoryACPILevel.MpllSs1            =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_SS1);
	table->MemoryACPILevel.MpllSs2            =
		PP_HOST_TO_SMC_UL(data->घड़ी_रेजिस्टरs.vMPLL_SS2);

	table->MemoryACPILevel.EnabledForThrottle = 0;
	table->MemoryACPILevel.EnabledForActivity = 0;
	table->MemoryACPILevel.UpH = 0;
	table->MemoryACPILevel.DownH = 100;
	table->MemoryACPILevel.VoltageDownH = 0;
	/* Indicates maximum activity level क्रम this perक्रमmance level.*/
	table->MemoryACPILevel.ActivityLevel = PP_HOST_TO_SMC_US(data->current_profile_setting.mclk_activity);

	table->MemoryACPILevel.StutterEnable = 0;
	table->MemoryACPILevel.StrobeEnable = 0;
	table->MemoryACPILevel.EdcReadEnable = 0;
	table->MemoryACPILevel.EdcWriteEnable = 0;
	table->MemoryACPILevel.RttEnable = 0;

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_smc_uvd_level(काष्ठा pp_hwmgr *hwmgr,
					SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result = 0;
	uपूर्णांक8_t count;
	काष्ठा pp_atomctrl_घड़ी_भागiders_vi भागiders;
	काष्ठा phm_uvd_घड़ी_voltage_dependency_table *uvd_table =
		hwmgr->dyn_state.uvd_घड़ी_voltage_dependency_table;

	table->UvdLevelCount = (uपूर्णांक8_t)(uvd_table->count);

	क्रम (count = 0; count < table->UvdLevelCount; count++) अणु
		table->UvdLevel[count].VclkFrequency =
					uvd_table->entries[count].vclk;
		table->UvdLevel[count].DclkFrequency =
					uvd_table->entries[count].dclk;
		table->UvdLevel[count].MinVddc =
					uvd_table->entries[count].v * VOLTAGE_SCALE;
		table->UvdLevel[count].MinVddcPhases = 1;

		result = atomctrl_get_dfs_pll_भागiders_vi(hwmgr,
				table->UvdLevel[count].VclkFrequency, &भागiders);
		PP_ASSERT_WITH_CODE((0 == result),
				"can not find divide id for Vclk clock", वापस result);

		table->UvdLevel[count].VclkDivider = (uपूर्णांक8_t)भागiders.pll_post_भागider;

		result = atomctrl_get_dfs_pll_भागiders_vi(hwmgr,
				table->UvdLevel[count].DclkFrequency, &भागiders);
		PP_ASSERT_WITH_CODE((0 == result),
				"can not find divide id for Dclk clock", वापस result);

		table->UvdLevel[count].DclkDivider = (uपूर्णांक8_t)भागiders.pll_post_भागider;
		CONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].VclkFrequency);
		CONVERT_FROM_HOST_TO_SMC_UL(table->UvdLevel[count].DclkFrequency);
		CONVERT_FROM_HOST_TO_SMC_US(table->UvdLevel[count].MinVddc);
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_smc_vce_level(काष्ठा pp_hwmgr *hwmgr,
		SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result = -EINVAL;
	uपूर्णांक8_t count;
	काष्ठा pp_atomctrl_घड़ी_भागiders_vi भागiders;
	काष्ठा phm_vce_घड़ी_voltage_dependency_table *vce_table =
				hwmgr->dyn_state.vce_घड़ी_voltage_dependency_table;

	table->VceLevelCount = (uपूर्णांक8_t)(vce_table->count);
	table->VceBootLevel = 0;

	क्रम (count = 0; count < table->VceLevelCount; count++) अणु
		table->VceLevel[count].Frequency = vce_table->entries[count].evclk;
		table->VceLevel[count].MinVoltage =
				vce_table->entries[count].v * VOLTAGE_SCALE;
		table->VceLevel[count].MinPhases = 1;

		result = atomctrl_get_dfs_pll_भागiders_vi(hwmgr,
				table->VceLevel[count].Frequency, &भागiders);
		PP_ASSERT_WITH_CODE((0 == result),
				"can not find divide id for VCE engine clock",
				वापस result);

		table->VceLevel[count].Divider = (uपूर्णांक8_t)भागiders.pll_post_भागider;

		CONVERT_FROM_HOST_TO_SMC_UL(table->VceLevel[count].Frequency);
		CONVERT_FROM_HOST_TO_SMC_US(table->VceLevel[count].MinVoltage);
	पूर्ण
	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_smc_acp_level(काष्ठा pp_hwmgr *hwmgr,
					SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result = -EINVAL;
	uपूर्णांक8_t count;
	काष्ठा pp_atomctrl_घड़ी_भागiders_vi भागiders;
	काष्ठा phm_acp_घड़ी_voltage_dependency_table *acp_table =
				hwmgr->dyn_state.acp_घड़ी_voltage_dependency_table;

	table->AcpLevelCount = (uपूर्णांक8_t)(acp_table->count);
	table->AcpBootLevel = 0;

	क्रम (count = 0; count < table->AcpLevelCount; count++) अणु
		table->AcpLevel[count].Frequency = acp_table->entries[count].acpclk;
		table->AcpLevel[count].MinVoltage = acp_table->entries[count].v;
		table->AcpLevel[count].MinPhases = 1;

		result = atomctrl_get_dfs_pll_भागiders_vi(hwmgr,
				table->AcpLevel[count].Frequency, &भागiders);
		PP_ASSERT_WITH_CODE((0 == result),
				"can not find divide id for engine clock", वापस result);

		table->AcpLevel[count].Divider = (uपूर्णांक8_t)भागiders.pll_post_भागider;

		CONVERT_FROM_HOST_TO_SMC_UL(table->AcpLevel[count].Frequency);
		CONVERT_FROM_HOST_TO_SMC_US(table->AcpLevel[count].MinVoltage);
	पूर्ण
	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_memory_timing_parameters(
		काष्ठा pp_hwmgr *hwmgr,
		uपूर्णांक32_t engine_घड़ी,
		uपूर्णांक32_t memory_घड़ी,
		काष्ठा SMU7_Discrete_MCArbDramTimingTableEntry *arb_regs
		)
अणु
	uपूर्णांक32_t dramTiming;
	uपूर्णांक32_t dramTiming2;
	uपूर्णांक32_t burstTime;
	पूर्णांक result;

	result = atomctrl_set_engine_dram_timings_rv770(hwmgr,
				engine_घड़ी, memory_घड़ी);

	PP_ASSERT_WITH_CODE(result == 0,
		"Error calling VBIOS to set DRAM_TIMING.", वापस result);

	dramTiming  = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_ARB_DRAM_TIMING);
	dramTiming2 = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_ARB_DRAM_TIMING2);
	burstTime = PHM_READ_FIELD(hwmgr->device, MC_ARB_BURST_TIME, STATE0);

	arb_regs->McArbDramTiming  = PP_HOST_TO_SMC_UL(dramTiming);
	arb_regs->McArbDramTiming2 = PP_HOST_TO_SMC_UL(dramTiming2);
	arb_regs->McArbBurstTime = (uपूर्णांक8_t)burstTime;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_program_memory_timing_parameters(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	पूर्णांक result = 0;
	SMU7_Discrete_MCArbDramTimingTable  arb_regs;
	uपूर्णांक32_t i, j;

	स_रखो(&arb_regs, 0x00, माप(SMU7_Discrete_MCArbDramTimingTable));

	क्रम (i = 0; i < data->dpm_table.sclk_table.count; i++) अणु
		क्रम (j = 0; j < data->dpm_table.mclk_table.count; j++) अणु
			result = ci_populate_memory_timing_parameters
				(hwmgr, data->dpm_table.sclk_table.dpm_levels[i].value,
				 data->dpm_table.mclk_table.dpm_levels[j].value,
				 &arb_regs.entries[i][j]);

			अगर (0 != result)
				अवरोध;
		पूर्ण
	पूर्ण

	अगर (0 == result) अणु
		result = ci_copy_bytes_to_smc(
				hwmgr,
				smu_data->arb_table_start,
				(uपूर्णांक8_t *)&arb_regs,
				माप(SMU7_Discrete_MCArbDramTimingTable),
				SMC_RAM_END
				);
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_smc_boot_level(काष्ठा pp_hwmgr *hwmgr,
			SMU7_Discrete_DpmTable *table)
अणु
	पूर्णांक result = 0;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);

	table->GraphicsBootLevel = 0;
	table->MemoryBootLevel = 0;

	/* find boot level from dpm table*/
	result = phm_find_boot_level(&(data->dpm_table.sclk_table),
			data->vbios_boot_state.sclk_bootup_value,
			(uपूर्णांक32_t *)&(smu_data->smc_state_table.GraphicsBootLevel));

	अगर (0 != result) अणु
		smu_data->smc_state_table.GraphicsBootLevel = 0;
		pr_err("VBIOS did not find boot engine clock value in dependency table. Using Graphics DPM level 0!\n");
		result = 0;
	पूर्ण

	result = phm_find_boot_level(&(data->dpm_table.mclk_table),
		data->vbios_boot_state.mclk_bootup_value,
		(uपूर्णांक32_t *)&(smu_data->smc_state_table.MemoryBootLevel));

	अगर (0 != result) अणु
		smu_data->smc_state_table.MemoryBootLevel = 0;
		pr_err("VBIOS did not find boot engine clock value in dependency table. Using Memory DPM level 0!\n");
		result = 0;
	पूर्ण

	table->BootVddc = data->vbios_boot_state.vddc_bootup_value;
	table->BootVddci = data->vbios_boot_state.vddci_bootup_value;
	table->BootMVdd = data->vbios_boot_state.mvdd_bootup_value;

	वापस result;
पूर्ण

अटल पूर्णांक ci_populate_mc_reg_address(काष्ठा pp_hwmgr *hwmgr,
				 SMU7_Discrete_MCRegisters *mc_reg_table)
अणु
	स्थिर काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)hwmgr->smu_backend;

	uपूर्णांक32_t i, j;

	क्रम (i = 0, j = 0; j < smu_data->mc_reg_table.last; j++) अणु
		अगर (smu_data->mc_reg_table.validflag & 1<<j) अणु
			PP_ASSERT_WITH_CODE(i < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE,
				"Index of mc_reg_table->address[] array out of boundary", वापस -EINVAL);
			mc_reg_table->address[i].s0 =
				PP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s0);
			mc_reg_table->address[i].s1 =
				PP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s1);
			i++;
		पूर्ण
	पूर्ण

	mc_reg_table->last = (uपूर्णांक8_t)i;

	वापस 0;
पूर्ण

अटल व्योम ci_convert_mc_रेजिस्टरs(
	स्थिर काष्ठा ci_mc_reg_entry *entry,
	SMU7_Discrete_MCRegisterSet *data,
	uपूर्णांक32_t num_entries, uपूर्णांक32_t valid_flag)
अणु
	uपूर्णांक32_t i, j;

	क्रम (i = 0, j = 0; j < num_entries; j++) अणु
		अगर (valid_flag & 1<<j) अणु
			data->value[i] = PP_HOST_TO_SMC_UL(entry->mc_data[j]);
			i++;
		पूर्ण
	पूर्ण
पूर्ण

अटल पूर्णांक ci_convert_mc_reg_table_entry_to_smc(
		काष्ठा pp_hwmgr *hwmgr,
		स्थिर uपूर्णांक32_t memory_घड़ी,
		SMU7_Discrete_MCRegisterSet *mc_reg_table_data
		)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक32_t i = 0;

	क्रम (i = 0; i < smu_data->mc_reg_table.num_entries; i++) अणु
		अगर (memory_घड़ी <=
			smu_data->mc_reg_table.mc_reg_table_entry[i].mclk_max) अणु
			अवरोध;
		पूर्ण
	पूर्ण

	अगर ((i == smu_data->mc_reg_table.num_entries) && (i > 0))
		--i;

	ci_convert_mc_रेजिस्टरs(&smu_data->mc_reg_table.mc_reg_table_entry[i],
				mc_reg_table_data, smu_data->mc_reg_table.last,
				smu_data->mc_reg_table.validflag);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_convert_mc_reg_table_to_smc(काष्ठा pp_hwmgr *hwmgr,
		SMU7_Discrete_MCRegisters *mc_regs)
अणु
	पूर्णांक result = 0;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	पूर्णांक res;
	uपूर्णांक32_t i;

	क्रम (i = 0; i < data->dpm_table.mclk_table.count; i++) अणु
		res = ci_convert_mc_reg_table_entry_to_smc(
				hwmgr,
				data->dpm_table.mclk_table.dpm_levels[i].value,
				&mc_regs->data[i]
				);

		अगर (0 != res)
			result = res;
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_update_and_upload_mc_reg_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	uपूर्णांक32_t address;
	पूर्णांक32_t result;

	अगर (0 == (data->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))
		वापस 0;


	स_रखो(&smu_data->mc_regs, 0, माप(SMU7_Discrete_MCRegisters));

	result = ci_convert_mc_reg_table_to_smc(hwmgr, &(smu_data->mc_regs));

	अगर (result != 0)
		वापस result;

	address = smu_data->mc_reg_table_start + (uपूर्णांक32_t)दुरत्व(SMU7_Discrete_MCRegisters, data[0]);

	वापस  ci_copy_bytes_to_smc(hwmgr, address,
				 (uपूर्णांक8_t *)&smu_data->mc_regs.data[0],
				माप(SMU7_Discrete_MCRegisterSet) * data->dpm_table.mclk_table.count,
				SMC_RAM_END);
पूर्ण

अटल पूर्णांक ci_populate_initial_mc_reg_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	पूर्णांक result;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);

	स_रखो(&smu_data->mc_regs, 0x00, माप(SMU7_Discrete_MCRegisters));
	result = ci_populate_mc_reg_address(hwmgr, &(smu_data->mc_regs));
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize MCRegTable for the MC register addresses!", वापस result;);

	result = ci_convert_mc_reg_table_to_smc(hwmgr, &smu_data->mc_regs);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize MCRegTable for driver state!", वापस result;);

	वापस ci_copy_bytes_to_smc(hwmgr, smu_data->mc_reg_table_start,
			(uपूर्णांक8_t *)&smu_data->mc_regs, माप(SMU7_Discrete_MCRegisters), SMC_RAM_END);
पूर्ण

अटल पूर्णांक ci_populate_smc_initial_state(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	uपूर्णांक8_t count, level;

	count = (uपूर्णांक8_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->count);

	क्रम (level = 0; level < count; level++) अणु
		अगर (hwmgr->dyn_state.vddc_dependency_on_sclk->entries[level].clk
			 >= data->vbios_boot_state.sclk_bootup_value) अणु
			smu_data->smc_state_table.GraphicsBootLevel = level;
			अवरोध;
		पूर्ण
	पूर्ण

	count = (uपूर्णांक8_t)(hwmgr->dyn_state.vddc_dependency_on_mclk->count);

	क्रम (level = 0; level < count; level++) अणु
		अगर (hwmgr->dyn_state.vddc_dependency_on_mclk->entries[level].clk
			>= data->vbios_boot_state.mclk_bootup_value) अणु
			smu_data->smc_state_table.MemoryBootLevel = level;
			अवरोध;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_smc_svi2_config(काष्ठा pp_hwmgr *hwmgr,
					    SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	अगर (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control)
		table->SVI2Enable = 1;
	अन्यथा
		table->SVI2Enable = 0;
	वापस 0;
पूर्ण

अटल पूर्णांक ci_start_smc(काष्ठा pp_hwmgr *hwmgr)
अणु
	/* set smc inकाष्ठा start poपूर्णांक at 0x0 */
	ci_program_jump_on_start(hwmgr);

	/* enable smc घड़ी */
	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable, 0);

	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_RESET_CNTL, rst_reg, 0);

	PHM_WAIT_INसूचीECT_FIELD(hwmgr, SMC_IND, FIRMWARE_FLAGS,
				 INTERRUPTS_ENABLED, 1);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_populate_vr_config(काष्ठा pp_hwmgr *hwmgr, SMU7_Discrete_DpmTable *table)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	uपूर्णांक16_t config;

	config = VR_SVI2_PLANE_1;
	table->VRConfig |= (config<<VRCONF_VDDGFX_SHIFT);

	अगर (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control) अणु
		config = VR_SVI2_PLANE_2;
		table->VRConfig |= config;
	पूर्ण अन्यथा अणु
		pr_info("VDDCshould be on SVI2 controller!");
	पूर्ण

	अगर (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control) अणु
		config = VR_SVI2_PLANE_2;
		table->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);
	पूर्ण अन्यथा अगर (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control) अणु
		config = VR_SMIO_PATTERN_1;
		table->VRConfig |= (config<<VRCONF_VDDCI_SHIFT);
	पूर्ण

	अगर (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control) अणु
		config = VR_SMIO_PATTERN_2;
		table->VRConfig |= (config<<VRCONF_MVDD_SHIFT);
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_init_smc_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	पूर्णांक result;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	SMU7_Discrete_DpmTable  *table = &(smu_data->smc_state_table);
	काष्ठा pp_atomctrl_gpio_pin_assignment gpio_pin;
	u32 i;

	ci_initialize_घातer_tune_शेषs(hwmgr);
	स_रखो(&(smu_data->smc_state_table), 0x00, माप(smu_data->smc_state_table));

	अगर (SMU7_VOLTAGE_CONTROL_NONE != data->voltage_control)
		ci_populate_smc_voltage_tables(hwmgr, table);

	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_AutomaticDCTransition))
		table->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;


	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_StepVddc))
		table->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;

	अगर (data->is_memory_gddr5)
		table->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;

	अगर (data->ulv_supported) अणु
		result = ci_populate_ulv_state(hwmgr, &(table->Ulv));
		PP_ASSERT_WITH_CODE(0 == result,
			"Failed to initialize ULV state!", वापस result);

		cgs_ग_लिखो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC,
			ixCG_ULV_PARAMETER, 0x40035);
	पूर्ण

	result = ci_populate_all_graphic_levels(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize Graphics Level!", वापस result);

	result = ci_populate_all_memory_levels(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize Memory Level!", वापस result);

	result = ci_populate_smc_link_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize Link Level!", वापस result);

	result = ci_populate_smc_acpi_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize ACPI Level!", वापस result);

	result = ci_populate_smc_vce_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize VCE Level!", वापस result);

	result = ci_populate_smc_acp_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize ACP Level!", वापस result);

	/* Since only the initial state is completely set up at this poपूर्णांक (the other states are just copies of the boot state) we only */
	/* need to populate the  ARB settings क्रम the initial state. */
	result = ci_program_memory_timing_parameters(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to Write ARB settings for the initial state.", वापस result);

	result = ci_populate_smc_uvd_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize UVD Level!", वापस result);

	table->UvdBootLevel  = 0;
	table->VceBootLevel  = 0;
	table->AcpBootLevel  = 0;
	table->SamuBootLevel  = 0;

	table->GraphicsBootLevel = 0;
	table->MemoryBootLevel = 0;

	result = ci_populate_smc_boot_level(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to initialize Boot Level!", वापस result);

	result = ci_populate_smc_initial_state(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result, "Failed to initialize Boot State!", वापस result);

	result = ci_populate_bapm_parameters_in_dpm_table(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result, "Failed to populate BAPM Parameters!", वापस result);

	table->UVDInterval = 1;
	table->VCEInterval = 1;
	table->ACPInterval = 1;
	table->SAMUInterval = 1;
	table->GraphicsVoltageChangeEnable  = 1;
	table->GraphicsThermThrottleEnable  = 1;
	table->GraphicsInterval = 1;
	table->VoltageInterval  = 1;
	table->ThermalInterval  = 1;

	table->TemperatureLimitHigh =
		(data->thermal_temp_setting.temperature_high *
		 SMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
	table->TemperatureLimitLow =
		(data->thermal_temp_setting.temperature_low *
		SMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;

	table->MemoryVoltageChangeEnable  = 1;
	table->MemoryInterval  = 1;
	table->VoltageResponseTime  = 0;
	table->VddcVddciDelta = 4000;
	table->PhaseResponseTime  = 0;
	table->MemoryThermThrottleEnable  = 1;

	PP_ASSERT_WITH_CODE((1 <= data->dpm_table.pcie_speed_table.count),
			"There must be 1 or more PCIE levels defined in PPTable.",
			वापस -EINVAL);

	table->PCIeBootLinkLevel = (uपूर्णांक8_t)data->dpm_table.pcie_speed_table.count;
	table->PCIeGenInterval = 1;

	result = ci_populate_vr_config(hwmgr, table);
	PP_ASSERT_WITH_CODE(0 == result,
			"Failed to populate VRConfig setting!", वापस result);
	data->vr_config = table->VRConfig;

	ci_populate_smc_svi2_config(hwmgr, table);

	क्रम (i = 0; i < SMU7_MAX_ENTRIES_SMIO; i++)
		CONVERT_FROM_HOST_TO_SMC_UL(table->Smio[i]);

	table->ThermGpio  = 17;
	table->SclkStepSize = 0x4000;
	अगर (atomctrl_get_pp_assign_pin(hwmgr, VDDC_VRHOT_GPIO_PINID, &gpio_pin)) अणु
		table->VRHotGpio = gpio_pin.uc_gpio_pin_bit_shअगरt;
		phm_cap_set(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
				PHM_Platक्रमmCaps_RegulatorHot);
	पूर्ण अन्यथा अणु
		table->VRHotGpio = SMU7_UNUSED_GPIO_PIN;
		phm_cap_unset(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
				PHM_Platक्रमmCaps_RegulatorHot);
	पूर्ण

	table->AcDcGpio = SMU7_UNUSED_GPIO_PIN;

	CONVERT_FROM_HOST_TO_SMC_UL(table->SystemFlags);
	CONVERT_FROM_HOST_TO_SMC_UL(table->VRConfig);
	CONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcVid);
	CONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcPhase);
	CONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddciVid);
	CONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskMvddVid);
	CONVERT_FROM_HOST_TO_SMC_UL(table->SclkStepSize);
	CONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitHigh);
	CONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitLow);
	table->VddcVddciDelta = PP_HOST_TO_SMC_US(table->VddcVddciDelta);
	CONVERT_FROM_HOST_TO_SMC_US(table->VoltageResponseTime);
	CONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);

	table->BootVddc = PP_HOST_TO_SMC_US(table->BootVddc * VOLTAGE_SCALE);
	table->BootVddci = PP_HOST_TO_SMC_US(table->BootVddci * VOLTAGE_SCALE);
	table->BootMVdd = PP_HOST_TO_SMC_US(table->BootMVdd * VOLTAGE_SCALE);

	/* Upload all dpm data to SMC memory.(dpm level, dpm level count etc) */
	result = ci_copy_bytes_to_smc(hwmgr, smu_data->dpm_table_start +
					दुरत्व(SMU7_Discrete_DpmTable, SystemFlags),
					(uपूर्णांक8_t *)&(table->SystemFlags),
					माप(SMU7_Discrete_DpmTable)-3 * माप(SMU7_PIDController),
					SMC_RAM_END);

	PP_ASSERT_WITH_CODE(0 == result,
		"Failed to upload dpm data to SMC memory!", वापस result;);

	result = ci_populate_initial_mc_reg_table(hwmgr);
	PP_ASSERT_WITH_CODE((0 == result),
		"Failed to populate initialize MC Reg table!", वापस result);

	result = ci_populate_pm_fuses(hwmgr);
	PP_ASSERT_WITH_CODE(0 == result,
			"Failed to  populate PM fuses to SMC memory!", वापस result);

	ci_start_smc(hwmgr);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_thermal_setup_fan_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *ci_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	SMU7_Discrete_FanTable fan_table = अणु FDO_MODE_HARDWARE पूर्ण;
	uपूर्णांक32_t duty100;
	uपूर्णांक32_t t_dअगरf1, t_dअगरf2, pwm_dअगरf1, pwm_dअगरf2;
	uपूर्णांक16_t fकरो_min, slope1, slope2;
	uपूर्णांक32_t reference_घड़ी;
	पूर्णांक res;
	uपूर्णांक64_t पंचांगp64;

	अगर (!phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps, PHM_Platक्रमmCaps_MicrocodeFanControl))
		वापस 0;

	अगर (hwmgr->thermal_controller.fanInfo.bNoFan) अणु
		phm_cap_unset(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_MicrocodeFanControl);
		वापस 0;
	पूर्ण

	अगर (0 == ci_data->fan_table_start) अणु
		phm_cap_unset(hwmgr->platक्रमm_descriptor.platक्रमmCaps, PHM_Platक्रमmCaps_MicrocodeFanControl);
		वापस 0;
	पूर्ण

	duty100 = PHM_READ_VFPF_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_FDO_CTRL1, FMAX_DUTY100);

	अगर (0 == duty100) अणु
		phm_cap_unset(hwmgr->platक्रमm_descriptor.platक्रमmCaps, PHM_Platक्रमmCaps_MicrocodeFanControl);
		वापस 0;
	पूर्ण

	पंचांगp64 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin * duty100;
	करो_भाग(पंचांगp64, 10000);
	fकरो_min = (uपूर्णांक16_t)पंचांगp64;

	t_dअगरf1 = hwmgr->thermal_controller.advanceFanControlParameters.usTMed - hwmgr->thermal_controller.advanceFanControlParameters.usTMin;
	t_dअगरf2 = hwmgr->thermal_controller.advanceFanControlParameters.usTHigh - hwmgr->thermal_controller.advanceFanControlParameters.usTMed;

	pwm_dअगरf1 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin;
	pwm_dअगरf2 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed;

	slope1 = (uपूर्णांक16_t)((50 + ((16 * duty100 * pwm_dअगरf1) / t_dअगरf1)) / 100);
	slope2 = (uपूर्णांक16_t)((50 + ((16 * duty100 * pwm_dअगरf2) / t_dअगरf2)) / 100);

	fan_table.TempMin = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMin) / 100);
	fan_table.TempMed = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMed) / 100);
	fan_table.TempMax = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMax) / 100);

	fan_table.Slope1 = cpu_to_be16(slope1);
	fan_table.Slope2 = cpu_to_be16(slope2);

	fan_table.FकरोMin = cpu_to_be16(fकरो_min);

	fan_table.HystDown = cpu_to_be16(hwmgr->thermal_controller.advanceFanControlParameters.ucTHyst);

	fan_table.HystUp = cpu_to_be16(1);

	fan_table.HystSlope = cpu_to_be16(1);

	fan_table.TempRespLim = cpu_to_be16(5);

	reference_घड़ी = amdgpu_asic_get_xclk((काष्ठा amdgpu_device *)hwmgr->adev);

	fan_table.RefreshPeriod = cpu_to_be32((hwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay * reference_घड़ी) / 1600);

	fan_table.FकरोMax = cpu_to_be16((uपूर्णांक16_t)duty100);

	fan_table.TempSrc = (uपूर्णांक8_t)PHM_READ_VFPF_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_MULT_THERMAL_CTRL, TEMP_SEL);

	res = ci_copy_bytes_to_smc(hwmgr, ci_data->fan_table_start, (uपूर्णांक8_t *)&fan_table, (uपूर्णांक32_t)माप(fan_table), SMC_RAM_END);

	वापस res;
पूर्ण

अटल पूर्णांक ci_program_mem_timing_parameters(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	अगर (data->need_update_smu7_dpm_table &
			(DPMTABLE_OD_UPDATE_SCLK + DPMTABLE_OD_UPDATE_MCLK))
		वापस ci_program_memory_timing_parameters(hwmgr);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_update_sclk_threshold(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);

	पूर्णांक result = 0;
	uपूर्णांक32_t low_sclk_पूर्णांकerrupt_threshold = 0;

	अगर (phm_cap_enabled(hwmgr->platक्रमm_descriptor.platक्रमmCaps,
			PHM_Platक्रमmCaps_SclkThrottleLowNotअगरication)
		&& (data->low_sclk_पूर्णांकerrupt_threshold != 0)) अणु
		low_sclk_पूर्णांकerrupt_threshold =
				data->low_sclk_पूर्णांकerrupt_threshold;

		CONVERT_FROM_HOST_TO_SMC_UL(low_sclk_पूर्णांकerrupt_threshold);

		result = ci_copy_bytes_to_smc(
				hwmgr,
				smu_data->dpm_table_start +
				दुरत्व(SMU7_Discrete_DpmTable,
					LowSclkInterruptT),
				(uपूर्णांक8_t *)&low_sclk_पूर्णांकerrupt_threshold,
				माप(uपूर्णांक32_t),
				SMC_RAM_END);
	पूर्ण

	result = ci_update_and_upload_mc_reg_table(hwmgr);

	PP_ASSERT_WITH_CODE((0 == result), "Failed to upload MC reg table!", वापस result);

	result = ci_program_mem_timing_parameters(hwmgr);
	PP_ASSERT_WITH_CODE((result == 0),
			"Failed to program memory timing parameters!",
			);

	वापस result;
पूर्ण

अटल uपूर्णांक32_t ci_get_दुरत्व(uपूर्णांक32_t type, uपूर्णांक32_t member)
अणु
	चयन (type) अणु
	हाल SMU_SoftRegisters:
		चयन (member) अणु
		हाल HandshakeDisables:
			वापस दुरत्व(SMU7_SoftRegisters, HandshakeDisables);
		हाल VoltageChangeTimeout:
			वापस दुरत्व(SMU7_SoftRegisters, VoltageChangeTimeout);
		हाल AverageGraphicsActivity:
			वापस दुरत्व(SMU7_SoftRegisters, AverageGraphicsA);
		हाल AverageMemoryActivity:
			वापस दुरत्व(SMU7_SoftRegisters, AverageMemoryA);
		हाल PreVBlankGap:
			वापस दुरत्व(SMU7_SoftRegisters, PreVBlankGap);
		हाल VBlankTimeout:
			वापस दुरत्व(SMU7_SoftRegisters, VBlankTimeout);
		हाल DRAM_LOG_ADDR_H:
			वापस दुरत्व(SMU7_SoftRegisters, DRAM_LOG_ADDR_H);
		हाल DRAM_LOG_ADDR_L:
			वापस दुरत्व(SMU7_SoftRegisters, DRAM_LOG_ADDR_L);
		हाल DRAM_LOG_PHY_ADDR_H:
			वापस दुरत्व(SMU7_SoftRegisters, DRAM_LOG_PHY_ADDR_H);
		हाल DRAM_LOG_PHY_ADDR_L:
			वापस दुरत्व(SMU7_SoftRegisters, DRAM_LOG_PHY_ADDR_L);
		हाल DRAM_LOG_BUFF_SIZE:
			वापस दुरत्व(SMU7_SoftRegisters, DRAM_LOG_BUFF_SIZE);
		पूर्ण
		अवरोध;
	हाल SMU_Discrete_DpmTable:
		चयन (member) अणु
		हाल LowSclkInterruptThreshold:
			वापस दुरत्व(SMU7_Discrete_DpmTable, LowSclkInterruptT);
		पूर्ण
		अवरोध;
	पूर्ण
	pr_debug("can't get the offset of type %x member %x\n", type, member);
	वापस 0;
पूर्ण

अटल uपूर्णांक32_t ci_get_mac_definition(uपूर्णांक32_t value)
अणु
	चयन (value) अणु
	हाल SMU_MAX_LEVELS_GRAPHICS:
		वापस SMU7_MAX_LEVELS_GRAPHICS;
	हाल SMU_MAX_LEVELS_MEMORY:
		वापस SMU7_MAX_LEVELS_MEMORY;
	हाल SMU_MAX_LEVELS_LINK:
		वापस SMU7_MAX_LEVELS_LINK;
	हाल SMU_MAX_ENTRIES_SMIO:
		वापस SMU7_MAX_ENTRIES_SMIO;
	हाल SMU_MAX_LEVELS_VDDC:
		वापस SMU7_MAX_LEVELS_VDDC;
	हाल SMU_MAX_LEVELS_VDDCI:
		वापस SMU7_MAX_LEVELS_VDDCI;
	हाल SMU_MAX_LEVELS_MVDD:
		वापस SMU7_MAX_LEVELS_MVDD;
	पूर्ण

	pr_debug("can't get the mac of %x\n", value);
	वापस 0;
पूर्ण

अटल पूर्णांक ci_load_smc_ucode(काष्ठा pp_hwmgr *hwmgr)
अणु
	uपूर्णांक32_t byte_count, start_addr;
	uपूर्णांक8_t *src;
	uपूर्णांक32_t data;

	काष्ठा cgs_firmware_info info = अणु0पूर्ण;

	cgs_get_firmware_info(hwmgr->device, CGS_UCODE_ID_SMU, &info);

	hwmgr->is_kicker = info.is_kicker;
	hwmgr->smu_version = info.version;
	byte_count = info.image_size;
	src = (uपूर्णांक8_t *)info.kptr;
	start_addr = info.ucode_start_address;

	अगर  (byte_count > SMC_RAM_END) अणु
		pr_err("SMC address is beyond the SMC RAM area.\n");
		वापस -EINVAL;
	पूर्ण

	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_IND_INDEX_0, start_addr);
	PHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);

	क्रम (; byte_count >= 4; byte_count -= 4) अणु
		data = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
		cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmSMC_IND_DATA_0, data);
		src += 4;
	पूर्ण
	PHM_WRITE_FIELD(hwmgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);

	अगर (0 != byte_count) अणु
		pr_err("SMC size must be divisible by 4\n");
		वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_upload_firmware(काष्ठा pp_hwmgr *hwmgr)
अणु
	अगर (ci_is_smc_ram_running(hwmgr)) अणु
		pr_info("smc is running, no need to load smc firmware\n");
		वापस 0;
	पूर्ण
	PHM_WAIT_INसूचीECT_FIELD(hwmgr, SMC_IND, RCU_UC_EVENTS,
			boot_seq_करोne, 1);
	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_MISC_CNTL,
			pre_fetcher_en, 1);

	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_CLOCK_CNTL_0, ck_disable, 1);
	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, SMC_SYSCON_RESET_CNTL, rst_reg, 1);
	वापस ci_load_smc_ucode(hwmgr);
पूर्ण

अटल पूर्णांक ci_process_firmware_header(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *ci_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);

	uपूर्णांक32_t पंचांगp = 0;
	पूर्णांक result;
	bool error = false;

	अगर (ci_upload_firmware(hwmgr))
		वापस -EINVAL;

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, DpmTable),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result)
		ci_data->dpm_table_start = पंचांगp;

	error |= (0 != result);

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, SoftRegisters),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result) अणु
		data->soft_regs_start = पंचांगp;
		ci_data->soft_regs_start = पंचांगp;
	पूर्ण

	error |= (0 != result);

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, mcRegisterTable),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result)
		ci_data->mc_reg_table_start = पंचांगp;

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, FanTable),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result)
		ci_data->fan_table_start = पंचांगp;

	error |= (0 != result);

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, mcArbDramTimingTable),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result)
		ci_data->arb_table_start = पंचांगp;

	error |= (0 != result);

	result = ci_पढ़ो_smc_sram_dword(hwmgr,
				SMU7_FIRMWARE_HEADER_LOCATION +
				दुरत्व(SMU7_Firmware_Header, Version),
				&पंचांगp, SMC_RAM_END);

	अगर (0 == result)
		hwmgr->microcode_version_info.SMC = पंचांगp;

	error |= (0 != result);

	वापस error ? 1 : 0;
पूर्ण

अटल uपूर्णांक8_t ci_get_memory_modile_index(काष्ठा pp_hwmgr *hwmgr)
अणु
	वापस (uपूर्णांक8_t) (0xFF & (cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmBIOS_SCRATCH_4) >> 16));
पूर्ण

अटल bool ci_check_s0_mc_reg_index(uपूर्णांक16_t in_reg, uपूर्णांक16_t *out_reg)
अणु
	bool result = true;

	चयन (in_reg) अणु
	हाल  mmMC_SEQ_RAS_TIMING:
		*out_reg = mmMC_SEQ_RAS_TIMING_LP;
		अवरोध;

	हाल  mmMC_SEQ_DLL_STBY:
		*out_reg = mmMC_SEQ_DLL_STBY_LP;
		अवरोध;

	हाल  mmMC_SEQ_G5PDX_CMD0:
		*out_reg = mmMC_SEQ_G5PDX_CMD0_LP;
		अवरोध;

	हाल  mmMC_SEQ_G5PDX_CMD1:
		*out_reg = mmMC_SEQ_G5PDX_CMD1_LP;
		अवरोध;

	हाल  mmMC_SEQ_G5PDX_CTRL:
		*out_reg = mmMC_SEQ_G5PDX_CTRL_LP;
		अवरोध;

	हाल mmMC_SEQ_CAS_TIMING:
		*out_reg = mmMC_SEQ_CAS_TIMING_LP;
		अवरोध;

	हाल mmMC_SEQ_MISC_TIMING:
		*out_reg = mmMC_SEQ_MISC_TIMING_LP;
		अवरोध;

	हाल mmMC_SEQ_MISC_TIMING2:
		*out_reg = mmMC_SEQ_MISC_TIMING2_LP;
		अवरोध;

	हाल mmMC_SEQ_PMG_DVS_CMD:
		*out_reg = mmMC_SEQ_PMG_DVS_CMD_LP;
		अवरोध;

	हाल mmMC_SEQ_PMG_DVS_CTL:
		*out_reg = mmMC_SEQ_PMG_DVS_CTL_LP;
		अवरोध;

	हाल mmMC_SEQ_RD_CTL_D0:
		*out_reg = mmMC_SEQ_RD_CTL_D0_LP;
		अवरोध;

	हाल mmMC_SEQ_RD_CTL_D1:
		*out_reg = mmMC_SEQ_RD_CTL_D1_LP;
		अवरोध;

	हाल mmMC_SEQ_WR_CTL_D0:
		*out_reg = mmMC_SEQ_WR_CTL_D0_LP;
		अवरोध;

	हाल mmMC_SEQ_WR_CTL_D1:
		*out_reg = mmMC_SEQ_WR_CTL_D1_LP;
		अवरोध;

	हाल mmMC_PMG_CMD_EMRS:
		*out_reg = mmMC_SEQ_PMG_CMD_EMRS_LP;
		अवरोध;

	हाल mmMC_PMG_CMD_MRS:
		*out_reg = mmMC_SEQ_PMG_CMD_MRS_LP;
		अवरोध;

	हाल mmMC_PMG_CMD_MRS1:
		*out_reg = mmMC_SEQ_PMG_CMD_MRS1_LP;
		अवरोध;

	हाल mmMC_SEQ_PMG_TIMING:
		*out_reg = mmMC_SEQ_PMG_TIMING_LP;
		अवरोध;

	हाल mmMC_PMG_CMD_MRS2:
		*out_reg = mmMC_SEQ_PMG_CMD_MRS2_LP;
		अवरोध;

	हाल mmMC_SEQ_WR_CTL_2:
		*out_reg = mmMC_SEQ_WR_CTL_2_LP;
		अवरोध;

	शेष:
		result = false;
		अवरोध;
	पूर्ण

	वापस result;
पूर्ण

अटल पूर्णांक ci_set_s0_mc_reg_index(काष्ठा ci_mc_reg_table *table)
अणु
	uपूर्णांक32_t i;
	uपूर्णांक16_t address;

	क्रम (i = 0; i < table->last; i++) अणु
		table->mc_reg_address[i].s0 =
			ci_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address)
			? address : table->mc_reg_address[i].s1;
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ci_copy_vbios_smc_reg_table(स्थिर pp_atomctrl_mc_reg_table *table,
					काष्ठा ci_mc_reg_table *ni_table)
अणु
	uपूर्णांक8_t i, j;

	PP_ASSERT_WITH_CODE((table->last <= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),
		"Invalid VramInfo table.", वापस -EINVAL);
	PP_ASSERT_WITH_CODE((table->num_entries <= MAX_AC_TIMING_ENTRIES),
		"Invalid VramInfo table.", वापस -EINVAL);

	क्रम (i = 0; i < table->last; i++)
		ni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;

	ni_table->last = table->last;

	क्रम (i = 0; i < table->num_entries; i++) अणु
		ni_table->mc_reg_table_entry[i].mclk_max =
			table->mc_reg_table_entry[i].mclk_max;
		क्रम (j = 0; j < table->last; j++) अणु
			ni_table->mc_reg_table_entry[i].mc_data[j] =
				table->mc_reg_table_entry[i].mc_data[j];
		पूर्ण
	पूर्ण

	ni_table->num_entries = table->num_entries;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_mc_special_रेजिस्टरs(काष्ठा pp_hwmgr *hwmgr,
					काष्ठा ci_mc_reg_table *table)
अणु
	uपूर्णांक8_t i, j, k;
	uपूर्णांक32_t temp_reg;
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);

	क्रम (i = 0, j = table->last; i < table->last; i++) अणु
		PP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),
			"Invalid VramInfo table.", वापस -EINVAL);

		चयन (table->mc_reg_address[i].s1) अणु

		हाल mmMC_SEQ_MISC1:
			temp_reg = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_EMRS);
			table->mc_reg_address[j].s1 = mmMC_PMG_CMD_EMRS;
			table->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_EMRS_LP;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					((temp_reg & 0xffff0000)) |
					((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);
			पूर्ण
			j++;

			PP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),
				"Invalid VramInfo table.", वापस -EINVAL);
			temp_reg = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_MRS);
			table->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS;
			table->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS_LP;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) |
					(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);

				अगर (!data->is_memory_gddr5)
					table->mc_reg_table_entry[k].mc_data[j] |= 0x100;
			पूर्ण
			j++;

			अगर (!data->is_memory_gddr5) अणु
				PP_ASSERT_WITH_CODE((j < SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE),
					"Invalid VramInfo table.", वापस -EINVAL);
				table->mc_reg_address[j].s1 = mmMC_PMG_AUTO_CMD;
				table->mc_reg_address[j].s0 = mmMC_PMG_AUTO_CMD;
				क्रम (k = 0; k < table->num_entries; k++) अणु
					table->mc_reg_table_entry[k].mc_data[j] =
						(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;
				पूर्ण
				j++;
			पूर्ण

			अवरोध;

		हाल mmMC_SEQ_RESERVE_M:
			temp_reg = cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_MRS1);
			table->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS1;
			table->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS1_LP;
			क्रम (k = 0; k < table->num_entries; k++) अणु
				table->mc_reg_table_entry[k].mc_data[j] =
					(temp_reg & 0xffff0000) |
					(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);
			पूर्ण
			j++;
			अवरोध;

		शेष:
			अवरोध;
		पूर्ण

	पूर्ण

	table->last = j;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_set_valid_flag(काष्ठा ci_mc_reg_table *table)
अणु
	uपूर्णांक8_t i, j;

	क्रम (i = 0; i < table->last; i++) अणु
		क्रम (j = 1; j < table->num_entries; j++) अणु
			अगर (table->mc_reg_table_entry[j-1].mc_data[i] !=
				table->mc_reg_table_entry[j].mc_data[i]) अणु
				table->validflag |= (1 << i);
				अवरोध;
			पूर्ण
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक ci_initialize_mc_reg_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	पूर्णांक result;
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)(hwmgr->smu_backend);
	pp_atomctrl_mc_reg_table *table;
	काष्ठा ci_mc_reg_table *ni_table = &smu_data->mc_reg_table;
	uपूर्णांक8_t module_index = ci_get_memory_modile_index(hwmgr);

	table = kzalloc(माप(pp_atomctrl_mc_reg_table), GFP_KERNEL);

	अगर (शून्य == table)
		वापस -ENOMEM;

	/* Program additional LP रेजिस्टरs that are no दीर्घer programmed by VBIOS */
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RAS_TIMING_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RAS_TIMING));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_CAS_TIMING_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_CAS_TIMING));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_DLL_STBY_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_DLL_STBY));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CMD0_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CMD0));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CMD1_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CMD1));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CTRL_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_G5PDX_CTRL));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC_TIMING_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC_TIMING));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC_TIMING2_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_MISC_TIMING2));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_CMD_EMRS_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_EMRS));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_MRS));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS1_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_MRS1));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_D0_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_D0));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_D1_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_D1));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RD_CTL_D0_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RD_CTL_D0));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RD_CTL_D1_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_RD_CTL_D1));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_TIMING_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_TIMING));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS2_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_PMG_CMD_MRS2));
	cgs_ग_लिखो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_2_LP, cgs_पढ़ो_रेजिस्टर(hwmgr->device, mmMC_SEQ_WR_CTL_2));

	result = atomctrl_initialize_mc_reg_table(hwmgr, module_index, table);

	अगर (0 == result)
		result = ci_copy_vbios_smc_reg_table(table, ni_table);

	अगर (0 == result) अणु
		ci_set_s0_mc_reg_index(ni_table);
		result = ci_set_mc_special_रेजिस्टरs(hwmgr, ni_table);
	पूर्ण

	अगर (0 == result)
		ci_set_valid_flag(ni_table);

	kमुक्त(table);

	वापस result;
पूर्ण

अटल bool ci_is_dpm_running(काष्ठा pp_hwmgr *hwmgr)
अणु
	वापस ci_is_smc_ram_running(hwmgr);
पूर्ण

अटल पूर्णांक ci_smu_init(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा ci_smumgr *ci_priv = शून्य;

	ci_priv = kzalloc(माप(काष्ठा ci_smumgr), GFP_KERNEL);

	अगर (ci_priv == शून्य)
		वापस -ENOMEM;

	hwmgr->smu_backend = ci_priv;

	वापस 0;
पूर्ण

अटल पूर्णांक ci_smu_fini(काष्ठा pp_hwmgr *hwmgr)
अणु
	kमुक्त(hwmgr->smu_backend);
	hwmgr->smu_backend = शून्य;
	वापस 0;
पूर्ण

अटल पूर्णांक ci_start_smu(काष्ठा pp_hwmgr *hwmgr)
अणु
	वापस 0;
पूर्ण

अटल पूर्णांक ci_update_dpm_settings(काष्ठा pp_hwmgr *hwmgr,
				व्योम *profile_setting)
अणु
	काष्ठा smu7_hwmgr *data = (काष्ठा smu7_hwmgr *)(hwmgr->backend);
	काष्ठा ci_smumgr *smu_data = (काष्ठा ci_smumgr *)
			(hwmgr->smu_backend);
	काष्ठा profile_mode_setting *setting;
	काष्ठा SMU7_Discrete_GraphicsLevel *levels =
			smu_data->smc_state_table.GraphicsLevel;
	uपूर्णांक32_t array = smu_data->dpm_table_start +
			दुरत्व(SMU7_Discrete_DpmTable, GraphicsLevel);

	uपूर्णांक32_t mclk_array = smu_data->dpm_table_start +
			दुरत्व(SMU7_Discrete_DpmTable, MemoryLevel);
	काष्ठा SMU7_Discrete_MemoryLevel *mclk_levels =
			smu_data->smc_state_table.MemoryLevel;
	uपूर्णांक32_t i;
	uपूर्णांक32_t offset, up_hyst_offset, करोwn_hyst_offset, clk_activity_offset, पंचांगp;

	अगर (profile_setting == शून्य)
		वापस -EINVAL;

	setting = (काष्ठा profile_mode_setting *)profile_setting;

	अगर (setting->bupdate_sclk) अणु
		अगर (!data->sclk_dpm_key_disabled)
			smum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_FreezeLevel, शून्य);
		क्रम (i = 0; i < smu_data->smc_state_table.GraphicsDpmLevelCount; i++) अणु
			अगर (levels[i].ActivityLevel !=
				cpu_to_be16(setting->sclk_activity)) अणु
				levels[i].ActivityLevel = cpu_to_be16(setting->sclk_activity);

				clk_activity_offset = array + (माप(SMU7_Discrete_GraphicsLevel) * i)
						+ दुरत्व(SMU7_Discrete_GraphicsLevel, ActivityLevel);
				offset = clk_activity_offset & ~0x3;
				पंचांगp = PP_HOST_TO_SMC_UL(cgs_पढ़ो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset));
				पंचांगp = phm_set_field_to_u32(clk_activity_offset, पंचांगp, levels[i].ActivityLevel, माप(uपूर्णांक16_t));
				cgs_ग_लिखो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(पंचांगp));

			पूर्ण
			अगर (levels[i].UpH != setting->sclk_up_hyst ||
				levels[i].DownH != setting->sclk_करोwn_hyst) अणु
				levels[i].UpH = setting->sclk_up_hyst;
				levels[i].DownH = setting->sclk_करोwn_hyst;
				up_hyst_offset = array + (माप(SMU7_Discrete_GraphicsLevel) * i)
						+ दुरत्व(SMU7_Discrete_GraphicsLevel, UpH);
				करोwn_hyst_offset = array + (माप(SMU7_Discrete_GraphicsLevel) * i)
						+ दुरत्व(SMU7_Discrete_GraphicsLevel, DownH);
				offset = up_hyst_offset & ~0x3;
				पंचांगp = PP_HOST_TO_SMC_UL(cgs_पढ़ो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset));
				पंचांगp = phm_set_field_to_u32(up_hyst_offset, पंचांगp, levels[i].UpH, माप(uपूर्णांक8_t));
				पंचांगp = phm_set_field_to_u32(करोwn_hyst_offset, पंचांगp, levels[i].DownH, माप(uपूर्णांक8_t));
				cgs_ग_लिखो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(पंचांगp));
			पूर्ण
		पूर्ण
		अगर (!data->sclk_dpm_key_disabled)
			smum_send_msg_to_smc(hwmgr, PPSMC_MSG_SCLKDPM_Unमुक्तzeLevel, शून्य);
	पूर्ण

	अगर (setting->bupdate_mclk) अणु
		अगर (!data->mclk_dpm_key_disabled)
			smum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_FreezeLevel, शून्य);
		क्रम (i = 0; i < smu_data->smc_state_table.MemoryDpmLevelCount; i++) अणु
			अगर (mclk_levels[i].ActivityLevel !=
				cpu_to_be16(setting->mclk_activity)) अणु
				mclk_levels[i].ActivityLevel = cpu_to_be16(setting->mclk_activity);

				clk_activity_offset = mclk_array + (माप(SMU7_Discrete_MemoryLevel) * i)
						+ दुरत्व(SMU7_Discrete_MemoryLevel, ActivityLevel);
				offset = clk_activity_offset & ~0x3;
				पंचांगp = PP_HOST_TO_SMC_UL(cgs_पढ़ो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset));
				पंचांगp = phm_set_field_to_u32(clk_activity_offset, पंचांगp, mclk_levels[i].ActivityLevel, माप(uपूर्णांक16_t));
				cgs_ग_लिखो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(पंचांगp));

			पूर्ण
			अगर (mclk_levels[i].UpH != setting->mclk_up_hyst ||
				mclk_levels[i].DownH != setting->mclk_करोwn_hyst) अणु
				mclk_levels[i].UpH = setting->mclk_up_hyst;
				mclk_levels[i].DownH = setting->mclk_करोwn_hyst;
				up_hyst_offset = mclk_array + (माप(SMU7_Discrete_MemoryLevel) * i)
						+ दुरत्व(SMU7_Discrete_MemoryLevel, UpH);
				करोwn_hyst_offset = mclk_array + (माप(SMU7_Discrete_MemoryLevel) * i)
						+ दुरत्व(SMU7_Discrete_MemoryLevel, DownH);
				offset = up_hyst_offset & ~0x3;
				पंचांगp = PP_HOST_TO_SMC_UL(cgs_पढ़ो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset));
				पंचांगp = phm_set_field_to_u32(up_hyst_offset, पंचांगp, mclk_levels[i].UpH, माप(uपूर्णांक8_t));
				पंचांगp = phm_set_field_to_u32(करोwn_hyst_offset, पंचांगp, mclk_levels[i].DownH, माप(uपूर्णांक8_t));
				cgs_ग_लिखो_ind_रेजिस्टर(hwmgr->device, CGS_IND_REG__SMC, offset, PP_HOST_TO_SMC_UL(पंचांगp));
			पूर्ण
		पूर्ण
		अगर (!data->mclk_dpm_key_disabled)
			smum_send_msg_to_smc(hwmgr, PPSMC_MSG_MCLKDPM_Unमुक्तzeLevel, शून्य);
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक ci_update_uvd_smc_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा amdgpu_device *adev = hwmgr->adev;
	काष्ठा smu7_hwmgr *data = hwmgr->backend;
	काष्ठा ci_smumgr *smu_data = hwmgr->smu_backend;
	काष्ठा phm_uvd_घड़ी_voltage_dependency_table *uvd_table =
			hwmgr->dyn_state.uvd_घड़ी_voltage_dependency_table;
	uपूर्णांक32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROखाता_STANDARD |
					AMD_DPM_FORCED_LEVEL_PROखाता_MIN_SCLK |
					AMD_DPM_FORCED_LEVEL_PROखाता_MIN_MCLK |
					AMD_DPM_FORCED_LEVEL_PROखाता_PEAK;
	uपूर्णांक32_t max_vddc = adev->pm.ac_घातer ? hwmgr->dyn_state.max_घड़ी_voltage_on_ac.vddc :
						hwmgr->dyn_state.max_घड़ी_voltage_on_dc.vddc;
	पूर्णांक32_t i;

	अगर (PP_CAP(PHM_Platक्रमmCaps_UVDDPM) || uvd_table->count <= 0)
		smu_data->smc_state_table.UvdBootLevel = 0;
	अन्यथा
		smu_data->smc_state_table.UvdBootLevel = uvd_table->count - 1;

	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, DPM_TABLE_475,
				UvdBootLevel, smu_data->smc_state_table.UvdBootLevel);

	data->dpm_level_enable_mask.uvd_dpm_enable_mask = 0;

	क्रम (i = uvd_table->count - 1; i >= 0; i--) अणु
		अगर (uvd_table->entries[i].v <= max_vddc)
			data->dpm_level_enable_mask.uvd_dpm_enable_mask |= 1 << i;
		अगर (hwmgr->dpm_level & profile_mode_mask || !PP_CAP(PHM_Platक्रमmCaps_UVDDPM))
			अवरोध;
	पूर्ण
	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_UVDDPM_SetEnabledMask,
				data->dpm_level_enable_mask.uvd_dpm_enable_mask,
				शून्य);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_update_vce_smc_table(काष्ठा pp_hwmgr *hwmgr)
अणु
	काष्ठा amdgpu_device *adev = hwmgr->adev;
	काष्ठा smu7_hwmgr *data = hwmgr->backend;
	काष्ठा phm_vce_घड़ी_voltage_dependency_table *vce_table =
			hwmgr->dyn_state.vce_घड़ी_voltage_dependency_table;
	uपूर्णांक32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROखाता_STANDARD |
					AMD_DPM_FORCED_LEVEL_PROखाता_MIN_SCLK |
					AMD_DPM_FORCED_LEVEL_PROखाता_MIN_MCLK |
					AMD_DPM_FORCED_LEVEL_PROखाता_PEAK;
	uपूर्णांक32_t max_vddc = adev->pm.ac_घातer ? hwmgr->dyn_state.max_घड़ी_voltage_on_ac.vddc :
						hwmgr->dyn_state.max_घड़ी_voltage_on_dc.vddc;
	पूर्णांक32_t i;

	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, DPM_TABLE_475,
				VceBootLevel, 0); /* temp hard code to level 0, vce can set min evclk*/

	data->dpm_level_enable_mask.vce_dpm_enable_mask = 0;

	क्रम (i = vce_table->count - 1; i >= 0; i--) अणु
		अगर (vce_table->entries[i].v <= max_vddc)
			data->dpm_level_enable_mask.vce_dpm_enable_mask |= 1 << i;
		अगर (hwmgr->dpm_level & profile_mode_mask || !PP_CAP(PHM_Platक्रमmCaps_VCEDPM))
			अवरोध;
	पूर्ण
	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_VCEDPM_SetEnabledMask,
				data->dpm_level_enable_mask.vce_dpm_enable_mask,
				शून्य);

	वापस 0;
पूर्ण

अटल पूर्णांक ci_update_smc_table(काष्ठा pp_hwmgr *hwmgr, uपूर्णांक32_t type)
अणु
	चयन (type) अणु
	हाल SMU_UVD_TABLE:
		ci_update_uvd_smc_table(hwmgr);
		अवरोध;
	हाल SMU_VCE_TABLE:
		ci_update_vce_smc_table(hwmgr);
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम ci_reset_smc(काष्ठा pp_hwmgr *hwmgr)
अणु
	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,
				  SMC_SYSCON_RESET_CNTL,
				  rst_reg, 1);
पूर्ण


अटल व्योम ci_stop_smc_घड़ी(काष्ठा pp_hwmgr *hwmgr)
अणु
	PHM_WRITE_INसूचीECT_FIELD(hwmgr->device, CGS_IND_REG__SMC,
				  SMC_SYSCON_CLOCK_CNTL_0,
				  ck_disable, 1);
पूर्ण

अटल पूर्णांक ci_stop_smc(काष्ठा pp_hwmgr *hwmgr)
अणु
	ci_reset_smc(hwmgr);
	ci_stop_smc_घड़ी(hwmgr);

	वापस 0;
पूर्ण

स्थिर काष्ठा pp_smumgr_func ci_smu_funcs = अणु
	.name = "ci_smu",
	.smu_init = ci_smu_init,
	.smu_fini = ci_smu_fini,
	.start_smu = ci_start_smu,
	.check_fw_load_finish = शून्य,
	.request_smu_load_fw = शून्य,
	.request_smu_load_specअगरic_fw = शून्य,
	.send_msg_to_smc = ci_send_msg_to_smc,
	.send_msg_to_smc_with_parameter = ci_send_msg_to_smc_with_parameter,
	.get_argument = smu7_get_argument,
	.करोwnload_pptable_settings = शून्य,
	.upload_pptable_settings = शून्य,
	.get_दुरत्व = ci_get_दुरत्व,
	.process_firmware_header = ci_process_firmware_header,
	.init_smc_table = ci_init_smc_table,
	.update_sclk_threshold = ci_update_sclk_threshold,
	.thermal_setup_fan_table = ci_thermal_setup_fan_table,
	.populate_all_graphic_levels = ci_populate_all_graphic_levels,
	.populate_all_memory_levels = ci_populate_all_memory_levels,
	.get_mac_definition = ci_get_mac_definition,
	.initialize_mc_reg_table = ci_initialize_mc_reg_table,
	.is_dpm_running = ci_is_dpm_running,
	.update_dpm_settings = ci_update_dpm_settings,
	.update_smc_table = ci_update_smc_table,
	.stop_smc = ci_stop_smc,
पूर्ण;
