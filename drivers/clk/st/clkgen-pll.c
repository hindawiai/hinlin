<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*
 * Copyright (C) 2014 STMicroelectronics (R&D) Limited
 */

/*
 * Authors:
 * Stephen Gallimore <stephen.gallimore@st.com>,
 * Pankaj Dev <pankaj.dev@st.com>.
 */

#समावेश <linux/slab.h>
#समावेश <linux/of_address.h>
#समावेश <linux/clk.h>
#समावेश <linux/clk-provider.h>
#समावेश <linux/iopoll.h>

#समावेश "clkgen.h"

अटल DEFINE_SPINLOCK(clkgena_c32_odf_lock);
DEFINE_SPINLOCK(clkgen_a9_lock);

/*
 * PLL configuration रेजिस्टर bits क्रम PLL3200 C32
 */
#घोषणा C32_NDIV_MASK (0xff)
#घोषणा C32_IDF_MASK (0x7)
#घोषणा C32_ODF_MASK (0x3f)
#घोषणा C32_LDF_MASK (0x7f)
#घोषणा C32_CP_MASK (0x1f)

#घोषणा C32_MAX_ODFS (4)

/*
 * PLL configuration रेजिस्टर bits क्रम PLL4600 C28
 */
#घोषणा C28_NDIV_MASK (0xff)
#घोषणा C28_IDF_MASK (0x7)
#घोषणा C28_ODF_MASK (0x3f)

काष्ठा clkgen_pll_data अणु
	काष्ठा clkgen_field pdn_status;
	काष्ठा clkgen_field pdn_ctrl;
	काष्ठा clkgen_field locked_status;
	काष्ठा clkgen_field mभाग;
	काष्ठा clkgen_field nभाग;
	काष्ठा clkgen_field pभाग;
	काष्ठा clkgen_field idf;
	काष्ठा clkgen_field ldf;
	काष्ठा clkgen_field cp;
	अचिन्हित पूर्णांक num_odfs;
	काष्ठा clkgen_field odf[C32_MAX_ODFS];
	काष्ठा clkgen_field odf_gate[C32_MAX_ODFS];
	bool चयन2pll_en;
	काष्ठा clkgen_field चयन2pll;
	spinlock_t *lock;
	स्थिर काष्ठा clk_ops *ops;
पूर्ण;

अटल स्थिर काष्ठा clk_ops sपंचांग_pll3200c32_ops;
अटल स्थिर काष्ठा clk_ops sपंचांग_pll3200c32_a9_ops;
अटल स्थिर काष्ठा clk_ops sपंचांग_pll4600c28_ops;

अटल स्थिर काष्ठा clkgen_pll_data st_pll3200c32_cx_0 = अणु
	/* 407 C0 PLL0 */
	.pdn_status	= CLKGEN_FIELD(0x2a0,	0x1,			8),
	.pdn_ctrl	= CLKGEN_FIELD(0x2a0,	0x1,			8),
	.locked_status	= CLKGEN_FIELD(0x2a0,	0x1,			24),
	.nभाग		= CLKGEN_FIELD(0x2a4,	C32_NDIV_MASK,		16),
	.idf		= CLKGEN_FIELD(0x2a4,	C32_IDF_MASK,		0x0),
	.num_odfs = 1,
	.odf		= अणु CLKGEN_FIELD(0x2b4, C32_ODF_MASK,		0) पूर्ण,
	.odf_gate	= अणु CLKGEN_FIELD(0x2b4, 0x1,			6) पूर्ण,
	.ops		= &sपंचांग_pll3200c32_ops,
पूर्ण;

अटल स्थिर काष्ठा clkgen_pll_data st_pll3200c32_cx_1 = अणु
	/* 407 C0 PLL1 */
	.pdn_status	= CLKGEN_FIELD(0x2c8,	0x1,			8),
	.pdn_ctrl	= CLKGEN_FIELD(0x2c8,	0x1,			8),
	.locked_status	= CLKGEN_FIELD(0x2c8,	0x1,			24),
	.nभाग		= CLKGEN_FIELD(0x2cc,	C32_NDIV_MASK,		16),
	.idf		= CLKGEN_FIELD(0x2cc,	C32_IDF_MASK,		0x0),
	.num_odfs = 1,
	.odf		= अणु CLKGEN_FIELD(0x2dc, C32_ODF_MASK,		0) पूर्ण,
	.odf_gate	= अणु CLKGEN_FIELD(0x2dc, 0x1,			6) पूर्ण,
	.ops		= &sपंचांग_pll3200c32_ops,
पूर्ण;

अटल स्थिर काष्ठा clkgen_pll_data st_pll3200c32_407_a9 = अणु
	/* 407 A9 */
	.pdn_status	= CLKGEN_FIELD(0x1a8,	0x1,			0),
	.pdn_ctrl	= CLKGEN_FIELD(0x1a8,	0x1,			0),
	.locked_status	= CLKGEN_FIELD(0x87c,	0x1,			0),
	.nभाग		= CLKGEN_FIELD(0x1b0,	C32_NDIV_MASK,		0),
	.idf		= CLKGEN_FIELD(0x1a8,	C32_IDF_MASK,		25),
	.num_odfs = 1,
	.odf		= अणु CLKGEN_FIELD(0x1b0, C32_ODF_MASK,		8) पूर्ण,
	.odf_gate	= अणु CLKGEN_FIELD(0x1ac, 0x1,			28) पूर्ण,
	.चयन2pll_en	= true,
	.cp		= CLKGEN_FIELD(0x1a8,	C32_CP_MASK,		1),
	.चयन2pll	= CLKGEN_FIELD(0x1a4,	0x1,			1),
	.lock = &clkgen_a9_lock,
	.ops		= &sपंचांग_pll3200c32_a9_ops,
पूर्ण;

अटल काष्ठा clkgen_pll_data st_pll4600c28_418_a9 = अणु
	/* 418 A9 */
	.pdn_status	= CLKGEN_FIELD(0x1a8,	0x1,			0),
	.pdn_ctrl	= CLKGEN_FIELD(0x1a8,	0x1,			0),
	.locked_status	= CLKGEN_FIELD(0x87c,	0x1,			0),
	.nभाग		= CLKGEN_FIELD(0x1b0,	C28_NDIV_MASK,		0),
	.idf		= CLKGEN_FIELD(0x1a8,	C28_IDF_MASK,		25),
	.num_odfs = 1,
	.odf		= अणु CLKGEN_FIELD(0x1b0, C28_ODF_MASK,		8) पूर्ण,
	.odf_gate	= अणु CLKGEN_FIELD(0x1ac, 0x1,			28) पूर्ण,
	.चयन2pll_en	= true,
	.चयन2pll	= CLKGEN_FIELD(0x1a4,	0x1,			1),
	.lock		= &clkgen_a9_lock,
	.ops		= &sपंचांग_pll4600c28_ops,
पूर्ण;

/**
 * DOC: Clock Generated by PLL, rate set and enabled by bootloader
 *
 * Traits of this घड़ी:
 * prepare - clk_(un)prepare only ensures parent is (un)prepared
 * enable - clk_enable/disable only ensures parent is enabled
 * rate - rate is fixed. No clk_set_rate support
 * parent - fixed parent.  No clk_set_parent support
 */

/*
 * PLL घड़ी that is पूर्णांकegrated in the ClockGenA instances on the STiH415
 * and STiH416.
 *
 * @hw: handle between common and hardware-specअगरic पूर्णांकerfaces.
 * @regs_base: base of the PLL configuration रेजिस्टर(s).
 *
 */
काष्ठा clkgen_pll अणु
	काष्ठा clk_hw		hw;
	काष्ठा clkgen_pll_data	*data;
	व्योम __iomem		*regs_base;
	spinlock_t	*lock;

	u32 nभाग;
	u32 idf;
	u32 odf;
	u32 cp;
पूर्ण;

#घोषणा to_clkgen_pll(_hw) container_of(_hw, काष्ठा clkgen_pll, hw)

काष्ठा sपंचांग_pll अणु
	अचिन्हित दीर्घ mभाग;
	अचिन्हित दीर्घ nभाग;
	अचिन्हित दीर्घ pभाग;
	अचिन्हित दीर्घ odf;
	अचिन्हित दीर्घ idf;
	अचिन्हित दीर्घ ldf;
	अचिन्हित दीर्घ cp;
पूर्ण;

अटल पूर्णांक clkgen_pll_is_locked(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	u32 locked = CLKGEN_READ(pll, locked_status);

	वापस !!locked;
पूर्ण

अटल पूर्णांक clkgen_pll_is_enabled(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	u32 घातeroff = CLKGEN_READ(pll, pdn_status);
	वापस !घातeroff;
पूर्ण

अटल पूर्णांक __clkgen_pll_enable(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	व्योम __iomem *base =  pll->regs_base;
	काष्ठा clkgen_field *field = &pll->data->locked_status;
	पूर्णांक ret = 0;
	u32 reg;

	अगर (clkgen_pll_is_enabled(hw))
		वापस 0;

	CLKGEN_WRITE(pll, pdn_ctrl, 0);

	ret = पढ़ोl_relaxed_poll_समयout(base + field->offset, reg,
			!!((reg >> field->shअगरt) & field->mask),  0, 10000);

	अगर (!ret) अणु
		अगर (pll->data->चयन2pll_en)
			CLKGEN_WRITE(pll, चयन2pll, 0);

		pr_debug("%s:%s enabled\n", __clk_get_name(hw->clk), __func__);
	पूर्ण

	वापस ret;
पूर्ण

अटल पूर्णांक clkgen_pll_enable(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	अचिन्हित दीर्घ flags = 0;
	पूर्णांक ret = 0;

	अगर (pll->lock)
		spin_lock_irqsave(pll->lock, flags);

	ret = __clkgen_pll_enable(hw);

	अगर (pll->lock)
		spin_unlock_irqrestore(pll->lock, flags);

	वापस ret;
पूर्ण

अटल व्योम __clkgen_pll_disable(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);

	अगर (!clkgen_pll_is_enabled(hw))
		वापस;

	अगर (pll->data->चयन2pll_en)
		CLKGEN_WRITE(pll, चयन2pll, 1);

	CLKGEN_WRITE(pll, pdn_ctrl, 1);

	pr_debug("%s:%s disabled\n", __clk_get_name(hw->clk), __func__);
पूर्ण

अटल व्योम clkgen_pll_disable(काष्ठा clk_hw *hw)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	अचिन्हित दीर्घ flags = 0;

	अगर (pll->lock)
		spin_lock_irqsave(pll->lock, flags);

	__clkgen_pll_disable(hw);

	अगर (pll->lock)
		spin_unlock_irqrestore(pll->lock, flags);
पूर्ण

अटल पूर्णांक clk_pll3200c32_get_params(अचिन्हित दीर्घ input, अचिन्हित दीर्घ output,
			  काष्ठा sपंचांग_pll *pll)
अणु
	अचिन्हित दीर्घ i, n;
	अचिन्हित दीर्घ deviation = ~0;
	अचिन्हित दीर्घ new_freq;
	दीर्घ new_deviation;
	/* Charge pump table: highest nभाग value क्रम cp=6 to 25 */
	अटल स्थिर अचिन्हित अक्षर cp_table[] = अणु
		48, 56, 64, 72, 80, 88, 96, 104, 112, 120,
		128, 136, 144, 152, 160, 168, 176, 184, 192
	पूर्ण;

	/* Output घड़ी range: 800Mhz to 1600Mhz */
	अगर (output < 800000000 || output > 1600000000)
		वापस -EINVAL;

	input /= 1000;
	output /= 1000;

	क्रम (i = 1; i <= 7 && deviation; i++) अणु
		n = i * output / (2 * input);

		/* Checks */
		अगर (n < 8)
			जारी;
		अगर (n > 200)
			अवरोध;

		new_freq = (input * 2 * n) / i;

		new_deviation = असल(new_freq - output);

		अगर (!new_deviation || new_deviation < deviation) अणु
			pll->idf  = i;
			pll->nभाग = n;
			deviation = new_deviation;
		पूर्ण
	पूर्ण

	अगर (deviation == ~0) /* No solution found */
		वापस -EINVAL;

	/* Computing recommended अक्षरge pump value */
	क्रम (pll->cp = 6; pll->nभाग > cp_table[pll->cp-6]; (pll->cp)++)
		;

	वापस 0;
पूर्ण

अटल पूर्णांक clk_pll3200c32_get_rate(अचिन्हित दीर्घ input, काष्ठा sपंचांग_pll *pll,
			अचिन्हित दीर्घ *rate)
अणु
	अगर (!pll->idf)
		pll->idf = 1;

	*rate = ((2 * (input / 1000) * pll->nभाग) / pll->idf) * 1000;

	वापस 0;
पूर्ण

अटल अचिन्हित दीर्घ recalc_sपंचांग_pll3200c32(काष्ठा clk_hw *hw,
		अचिन्हित दीर्घ parent_rate)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	अचिन्हित दीर्घ nभाग, idf;
	अचिन्हित दीर्घ rate = 0;

	अगर (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))
		वापस 0;

	nभाग = CLKGEN_READ(pll, nभाग);
	idf = CLKGEN_READ(pll, idf);

	अगर (idf)
		/* Note: input is भागided to aव्योम overflow */
		rate = ((2 * (parent_rate/1000) * nभाग) / idf) * 1000;

	pr_debug("%s:%s rate %lu\n", clk_hw_get_name(hw), __func__, rate);

	वापस rate;
पूर्ण

अटल दीर्घ round_rate_sपंचांग_pll3200c32(काष्ठा clk_hw *hw, अचिन्हित दीर्घ rate,
		अचिन्हित दीर्घ *prate)
अणु
	काष्ठा sपंचांग_pll params;

	अगर (!clk_pll3200c32_get_params(*prate, rate, &params))
		clk_pll3200c32_get_rate(*prate, &params, &rate);
	अन्यथा अणु
		pr_debug("%s: %s rate %ld Invalid\n", __func__,
			 __clk_get_name(hw->clk), rate);
		वापस 0;
	पूर्ण

	pr_debug("%s: %s new rate %ld [ndiv=%u] [idf=%u]\n",
		 __func__, __clk_get_name(hw->clk),
		 rate, (अचिन्हित पूर्णांक)params.nभाग,
		 (अचिन्हित पूर्णांक)params.idf);

	वापस rate;
पूर्ण

अटल पूर्णांक set_rate_sपंचांग_pll3200c32(काष्ठा clk_hw *hw, अचिन्हित दीर्घ rate,
				अचिन्हित दीर्घ parent_rate)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	काष्ठा sपंचांग_pll params;
	दीर्घ hwrate = 0;
	अचिन्हित दीर्घ flags = 0;

	अगर (!rate || !parent_rate)
		वापस -EINVAL;

	अगर (!clk_pll3200c32_get_params(parent_rate, rate, &params))
		clk_pll3200c32_get_rate(parent_rate, &params, &hwrate);

	pr_debug("%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\n",
		 __func__, __clk_get_name(hw->clk),
		 hwrate, (अचिन्हित पूर्णांक)params.nभाग,
		 (अचिन्हित पूर्णांक)params.idf);

	अगर (!hwrate)
		वापस -EINVAL;

	pll->nभाग = params.nभाग;
	pll->idf = params.idf;
	pll->cp = params.cp;

	__clkgen_pll_disable(hw);

	अगर (pll->lock)
		spin_lock_irqsave(pll->lock, flags);

	CLKGEN_WRITE(pll, nभाग, pll->nभाग);
	CLKGEN_WRITE(pll, idf, pll->idf);
	CLKGEN_WRITE(pll, cp, pll->cp);

	अगर (pll->lock)
		spin_unlock_irqrestore(pll->lock, flags);

	__clkgen_pll_enable(hw);

	वापस 0;
पूर्ण

/* PLL output काष्ठाure
 * FVCO >> /2 >> FVCOBY2 (no output)
 *                 |> Divider (ODF) >> PHI
 *
 * FVCOby2 output = (input * 2 * NDIV) / IDF (assuming FRAC_CONTROL==L)
 *
 * Rules:
 *   4Mhz <= INFF input <= 350Mhz
 *   4Mhz <= INFIN (INFF / IDF) <= 50Mhz
 *   19.05Mhz <= FVCOby2 output (PHI w ODF=1) <= 3000Mhz
 *   1 <= i (रेजिस्टर/dec value क्रम IDF) <= 7
 *   8 <= n (रेजिस्टर/dec value क्रम NDIV) <= 246
 */

अटल पूर्णांक clk_pll4600c28_get_params(अचिन्हित दीर्घ input, अचिन्हित दीर्घ output,
			  काष्ठा sपंचांग_pll *pll)
अणु

	अचिन्हित दीर्घ i, infin, n;
	अचिन्हित दीर्घ deviation = ~0;
	अचिन्हित दीर्घ new_freq, new_deviation;

	/* Output घड़ी range: 19Mhz to 3000Mhz */
	अगर (output < 19000000 || output > 3000000000u)
		वापस -EINVAL;

	/* For better jitter, IDF should be smallest and NDIV must be maximum */
	क्रम (i = 1; i <= 7 && deviation; i++) अणु
		/* INFIN checks */
		infin = input / i;
		अगर (infin < 4000000 || infin > 50000000)
			जारी;	/* Invalid हाल */

		n = output / (infin * 2);
		अगर (n < 8 || n > 246)
			जारी;	/* Invalid हाल */
		अगर (n < 246)
			n++;	/* To work around 'y' when n=x.y */

		क्रम (; n >= 8 && deviation; n--) अणु
			new_freq = infin * 2 * n;
			अगर (new_freq < output)
				अवरोध;	/* Optimization: लघुing loop */

			new_deviation = new_freq - output;
			अगर (!new_deviation || new_deviation < deviation) अणु
				pll->idf  = i;
				pll->nभाग = n;
				deviation = new_deviation;
			पूर्ण
		पूर्ण
	पूर्ण

	अगर (deviation == ~0) /* No solution found */
		वापस -EINVAL;

	वापस 0;
पूर्ण

अटल पूर्णांक clk_pll4600c28_get_rate(अचिन्हित दीर्घ input, काष्ठा sपंचांग_pll *pll,
			अचिन्हित दीर्घ *rate)
अणु
	अगर (!pll->idf)
		pll->idf = 1;

	*rate = (input / pll->idf) * 2 * pll->nभाग;

	वापस 0;
पूर्ण

अटल अचिन्हित दीर्घ recalc_sपंचांग_pll4600c28(काष्ठा clk_hw *hw,
				    अचिन्हित दीर्घ parent_rate)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	काष्ठा sपंचांग_pll params;
	अचिन्हित दीर्घ rate;

	अगर (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))
		वापस 0;

	params.nभाग = CLKGEN_READ(pll, nभाग);
	params.idf = CLKGEN_READ(pll, idf);

	clk_pll4600c28_get_rate(parent_rate, &params, &rate);

	pr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);

	वापस rate;
पूर्ण

अटल दीर्घ round_rate_sपंचांग_pll4600c28(काष्ठा clk_hw *hw, अचिन्हित दीर्घ rate,
				      अचिन्हित दीर्घ *prate)
अणु
	काष्ठा sपंचांग_pll params;

	अगर (!clk_pll4600c28_get_params(*prate, rate, &params)) अणु
		clk_pll4600c28_get_rate(*prate, &params, &rate);
	पूर्ण अन्यथा अणु
		pr_debug("%s: %s rate %ld Invalid\n", __func__,
			 __clk_get_name(hw->clk), rate);
		वापस 0;
	पूर्ण

	pr_debug("%s: %s new rate %ld [ndiv=%u] [idf=%u]\n",
		 __func__, __clk_get_name(hw->clk),
		 rate, (अचिन्हित पूर्णांक)params.nभाग,
		 (अचिन्हित पूर्णांक)params.idf);

	वापस rate;
पूर्ण

अटल पूर्णांक set_rate_sपंचांग_pll4600c28(काष्ठा clk_hw *hw, अचिन्हित दीर्घ rate,
				   अचिन्हित दीर्घ parent_rate)
अणु
	काष्ठा clkgen_pll *pll = to_clkgen_pll(hw);
	काष्ठा sपंचांग_pll params;
	दीर्घ hwrate;
	अचिन्हित दीर्घ flags = 0;

	अगर (!rate || !parent_rate)
		वापस -EINVAL;

	अगर (!clk_pll4600c28_get_params(parent_rate, rate, &params)) अणु
		clk_pll4600c28_get_rate(parent_rate, &params, &hwrate);
	पूर्ण अन्यथा अणु
		pr_debug("%s: %s rate %ld Invalid\n", __func__,
			 __clk_get_name(hw->clk), rate);
		वापस -EINVAL;
	पूर्ण

	pr_debug("%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\n",
		 __func__, __clk_get_name(hw->clk),
		 hwrate, (अचिन्हित पूर्णांक)params.nभाग,
		 (अचिन्हित पूर्णांक)params.idf);

	अगर (!hwrate)
		वापस -EINVAL;

	pll->nभाग = params.nभाग;
	pll->idf = params.idf;

	__clkgen_pll_disable(hw);

	अगर (pll->lock)
		spin_lock_irqsave(pll->lock, flags);

	CLKGEN_WRITE(pll, nभाग, pll->nभाग);
	CLKGEN_WRITE(pll, idf, pll->idf);

	अगर (pll->lock)
		spin_unlock_irqrestore(pll->lock, flags);

	__clkgen_pll_enable(hw);

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा clk_ops sपंचांग_pll3200c32_ops = अणु
	.enable		= clkgen_pll_enable,
	.disable	= clkgen_pll_disable,
	.is_enabled	= clkgen_pll_is_enabled,
	.recalc_rate	= recalc_sपंचांग_pll3200c32,
पूर्ण;

अटल स्थिर काष्ठा clk_ops sपंचांग_pll3200c32_a9_ops = अणु
	.enable		= clkgen_pll_enable,
	.disable	= clkgen_pll_disable,
	.is_enabled	= clkgen_pll_is_enabled,
	.recalc_rate	= recalc_sपंचांग_pll3200c32,
	.round_rate	= round_rate_sपंचांग_pll3200c32,
	.set_rate	= set_rate_sपंचांग_pll3200c32,
पूर्ण;

अटल स्थिर काष्ठा clk_ops sपंचांग_pll4600c28_ops = अणु
	.enable		= clkgen_pll_enable,
	.disable	= clkgen_pll_disable,
	.is_enabled	= clkgen_pll_is_enabled,
	.recalc_rate	= recalc_sपंचांग_pll4600c28,
	.round_rate	= round_rate_sपंचांग_pll4600c28,
	.set_rate	= set_rate_sपंचांग_pll4600c28,
पूर्ण;

अटल काष्ठा clk * __init clkgen_pll_रेजिस्टर(स्थिर अक्षर *parent_name,
				काष्ठा clkgen_pll_data	*pll_data,
				व्योम __iomem *reg, अचिन्हित दीर्घ pll_flags,
				स्थिर अक्षर *clk_name, spinlock_t *lock)
अणु
	काष्ठा clkgen_pll *pll;
	काष्ठा clk *clk;
	काष्ठा clk_init_data init;

	pll = kzalloc(माप(*pll), GFP_KERNEL);
	अगर (!pll)
		वापस ERR_PTR(-ENOMEM);

	init.name = clk_name;
	init.ops = pll_data->ops;

	init.flags = pll_flags | CLK_GET_RATE_NOCACHE;
	init.parent_names = &parent_name;
	init.num_parents  = 1;

	pll->data = pll_data;
	pll->regs_base = reg;
	pll->hw.init = &init;
	pll->lock = lock;

	clk = clk_रेजिस्टर(शून्य, &pll->hw);
	अगर (IS_ERR(clk)) अणु
		kमुक्त(pll);
		वापस clk;
	पूर्ण

	pr_debug("%s: parent %s rate %lu\n",
			__clk_get_name(clk),
			__clk_get_name(clk_get_parent(clk)),
			clk_get_rate(clk));

	वापस clk;
पूर्ण

अटल व्योम __iomem * __init clkgen_get_रेजिस्टर_base(
				काष्ठा device_node *np)
अणु
	काष्ठा device_node *pnode;
	व्योम __iomem *reg = शून्य;

	pnode = of_get_parent(np);
	अगर (!pnode)
		वापस शून्य;

	reg = of_iomap(pnode, 0);

	of_node_put(pnode);
	वापस reg;
पूर्ण

अटल काष्ठा clk * __init clkgen_odf_रेजिस्टर(स्थिर अक्षर *parent_name,
					       व्योम __iomem *reg,
					       काष्ठा clkgen_pll_data *pll_data,
					       अचिन्हित दीर्घ pll_flags, पूर्णांक odf,
					       spinlock_t *odf_lock,
					       स्थिर अक्षर *odf_name)
अणु
	काष्ठा clk *clk;
	अचिन्हित दीर्घ flags;
	काष्ठा clk_gate *gate;
	काष्ठा clk_भागider *भाग;

	flags = pll_flags | CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT;

	gate = kzalloc(माप(*gate), GFP_KERNEL);
	अगर (!gate)
		वापस ERR_PTR(-ENOMEM);

	gate->flags = CLK_GATE_SET_TO_DISABLE;
	gate->reg = reg + pll_data->odf_gate[odf].offset;
	gate->bit_idx = pll_data->odf_gate[odf].shअगरt;
	gate->lock = odf_lock;

	भाग = kzalloc(माप(*भाग), GFP_KERNEL);
	अगर (!भाग) अणु
		kमुक्त(gate);
		वापस ERR_PTR(-ENOMEM);
	पूर्ण

	भाग->flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;
	भाग->reg = reg + pll_data->odf[odf].offset;
	भाग->shअगरt = pll_data->odf[odf].shअगरt;
	भाग->width = fls(pll_data->odf[odf].mask);
	भाग->lock = odf_lock;

	clk = clk_रेजिस्टर_composite(शून्य, odf_name, &parent_name, 1,
				     शून्य, शून्य,
				     &भाग->hw, &clk_भागider_ops,
				     &gate->hw, &clk_gate_ops,
				     flags);
	अगर (IS_ERR(clk))
		वापस clk;

	pr_debug("%s: parent %s rate %lu\n",
			__clk_get_name(clk),
			__clk_get_name(clk_get_parent(clk)),
			clk_get_rate(clk));
	वापस clk;
पूर्ण


अटल व्योम __init clkgen_c32_pll_setup(काष्ठा device_node *np,
		काष्ठा clkgen_pll_data *data)
अणु
	काष्ठा clk *clk;
	स्थिर अक्षर *parent_name, *pll_name;
	व्योम __iomem *pll_base;
	पूर्णांक num_odfs, odf;
	काष्ठा clk_onecell_data *clk_data;
	अचिन्हित दीर्घ pll_flags = 0;


	parent_name = of_clk_get_parent_name(np, 0);
	अगर (!parent_name)
		वापस;

	pll_base = clkgen_get_रेजिस्टर_base(np);
	अगर (!pll_base)
		वापस;

	of_clk_detect_critical(np, 0, &pll_flags);

	clk = clkgen_pll_रेजिस्टर(parent_name, data, pll_base, pll_flags,
				  np->name, data->lock);
	अगर (IS_ERR(clk))
		वापस;

	pll_name = __clk_get_name(clk);

	num_odfs = data->num_odfs;

	clk_data = kzalloc(माप(*clk_data), GFP_KERNEL);
	अगर (!clk_data)
		वापस;

	clk_data->clk_num = num_odfs;
	clk_data->clks = kसुस्मृति(clk_data->clk_num, माप(काष्ठा clk *),
				 GFP_KERNEL);

	अगर (!clk_data->clks)
		जाओ err;

	क्रम (odf = 0; odf < num_odfs; odf++) अणु
		काष्ठा clk *clk;
		स्थिर अक्षर *clk_name;
		अचिन्हित दीर्घ odf_flags = 0;

		अगर (of_property_पढ़ो_string_index(np, "clock-output-names",
						  odf, &clk_name))
			वापस;

		of_clk_detect_critical(np, odf, &odf_flags);

		clk = clkgen_odf_रेजिस्टर(pll_name, pll_base, data, odf_flags,
				odf, &clkgena_c32_odf_lock, clk_name);
		अगर (IS_ERR(clk))
			जाओ err;

		clk_data->clks[odf] = clk;
	पूर्ण

	of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
	वापस;

err:
	kमुक्त(pll_name);
	kमुक्त(clk_data->clks);
	kमुक्त(clk_data);
पूर्ण
अटल व्योम __init clkgen_c32_pll0_setup(काष्ठा device_node *np)
अणु
	clkgen_c32_pll_setup(np,
			(काष्ठा clkgen_pll_data *) &st_pll3200c32_cx_0);
पूर्ण
CLK_OF_DECLARE(c32_pll0, "st,clkgen-pll0", clkgen_c32_pll0_setup);

अटल व्योम __init clkgen_c32_pll1_setup(काष्ठा device_node *np)
अणु
	clkgen_c32_pll_setup(np,
			(काष्ठा clkgen_pll_data *) &st_pll3200c32_cx_1);
पूर्ण
CLK_OF_DECLARE(c32_pll1, "st,clkgen-pll1", clkgen_c32_pll1_setup);

अटल व्योम __init clkgen_c32_plla9_setup(काष्ठा device_node *np)
अणु
	clkgen_c32_pll_setup(np,
			(काष्ठा clkgen_pll_data *) &st_pll3200c32_407_a9);
पूर्ण
CLK_OF_DECLARE(c32_plla9, "st,stih407-clkgen-plla9", clkgen_c32_plla9_setup);

अटल व्योम __init clkgen_c28_plla9_setup(काष्ठा device_node *np)
अणु
	clkgen_c32_pll_setup(np,
			(काष्ठा clkgen_pll_data *) &st_pll4600c28_418_a9);
पूर्ण
CLK_OF_DECLARE(c28_plla9, "st,stih418-clkgen-plla9", clkgen_c28_plla9_setup);
