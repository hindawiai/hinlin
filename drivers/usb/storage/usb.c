<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0+
/*
 * Driver क्रम USB Mass Storage compliant devices
 *
 * Current development and मुख्यtenance by:
 *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
 *
 * Developed with the assistance of:
 *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)
 *   (c) 2003-2009 Alan Stern (stern@rowland.harvard.edu)
 *
 * Initial work by:
 *   (c) 1999 Michael Gee (michael@linuxspecअगरic.com)
 *
 * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):
 *   (c) 2000 Yggdrasil Computing, Inc.
 *
 * This driver is based on the 'USB Mass Storage Class' करोcument. This
 * describes in detail the protocol used to communicate with such
 * devices.  Clearly, the designers had SCSI and ATAPI commands in
 * mind when they created this करोcument.  The commands are all very
 * similar to commands in the SCSI-II and ATAPI specअगरications.
 *
 * It is important to note that in a number of हालs this class
 * exhibits class-specअगरic exemptions from the USB specअगरication.
 * Notably the usage of NAK, STALL and ACK dअगरfers from the norm, in
 * that they are used to communicate रुको, failed and OK on commands.
 *
 * Also, क्रम certain devices, the पूर्णांकerrupt endpoपूर्णांक is used to convey
 * status of a command.
 */

#अगर_घोषित CONFIG_USB_STORAGE_DEBUG
#घोषणा DEBUG
#पूर्ण_अगर

#समावेश <linux/sched.h>
#समावेश <linux/त्रुटिसं.स>
#समावेश <linux/module.h>
#समावेश <linux/slab.h>
#समावेश <linux/kthपढ़ो.h>
#समावेश <linux/mutex.h>
#समावेश <linux/utsname.h>

#समावेश <scsi/scsi.h>
#समावेश <scsi/scsi_cmnd.h>
#समावेश <scsi/scsi_device.h>

#समावेश "usb.h"
#समावेश "scsiglue.h"
#समावेश "transport.h"
#समावेश "protocol.h"
#समावेश "debug.h"
#समावेश "initializers.h"

#समावेश "sierra_ms.h"
#समावेश "option_ms.h"

#अगर IS_ENABLED(CONFIG_USB_UAS)
#समावेश "uas-detect.h"
#पूर्ण_अगर

#घोषणा DRV_NAME "usb-storage"

/* Some inक्रमmational data */
MODULE_AUTHOR("Matthew Dharm <mdharm-usb@one-eyed-alien.net>");
MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
MODULE_LICENSE("GPL");

अटल अचिन्हित पूर्णांक delay_use = 1;
module_param(delay_use, uपूर्णांक, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");

अटल अक्षर quirks[128];
module_param_string(quirks, quirks, माप(quirks), S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(quirks, "supplemental list of device IDs and their quirks");


/*
 * The entries in this table correspond, line क्रम line,
 * with the entries in usb_storage_usb_ids[], defined in usual-tables.c.
 */

/*
 *The venकरोr name should be kept at eight अक्षरacters or less, and
 * the product name should be kept at 16 अक्षरacters or less. If a device
 * has the US_FL_FIX_INQUIRY flag, then the venकरोr and product names
 * normally generated by a device through the INQUIRY response will be
 * taken from this list, and this is the reason क्रम the above size
 * restriction. However, अगर the flag is not present, then you
 * are मुक्त to use as many अक्षरacters as you like.
 */

#घोषणा UNUSUAL_DEV(idVenकरोr, idProduct, bcdDeviceMin, bcdDeviceMax, \
		    venकरोr_name, product_name, use_protocol, use_transport, \
		    init_function, Flags) \
अणु \
	.venकरोrName = venकरोr_name,	\
	.productName = product_name,	\
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
	.initFunction = init_function,	\
पूर्ण

#घोषणा COMPLIANT_DEV	UNUSUAL_DEV

#घोषणा USUAL_DEV(use_protocol, use_transport) \
अणु \
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
पूर्ण

#घोषणा UNUSUAL_VENDOR_INTF(idVenकरोr, cl, sc, pr, \
		venकरोr_name, product_name, use_protocol, use_transport, \
		init_function, Flags) \
अणु \
	.venकरोrName = venकरोr_name,	\
	.productName = product_name,	\
	.useProtocol = use_protocol,	\
	.useTransport = use_transport,	\
	.initFunction = init_function,	\
पूर्ण

अटल स्थिर काष्ठा us_unusual_dev us_unusual_dev_list[] = अणु
#	include "unusual_devs.h"
	अणु पूर्ण		/* Terminating entry */
पूर्ण;

अटल स्थिर काष्ठा us_unusual_dev क्रम_dynamic_ids =
		USUAL_DEV(USB_SC_SCSI, USB_PR_BULK);

#अघोषित UNUSUAL_DEV
#अघोषित COMPLIANT_DEV
#अघोषित USUAL_DEV
#अघोषित UNUSUAL_VENDOR_INTF

#अगर_घोषित CONFIG_LOCKDEP

अटल काष्ठा lock_class_key us_पूर्णांकerface_key[USB_MAXINTERFACES];

अटल व्योम us_set_lock_class(काष्ठा mutex *mutex,
		काष्ठा usb_पूर्णांकerface *पूर्णांकf)
अणु
	काष्ठा usb_device *udev = पूर्णांकerface_to_usbdev(पूर्णांकf);
	काष्ठा usb_host_config *config = udev->actconfig;
	पूर्णांक i;

	क्रम (i = 0; i < config->desc.bNumInterfaces; i++) अणु
		अगर (config->पूर्णांकerface[i] == पूर्णांकf)
			अवरोध;
	पूर्ण

	BUG_ON(i == config->desc.bNumInterfaces);

	lockdep_set_class(mutex, &us_पूर्णांकerface_key[i]);
पूर्ण

#अन्यथा

अटल व्योम us_set_lock_class(काष्ठा mutex *mutex,
		काष्ठा usb_पूर्णांकerface *पूर्णांकf)
अणु
पूर्ण

#पूर्ण_अगर

#अगर_घोषित CONFIG_PM	/* Minimal support क्रम suspend and resume */

पूर्णांक usb_stor_suspend(काष्ठा usb_पूर्णांकerface *अगरace, pm_message_t message)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(अगरace);

	/* Wait until no command is running */
	mutex_lock(&us->dev_mutex);

	अगर (us->suspend_resume_hook)
		(us->suspend_resume_hook)(us, US_SUSPEND);

	/*
	 * When runसमय PM is working, we'll set a flag to indicate
	 * whether we should स्वतःresume when a SCSI request arrives.
	 */

	mutex_unlock(&us->dev_mutex);
	वापस 0;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_suspend);

पूर्णांक usb_stor_resume(काष्ठा usb_पूर्णांकerface *अगरace)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(अगरace);

	mutex_lock(&us->dev_mutex);

	अगर (us->suspend_resume_hook)
		(us->suspend_resume_hook)(us, US_RESUME);

	mutex_unlock(&us->dev_mutex);
	वापस 0;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_resume);

पूर्णांक usb_stor_reset_resume(काष्ठा usb_पूर्णांकerface *अगरace)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(अगरace);

	/* Report the reset to the SCSI core */
	usb_stor_report_bus_reset(us);

	/*
	 * If any of the subdrivers implemented a reinitialization scheme,
	 * this is where the callback would be invoked.
	 */
	वापस 0;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_reset_resume);

#पूर्ण_अगर /* CONFIG_PM */

/*
 * The next two routines get called just beक्रमe and just after
 * a USB port reset, whether from this driver or a dअगरferent one.
 */

पूर्णांक usb_stor_pre_reset(काष्ठा usb_पूर्णांकerface *अगरace)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(अगरace);

	/* Make sure no command runs during the reset */
	mutex_lock(&us->dev_mutex);
	वापस 0;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_pre_reset);

पूर्णांक usb_stor_post_reset(काष्ठा usb_पूर्णांकerface *अगरace)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(अगरace);

	/* Report the reset to the SCSI core */
	usb_stor_report_bus_reset(us);

	/*
	 * If any of the subdrivers implemented a reinitialization scheme,
	 * this is where the callback would be invoked.
	 */

	mutex_unlock(&us->dev_mutex);
	वापस 0;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_post_reset);

/*
 * fill_inquiry_response takes an अचिन्हित अक्षर array (which must
 * be at least 36 अक्षरacters) and populates the venकरोr name,
 * product name, and revision fields. Then the array is copied
 * पूर्णांकo the SCSI command's response buffer (oddly enough
 * called request_buffer). data_len contains the length of the
 * data array, which again must be at least 36.
 */

व्योम fill_inquiry_response(काष्ठा us_data *us, अचिन्हित अक्षर *data,
		अचिन्हित पूर्णांक data_len)
अणु
	अगर (data_len < 36) /* You lose. */
		वापस;

	स_रखो(data+8, ' ', 28);
	अगर (data[0]&0x20) अणु /*
			     * USB device currently not connected. Return
			     * peripheral qualअगरier 001b ("...however, the
			     * physical device is not currently connected
			     * to this logical unit") and leave venकरोr and
			     * product identअगरication empty. ("If the target
			     * करोes store some of the INQUIRY data on the
			     * device, it may वापस zeros or ASCII spaces
			     * (20h) in those fields until the data is
			     * available from the device.").
			     */
	पूर्ण अन्यथा अणु
		u16 bcdDevice = le16_to_cpu(us->pusb_dev->descriptor.bcdDevice);
		पूर्णांक n;

		n = म_माप(us->unusual_dev->venकरोrName);
		स_नकल(data+8, us->unusual_dev->venकरोrName, min(8, n));
		n = म_माप(us->unusual_dev->productName);
		स_नकल(data+16, us->unusual_dev->productName, min(16, n));

		data[32] = 0x30 + ((bcdDevice>>12) & 0x0F);
		data[33] = 0x30 + ((bcdDevice>>8) & 0x0F);
		data[34] = 0x30 + ((bcdDevice>>4) & 0x0F);
		data[35] = 0x30 + ((bcdDevice) & 0x0F);
	पूर्ण

	usb_stor_set_xfer_buf(data, data_len, us->srb);
पूर्ण
EXPORT_SYMBOL_GPL(fill_inquiry_response);

अटल पूर्णांक usb_stor_control_thपढ़ो(व्योम * __us)
अणु
	काष्ठा us_data *us = (काष्ठा us_data *)__us;
	काष्ठा Scsi_Host *host = us_to_host(us);
	काष्ठा scsi_cmnd *srb;

	क्रम (;;) अणु
		usb_stor_dbg(us, "*** thread sleeping\n");
		अगर (रुको_क्रम_completion_पूर्णांकerruptible(&us->cmnd_पढ़ोy))
			अवरोध;

		usb_stor_dbg(us, "*** thread awakened\n");

		/* lock the device poपूर्णांकers */
		mutex_lock(&(us->dev_mutex));

		/* lock access to the state */
		scsi_lock(host);

		/* When we are called with no command pending, we're करोne */
		srb = us->srb;
		अगर (srb == शून्य) अणु
			scsi_unlock(host);
			mutex_unlock(&us->dev_mutex);
			usb_stor_dbg(us, "-- exiting\n");
			अवरोध;
		पूर्ण

		/* has the command समयd out *alपढ़ोy* ? */
		अगर (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) अणु
			srb->result = DID_ABORT << 16;
			जाओ SkipForAbort;
		पूर्ण

		scsi_unlock(host);

		/*
		 * reject the command अगर the direction indicator
		 * is UNKNOWN
		 */
		अगर (srb->sc_data_direction == DMA_BIसूचीECTIONAL) अणु
			usb_stor_dbg(us, "UNKNOWN data direction\n");
			srb->result = DID_ERROR << 16;
		पूर्ण

		/*
		 * reject अगर target != 0 or अगर LUN is higher than
		 * the maximum known LUN
		 */
		अन्यथा अगर (srb->device->id &&
				!(us->fflags & US_FL_SCM_MULT_TARG)) अणु
			usb_stor_dbg(us, "Bad target number (%d:%llu)\n",
				     srb->device->id,
				     srb->device->lun);
			srb->result = DID_BAD_TARGET << 16;
		पूर्ण

		अन्यथा अगर (srb->device->lun > us->max_lun) अणु
			usb_stor_dbg(us, "Bad LUN (%d:%llu)\n",
				     srb->device->id,
				     srb->device->lun);
			srb->result = DID_BAD_TARGET << 16;
		पूर्ण

		/*
		 * Handle those devices which need us to fake
		 * their inquiry data
		 */
		अन्यथा अगर ((srb->cmnd[0] == INQUIRY) &&
			    (us->fflags & US_FL_FIX_INQUIRY)) अणु
			अचिन्हित अक्षर data_ptr[36] = अणु
			    0x00, 0x80, 0x02, 0x02,
			    0x1F, 0x00, 0x00, 0x00पूर्ण;

			usb_stor_dbg(us, "Faking INQUIRY command\n");
			fill_inquiry_response(us, data_ptr, 36);
			srb->result = SAM_STAT_GOOD;
		पूर्ण

		/* we've got a command, let's करो it! */
		अन्यथा अणु
			US_DEBUG(usb_stor_show_command(us, srb));
			us->proto_handler(srb, us);
			usb_mark_last_busy(us->pusb_dev);
		पूर्ण

		/* lock access to the state */
		scsi_lock(host);

		/* was the command पातed? */
		अगर (srb->result == DID_ABORT << 16) अणु
SkipForAbort:
			usb_stor_dbg(us, "scsi command aborted\n");
			srb = शून्य;	/* Don't call srb->scsi_करोne() */
		पूर्ण

		/*
		 * If an पात request was received we need to संकेत that
		 * the पात has finished.  The proper test क्रम this is
		 * the TIMED_OUT flag, not srb->result == DID_ABORT, because
		 * the समयout might have occurred after the command had
		 * alपढ़ोy completed with a dअगरferent result code.
		 */
		अगर (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) अणु
			complete(&(us->notअगरy));

			/* Allow USB transfers to resume */
			clear_bit(US_FLIDX_ABORTING, &us->dflags);
			clear_bit(US_FLIDX_TIMED_OUT, &us->dflags);
		पूर्ण

		/* finished working on this command */
		us->srb = शून्य;
		scsi_unlock(host);

		/* unlock the device poपूर्णांकers */
		mutex_unlock(&us->dev_mutex);

		/* now that the locks are released, notअगरy the SCSI core */
		अगर (srb) अणु
			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
					srb->result);
			srb->scsi_करोne(srb);
		पूर्ण
	पूर्ण /* क्रम (;;) */

	/* Wait until we are told to stop */
	क्रम (;;) अणु
		set_current_state(TASK_INTERRUPTIBLE);
		अगर (kthपढ़ो_should_stop())
			अवरोध;
		schedule();
	पूर्ण
	__set_current_state(TASK_RUNNING);
	वापस 0;
पूर्ण

/***********************************************************************
 * Device probing and disconnecting
 ***********************************************************************/

/* Associate our निजी data with the USB device */
अटल पूर्णांक associate_dev(काष्ठा us_data *us, काष्ठा usb_पूर्णांकerface *पूर्णांकf)
अणु
	/* Fill in the device-related fields */
	us->pusb_dev = पूर्णांकerface_to_usbdev(पूर्णांकf);
	us->pusb_पूर्णांकf = पूर्णांकf;
	us->अगरnum = पूर्णांकf->cur_altsetting->desc.bInterfaceNumber;
	usb_stor_dbg(us, "Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x\n",
		     le16_to_cpu(us->pusb_dev->descriptor.idVenकरोr),
		     le16_to_cpu(us->pusb_dev->descriptor.idProduct),
		     le16_to_cpu(us->pusb_dev->descriptor.bcdDevice));
	usb_stor_dbg(us, "Interface Subclass: 0x%02x, Protocol: 0x%02x\n",
		     पूर्णांकf->cur_altsetting->desc.bInterfaceSubClass,
		     पूर्णांकf->cur_altsetting->desc.bInterfaceProtocol);

	/* Store our निजी data in the पूर्णांकerface */
	usb_set_पूर्णांकfdata(पूर्णांकf, us);

	/* Allocate the control/setup and DMA-mapped buffers */
	us->cr = kदो_स्मृति(माप(*us->cr), GFP_KERNEL);
	अगर (!us->cr)
		वापस -ENOMEM;

	us->iobuf = usb_alloc_coherent(us->pusb_dev, US_IOBUF_SIZE,
			GFP_KERNEL, &us->iobuf_dma);
	अगर (!us->iobuf) अणु
		usb_stor_dbg(us, "I/O buffer allocation failed\n");
		वापस -ENOMEM;
	पूर्ण
	वापस 0;
पूर्ण

/* Works only क्रम digits and letters, but small and fast */
#घोषणा TOLOWER(x) ((x) | 0x20)

/* Adjust device flags based on the "quirks=" module parameter */
व्योम usb_stor_adjust_quirks(काष्ठा usb_device *udev, अचिन्हित दीर्घ *fflags)
अणु
	अक्षर *p;
	u16 vid = le16_to_cpu(udev->descriptor.idVenकरोr);
	u16 pid = le16_to_cpu(udev->descriptor.idProduct);
	अचिन्हित f = 0;
	अचिन्हित पूर्णांक mask = (US_FL_SANE_SENSE | US_FL_BAD_SENSE |
			US_FL_FIX_CAPACITY | US_FL_IGNORE_UAS |
			US_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |
			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
			US_FL_INITIAL_READ10 | US_FL_WRITE_CACHE |
			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES |
			US_FL_MAX_SECTORS_240 | US_FL_NO_REPORT_LUNS |
			US_FL_ALWAYS_SYNC);

	p = quirks;
	जबतक (*p) अणु
		/* Each entry consists of VID:PID:flags */
		अगर (vid == simple_म_से_अदीर्घ(p, &p, 16) &&
				*p == ':' &&
				pid == simple_म_से_अदीर्घ(p+1, &p, 16) &&
				*p == ':')
			अवरोध;

		/* Move क्रमward to the next entry */
		जबतक (*p) अणु
			अगर (*p++ == ',')
				अवरोध;
		पूर्ण
	पूर्ण
	अगर (!*p)	/* No match */
		वापस;

	/* Collect the flags */
	जबतक (*++p && *p != ',') अणु
		चयन (TOLOWER(*p)) अणु
		हाल 'a':
			f |= US_FL_SANE_SENSE;
			अवरोध;
		हाल 'b':
			f |= US_FL_BAD_SENSE;
			अवरोध;
		हाल 'c':
			f |= US_FL_FIX_CAPACITY;
			अवरोध;
		हाल 'd':
			f |= US_FL_NO_READ_DISC_INFO;
			अवरोध;
		हाल 'e':
			f |= US_FL_NO_READ_CAPACITY_16;
			अवरोध;
		हाल 'f':
			f |= US_FL_NO_REPORT_OPCODES;
			अवरोध;
		हाल 'g':
			f |= US_FL_MAX_SECTORS_240;
			अवरोध;
		हाल 'h':
			f |= US_FL_CAPACITY_HEURISTICS;
			अवरोध;
		हाल 'i':
			f |= US_FL_IGNORE_DEVICE;
			अवरोध;
		हाल 'j':
			f |= US_FL_NO_REPORT_LUNS;
			अवरोध;
		हाल 'k':
			f |= US_FL_NO_SAME;
			अवरोध;
		हाल 'l':
			f |= US_FL_NOT_LOCKABLE;
			अवरोध;
		हाल 'm':
			f |= US_FL_MAX_SECTORS_64;
			अवरोध;
		हाल 'n':
			f |= US_FL_INITIAL_READ10;
			अवरोध;
		हाल 'o':
			f |= US_FL_CAPACITY_OK;
			अवरोध;
		हाल 'p':
			f |= US_FL_WRITE_CACHE;
			अवरोध;
		हाल 'r':
			f |= US_FL_IGNORE_RESIDUE;
			अवरोध;
		हाल 's':
			f |= US_FL_SINGLE_LUN;
			अवरोध;
		हाल 't':
			f |= US_FL_NO_ATA_1X;
			अवरोध;
		हाल 'u':
			f |= US_FL_IGNORE_UAS;
			अवरोध;
		हाल 'w':
			f |= US_FL_NO_WP_DETECT;
			अवरोध;
		हाल 'y':
			f |= US_FL_ALWAYS_SYNC;
			अवरोध;
		/* Ignore unrecognized flag अक्षरacters */
		पूर्ण
	पूर्ण
	*fflags = (*fflags & ~mask) | f;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_adjust_quirks);

/* Get the unusual_devs entries and the string descriptors */
अटल पूर्णांक get_device_info(काष्ठा us_data *us, स्थिर काष्ठा usb_device_id *id,
		स्थिर काष्ठा us_unusual_dev *unusual_dev)
अणु
	काष्ठा usb_device *dev = us->pusb_dev;
	काष्ठा usb_पूर्णांकerface_descriptor *idesc =
		&us->pusb_पूर्णांकf->cur_altsetting->desc;
	काष्ठा device *pdev = &us->pusb_पूर्णांकf->dev;

	/* Store the entries */
	us->unusual_dev = unusual_dev;
	us->subclass = (unusual_dev->useProtocol == USB_SC_DEVICE) ?
			idesc->bInterfaceSubClass :
			unusual_dev->useProtocol;
	us->protocol = (unusual_dev->useTransport == USB_PR_DEVICE) ?
			idesc->bInterfaceProtocol :
			unusual_dev->useTransport;
	us->fflags = id->driver_info;
	usb_stor_adjust_quirks(us->pusb_dev, &us->fflags);

	अगर (us->fflags & US_FL_IGNORE_DEVICE) अणु
		dev_info(pdev, "device ignored\n");
		वापस -ENODEV;
	पूर्ण

	/*
	 * This flag is only needed when we're in high-speed, so let's
	 * disable it अगर we're in full-speed
	 */
	अगर (dev->speed != USB_SPEED_HIGH)
		us->fflags &= ~US_FL_GO_SLOW;

	अगर (us->fflags)
		dev_info(pdev, "Quirks match for vid %04x pid %04x: %lx\n",
				le16_to_cpu(dev->descriptor.idVenकरोr),
				le16_to_cpu(dev->descriptor.idProduct),
				us->fflags);

	/*
	 * Log a message अगर a non-generic unusual_dev entry contains an
	 * unnecessary subclass or protocol override.  This may stimulate
	 * reports from users that will help us हटाओ unneeded entries
	 * from the unusual_devs.h table.
	 */
	अगर (id->idVenकरोr || id->idProduct) अणु
		अटल स्थिर अक्षर *msgs[3] = अणु
			"an unneeded SubClass entry",
			"an unneeded Protocol entry",
			"unneeded SubClass and Protocol entries"पूर्ण;
		काष्ठा usb_device_descriptor *ddesc = &dev->descriptor;
		पूर्णांक msg = -1;

		अगर (unusual_dev->useProtocol != USB_SC_DEVICE &&
			us->subclass == idesc->bInterfaceSubClass)
			msg += 1;
		अगर (unusual_dev->useTransport != USB_PR_DEVICE &&
			us->protocol == idesc->bInterfaceProtocol)
			msg += 2;
		अगर (msg >= 0 && !(us->fflags & US_FL_NEED_OVERRIDE))
			dev_notice(pdev, "This device "
					"(%04x,%04x,%04x S %02x P %02x)"
					" has %s in unusual_devs.h (kernel"
					" %s)\n"
					"   Please send a copy of this message to "
					"<linux-usb@vger.kernel.org> and "
					"<usb-storage@lists.one-eyed-alien.net>\n",
					le16_to_cpu(ddesc->idVenकरोr),
					le16_to_cpu(ddesc->idProduct),
					le16_to_cpu(ddesc->bcdDevice),
					idesc->bInterfaceSubClass,
					idesc->bInterfaceProtocol,
					msgs[msg],
					utsname()->release);
	पूर्ण

	वापस 0;
पूर्ण

/* Get the transport settings */
अटल व्योम get_transport(काष्ठा us_data *us)
अणु
	चयन (us->protocol) अणु
	हाल USB_PR_CB:
		us->transport_name = "Control/Bulk";
		us->transport = usb_stor_CB_transport;
		us->transport_reset = usb_stor_CB_reset;
		us->max_lun = 7;
		अवरोध;

	हाल USB_PR_CBI:
		us->transport_name = "Control/Bulk/Interrupt";
		us->transport = usb_stor_CB_transport;
		us->transport_reset = usb_stor_CB_reset;
		us->max_lun = 7;
		अवरोध;

	हाल USB_PR_BULK:
		us->transport_name = "Bulk";
		us->transport = usb_stor_Bulk_transport;
		us->transport_reset = usb_stor_Bulk_reset;
		अवरोध;
	पूर्ण
पूर्ण

/* Get the protocol settings */
अटल व्योम get_protocol(काष्ठा us_data *us)
अणु
	चयन (us->subclass) अणु
	हाल USB_SC_RBC:
		us->protocol_name = "Reduced Block Commands (RBC)";
		us->proto_handler = usb_stor_transparent_scsi_command;
		अवरोध;

	हाल USB_SC_8020:
		us->protocol_name = "8020i";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		अवरोध;

	हाल USB_SC_QIC:
		us->protocol_name = "QIC-157";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		अवरोध;

	हाल USB_SC_8070:
		us->protocol_name = "8070i";
		us->proto_handler = usb_stor_pad12_command;
		us->max_lun = 0;
		अवरोध;

	हाल USB_SC_SCSI:
		us->protocol_name = "Transparent SCSI";
		us->proto_handler = usb_stor_transparent_scsi_command;
		अवरोध;

	हाल USB_SC_UFI:
		us->protocol_name = "Uniform Floppy Interface (UFI)";
		us->proto_handler = usb_stor_ufi_command;
		अवरोध;
	पूर्ण
पूर्ण

/* Get the pipe settings */
अटल पूर्णांक get_pipes(काष्ठा us_data *us)
अणु
	काष्ठा usb_host_पूर्णांकerface *alt = us->pusb_पूर्णांकf->cur_altsetting;
	काष्ठा usb_endpoपूर्णांक_descriptor *ep_in;
	काष्ठा usb_endpoपूर्णांक_descriptor *ep_out;
	काष्ठा usb_endpoपूर्णांक_descriptor *ep_पूर्णांक;
	पूर्णांक res;

	/*
	 * Find the first endpoपूर्णांक of each type we need.
	 * We are expecting a minimum of 2 endpoपूर्णांकs - in and out (bulk).
	 * An optional पूर्णांकerrupt-in is OK (necessary क्रम CBI protocol).
	 * We will ignore any others.
	 */
	res = usb_find_common_endpoपूर्णांकs(alt, &ep_in, &ep_out, शून्य, शून्य);
	अगर (res) अणु
		usb_stor_dbg(us, "bulk endpoints not found\n");
		वापस res;
	पूर्ण

	res = usb_find_पूर्णांक_in_endpoपूर्णांक(alt, &ep_पूर्णांक);
	अगर (res && us->protocol == USB_PR_CBI) अणु
		usb_stor_dbg(us, "interrupt endpoint not found\n");
		वापस res;
	पूर्ण

	/* Calculate and store the pipe values */
	us->send_ctrl_pipe = usb_sndctrlpipe(us->pusb_dev, 0);
	us->recv_ctrl_pipe = usb_rcvctrlpipe(us->pusb_dev, 0);
	us->send_bulk_pipe = usb_sndbulkpipe(us->pusb_dev,
		usb_endpoपूर्णांक_num(ep_out));
	us->recv_bulk_pipe = usb_rcvbulkpipe(us->pusb_dev,
		usb_endpoपूर्णांक_num(ep_in));
	अगर (ep_पूर्णांक) अणु
		us->recv_पूर्णांकr_pipe = usb_rcvपूर्णांकpipe(us->pusb_dev,
			usb_endpoपूर्णांक_num(ep_पूर्णांक));
		us->ep_bInterval = ep_पूर्णांक->bInterval;
	पूर्ण
	वापस 0;
पूर्ण

/* Initialize all the dynamic resources we need */
अटल पूर्णांक usb_stor_acquire_resources(काष्ठा us_data *us)
अणु
	पूर्णांक p;
	काष्ठा task_काष्ठा *th;

	us->current_urb = usb_alloc_urb(0, GFP_KERNEL);
	अगर (!us->current_urb)
		वापस -ENOMEM;

	/*
	 * Just beक्रमe we start our control thपढ़ो, initialize
	 * the device अगर it needs initialization
	 */
	अगर (us->unusual_dev->initFunction) अणु
		p = us->unusual_dev->initFunction(us);
		अगर (p)
			वापस p;
	पूर्ण

	/* Start up our control thपढ़ो */
	th = kthपढ़ो_run(usb_stor_control_thपढ़ो, us, "usb-storage");
	अगर (IS_ERR(th)) अणु
		dev_warn(&us->pusb_पूर्णांकf->dev,
				"Unable to start control thread\n");
		वापस PTR_ERR(th);
	पूर्ण
	us->ctl_thपढ़ो = th;

	वापस 0;
पूर्ण

/* Release all our dynamic resources */
अटल व्योम usb_stor_release_resources(काष्ठा us_data *us)
अणु
	/*
	 * Tell the control thपढ़ो to निकास.  The SCSI host must
	 * alपढ़ोy have been हटाओd and the DISCONNECTING flag set
	 * so that we won't accept any more commands.
	 */
	usb_stor_dbg(us, "-- sending exit command to thread\n");
	complete(&us->cmnd_पढ़ोy);
	अगर (us->ctl_thपढ़ो)
		kthपढ़ो_stop(us->ctl_thपढ़ो);

	/* Call the deकाष्ठाor routine, अगर it exists */
	अगर (us->extra_deकाष्ठाor) अणु
		usb_stor_dbg(us, "-- calling extra_destructor()\n");
		us->extra_deकाष्ठाor(us->extra);
	पूर्ण

	/* Free the extra data and the URB */
	kमुक्त(us->extra);
	usb_मुक्त_urb(us->current_urb);
पूर्ण

/* Dissociate from the USB device */
अटल व्योम dissociate_dev(काष्ठा us_data *us)
अणु
	/* Free the buffers */
	kमुक्त(us->cr);
	usb_मुक्त_coherent(us->pusb_dev, US_IOBUF_SIZE, us->iobuf, us->iobuf_dma);

	/* Remove our निजी data from the पूर्णांकerface */
	usb_set_पूर्णांकfdata(us->pusb_पूर्णांकf, शून्य);
पूर्ण

/*
 * First stage of disconnect processing: stop SCSI scanning,
 * हटाओ the host, and stop accepting new commands
 */
अटल व्योम quiesce_and_हटाओ_host(काष्ठा us_data *us)
अणु
	काष्ठा Scsi_Host *host = us_to_host(us);

	/* If the device is really gone, cut लघु reset delays */
	अगर (us->pusb_dev->state == USB_STATE_NOTATTACHED) अणु
		set_bit(US_FLIDX_DISCONNECTING, &us->dflags);
		wake_up(&us->delay_रुको);
	पूर्ण

	/*
	 * Prevent SCSI scanning (अगर it hasn't started yet)
	 * or रुको क्रम the SCSI-scanning routine to stop.
	 */
	cancel_delayed_work_sync(&us->scan_dwork);

	/* Balance स्वतःpm calls अगर scanning was cancelled */
	अगर (test_bit(US_FLIDX_SCAN_PENDING, &us->dflags))
		usb_स्वतःpm_put_पूर्णांकerface_no_suspend(us->pusb_पूर्णांकf);

	/*
	 * Removing the host will perक्रमm an orderly shutकरोwn: caches
	 * synchronized, disks spun करोwn, etc.
	 */
	scsi_हटाओ_host(host);

	/*
	 * Prevent any new commands from being accepted and cut लघु
	 * reset delays.
	 */
	scsi_lock(host);
	set_bit(US_FLIDX_DISCONNECTING, &us->dflags);
	scsi_unlock(host);
	wake_up(&us->delay_रुको);
पूर्ण

/* Second stage of disconnect processing: deallocate all resources */
अटल व्योम release_everything(काष्ठा us_data *us)
अणु
	usb_stor_release_resources(us);
	dissociate_dev(us);

	/*
	 * Drop our reference to the host; the SCSI core will मुक्त it
	 * (and "us" aदीर्घ with it) when the refcount becomes 0.
	 */
	scsi_host_put(us_to_host(us));
पूर्ण

/* Delayed-work routine to carry out SCSI-device scanning */
अटल व्योम usb_stor_scan_dwork(काष्ठा work_काष्ठा *work)
अणु
	काष्ठा us_data *us = container_of(work, काष्ठा us_data,
			scan_dwork.work);
	काष्ठा device *dev = &us->pusb_पूर्णांकf->dev;

	dev_dbg(dev, "starting scan\n");

	/* For bulk-only devices, determine the max LUN value */
	अगर (us->protocol == USB_PR_BULK &&
	    !(us->fflags & US_FL_SINGLE_LUN) &&
	    !(us->fflags & US_FL_SCM_MULT_TARG)) अणु
		mutex_lock(&us->dev_mutex);
		us->max_lun = usb_stor_Bulk_max_lun(us);
		/*
		 * Allow proper scanning of devices that present more than 8 LUNs
		 * While not affecting other devices that may need the previous
		 * behavior
		 */
		अगर (us->max_lun >= 8)
			us_to_host(us)->max_lun = us->max_lun+1;
		mutex_unlock(&us->dev_mutex);
	पूर्ण
	scsi_scan_host(us_to_host(us));
	dev_dbg(dev, "scan complete\n");

	/* Should we unbind अगर no devices were detected? */

	usb_स्वतःpm_put_पूर्णांकerface(us->pusb_पूर्णांकf);
	clear_bit(US_FLIDX_SCAN_PENDING, &us->dflags);
पूर्ण

अटल अचिन्हित पूर्णांक usb_stor_sg_tablesize(काष्ठा usb_पूर्णांकerface *पूर्णांकf)
अणु
	काष्ठा usb_device *usb_dev = पूर्णांकerface_to_usbdev(पूर्णांकf);

	अगर (usb_dev->bus->sg_tablesize) अणु
		वापस usb_dev->bus->sg_tablesize;
	पूर्ण
	वापस SG_ALL;
पूर्ण

/* First part of general USB mass-storage probing */
पूर्णांक usb_stor_probe1(काष्ठा us_data **pus,
		काष्ठा usb_पूर्णांकerface *पूर्णांकf,
		स्थिर काष्ठा usb_device_id *id,
		स्थिर काष्ठा us_unusual_dev *unusual_dev,
		काष्ठा scsi_host_ढाँचा *sht)
अणु
	काष्ठा Scsi_Host *host;
	काष्ठा us_data *us;
	पूर्णांक result;

	dev_info(&पूर्णांकf->dev, "USB Mass Storage device detected\n");

	/*
	 * Ask the SCSI layer to allocate a host काष्ठाure, with extra
	 * space at the end क्रम our निजी us_data काष्ठाure.
	 */
	host = scsi_host_alloc(sht, माप(*us));
	अगर (!host) अणु
		dev_warn(&पूर्णांकf->dev, "Unable to allocate the scsi host\n");
		वापस -ENOMEM;
	पूर्ण

	/*
	 * Allow 16-byte CDBs and thus > 2TB
	 */
	host->max_cmd_len = 16;
	host->sg_tablesize = usb_stor_sg_tablesize(पूर्णांकf);
	*pus = us = host_to_us(host);
	mutex_init(&(us->dev_mutex));
	us_set_lock_class(&us->dev_mutex, पूर्णांकf);
	init_completion(&us->cmnd_पढ़ोy);
	init_completion(&(us->notअगरy));
	init_रुकोqueue_head(&us->delay_रुको);
	INIT_DELAYED_WORK(&us->scan_dwork, usb_stor_scan_dwork);

	/* Associate the us_data काष्ठाure with the USB device */
	result = associate_dev(us, पूर्णांकf);
	अगर (result)
		जाओ BadDevice;

	/* Get the unusual_devs entries and the descriptors */
	result = get_device_info(us, id, unusual_dev);
	अगर (result)
		जाओ BadDevice;

	/* Get standard transport and protocol settings */
	get_transport(us);
	get_protocol(us);

	/*
	 * Give the caller a chance to fill in specialized transport
	 * or protocol settings.
	 */
	वापस 0;

BadDevice:
	usb_stor_dbg(us, "storage_probe() failed\n");
	release_everything(us);
	वापस result;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_probe1);

/* Second part of general USB mass-storage probing */
पूर्णांक usb_stor_probe2(काष्ठा us_data *us)
अणु
	पूर्णांक result;
	काष्ठा device *dev = &us->pusb_पूर्णांकf->dev;

	/* Make sure the transport and protocol have both been set */
	अगर (!us->transport || !us->proto_handler) अणु
		result = -ENXIO;
		जाओ BadDevice;
	पूर्ण
	usb_stor_dbg(us, "Transport: %s\n", us->transport_name);
	usb_stor_dbg(us, "Protocol: %s\n", us->protocol_name);

	अगर (us->fflags & US_FL_SCM_MULT_TARG) अणु
		/*
		 * SCM eUSCSI bridge devices can have dअगरferent numbers
		 * of LUNs on dअगरferent tarमाला_लो; allow all to be probed.
		 */
		us->max_lun = 7;
		/* The eUSCSI itself has ID 7, so aव्योम scanning that */
		us_to_host(us)->this_id = 7;
		/* max_id is 8 initially, so no need to set it here */
	पूर्ण अन्यथा अणु
		/* In the normal हाल there is only a single target */
		us_to_host(us)->max_id = 1;
		/*
		 * Like Winकरोws, we won't store the LUN bits in CDB[1] क्रम
		 * SCSI-2 devices using the Bulk-Only transport (even though
		 * this violates the SCSI spec).
		 */
		अगर (us->transport == usb_stor_Bulk_transport)
			us_to_host(us)->no_scsi2_lun_in_cdb = 1;
	पूर्ण

	/* fix क्रम single-lun devices */
	अगर (us->fflags & US_FL_SINGLE_LUN)
		us->max_lun = 0;

	/* Find the endpoपूर्णांकs and calculate pipe values */
	result = get_pipes(us);
	अगर (result)
		जाओ BadDevice;

	/*
	 * If the device वापसs invalid data क्रम the first READ(10)
	 * command, indicate the command should be retried.
	 */
	अगर (us->fflags & US_FL_INITIAL_READ10)
		set_bit(US_FLIDX_REDO_READ10, &us->dflags);

	/* Acquire all the other resources and add the host */
	result = usb_stor_acquire_resources(us);
	अगर (result)
		जाओ BadDevice;
	usb_स्वतःpm_get_पूर्णांकerface_no_resume(us->pusb_पूर्णांकf);
	snम_लिखो(us->scsi_name, माप(us->scsi_name), "usb-storage %s",
					dev_name(&us->pusb_पूर्णांकf->dev));
	result = scsi_add_host(us_to_host(us), dev);
	अगर (result) अणु
		dev_warn(dev,
				"Unable to add the scsi host\n");
		जाओ HostAddErr;
	पूर्ण

	/* Submit the delayed_work क्रम SCSI-device scanning */
	set_bit(US_FLIDX_SCAN_PENDING, &us->dflags);

	अगर (delay_use > 0)
		dev_dbg(dev, "waiting for device to settle before scanning\n");
	queue_delayed_work(प्रणाली_मुक्तzable_wq, &us->scan_dwork,
			delay_use * HZ);
	वापस 0;

	/* We come here अगर there are any problems */
HostAddErr:
	usb_स्वतःpm_put_पूर्णांकerface_no_suspend(us->pusb_पूर्णांकf);
BadDevice:
	usb_stor_dbg(us, "storage_probe() failed\n");
	release_everything(us);
	वापस result;
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_probe2);

/* Handle a USB mass-storage disconnect */
व्योम usb_stor_disconnect(काष्ठा usb_पूर्णांकerface *पूर्णांकf)
अणु
	काष्ठा us_data *us = usb_get_पूर्णांकfdata(पूर्णांकf);

	quiesce_and_हटाओ_host(us);
	release_everything(us);
पूर्ण
EXPORT_SYMBOL_GPL(usb_stor_disconnect);

अटल काष्ठा scsi_host_ढाँचा usb_stor_host_ढाँचा;

/* The मुख्य probe routine क्रम standard devices */
अटल पूर्णांक storage_probe(काष्ठा usb_पूर्णांकerface *पूर्णांकf,
			 स्थिर काष्ठा usb_device_id *id)
अणु
	स्थिर काष्ठा us_unusual_dev *unusual_dev;
	काष्ठा us_data *us;
	पूर्णांक result;
	पूर्णांक size;

	/* If uas is enabled and this device can करो uas then ignore it. */
#अगर IS_ENABLED(CONFIG_USB_UAS)
	अगर (uas_use_uas_driver(पूर्णांकf, id, शून्य))
		वापस -ENXIO;
#पूर्ण_अगर

	/*
	 * If the device isn't standard (is handled by a subdriver
	 * module) then करोn't accept it.
	 */
	अगर (usb_usual_ignore_device(पूर्णांकf))
		वापस -ENXIO;

	/*
	 * Call the general probe procedures.
	 *
	 * The unusual_dev_list array is parallel to the usb_storage_usb_ids
	 * table, so we use the index of the id entry to find the
	 * corresponding unusual_devs entry.
	 */

	size = ARRAY_SIZE(us_unusual_dev_list);
	अगर (id >= usb_storage_usb_ids && id < usb_storage_usb_ids + size) अणु
		unusual_dev = (id - usb_storage_usb_ids) + us_unusual_dev_list;
	पूर्ण अन्यथा अणु
		unusual_dev = &क्रम_dynamic_ids;

		dev_dbg(&पूर्णांकf->dev, "Use Bulk-Only transport with the Transparent SCSI protocol for dynamic id: 0x%04x 0x%04x\n",
			id->idVenकरोr, id->idProduct);
	पूर्ण

	result = usb_stor_probe1(&us, पूर्णांकf, id, unusual_dev,
				 &usb_stor_host_ढाँचा);
	अगर (result)
		वापस result;

	/* No special transport or protocol settings in the मुख्य module */

	result = usb_stor_probe2(us);
	वापस result;
पूर्ण

अटल काष्ठा usb_driver usb_storage_driver = अणु
	.name =		DRV_NAME,
	.probe =	storage_probe,
	.disconnect =	usb_stor_disconnect,
	.suspend =	usb_stor_suspend,
	.resume =	usb_stor_resume,
	.reset_resume =	usb_stor_reset_resume,
	.pre_reset =	usb_stor_pre_reset,
	.post_reset =	usb_stor_post_reset,
	.id_table =	usb_storage_usb_ids,
	.supports_स्वतःsuspend = 1,
	.soft_unbind =	1,
पूर्ण;

module_usb_stor_driver(usb_storage_driver, usb_stor_host_ढाँचा, DRV_NAME);
