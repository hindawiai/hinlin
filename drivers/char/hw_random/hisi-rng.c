<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 * Copyright (C) 2016 HiSilicon Co., Ltd.
 */

#समावेश <linux/err.h>
#समावेश <linux/kernel.h>
#समावेश <linux/hw_अक्रमom.h>
#समावेश <linux/पन.स>
#समावेश <linux/module.h>
#समावेश <linux/of.h>
#समावेश <linux/platक्रमm_device.h>
#समावेश <linux/अक्रमom.h>

#घोषणा RNG_SEED	0x0
#घोषणा RNG_CTRL	0x4
  #घोषणा RNG_SEED_SEL	BIT(2)
  #घोषणा RNG_RING_EN	BIT(1)
  #घोषणा RNG_EN	BIT(0)
#घोषणा RNG_RAN_NUM	0x10
#घोषणा RNG_PHY_SEED	0x14

#घोषणा to_hisi_rng(p)	container_of(p, काष्ठा hisi_rng, rng)

अटल पूर्णांक seed_sel;
module_param(seed_sel, पूर्णांक, S_IRUGO);
MODULE_PARM_DESC(seed_sel, "Auto reload seed. 0, use LFSR(default); 1, use ring oscillator.");

काष्ठा hisi_rng अणु
	व्योम __iomem *base;
	काष्ठा hwrng rng;
पूर्ण;

अटल पूर्णांक hisi_rng_init(काष्ठा hwrng *rng)
अणु
	काष्ठा hisi_rng *hrng = to_hisi_rng(rng);
	पूर्णांक val = RNG_EN;
	u32 seed;

	/* get a अक्रमom number as initial seed */
	get_अक्रमom_bytes(&seed, माप(seed));

	ग_लिखोl_relaxed(seed, hrng->base + RNG_SEED);

	/**
	 * The seed is reload periodically, there are two choice
	 * of seeds, शेष seed using the value from LFSR, or
	 * will use seed generated by ring oscillator.
	 */
	अगर (seed_sel == 1)
		val |= RNG_RING_EN | RNG_SEED_SEL;

	ग_लिखोl_relaxed(val, hrng->base + RNG_CTRL);
	वापस 0;
पूर्ण

अटल व्योम hisi_rng_cleanup(काष्ठा hwrng *rng)
अणु
	काष्ठा hisi_rng *hrng = to_hisi_rng(rng);

	ग_लिखोl_relaxed(0, hrng->base + RNG_CTRL);
पूर्ण

अटल पूर्णांक hisi_rng_पढ़ो(काष्ठा hwrng *rng, व्योम *buf, माप_प्रकार max, bool रुको)
अणु
	काष्ठा hisi_rng *hrng = to_hisi_rng(rng);
	u32 *data = buf;

	*data = पढ़ोl_relaxed(hrng->base + RNG_RAN_NUM);
	वापस 4;
पूर्ण

अटल पूर्णांक hisi_rng_probe(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा hisi_rng *rng;
	पूर्णांक ret;

	rng = devm_kzalloc(&pdev->dev, माप(*rng), GFP_KERNEL);
	अगर (!rng)
		वापस -ENOMEM;

	platक्रमm_set_drvdata(pdev, rng);

	rng->base = devm_platक्रमm_ioremap_resource(pdev, 0);
	अगर (IS_ERR(rng->base))
		वापस PTR_ERR(rng->base);

	rng->rng.name = pdev->name;
	rng->rng.init = hisi_rng_init;
	rng->rng.cleanup = hisi_rng_cleanup;
	rng->rng.पढ़ो = hisi_rng_पढ़ो;

	ret = devm_hwrng_रेजिस्टर(&pdev->dev, &rng->rng);
	अगर (ret) अणु
		dev_err(&pdev->dev, "failed to register hwrng\n");
		वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा of_device_id hisi_rng_dt_ids[] __maybe_unused = अणु
	अणु .compatible = "hisilicon,hip04-rng" पूर्ण,
	अणु .compatible = "hisilicon,hip05-rng" पूर्ण,
	अणु पूर्ण
पूर्ण;
MODULE_DEVICE_TABLE(of, hisi_rng_dt_ids);

अटल काष्ठा platक्रमm_driver hisi_rng_driver = अणु
	.probe		= hisi_rng_probe,
	.driver		= अणु
		.name	= "hisi-rng",
		.of_match_table = of_match_ptr(hisi_rng_dt_ids),
	पूर्ण,
पूर्ण;

module_platक्रमm_driver(hisi_rng_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kefeng Wang <wangkefeng.wang@huawei>");
MODULE_DESCRIPTION("Hisilicon random number generator driver");
