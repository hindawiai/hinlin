<शैली गुरु>
/*
 * अक्रमom.c -- A strong अक्रमom number generator
 *
 * Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All
 * Rights Reserved.
 *
 * Copyright Matt Mackall <mpm@selenic.com>, 2003, 2004, 2005
 *
 * Copyright Theoकरोre Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.  All
 * rights reserved.
 *
 * Redistribution and use in source and binary क्रमms, with or without
 * modअगरication, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary क्रमm must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    करोcumentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to enकरोrse or promote
 *    products derived from this software without specअगरic prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU General Public License, in which हाल the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad पूर्णांकeraction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
 * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY सूचीECT, INसूचीECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
 * (now, with legal B.S. out of the way.....)
 *
 * This routine gathers environmental noise from device drivers, etc.,
 * and वापसs good अक्रमom numbers, suitable क्रम cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * क्रम seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only अक्रमom, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly अक्रमom numbers on a computer --- as opposed to
 * pseuकरो-अक्रमom numbers, which can easily generated by using a
 * algorithm.  Unक्रमtunately, it is very easy क्रम attackers to guess
 * the sequence of pseuकरो-अक्रमom number generators, and क्रम some
 * applications this is not acceptable.  So instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard क्रम outside attackers to observe, and use that to
 * generate अक्रमom numbers.  In a Unix environment, this is best करोne
 * from inside the kernel.
 *
 * Sources of अक्रमomness from the environment include पूर्णांकer-keyboard
 * timings, पूर्णांकer-पूर्णांकerrupt timings from some पूर्णांकerrupts, and other
 * events which are both (a) non-deterministic and (b) hard क्रम an
 * outside observer to measure.  Ranकरोmness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the अक्रमomness is not chosen maliciously, and it is fast enough that
 * the overhead of करोing it on every पूर्णांकerrupt is very reasonable.
 * As अक्रमom bytes are mixed पूर्णांकo the entropy pool, the routines keep
 * an *estimate* of how many bits of अक्रमomness have been stored पूर्णांकo
 * the अक्रमom number generator's पूर्णांकernal state.
 *
 * When अक्रमom bytes are desired, they are obtained by taking the SHA
 * hash of the contents of the "entropy pool".  The SHA hash aव्योमs
 * exposing the पूर्णांकernal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful inक्रमmation
 * about the input of SHA from its output.  Even अगर it is possible to
 * analyze SHA in some clever way, as दीर्घ as the amount of data
 * वापसed from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its पूर्णांकernal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outमाला_दो अक्रमom numbers.
 *
 * If this estimate goes to zero, the routine can still generate
 * अक्रमom numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outमाला_दो.  This requires successful cryptanalysis of SHA, which is
 * not believed to be feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful क्रम the vast majority
 * of purposes.
 *
 * Exported पूर्णांकerfaces ---- output
 * ===============================
 *
 * There are four exported पूर्णांकerfaces; two क्रम use within the kernel,
 * and two or use from userspace.
 *
 * Exported पूर्णांकerfaces ---- userspace output
 * -----------------------------------------
 *
 * The userspace पूर्णांकerfaces are two अक्षरacter devices /dev/अक्रमom and
 * /dev/uअक्रमom.  /dev/अक्रमom is suitable क्रम use when very high
 * quality अक्रमomness is desired (क्रम example, क्रम key generation or
 * one-समय pads), as it will only वापस a maximum of the number of
 * bits of अक्रमomness (as estimated by the अक्रमom number generator)
 * contained in the entropy pool.
 *
 * The /dev/uअक्रमom device करोes not have this limit, and will वापस
 * as many bytes as are requested.  As more and more अक्रमom bytes are
 * requested without giving समय क्रम the entropy pool to reअक्षरge,
 * this will result in अक्रमom numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
 * Exported पूर्णांकerfaces ---- kernel output
 * --------------------------------------
 *
 * The primary kernel पूर्णांकerface is
 *
 * 	व्योम get_अक्रमom_bytes(व्योम *buf, पूर्णांक nbytes);
 *
 * This पूर्णांकerface will वापस the requested number of अक्रमom bytes,
 * and place it in the requested buffer.  This is equivalent to a
 * पढ़ो from /dev/uअक्रमom.
 *
 * For less critical applications, there are the functions:
 *
 * 	u32 get_अक्रमom_u32()
 * 	u64 get_अक्रमom_u64()
 * 	अचिन्हित पूर्णांक get_अक्रमom_पूर्णांक()
 * 	अचिन्हित दीर्घ get_अक्रमom_दीर्घ()
 *
 * These are produced by a cryptographic RNG seeded from get_अक्रमom_bytes,
 * and so करो not deplete the entropy pool as much.  These are recommended
 * क्रम most in-kernel operations *अगर the result is going to be stored in
 * the kernel*.
 *
 * Specअगरically, the get_अक्रमom_पूर्णांक() family करो not attempt to करो
 * "anti-backtracking".  If you capture the state of the kernel (e.g.
 * by snapshotting the VM), you can figure out previous get_अक्रमom_पूर्णांक()
 * वापस values.  But अगर the value is stored in the kernel anyway,
 * this is not a problem.
 *
 * It *is* safe to expose get_अक्रमom_पूर्णांक() output to attackers (e.g. as
 * network cookies); given outमाला_दो 1..n, it's not feasible to predict
 * outमाला_दो 0 or n+1.  The only concern is an attacker who अवरोधs पूर्णांकo
 * the kernel later; the get_अक्रमom_पूर्णांक() engine is not reseeded as
 * often as the get_अक्रमom_bytes() one.
 *
 * get_अक्रमom_bytes() is needed क्रम keys that need to stay secret after
 * they are erased from the kernel.  For example, any key that will
 * be wrapped and stored encrypted.  And session encryption keys: we'd
 * like to know that after the session is बंदd and the keys erased,
 * the plaपूर्णांकext is unrecoverable to someone who recorded the ciphertext.
 *
 * But क्रम network ports/cookies, stack canaries, PRNG seeds, address
 * space layout अक्रमomization, session *authentication* keys, or other
 * applications where the sensitive data is stored in the kernel in
 * plaपूर्णांकext क्रम as दीर्घ as it's sensitive, the get_अक्रमom_पूर्णांक() family
 * is just fine.
 *
 * Consider ASLR.  We want to keep the address space secret from an
 * outside attacker जबतक the process is running, but once the address
 * space is torn करोwn, it's of no use to an attacker any more.  And it's
 * stored in kernel data काष्ठाures as दीर्घ as it's alive, so worrying
 * about an attacker's ability to extrapolate it from the get_अक्रमom_पूर्णांक()
 * CRNG is silly.
 *
 * Even some cryptographic keys are safe to generate with get_अक्रमom_पूर्णांक().
 * In particular, keys क्रम SipHash are generally fine.  Here, knowledge
 * of the key authorizes you to करो something to a kernel object (inject
 * packets to a network connection, or flood a hash table), and the
 * key is stored with the object being रक्षित.  Once it goes away,
 * we no दीर्घer care अगर anyone knows the key.
 *
 * pअक्रमom_u32()
 * -------------
 *
 * For even weaker applications, see the pseuकरोअक्रमom generator
 * pअक्रमom_u32(), pअक्रमom_max(), and pअक्रमom_bytes().  If the अक्रमom
 * numbers aren't security-critical at all, these are *far* cheaper.
 * Useful क्रम self-tests, अक्रमom error simulation, अक्रमomized backoffs,
 * and any other application where you trust that nobody is trying to
 * maliciously mess with you by guessing the "random" numbers.
 *
 * Exported पूर्णांकerfaces ---- input
 * ==============================
 *
 * The current exported पूर्णांकerfaces क्रम gathering environmental noise
 * from the devices are:
 *
 *	व्योम add_device_अक्रमomness(स्थिर व्योम *buf, अचिन्हित पूर्णांक size);
 * 	व्योम add_input_अक्रमomness(अचिन्हित पूर्णांक type, अचिन्हित पूर्णांक code,
 *                                अचिन्हित पूर्णांक value);
 *	व्योम add_पूर्णांकerrupt_अक्रमomness(पूर्णांक irq, पूर्णांक irq_flags);
 * 	व्योम add_disk_अक्रमomness(काष्ठा gendisk *disk);
 *
 * add_device_अक्रमomness() is क्रम adding data to the अक्रमom pool that
 * is likely to dअगरfer between two devices (or possibly even per boot).
 * This would be things like MAC addresses or serial numbers, or the
 * पढ़ो-out of the RTC. This करोes *not* add any actual entropy to the
 * pool, but it initializes the pool to dअगरferent values क्रम devices
 * that might otherwise be identical and have very little entropy
 * available to them (particularly common in the embedded world).
 *
 * add_input_अक्रमomness() uses the input layer पूर्णांकerrupt timing, as well as
 * the event type inक्रमmation from the hardware.
 *
 * add_पूर्णांकerrupt_अक्रमomness() uses the पूर्णांकerrupt timing as अक्रमom
 * inमाला_दो to the entropy pool. Using the cycle counters and the irq source
 * as inमाला_दो, it feeds the अक्रमomness roughly once a second.
 *
 * add_disk_अक्रमomness() uses what amounts to the seek समय of block
 * layer request events, on a per-disk_devt basis, as input to the
 * entropy pool. Note that high-speed solid state drives with very low
 * seek बार करो not make क्रम good sources of entropy, as their seek
 * बार are usually fairly consistent.
 *
 * All of these routines try to estimate how many bits of अक्रमomness a
 * particular अक्रमomness source.  They करो this by keeping track of the
 * first and second order deltas of the event timings.
 *
 * Ensuring unpredictability at प्रणाली startup
 * ============================================
 *
 * When any operating प्रणाली starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * अगर the start-up करोes not involve पूर्णांकeraction with a human चालक.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry inक्रमmation in the
 * entropy pool across shut-करोwns and start-ups.  To करो this, put the
 * following lines an appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	अक्रमom_seed=/var/run/अक्रमom-seed
 *	# Carry a अक्रमom seed from start-up to start-up
 *	# Load and then save the whole entropy pool
 *	अगर [ -f $अक्रमom_seed ]; then
 *		cat $अक्रमom_seed >/dev/uअक्रमom
 *	अन्यथा
 *		touch $अक्रमom_seed
 *	fi
 *	chmod 600 $अक्रमom_seed
 *	dd अगर=/dev/uअक्रमom of=$अक्रमom_seed count=1 bs=512
 *
 * and the following lines in an appropriate script which is run as
 * the प्रणाली is shutकरोwn:
 *
 *	# Carry a अक्रमom seed from shut-करोwn to start-up
 *	# Save the whole entropy pool
 *	echo "Saving random seed..."
 *	अक्रमom_seed=/var/run/अक्रमom-seed
 *	touch $अक्रमom_seed
 *	chmod 600 $अक्रमom_seed
 *	dd अगर=/dev/uअक्रमom of=$अक्रमom_seed count=1 bs=512
 *
 * For example, on most modern प्रणालीs using the System V init
 * scripts, such code fragments would be found in
 * /etc/rc.d/init.d/अक्रमom.  On older Linux प्रणालीs, the correct script
 * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shut-करोwn समय and reloaded पूर्णांकo the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/अक्रमom-seed is dअगरferent क्रम every start-up,
 * even अगर the प्रणाली crashes without executing rc.0.)  Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the प्रणाली.
 *
 * Configuring the /dev/अक्रमom driver under Linux
 * ==============================================
 *
 * The /dev/अक्रमom driver under Linux uses minor numbers 8 and 9 of
 * the /dev/mem major number (#1).  So अगर your प्रणाली करोes not have
 * /dev/अक्रमom and /dev/uअक्रमom created alपढ़ोy, they can be created
 * by using the commands:
 *
 * 	mknod /dev/अक्रमom c 1 8
 * 	mknod /dev/uअक्रमom c 1 9
 *
 * Acknowledgements:
 * =================
 *
 * Ideas क्रम स्थिरructing this अक्रमom number generator were derived
 * from Pretty Good Privacy's अक्रमom number generator, and from निजी
 * discussions with Phil Karn.  Colin Plumb provided a faster अक्रमom
 * number generator, which speed up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of authors of PGP.
 *
 * Further background inक्रमmation on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 */

#घोषणा pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#समावेश <linux/utsname.h>
#समावेश <linux/module.h>
#समावेश <linux/kernel.h>
#समावेश <linux/major.h>
#समावेश <linux/माला.स>
#समावेश <linux/fcntl.h>
#समावेश <linux/slab.h>
#समावेश <linux/अक्रमom.h>
#समावेश <linux/poll.h>
#समावेश <linux/init.h>
#समावेश <linux/fs.h>
#समावेश <linux/genhd.h>
#समावेश <linux/पूर्णांकerrupt.h>
#समावेश <linux/mm.h>
#समावेश <linux/nodemask.h>
#समावेश <linux/spinlock.h>
#समावेश <linux/kthपढ़ो.h>
#समावेश <linux/percpu.h>
#समावेश <linux/fips.h>
#समावेश <linux/ptrace.h>
#समावेश <linux/workqueue.h>
#समावेश <linux/irq.h>
#समावेश <linux/ratelimit.h>
#समावेश <linux/syscalls.h>
#समावेश <linux/completion.h>
#समावेश <linux/uuid.h>
#समावेश <crypto/chacha.h>
#समावेश <crypto/sha1.h>

#समावेश <यंत्र/processor.h>
#समावेश <linux/uaccess.h>
#समावेश <यंत्र/irq.h>
#समावेश <यंत्र/irq_regs.h>
#समावेश <यंत्र/पन.स>

#घोषणा CREATE_TRACE_POINTS
#समावेश <trace/events/अक्रमom.h>

/* #घोषणा ADD_INTERRUPT_BENCH */

/*
 * Configuration inक्रमmation
 */
#घोषणा INPUT_POOL_SHIFT	12
#घोषणा INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
#घोषणा OUTPUT_POOL_SHIFT	10
#घोषणा OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
#घोषणा EXTRACT_SIZE		10


#घोषणा LONGS(x) (((x) + माप(अचिन्हित दीर्घ) - 1)/माप(अचिन्हित दीर्घ))

/*
 * To allow fractional bits to be tracked, the entropy_count field is
 * denominated in units of 1/8th bits.
 *
 * 2*(ENTROPY_SHIFT + poolbitshअगरt) must <= 31, or the multiply in
 * credit_entropy_bits() needs to be 64 bits wide.
 */
#घोषणा ENTROPY_SHIFT 3
#घोषणा ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)

/*
 * If the entropy count falls under this number of bits, then we
 * should wake up processes which are selecting or polling on ग_लिखो
 * access to /dev/अक्रमom.
 */
अटल पूर्णांक अक्रमom_ग_लिखो_wakeup_bits = 28 * OUTPUT_POOL_WORDS;

/*
 * Originally, we used a primitive polynomial of degree .poolwords
 * over GF(2).  The taps क्रम various sizes are defined below.  They
 * were chosen to be evenly spaced except क्रम the last tap, which is 1
 * to get the twisting happening as fast as possible.
 *
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a (modअगरied) twisted Generalized Feedback Shअगरt
 * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
 * generators.  ACM Transactions on Modeling and Computer Simulation
 * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
 * GFSR generators II.  ACM Transactions on Modeling and Computer
 * Simulation 4:254-266)
 *
 * Thanks to Colin Plumb क्रम suggesting this.
 *
 * The mixing operation is much less sensitive than the output hash,
 * where we use SHA-1.  All that we want of mixing operation is that
 * it be a good non-cryptographic hash; i.e. it not produce collisions
 * when fed "random" data of the sort we expect to see.  As दीर्घ as
 * the pool state dअगरfers क्रम dअगरferent inमाला_दो, we have preserved the
 * input entropy and करोne a good job.  The fact that an पूर्णांकelligent
 * attacker can स्थिरruct inमाला_दो that will produce controlled
 * alterations to the pool's state is not important because we don't
 * consider such inमाला_दो to contribute any अक्रमomness.  The only
 * property we need with respect to them is that the attacker can't
 * increase his/her knowledge of the pool's state.  Since all
 * additions are reversible (knowing the final state and the input,
 * you can reस्थिरruct the initial state), अगर an attacker has any
 * uncertaपूर्णांकy about the initial state, he/she can only shuffle that
 * uncertaपूर्णांकy about, but never cause any collisions (which would
 * decrease the uncertaपूर्णांकy).
 *
 * Our mixing functions were analyzed by Laअक्षरme, Roeck, Strubel, and
 * Videau in their paper, "The Linux Pseuकरोअक्रमom Number Generator
 * Revisited" (see: http://eprपूर्णांक.iacr.org/2012/251.pdf).  In their
 * paper, they poपूर्णांक out that we are not using a true Twisted GFSR,
 * since Matsumoto & Kurita used a trinomial feedback polynomial (that
 * is, with only three taps, instead of the six that we are using).
 * As a result, the resulting polynomial is neither primitive nor
 * irreducible, and hence करोes not have a maximal period over
 * GF(2**32).  They suggest a slight change to the generator
 * polynomial which improves the resulting TGFSR polynomial to be
 * irreducible, which we have made here.
 */
अटल स्थिर काष्ठा poolinfo अणु
	पूर्णांक poolbitshअगरt, poolwords, poolbytes, poolfracbits;
#घोषणा S(x) ilog2(x)+5, (x), (x)*4, (x) << (ENTROPY_SHIFT+5)
	पूर्णांक tap1, tap2, tap3, tap4, tap5;
पूर्ण poolinfo_table[] = अणु
	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
	अणु S(128),	104,	76,	51,	25,	1 पूर्ण,
पूर्ण;

/*
 * Static global variables
 */
अटल DECLARE_WAIT_QUEUE_HEAD(अक्रमom_ग_लिखो_रुको);
अटल काष्ठा fasync_काष्ठा *fasync;

अटल DEFINE_SPINLOCK(अक्रमom_पढ़ोy_list_lock);
अटल LIST_HEAD(अक्रमom_पढ़ोy_list);

काष्ठा crng_state अणु
	__u32		state[16];
	अचिन्हित दीर्घ	init_समय;
	spinlock_t	lock;
पूर्ण;

अटल काष्ठा crng_state primary_crng = अणु
	.lock = __SPIN_LOCK_UNLOCKED(primary_crng.lock),
पूर्ण;

/*
 * crng_init =  0 --> Uninitialized
 *		1 --> Initialized
 *		2 --> Initialized from input_pool
 *
 * crng_init is रक्षित by primary_crng->lock, and only increases
 * its value (from 0->1->2).
 */
अटल पूर्णांक crng_init = 0;
#घोषणा crng_पढ़ोy() (likely(crng_init > 1))
अटल पूर्णांक crng_init_cnt = 0;
अटल अचिन्हित दीर्घ crng_global_init_समय = 0;
#घोषणा CRNG_INIT_CNT_THRESH (2*CHACHA_KEY_SIZE)
अटल व्योम _extract_crng(काष्ठा crng_state *crng, __u8 out[CHACHA_BLOCK_SIZE]);
अटल व्योम _crng_backtrack_protect(काष्ठा crng_state *crng,
				    __u8 पंचांगp[CHACHA_BLOCK_SIZE], पूर्णांक used);
अटल व्योम process_अक्रमom_पढ़ोy_list(व्योम);
अटल व्योम _get_अक्रमom_bytes(व्योम *buf, पूर्णांक nbytes);

अटल काष्ठा ratelimit_state unseeded_warning =
	RATELIMIT_STATE_INIT("warn_unseeded_randomness", HZ, 3);
अटल काष्ठा ratelimit_state uअक्रमom_warning =
	RATELIMIT_STATE_INIT("warn_urandom_randomness", HZ, 3);

अटल पूर्णांक ratelimit_disable __पढ़ो_mostly;

module_param_named(ratelimit_disable, ratelimit_disable, पूर्णांक, 0644);
MODULE_PARM_DESC(ratelimit_disable, "Disable random ratelimit suppression");

/**********************************************************************
 *
 * OS independent entropy store.   Here are the functions which handle
 * storing entropy in an entropy pool.
 *
 **********************************************************************/

काष्ठा entropy_store;
काष्ठा entropy_store अणु
	/* पढ़ो-only data: */
	स्थिर काष्ठा poolinfo *poolinfo;
	__u32 *pool;
	स्थिर अक्षर *name;

	/* पढ़ो-ग_लिखो data: */
	spinlock_t lock;
	अचिन्हित लघु add_ptr;
	अचिन्हित लघु input_rotate;
	पूर्णांक entropy_count;
	अचिन्हित पूर्णांक last_data_init:1;
	__u8 last_data[EXTRACT_SIZE];
पूर्ण;

अटल sमाप_प्रकार extract_entropy(काष्ठा entropy_store *r, व्योम *buf,
			       माप_प्रकार nbytes, पूर्णांक min, पूर्णांक rsvd);
अटल sमाप_प्रकार _extract_entropy(काष्ठा entropy_store *r, व्योम *buf,
				माप_प्रकार nbytes, पूर्णांक fips);

अटल व्योम crng_reseed(काष्ठा crng_state *crng, काष्ठा entropy_store *r);
अटल __u32 input_pool_data[INPUT_POOL_WORDS] __latent_entropy;

अटल काष्ठा entropy_store input_pool = अणु
	.poolinfo = &poolinfo_table[0],
	.name = "input",
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
	.pool = input_pool_data
पूर्ण;

अटल __u32 स्थिर twist_table[8] = अणु
	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 पूर्ण;

/*
 * This function adds bytes पूर्णांकo the entropy "pool".  It करोes not
 * update the entropy estimate.  The caller should call
 * credit_entropy_bits अगर this is appropriate.
 *
 * The pool is stirred with a primitive polynomial of the appropriate
 * degree, and then twisted.  We twist by three bits at a समय because
 * it's cheap to करो so and helps slightly in the expected हाल where
 * the entropy is concentrated in the low-order bits.
 */
अटल व्योम _mix_pool_bytes(काष्ठा entropy_store *r, स्थिर व्योम *in,
			    पूर्णांक nbytes)
अणु
	अचिन्हित दीर्घ i, tap1, tap2, tap3, tap4, tap5;
	पूर्णांक input_rotate;
	पूर्णांक wordmask = r->poolinfo->poolwords - 1;
	स्थिर अक्षर *bytes = in;
	__u32 w;

	tap1 = r->poolinfo->tap1;
	tap2 = r->poolinfo->tap2;
	tap3 = r->poolinfo->tap3;
	tap4 = r->poolinfo->tap4;
	tap5 = r->poolinfo->tap5;

	input_rotate = r->input_rotate;
	i = r->add_ptr;

	/* mix one byte at a समय to simplअगरy size handling and churn faster */
	जबतक (nbytes--) अणु
		w = rol32(*bytes++, input_rotate);
		i = (i - 1) & wordmask;

		/* XOR in the various taps */
		w ^= r->pool[i];
		w ^= r->pool[(i + tap1) & wordmask];
		w ^= r->pool[(i + tap2) & wordmask];
		w ^= r->pool[(i + tap3) & wordmask];
		w ^= r->pool[(i + tap4) & wordmask];
		w ^= r->pool[(i + tap5) & wordmask];

		/* Mix the result back in with a twist */
		r->pool[i] = (w >> 3) ^ twist_table[w & 7];

		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spपढ़ो the
		 * input bits across the pool evenly.
		 */
		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
	पूर्ण

	r->input_rotate = input_rotate;
	r->add_ptr = i;
पूर्ण

अटल व्योम __mix_pool_bytes(काष्ठा entropy_store *r, स्थिर व्योम *in,
			     पूर्णांक nbytes)
अणु
	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
	_mix_pool_bytes(r, in, nbytes);
पूर्ण

अटल व्योम mix_pool_bytes(काष्ठा entropy_store *r, स्थिर व्योम *in,
			   पूर्णांक nbytes)
अणु
	अचिन्हित दीर्घ flags;

	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
	spin_lock_irqsave(&r->lock, flags);
	_mix_pool_bytes(r, in, nbytes);
	spin_unlock_irqrestore(&r->lock, flags);
पूर्ण

काष्ठा fast_pool अणु
	__u32		pool[4];
	अचिन्हित दीर्घ	last;
	अचिन्हित लघु	reg_idx;
	अचिन्हित अक्षर	count;
पूर्ण;

/*
 * This is a fast mixing routine used by the पूर्णांकerrupt अक्रमomness
 * collector.  It's hardcoded क्रम an 128 bit pool and assumes that any
 * locks that might be needed are taken by the caller.
 */
अटल व्योम fast_mix(काष्ठा fast_pool *f)
अणु
	__u32 a = f->pool[0],	b = f->pool[1];
	__u32 c = f->pool[2],	d = f->pool[3];

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	f->pool[0] = a;  f->pool[1] = b;
	f->pool[2] = c;  f->pool[3] = d;
	f->count++;
पूर्ण

अटल व्योम process_अक्रमom_पढ़ोy_list(व्योम)
अणु
	अचिन्हित दीर्घ flags;
	काष्ठा अक्रमom_पढ़ोy_callback *rdy, *पंचांगp;

	spin_lock_irqsave(&अक्रमom_पढ़ोy_list_lock, flags);
	list_क्रम_each_entry_safe(rdy, पंचांगp, &अक्रमom_पढ़ोy_list, list) अणु
		काष्ठा module *owner = rdy->owner;

		list_del_init(&rdy->list);
		rdy->func(rdy);
		module_put(owner);
	पूर्ण
	spin_unlock_irqrestore(&अक्रमom_पढ़ोy_list_lock, flags);
पूर्ण

/*
 * Credit (or debit) the entropy store with n bits of entropy.
 * Use credit_entropy_bits_safe() अगर the value comes from userspace
 * or otherwise should be checked क्रम extreme values.
 */
अटल व्योम credit_entropy_bits(काष्ठा entropy_store *r, पूर्णांक nbits)
अणु
	पूर्णांक entropy_count, orig;
	स्थिर पूर्णांक pool_size = r->poolinfo->poolfracbits;
	पूर्णांक nfrac = nbits << ENTROPY_SHIFT;

	अगर (!nbits)
		वापस;

retry:
	entropy_count = orig = READ_ONCE(r->entropy_count);
	अगर (nfrac < 0) अणु
		/* Debit */
		entropy_count += nfrac;
	पूर्ण अन्यथा अणु
		/*
		 * Credit: we have to account क्रम the possibility of
		 * overwriting alपढ़ोy present entropy.	 Even in the
		 * ideal हाल of pure Shannon entropy, new contributions
		 * approach the full value asymptotically:
		 *
		 * entropy <- entropy + (pool_size - entropy) *
		 *	(1 - exp(-add_entropy/pool_size))
		 *
		 * For add_entropy <= pool_size/2 then
		 * (1 - exp(-add_entropy/pool_size)) >=
		 *    (add_entropy/pool_size)*0.7869...
		 * so we can approximate the exponential with
		 * 3/4*add_entropy/pool_size and still be on the
		 * safe side by adding at most pool_size/2 at a समय.
		 *
		 * The use of pool_size-2 in the जबतक statement is to
		 * prevent rounding artअगरacts from making the loop
		 * arbitrarily दीर्घ; this limits the loop to log2(pool_size)*2
		 * turns no matter how large nbits is.
		 */
		पूर्णांक pnfrac = nfrac;
		स्थिर पूर्णांक s = r->poolinfo->poolbitshअगरt + ENTROPY_SHIFT + 2;
		/* The +2 corresponds to the /4 in the denominator */

		करो अणु
			अचिन्हित पूर्णांक anfrac = min(pnfrac, pool_size/2);
			अचिन्हित पूर्णांक add =
				((pool_size - entropy_count)*anfrac*3) >> s;

			entropy_count += add;
			pnfrac -= anfrac;
		पूर्ण जबतक (unlikely(entropy_count < pool_size-2 && pnfrac));
	पूर्ण

	अगर (WARN_ON(entropy_count < 0)) अणु
		pr_warn("negative entropy/overflow: pool %s count %d\n",
			r->name, entropy_count);
		entropy_count = 0;
	पूर्ण अन्यथा अगर (entropy_count > pool_size)
		entropy_count = pool_size;
	अगर (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		जाओ retry;

	trace_credit_entropy_bits(r->name, nbits,
				  entropy_count >> ENTROPY_SHIFT, _RET_IP_);

	अगर (r == &input_pool) अणु
		पूर्णांक entropy_bits = entropy_count >> ENTROPY_SHIFT;

		अगर (crng_init < 2 && entropy_bits >= 128)
			crng_reseed(&primary_crng, r);
	पूर्ण
पूर्ण

अटल पूर्णांक credit_entropy_bits_safe(काष्ठा entropy_store *r, पूर्णांक nbits)
अणु
	स्थिर पूर्णांक nbits_max = r->poolinfo->poolwords * 32;

	अगर (nbits < 0)
		वापस -EINVAL;

	/* Cap the value to aव्योम overflows */
	nbits = min(nbits,  nbits_max);

	credit_entropy_bits(r, nbits);
	वापस 0;
पूर्ण

/*********************************************************************
 *
 * CRNG using CHACHA20
 *
 *********************************************************************/

#घोषणा CRNG_RESEED_INTERVAL (300*HZ)

अटल DECLARE_WAIT_QUEUE_HEAD(crng_init_रुको);

#अगर_घोषित CONFIG_NUMA
/*
 * Hack to deal with crazy userspace progams when they are all trying
 * to access /dev/uअक्रमom in parallel.  The programs are almost
 * certainly करोing something terribly wrong, but we'll work around
 * their brain damage.
 */
अटल काष्ठा crng_state **crng_node_pool __पढ़ो_mostly;
#पूर्ण_अगर

अटल व्योम invalidate_batched_entropy(व्योम);
अटल व्योम numa_crng_init(व्योम);

अटल bool trust_cpu __ro_after_init = IS_ENABLED(CONFIG_RANDOM_TRUST_CPU);
अटल पूर्णांक __init parse_trust_cpu(अक्षर *arg)
अणु
	वापस kstrtobool(arg, &trust_cpu);
पूर्ण
early_param("random.trust_cpu", parse_trust_cpu);

अटल bool crng_init_try_arch(काष्ठा crng_state *crng)
अणु
	पूर्णांक		i;
	bool		arch_init = true;
	अचिन्हित दीर्घ	rv;

	क्रम (i = 4; i < 16; i++) अणु
		अगर (!arch_get_अक्रमom_seed_दीर्घ(&rv) &&
		    !arch_get_अक्रमom_दीर्घ(&rv)) अणु
			rv = अक्रमom_get_entropy();
			arch_init = false;
		पूर्ण
		crng->state[i] ^= rv;
	पूर्ण

	वापस arch_init;
पूर्ण

अटल bool __init crng_init_try_arch_early(काष्ठा crng_state *crng)
अणु
	पूर्णांक		i;
	bool		arch_init = true;
	अचिन्हित दीर्घ	rv;

	क्रम (i = 4; i < 16; i++) अणु
		अगर (!arch_get_अक्रमom_seed_दीर्घ_early(&rv) &&
		    !arch_get_अक्रमom_दीर्घ_early(&rv)) अणु
			rv = अक्रमom_get_entropy();
			arch_init = false;
		पूर्ण
		crng->state[i] ^= rv;
	पूर्ण

	वापस arch_init;
पूर्ण

अटल व्योम __maybe_unused crng_initialize_secondary(काष्ठा crng_state *crng)
अणु
	chacha_init_स्थिरs(crng->state);
	_get_अक्रमom_bytes(&crng->state[4], माप(__u32) * 12);
	crng_init_try_arch(crng);
	crng->init_समय = jअगरfies - CRNG_RESEED_INTERVAL - 1;
पूर्ण

अटल व्योम __init crng_initialize_primary(काष्ठा crng_state *crng)
अणु
	chacha_init_स्थिरs(crng->state);
	_extract_entropy(&input_pool, &crng->state[4], माप(__u32) * 12, 0);
	अगर (crng_init_try_arch_early(crng) && trust_cpu) अणु
		invalidate_batched_entropy();
		numa_crng_init();
		crng_init = 2;
		pr_notice("crng done (trusting CPU's manufacturer)\n");
	पूर्ण
	crng->init_समय = jअगरfies - CRNG_RESEED_INTERVAL - 1;
पूर्ण

#अगर_घोषित CONFIG_NUMA
अटल व्योम करो_numa_crng_init(काष्ठा work_काष्ठा *work)
अणु
	पूर्णांक i;
	काष्ठा crng_state *crng;
	काष्ठा crng_state **pool;

	pool = kसुस्मृति(nr_node_ids, माप(*pool), GFP_KERNEL|__GFP_NOFAIL);
	क्रम_each_online_node(i) अणु
		crng = kदो_स्मृति_node(माप(काष्ठा crng_state),
				    GFP_KERNEL | __GFP_NOFAIL, i);
		spin_lock_init(&crng->lock);
		crng_initialize_secondary(crng);
		pool[i] = crng;
	पूर्ण
	mb();
	अगर (cmpxchg(&crng_node_pool, शून्य, pool)) अणु
		क्रम_each_node(i)
			kमुक्त(pool[i]);
		kमुक्त(pool);
	पूर्ण
पूर्ण

अटल DECLARE_WORK(numa_crng_init_work, करो_numa_crng_init);

अटल व्योम numa_crng_init(व्योम)
अणु
	schedule_work(&numa_crng_init_work);
पूर्ण
#अन्यथा
अटल व्योम numa_crng_init(व्योम) अणुपूर्ण
#पूर्ण_अगर

/*
 * crng_fast_load() can be called by code in the पूर्णांकerrupt service
 * path.  So we can't afक्रमd to dilly-dally.
 */
अटल पूर्णांक crng_fast_load(स्थिर अक्षर *cp, माप_प्रकार len)
अणु
	अचिन्हित दीर्घ flags;
	अक्षर *p;

	अगर (!spin_trylock_irqsave(&primary_crng.lock, flags))
		वापस 0;
	अगर (crng_init != 0) अणु
		spin_unlock_irqrestore(&primary_crng.lock, flags);
		वापस 0;
	पूर्ण
	p = (अचिन्हित अक्षर *) &primary_crng.state[4];
	जबतक (len > 0 && crng_init_cnt < CRNG_INIT_CNT_THRESH) अणु
		p[crng_init_cnt % CHACHA_KEY_SIZE] ^= *cp;
		cp++; crng_init_cnt++; len--;
	पूर्ण
	spin_unlock_irqrestore(&primary_crng.lock, flags);
	अगर (crng_init_cnt >= CRNG_INIT_CNT_THRESH) अणु
		invalidate_batched_entropy();
		crng_init = 1;
		pr_notice("fast init done\n");
	पूर्ण
	वापस 1;
पूर्ण

/*
 * crng_slow_load() is called by add_device_अक्रमomness, which has two
 * attributes.  (1) We can't trust the buffer passed to it is
 * guaranteed to be unpredictable (so it might not have any entropy at
 * all), and (2) it करोesn't have the perक्रमmance स्थिरraपूर्णांकs of
 * crng_fast_load().
 *
 * So we करो something more comprehensive which is guaranteed to touch
 * all of the primary_crng's state, and which uses a LFSR with a
 * period of 255 as part of the mixing algorithm.  Finally, we करो
 * *not* advance crng_init_cnt since buffer we may get may be something
 * like a fixed DMI table (क्रम example), which might very well be
 * unique to the machine, but is otherwise unvarying.
 */
अटल पूर्णांक crng_slow_load(स्थिर अक्षर *cp, माप_प्रकार len)
अणु
	अचिन्हित दीर्घ		flags;
	अटल अचिन्हित अक्षर	lfsr = 1;
	अचिन्हित अक्षर		पंचांगp;
	अचिन्हित		i, max = CHACHA_KEY_SIZE;
	स्थिर अक्षर *		src_buf = cp;
	अक्षर *			dest_buf = (अक्षर *) &primary_crng.state[4];

	अगर (!spin_trylock_irqsave(&primary_crng.lock, flags))
		वापस 0;
	अगर (crng_init != 0) अणु
		spin_unlock_irqrestore(&primary_crng.lock, flags);
		वापस 0;
	पूर्ण
	अगर (len > max)
		max = len;

	क्रम (i = 0; i < max ; i++) अणु
		पंचांगp = lfsr;
		lfsr >>= 1;
		अगर (पंचांगp & 1)
			lfsr ^= 0xE1;
		पंचांगp = dest_buf[i % CHACHA_KEY_SIZE];
		dest_buf[i % CHACHA_KEY_SIZE] ^= src_buf[i % len] ^ lfsr;
		lfsr += (पंचांगp << 3) | (पंचांगp >> 5);
	पूर्ण
	spin_unlock_irqrestore(&primary_crng.lock, flags);
	वापस 1;
पूर्ण

अटल व्योम crng_reseed(काष्ठा crng_state *crng, काष्ठा entropy_store *r)
अणु
	अचिन्हित दीर्घ	flags;
	पूर्णांक		i, num;
	जोड़ अणु
		__u8	block[CHACHA_BLOCK_SIZE];
		__u32	key[8];
	पूर्ण buf;

	अगर (r) अणु
		num = extract_entropy(r, &buf, 32, 16, 0);
		अगर (num == 0)
			वापस;
	पूर्ण अन्यथा अणु
		_extract_crng(&primary_crng, buf.block);
		_crng_backtrack_protect(&primary_crng, buf.block,
					CHACHA_KEY_SIZE);
	पूर्ण
	spin_lock_irqsave(&crng->lock, flags);
	क्रम (i = 0; i < 8; i++) अणु
		अचिन्हित दीर्घ	rv;
		अगर (!arch_get_अक्रमom_seed_दीर्घ(&rv) &&
		    !arch_get_अक्रमom_दीर्घ(&rv))
			rv = अक्रमom_get_entropy();
		crng->state[i+4] ^= buf.key[i] ^ rv;
	पूर्ण
	memzero_explicit(&buf, माप(buf));
	crng->init_समय = jअगरfies;
	spin_unlock_irqrestore(&crng->lock, flags);
	अगर (crng == &primary_crng && crng_init < 2) अणु
		invalidate_batched_entropy();
		numa_crng_init();
		crng_init = 2;
		process_अक्रमom_पढ़ोy_list();
		wake_up_पूर्णांकerruptible(&crng_init_रुको);
		समाप्त_fasync(&fasync, SIGIO, POLL_IN);
		pr_notice("crng init done\n");
		अगर (unseeded_warning.missed) अणु
			pr_notice("%d get_random_xx warning(s) missed due to ratelimiting\n",
				  unseeded_warning.missed);
			unseeded_warning.missed = 0;
		पूर्ण
		अगर (uअक्रमom_warning.missed) अणु
			pr_notice("%d urandom warning(s) missed due to ratelimiting\n",
				  uअक्रमom_warning.missed);
			uअक्रमom_warning.missed = 0;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम _extract_crng(काष्ठा crng_state *crng,
			  __u8 out[CHACHA_BLOCK_SIZE])
अणु
	अचिन्हित दीर्घ v, flags;

	अगर (crng_पढ़ोy() &&
	    (समय_after(crng_global_init_समय, crng->init_समय) ||
	     समय_after(jअगरfies, crng->init_समय + CRNG_RESEED_INTERVAL)))
		crng_reseed(crng, crng == &primary_crng ? &input_pool : शून्य);
	spin_lock_irqsave(&crng->lock, flags);
	अगर (arch_get_अक्रमom_दीर्घ(&v))
		crng->state[14] ^= v;
	chacha20_block(&crng->state[0], out);
	अगर (crng->state[12] == 0)
		crng->state[13]++;
	spin_unlock_irqrestore(&crng->lock, flags);
पूर्ण

अटल व्योम extract_crng(__u8 out[CHACHA_BLOCK_SIZE])
अणु
	काष्ठा crng_state *crng = शून्य;

#अगर_घोषित CONFIG_NUMA
	अगर (crng_node_pool)
		crng = crng_node_pool[numa_node_id()];
	अगर (crng == शून्य)
#पूर्ण_अगर
		crng = &primary_crng;
	_extract_crng(crng, out);
पूर्ण

/*
 * Use the leftover bytes from the CRNG block output (अगर there is
 * enough) to mutate the CRNG key to provide backtracking protection.
 */
अटल व्योम _crng_backtrack_protect(काष्ठा crng_state *crng,
				    __u8 पंचांगp[CHACHA_BLOCK_SIZE], पूर्णांक used)
अणु
	अचिन्हित दीर्घ	flags;
	__u32		*s, *d;
	पूर्णांक		i;

	used = round_up(used, माप(__u32));
	अगर (used + CHACHA_KEY_SIZE > CHACHA_BLOCK_SIZE) अणु
		extract_crng(पंचांगp);
		used = 0;
	पूर्ण
	spin_lock_irqsave(&crng->lock, flags);
	s = (__u32 *) &पंचांगp[used];
	d = &crng->state[4];
	क्रम (i=0; i < 8; i++)
		*d++ ^= *s++;
	spin_unlock_irqrestore(&crng->lock, flags);
पूर्ण

अटल व्योम crng_backtrack_protect(__u8 पंचांगp[CHACHA_BLOCK_SIZE], पूर्णांक used)
अणु
	काष्ठा crng_state *crng = शून्य;

#अगर_घोषित CONFIG_NUMA
	अगर (crng_node_pool)
		crng = crng_node_pool[numa_node_id()];
	अगर (crng == शून्य)
#पूर्ण_अगर
		crng = &primary_crng;
	_crng_backtrack_protect(crng, पंचांगp, used);
पूर्ण

अटल sमाप_प्रकार extract_crng_user(व्योम __user *buf, माप_प्रकार nbytes)
अणु
	sमाप_प्रकार ret = 0, i = CHACHA_BLOCK_SIZE;
	__u8 पंचांगp[CHACHA_BLOCK_SIZE] __aligned(4);
	पूर्णांक large_request = (nbytes > 256);

	जबतक (nbytes) अणु
		अगर (large_request && need_resched()) अणु
			अगर (संकेत_pending(current)) अणु
				अगर (ret == 0)
					ret = -ERESTARTSYS;
				अवरोध;
			पूर्ण
			schedule();
		पूर्ण

		extract_crng(पंचांगp);
		i = min_t(पूर्णांक, nbytes, CHACHA_BLOCK_SIZE);
		अगर (copy_to_user(buf, पंचांगp, i)) अणु
			ret = -EFAULT;
			अवरोध;
		पूर्ण

		nbytes -= i;
		buf += i;
		ret += i;
	पूर्ण
	crng_backtrack_protect(पंचांगp, i);

	/* Wipe data just written to memory */
	memzero_explicit(पंचांगp, माप(पंचांगp));

	वापस ret;
पूर्ण


/*********************************************************************
 *
 * Entropy input management
 *
 *********************************************************************/

/* There is one of these per entropy source */
काष्ठा समयr_अक्रम_state अणु
	cycles_t last_समय;
	दीर्घ last_delta, last_delta2;
पूर्ण;

#घोषणा INIT_TIMER_RAND_STATE अणु INITIAL_JIFFIES, पूर्ण;

/*
 * Add device- or boot-specअगरic data to the input pool to help
 * initialize it.
 *
 * None of this adds any entropy; it is meant to aव्योम the problem of
 * the entropy pool having similar initial state across largely
 * identical devices.
 */
व्योम add_device_अक्रमomness(स्थिर व्योम *buf, अचिन्हित पूर्णांक size)
अणु
	अचिन्हित दीर्घ समय = अक्रमom_get_entropy() ^ jअगरfies;
	अचिन्हित दीर्घ flags;

	अगर (!crng_पढ़ोy() && size)
		crng_slow_load(buf, size);

	trace_add_device_अक्रमomness(size, _RET_IP_);
	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(&input_pool, buf, size);
	_mix_pool_bytes(&input_pool, &समय, माप(समय));
	spin_unlock_irqrestore(&input_pool.lock, flags);
पूर्ण
EXPORT_SYMBOL(add_device_अक्रमomness);

अटल काष्ठा समयr_अक्रम_state input_समयr_state = INIT_TIMER_RAND_STATE;

/*
 * This function adds entropy to the entropy "pool" by using timing
 * delays.  It uses the समयr_अक्रम_state काष्ठाure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "num" is also added to the pool - it should somehow describe
 * the type of event which just happened.  This is currently 0-255 क्रम
 * keyboard scan codes, and 256 upwards क्रम पूर्णांकerrupts.
 *
 */
अटल व्योम add_समयr_अक्रमomness(काष्ठा समयr_अक्रम_state *state, अचिन्हित num)
अणु
	काष्ठा entropy_store	*r;
	काष्ठा अणु
		दीर्घ jअगरfies;
		अचिन्हित cycles;
		अचिन्हित num;
	पूर्ण sample;
	दीर्घ delta, delta2, delta3;

	sample.jअगरfies = jअगरfies;
	sample.cycles = अक्रमom_get_entropy();
	sample.num = num;
	r = &input_pool;
	mix_pool_bytes(r, &sample, माप(sample));

	/*
	 * Calculate number of bits of अक्रमomness we probably added.
	 * We take पूर्णांकo account the first, second and third-order deltas
	 * in order to make our estimate.
	 */
	delta = sample.jअगरfies - READ_ONCE(state->last_समय);
	WRITE_ONCE(state->last_समय, sample.jअगरfies);

	delta2 = delta - READ_ONCE(state->last_delta);
	WRITE_ONCE(state->last_delta, delta);

	delta3 = delta2 - READ_ONCE(state->last_delta2);
	WRITE_ONCE(state->last_delta2, delta2);

	अगर (delta < 0)
		delta = -delta;
	अगर (delta2 < 0)
		delta2 = -delta2;
	अगर (delta3 < 0)
		delta3 = -delta3;
	अगर (delta > delta2)
		delta = delta2;
	अगर (delta > delta3)
		delta = delta3;

	/*
	 * delta is now minimum असलolute delta.
	 * Round करोwn by 1 bit on general principles,
	 * and limit entropy estimate to 12 bits.
	 */
	credit_entropy_bits(r, min_t(पूर्णांक, fls(delta>>1), 11));
पूर्ण

व्योम add_input_अक्रमomness(अचिन्हित पूर्णांक type, अचिन्हित पूर्णांक code,
				 अचिन्हित पूर्णांक value)
अणु
	अटल अचिन्हित अक्षर last_value;

	/* ignore स्वतःrepeat and the like */
	अगर (value == last_value)
		वापस;

	last_value = value;
	add_समयr_अक्रमomness(&input_समयr_state,
			     (type << 4) ^ code ^ (code >> 4) ^ value);
	trace_add_input_अक्रमomness(ENTROPY_BITS(&input_pool));
पूर्ण
EXPORT_SYMBOL_GPL(add_input_अक्रमomness);

अटल DEFINE_PER_CPU(काष्ठा fast_pool, irq_अक्रमomness);

#अगर_घोषित ADD_INTERRUPT_BENCH
अटल अचिन्हित दीर्घ avg_cycles, avg_deviation;

#घोषणा AVG_SHIFT 8     /* Exponential average factor k=1/256 */
#घोषणा FIXED_1_2 (1 << (AVG_SHIFT-1))

अटल व्योम add_पूर्णांकerrupt_bench(cycles_t start)
अणु
        दीर्घ delta = अक्रमom_get_entropy() - start;

        /* Use a weighted moving average */
        delta = delta - ((avg_cycles + FIXED_1_2) >> AVG_SHIFT);
        avg_cycles += delta;
        /* And average deviation */
        delta = असल(delta) - ((avg_deviation + FIXED_1_2) >> AVG_SHIFT);
        avg_deviation += delta;
पूर्ण
#अन्यथा
#घोषणा add_पूर्णांकerrupt_bench(x)
#पूर्ण_अगर

अटल __u32 get_reg(काष्ठा fast_pool *f, काष्ठा pt_regs *regs)
अणु
	__u32 *ptr = (__u32 *) regs;
	अचिन्हित पूर्णांक idx;

	अगर (regs == शून्य)
		वापस 0;
	idx = READ_ONCE(f->reg_idx);
	अगर (idx >= माप(काष्ठा pt_regs) / माप(__u32))
		idx = 0;
	ptr += idx++;
	WRITE_ONCE(f->reg_idx, idx);
	वापस *ptr;
पूर्ण

व्योम add_पूर्णांकerrupt_अक्रमomness(पूर्णांक irq, पूर्णांक irq_flags)
अणु
	काष्ठा entropy_store	*r;
	काष्ठा fast_pool	*fast_pool = this_cpu_ptr(&irq_अक्रमomness);
	काष्ठा pt_regs		*regs = get_irq_regs();
	अचिन्हित दीर्घ		now = jअगरfies;
	cycles_t		cycles = अक्रमom_get_entropy();
	__u32			c_high, j_high;
	__u64			ip;

	अगर (cycles == 0)
		cycles = get_reg(fast_pool, regs);
	c_high = (माप(cycles) > 4) ? cycles >> 32 : 0;
	j_high = (माप(now) > 4) ? now >> 32 : 0;
	fast_pool->pool[0] ^= cycles ^ j_high ^ irq;
	fast_pool->pool[1] ^= now ^ c_high;
	ip = regs ? inकाष्ठाion_poपूर्णांकer(regs) : _RET_IP_;
	fast_pool->pool[2] ^= ip;
	fast_pool->pool[3] ^= (माप(ip) > 4) ? ip >> 32 :
		get_reg(fast_pool, regs);

	fast_mix(fast_pool);
	add_पूर्णांकerrupt_bench(cycles);

	अगर (unlikely(crng_init == 0)) अणु
		अगर ((fast_pool->count >= 64) &&
		    crng_fast_load((अक्षर *) fast_pool->pool,
				   माप(fast_pool->pool))) अणु
			fast_pool->count = 0;
			fast_pool->last = now;
		पूर्ण
		वापस;
	पूर्ण

	अगर ((fast_pool->count < 64) &&
	    !समय_after(now, fast_pool->last + HZ))
		वापस;

	r = &input_pool;
	अगर (!spin_trylock(&r->lock))
		वापस;

	fast_pool->last = now;
	__mix_pool_bytes(r, &fast_pool->pool, माप(fast_pool->pool));
	spin_unlock(&r->lock);

	fast_pool->count = 0;

	/* award one bit क्रम the contents of the fast pool */
	credit_entropy_bits(r, 1);
पूर्ण
EXPORT_SYMBOL_GPL(add_पूर्णांकerrupt_अक्रमomness);

#अगर_घोषित CONFIG_BLOCK
व्योम add_disk_अक्रमomness(काष्ठा gendisk *disk)
अणु
	अगर (!disk || !disk->अक्रमom)
		वापस;
	/* first major is 1, so we get >= 0x200 here */
	add_समयr_अक्रमomness(disk->अक्रमom, 0x100 + disk_devt(disk));
	trace_add_disk_अक्रमomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
पूर्ण
EXPORT_SYMBOL_GPL(add_disk_अक्रमomness);
#पूर्ण_अगर

/*********************************************************************
 *
 * Entropy extraction routines
 *
 *********************************************************************/

/*
 * This function decides how many bytes to actually take from the
 * given pool, and also debits the entropy count accordingly.
 */
अटल माप_प्रकार account(काष्ठा entropy_store *r, माप_प्रकार nbytes, पूर्णांक min,
		      पूर्णांक reserved)
अणु
	पूर्णांक entropy_count, orig, have_bytes;
	माप_प्रकार ibytes, nfrac;

	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);

	/* Can we pull enough? */
retry:
	entropy_count = orig = READ_ONCE(r->entropy_count);
	ibytes = nbytes;
	/* never pull more than available */
	have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);

	अगर ((have_bytes -= reserved) < 0)
		have_bytes = 0;
	ibytes = min_t(माप_प्रकार, ibytes, have_bytes);
	अगर (ibytes < min)
		ibytes = 0;

	अगर (WARN_ON(entropy_count < 0)) अणु
		pr_warn("negative entropy count: pool %s count %d\n",
			r->name, entropy_count);
		entropy_count = 0;
	पूर्ण
	nfrac = ibytes << (ENTROPY_SHIFT + 3);
	अगर ((माप_प्रकार) entropy_count > nfrac)
		entropy_count -= nfrac;
	अन्यथा
		entropy_count = 0;

	अगर (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		जाओ retry;

	trace_debit_entropy(r->name, 8 * ibytes);
	अगर (ibytes && ENTROPY_BITS(r) < अक्रमom_ग_लिखो_wakeup_bits) अणु
		wake_up_पूर्णांकerruptible(&अक्रमom_ग_लिखो_रुको);
		समाप्त_fasync(&fasync, SIGIO, POLL_OUT);
	पूर्ण

	वापस ibytes;
पूर्ण

/*
 * This function करोes the actual extraction क्रम extract_entropy.
 *
 * Note: we assume that .poolwords is a multiple of 16 words.
 */
अटल व्योम extract_buf(काष्ठा entropy_store *r, __u8 *out)
अणु
	पूर्णांक i;
	जोड़ अणु
		__u32 w[5];
		अचिन्हित दीर्घ l[LONGS(20)];
	पूर्ण hash;
	__u32 workspace[SHA1_WORKSPACE_WORDS];
	अचिन्हित दीर्घ flags;

	/*
	 * If we have an architectural hardware अक्रमom number
	 * generator, use it क्रम SHA's initial vector
	 */
	sha1_init(hash.w);
	क्रम (i = 0; i < LONGS(20); i++) अणु
		अचिन्हित दीर्घ v;
		अगर (!arch_get_अक्रमom_दीर्घ(&v))
			अवरोध;
		hash.l[i] = v;
	पूर्ण

	/* Generate a hash across the pool, 16 words (512 bits) at a समय */
	spin_lock_irqsave(&r->lock, flags);
	क्रम (i = 0; i < r->poolinfo->poolwords; i += 16)
		sha1_transक्रमm(hash.w, (__u8 *)(r->pool + i), workspace);

	/*
	 * We mix the hash back पूर्णांकo the pool to prevent backtracking
	 * attacks (where the attacker knows the state of the pool
	 * plus the current outमाला_दो, and attempts to find previous
	 * ouमाला_दो), unless the hash function can be inverted. By
	 * mixing at least a SHA1 worth of hash data back, we make
	 * brute-क्रमcing the feedback as hard as brute-क्रमcing the
	 * hash.
	 */
	__mix_pool_bytes(r, hash.w, माप(hash.w));
	spin_unlock_irqrestore(&r->lock, flags);

	memzero_explicit(workspace, माप(workspace));

	/*
	 * In हाल the hash function has some recognizable output
	 * pattern, we fold it in half. Thus, we always feed back
	 * twice as much data as we output.
	 */
	hash.w[0] ^= hash.w[3];
	hash.w[1] ^= hash.w[4];
	hash.w[2] ^= rol32(hash.w[2], 16);

	स_नकल(out, &hash, EXTRACT_SIZE);
	memzero_explicit(&hash, माप(hash));
पूर्ण

अटल sमाप_प्रकार _extract_entropy(काष्ठा entropy_store *r, व्योम *buf,
				माप_प्रकार nbytes, पूर्णांक fips)
अणु
	sमाप_प्रकार ret = 0, i;
	__u8 पंचांगp[EXTRACT_SIZE];
	अचिन्हित दीर्घ flags;

	जबतक (nbytes) अणु
		extract_buf(r, पंचांगp);

		अगर (fips) अणु
			spin_lock_irqsave(&r->lock, flags);
			अगर (!स_भेद(पंचांगp, r->last_data, EXTRACT_SIZE))
				panic("Hardware RNG duplicated output!\n");
			स_नकल(r->last_data, पंचांगp, EXTRACT_SIZE);
			spin_unlock_irqrestore(&r->lock, flags);
		पूर्ण
		i = min_t(पूर्णांक, nbytes, EXTRACT_SIZE);
		स_नकल(buf, पंचांगp, i);
		nbytes -= i;
		buf += i;
		ret += i;
	पूर्ण

	/* Wipe data just वापसed from memory */
	memzero_explicit(पंचांगp, माप(पंचांगp));

	वापस ret;
पूर्ण

/*
 * This function extracts अक्रमomness from the "entropy pool", and
 * वापसs it in a buffer.
 *
 * The min parameter specअगरies the minimum amount we can pull beक्रमe
 * failing to aव्योम races that defeat catastrophic reseeding जबतक the
 * reserved parameter indicates how much entropy we must leave in the
 * pool after each pull to aव्योम starving other पढ़ोers.
 */
अटल sमाप_प्रकार extract_entropy(काष्ठा entropy_store *r, व्योम *buf,
				 माप_प्रकार nbytes, पूर्णांक min, पूर्णांक reserved)
अणु
	__u8 पंचांगp[EXTRACT_SIZE];
	अचिन्हित दीर्घ flags;

	/* अगर last_data isn't primed, we need EXTRACT_SIZE extra bytes */
	अगर (fips_enabled) अणु
		spin_lock_irqsave(&r->lock, flags);
		अगर (!r->last_data_init) अणु
			r->last_data_init = 1;
			spin_unlock_irqrestore(&r->lock, flags);
			trace_extract_entropy(r->name, EXTRACT_SIZE,
					      ENTROPY_BITS(r), _RET_IP_);
			extract_buf(r, पंचांगp);
			spin_lock_irqsave(&r->lock, flags);
			स_नकल(r->last_data, पंचांगp, EXTRACT_SIZE);
		पूर्ण
		spin_unlock_irqrestore(&r->lock, flags);
	पूर्ण

	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	nbytes = account(r, nbytes, min, reserved);

	वापस _extract_entropy(r, buf, nbytes, fips_enabled);
पूर्ण

#घोषणा warn_unseeded_अक्रमomness(previous) \
	_warn_unseeded_अक्रमomness(__func__, (व्योम *) _RET_IP_, (previous))

अटल व्योम _warn_unseeded_अक्रमomness(स्थिर अक्षर *func_name, व्योम *caller,
				      व्योम **previous)
अणु
#अगर_घोषित CONFIG_WARN_ALL_UNSEEDED_RANDOM
	स्थिर bool prपूर्णांक_once = false;
#अन्यथा
	अटल bool prपूर्णांक_once __पढ़ो_mostly;
#पूर्ण_अगर

	अगर (prपूर्णांक_once ||
	    crng_पढ़ोy() ||
	    (previous && (caller == READ_ONCE(*previous))))
		वापस;
	WRITE_ONCE(*previous, caller);
#अगर_अघोषित CONFIG_WARN_ALL_UNSEEDED_RANDOM
	prपूर्णांक_once = true;
#पूर्ण_अगर
	अगर (__ratelimit(&unseeded_warning))
		prपूर्णांकk_deferred(KERN_NOTICE "random: %s called from %pS "
				"with crng_init=%d\n", func_name, caller,
				crng_init);
पूर्ण

/*
 * This function is the exported kernel पूर्णांकerface.  It वापसs some
 * number of good अक्रमom numbers, suitable क्रम key generation, seeding
 * TCP sequence numbers, etc.  It करोes not rely on the hardware अक्रमom
 * number generator.  For अक्रमom bytes direct from the hardware RNG
 * (when available), use get_अक्रमom_bytes_arch(). In order to ensure
 * that the अक्रमomness provided by this function is okay, the function
 * रुको_क्रम_अक्रमom_bytes() should be called and वापस 0 at least once
 * at any poपूर्णांक prior.
 */
अटल व्योम _get_अक्रमom_bytes(व्योम *buf, पूर्णांक nbytes)
अणु
	__u8 पंचांगp[CHACHA_BLOCK_SIZE] __aligned(4);

	trace_get_अक्रमom_bytes(nbytes, _RET_IP_);

	जबतक (nbytes >= CHACHA_BLOCK_SIZE) अणु
		extract_crng(buf);
		buf += CHACHA_BLOCK_SIZE;
		nbytes -= CHACHA_BLOCK_SIZE;
	पूर्ण

	अगर (nbytes > 0) अणु
		extract_crng(पंचांगp);
		स_नकल(buf, पंचांगp, nbytes);
		crng_backtrack_protect(पंचांगp, nbytes);
	पूर्ण अन्यथा
		crng_backtrack_protect(पंचांगp, CHACHA_BLOCK_SIZE);
	memzero_explicit(पंचांगp, माप(पंचांगp));
पूर्ण

व्योम get_अक्रमom_bytes(व्योम *buf, पूर्णांक nbytes)
अणु
	अटल व्योम *previous;

	warn_unseeded_अक्रमomness(&previous);
	_get_अक्रमom_bytes(buf, nbytes);
पूर्ण
EXPORT_SYMBOL(get_अक्रमom_bytes);


/*
 * Each समय the समयr fires, we expect that we got an unpredictable
 * jump in the cycle counter. Even अगर the समयr is running on another
 * CPU, the समयr activity will be touching the stack of the CPU that is
 * generating entropy..
 *
 * Note that we करोn't re-arm the समयr in the समयr itself - we are
 * happy to be scheduled away, since that just makes the load more
 * complex, but we करो not want the समयr to keep ticking unless the
 * entropy loop is running.
 *
 * So the re-arming always happens in the entropy loop itself.
 */
अटल व्योम entropy_समयr(काष्ठा समयr_list *t)
अणु
	credit_entropy_bits(&input_pool, 1);
पूर्ण

/*
 * If we have an actual cycle counter, see अगर we can
 * generate enough entropy with timing noise
 */
अटल व्योम try_to_generate_entropy(व्योम)
अणु
	काष्ठा अणु
		अचिन्हित दीर्घ now;
		काष्ठा समयr_list समयr;
	पूर्ण stack;

	stack.now = अक्रमom_get_entropy();

	/* Slow counter - or none. Don't even bother */
	अगर (stack.now == अक्रमom_get_entropy())
		वापस;

	समयr_setup_on_stack(&stack.समयr, entropy_समयr, 0);
	जबतक (!crng_पढ़ोy()) अणु
		अगर (!समयr_pending(&stack.समयr))
			mod_समयr(&stack.समयr, jअगरfies+1);
		mix_pool_bytes(&input_pool, &stack.now, माप(stack.now));
		schedule();
		stack.now = अक्रमom_get_entropy();
	पूर्ण

	del_समयr_sync(&stack.समयr);
	destroy_समयr_on_stack(&stack.समयr);
	mix_pool_bytes(&input_pool, &stack.now, माप(stack.now));
पूर्ण

/*
 * Wait क्रम the uअक्रमom pool to be seeded and thus guaranteed to supply
 * cryptographically secure अक्रमom numbers. This applies to: the /dev/uअक्रमom
 * device, the get_अक्रमom_bytes function, and the get_अक्रमom_अणुu32,u64,पूर्णांक,दीर्घपूर्ण
 * family of functions. Using any of these functions without first calling
 * this function क्रमfeits the guarantee of security.
 *
 * Returns: 0 अगर the uअक्रमom pool has been seeded.
 *          -ERESTARTSYS अगर the function was पूर्णांकerrupted by a संकेत.
 */
पूर्णांक रुको_क्रम_अक्रमom_bytes(व्योम)
अणु
	अगर (likely(crng_पढ़ोy()))
		वापस 0;

	करो अणु
		पूर्णांक ret;
		ret = रुको_event_पूर्णांकerruptible_समयout(crng_init_रुको, crng_पढ़ोy(), HZ);
		अगर (ret)
			वापस ret > 0 ? 0 : ret;

		try_to_generate_entropy();
	पूर्ण जबतक (!crng_पढ़ोy());

	वापस 0;
पूर्ण
EXPORT_SYMBOL(रुको_क्रम_अक्रमom_bytes);

/*
 * Returns whether or not the uअक्रमom pool has been seeded and thus guaranteed
 * to supply cryptographically secure अक्रमom numbers. This applies to: the
 * /dev/uअक्रमom device, the get_अक्रमom_bytes function, and the get_अक्रमom_अणुu32,
 * ,u64,पूर्णांक,दीर्घपूर्ण family of functions.
 *
 * Returns: true अगर the uअक्रमom pool has been seeded.
 *          false अगर the uअक्रमom pool has not been seeded.
 */
bool rng_is_initialized(व्योम)
अणु
	वापस crng_पढ़ोy();
पूर्ण
EXPORT_SYMBOL(rng_is_initialized);

/*
 * Add a callback function that will be invoked when the nonblocking
 * pool is initialised.
 *
 * वापसs: 0 अगर callback is successfully added
 *	    -EALREADY अगर pool is alपढ़ोy initialised (callback not called)
 *	    -ENOENT अगर module क्रम callback is not alive
 */
पूर्णांक add_अक्रमom_पढ़ोy_callback(काष्ठा अक्रमom_पढ़ोy_callback *rdy)
अणु
	काष्ठा module *owner;
	अचिन्हित दीर्घ flags;
	पूर्णांक err = -EALREADY;

	अगर (crng_पढ़ोy())
		वापस err;

	owner = rdy->owner;
	अगर (!try_module_get(owner))
		वापस -ENOENT;

	spin_lock_irqsave(&अक्रमom_पढ़ोy_list_lock, flags);
	अगर (crng_पढ़ोy())
		जाओ out;

	owner = शून्य;

	list_add(&rdy->list, &अक्रमom_पढ़ोy_list);
	err = 0;

out:
	spin_unlock_irqrestore(&अक्रमom_पढ़ोy_list_lock, flags);

	module_put(owner);

	वापस err;
पूर्ण
EXPORT_SYMBOL(add_अक्रमom_पढ़ोy_callback);

/*
 * Delete a previously रेजिस्टरed पढ़ोiness callback function.
 */
व्योम del_अक्रमom_पढ़ोy_callback(काष्ठा अक्रमom_पढ़ोy_callback *rdy)
अणु
	अचिन्हित दीर्घ flags;
	काष्ठा module *owner = शून्य;

	spin_lock_irqsave(&अक्रमom_पढ़ोy_list_lock, flags);
	अगर (!list_empty(&rdy->list)) अणु
		list_del_init(&rdy->list);
		owner = rdy->owner;
	पूर्ण
	spin_unlock_irqrestore(&अक्रमom_पढ़ोy_list_lock, flags);

	module_put(owner);
पूर्ण
EXPORT_SYMBOL(del_अक्रमom_पढ़ोy_callback);

/*
 * This function will use the architecture-specअगरic hardware अक्रमom
 * number generator अगर it is available.  The arch-specअगरic hw RNG will
 * almost certainly be faster than what we can करो in software, but it
 * is impossible to verअगरy that it is implemented securely (as
 * opposed, to, say, the AES encryption of a sequence number using a
 * key known by the NSA).  So it's useful अगर we need the speed, but
 * only अगर we're willing to trust the hardware manufacturer not to
 * have put in a back करोor.
 *
 * Return number of bytes filled in.
 */
पूर्णांक __must_check get_अक्रमom_bytes_arch(व्योम *buf, पूर्णांक nbytes)
अणु
	पूर्णांक left = nbytes;
	अक्षर *p = buf;

	trace_get_अक्रमom_bytes_arch(left, _RET_IP_);
	जबतक (left) अणु
		अचिन्हित दीर्घ v;
		पूर्णांक chunk = min_t(पूर्णांक, left, माप(अचिन्हित दीर्घ));

		अगर (!arch_get_अक्रमom_दीर्घ(&v))
			अवरोध;

		स_नकल(p, &v, chunk);
		p += chunk;
		left -= chunk;
	पूर्ण

	वापस nbytes - left;
पूर्ण
EXPORT_SYMBOL(get_अक्रमom_bytes_arch);

/*
 * init_std_data - initialize pool with प्रणाली data
 *
 * @r: pool to initialize
 *
 * This function clears the pool's entropy count and mixes some प्रणाली
 * data पूर्णांकo the pool to prepare it क्रम use. The pool is not cleared
 * as that can only decrease the entropy in the pool.
 */
अटल व्योम __init init_std_data(काष्ठा entropy_store *r)
अणु
	पूर्णांक i;
	kसमय_प्रकार now = kसमय_get_real();
	अचिन्हित दीर्घ rv;

	mix_pool_bytes(r, &now, माप(now));
	क्रम (i = r->poolinfo->poolbytes; i > 0; i -= माप(rv)) अणु
		अगर (!arch_get_अक्रमom_seed_दीर्घ(&rv) &&
		    !arch_get_अक्रमom_दीर्घ(&rv))
			rv = अक्रमom_get_entropy();
		mix_pool_bytes(r, &rv, माप(rv));
	पूर्ण
	mix_pool_bytes(r, utsname(), माप(*(utsname())));
पूर्ण

/*
 * Note that setup_arch() may call add_device_अक्रमomness()
 * दीर्घ beक्रमe we get here. This allows seeding of the pools
 * with some platक्रमm dependent data very early in the boot
 * process. But it limits our options here. We must use
 * अटलally allocated काष्ठाures that alपढ़ोy have all
 * initializations complete at compile समय. We should also
 * take care not to overग_लिखो the precious per platक्रमm data
 * we were given.
 */
पूर्णांक __init अक्रम_initialize(व्योम)
अणु
	init_std_data(&input_pool);
	crng_initialize_primary(&primary_crng);
	crng_global_init_समय = jअगरfies;
	अगर (ratelimit_disable) अणु
		uअक्रमom_warning.पूर्णांकerval = 0;
		unseeded_warning.पूर्णांकerval = 0;
	पूर्ण
	वापस 0;
पूर्ण

#अगर_घोषित CONFIG_BLOCK
व्योम अक्रम_initialize_disk(काष्ठा gendisk *disk)
अणु
	काष्ठा समयr_अक्रम_state *state;

	/*
	 * If kzalloc वापसs null, we just won't use that entropy
	 * source.
	 */
	state = kzalloc(माप(काष्ठा समयr_अक्रम_state), GFP_KERNEL);
	अगर (state) अणु
		state->last_समय = INITIAL_JIFFIES;
		disk->अक्रमom = state;
	पूर्ण
पूर्ण
#पूर्ण_अगर

अटल sमाप_प्रकार
uअक्रमom_पढ़ो_nowarn(काष्ठा file *file, अक्षर __user *buf, माप_प्रकार nbytes,
		    loff_t *ppos)
अणु
	पूर्णांक ret;

	nbytes = min_t(माप_प्रकार, nbytes, पूर्णांक_उच्च >> (ENTROPY_SHIFT + 3));
	ret = extract_crng_user(buf, nbytes);
	trace_uअक्रमom_पढ़ो(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
	वापस ret;
पूर्ण

अटल sमाप_प्रकार
uअक्रमom_पढ़ो(काष्ठा file *file, अक्षर __user *buf, माप_प्रकार nbytes, loff_t *ppos)
अणु
	अचिन्हित दीर्घ flags;
	अटल पूर्णांक maxwarn = 10;

	अगर (!crng_पढ़ोy() && maxwarn > 0) अणु
		maxwarn--;
		अगर (__ratelimit(&uअक्रमom_warning))
			pr_notice("%s: uninitialized urandom read (%zd bytes read)\n",
				  current->comm, nbytes);
		spin_lock_irqsave(&primary_crng.lock, flags);
		crng_init_cnt = 0;
		spin_unlock_irqrestore(&primary_crng.lock, flags);
	पूर्ण

	वापस uअक्रमom_पढ़ो_nowarn(file, buf, nbytes, ppos);
पूर्ण

अटल sमाप_प्रकार
अक्रमom_पढ़ो(काष्ठा file *file, अक्षर __user *buf, माप_प्रकार nbytes, loff_t *ppos)
अणु
	पूर्णांक ret;

	ret = रुको_क्रम_अक्रमom_bytes();
	अगर (ret != 0)
		वापस ret;
	वापस uअक्रमom_पढ़ो_nowarn(file, buf, nbytes, ppos);
पूर्ण

अटल __poll_t
अक्रमom_poll(काष्ठा file *file, poll_table * रुको)
अणु
	__poll_t mask;

	poll_रुको(file, &crng_init_रुको, रुको);
	poll_रुको(file, &अक्रमom_ग_लिखो_रुको, रुको);
	mask = 0;
	अगर (crng_पढ़ोy())
		mask |= EPOLLIN | EPOLLRDNORM;
	अगर (ENTROPY_BITS(&input_pool) < अक्रमom_ग_लिखो_wakeup_bits)
		mask |= EPOLLOUT | EPOLLWRNORM;
	वापस mask;
पूर्ण

अटल पूर्णांक
ग_लिखो_pool(काष्ठा entropy_store *r, स्थिर अक्षर __user *buffer, माप_प्रकार count)
अणु
	माप_प्रकार bytes;
	__u32 t, buf[16];
	स्थिर अक्षर __user *p = buffer;

	जबतक (count > 0) अणु
		पूर्णांक b, i = 0;

		bytes = min(count, माप(buf));
		अगर (copy_from_user(&buf, p, bytes))
			वापस -EFAULT;

		क्रम (b = bytes ; b > 0 ; b -= माप(__u32), i++) अणु
			अगर (!arch_get_अक्रमom_पूर्णांक(&t))
				अवरोध;
			buf[i] ^= t;
		पूर्ण

		count -= bytes;
		p += bytes;

		mix_pool_bytes(r, buf, bytes);
		cond_resched();
	पूर्ण

	वापस 0;
पूर्ण

अटल sमाप_प्रकार अक्रमom_ग_लिखो(काष्ठा file *file, स्थिर अक्षर __user *buffer,
			    माप_प्रकार count, loff_t *ppos)
अणु
	माप_प्रकार ret;

	ret = ग_लिखो_pool(&input_pool, buffer, count);
	अगर (ret)
		वापस ret;

	वापस (sमाप_प्रकार)count;
पूर्ण

अटल दीर्घ अक्रमom_ioctl(काष्ठा file *f, अचिन्हित पूर्णांक cmd, अचिन्हित दीर्घ arg)
अणु
	पूर्णांक size, ent_count;
	पूर्णांक __user *p = (पूर्णांक __user *)arg;
	पूर्णांक retval;

	चयन (cmd) अणु
	हाल RNDGETENTCNT:
		/* inherently racy, no poपूर्णांक locking */
		ent_count = ENTROPY_BITS(&input_pool);
		अगर (put_user(ent_count, p))
			वापस -EFAULT;
		वापस 0;
	हाल RNDADDTOENTCNT:
		अगर (!capable(CAP_SYS_ADMIN))
			वापस -EPERM;
		अगर (get_user(ent_count, p))
			वापस -EFAULT;
		वापस credit_entropy_bits_safe(&input_pool, ent_count);
	हाल RNDADDENTROPY:
		अगर (!capable(CAP_SYS_ADMIN))
			वापस -EPERM;
		अगर (get_user(ent_count, p++))
			वापस -EFAULT;
		अगर (ent_count < 0)
			वापस -EINVAL;
		अगर (get_user(size, p++))
			वापस -EFAULT;
		retval = ग_लिखो_pool(&input_pool, (स्थिर अक्षर __user *)p,
				    size);
		अगर (retval < 0)
			वापस retval;
		वापस credit_entropy_bits_safe(&input_pool, ent_count);
	हाल RNDZAPENTCNT:
	हाल RNDCLEARPOOL:
		/*
		 * Clear the entropy pool counters. We no दीर्घer clear
		 * the entropy pool, as that's silly.
		 */
		अगर (!capable(CAP_SYS_ADMIN))
			वापस -EPERM;
		input_pool.entropy_count = 0;
		वापस 0;
	हाल RNDRESEEDCRNG:
		अगर (!capable(CAP_SYS_ADMIN))
			वापस -EPERM;
		अगर (crng_init < 2)
			वापस -ENODATA;
		crng_reseed(&primary_crng, &input_pool);
		crng_global_init_समय = jअगरfies - 1;
		वापस 0;
	शेष:
		वापस -EINVAL;
	पूर्ण
पूर्ण

अटल पूर्णांक अक्रमom_fasync(पूर्णांक fd, काष्ठा file *filp, पूर्णांक on)
अणु
	वापस fasync_helper(fd, filp, on, &fasync);
पूर्ण

स्थिर काष्ठा file_operations अक्रमom_fops = अणु
	.पढ़ो  = अक्रमom_पढ़ो,
	.ग_लिखो = अक्रमom_ग_लिखो,
	.poll  = अक्रमom_poll,
	.unlocked_ioctl = अक्रमom_ioctl,
	.compat_ioctl = compat_ptr_ioctl,
	.fasync = अक्रमom_fasync,
	.llseek = noop_llseek,
पूर्ण;

स्थिर काष्ठा file_operations uअक्रमom_fops = अणु
	.पढ़ो  = uअक्रमom_पढ़ो,
	.ग_लिखो = अक्रमom_ग_लिखो,
	.unlocked_ioctl = अक्रमom_ioctl,
	.compat_ioctl = compat_ptr_ioctl,
	.fasync = अक्रमom_fasync,
	.llseek = noop_llseek,
पूर्ण;

SYSCALL_DEFINE3(getअक्रमom, अक्षर __user *, buf, माप_प्रकार, count,
		अचिन्हित पूर्णांक, flags)
अणु
	पूर्णांक ret;

	अगर (flags & ~(GRND_NONBLOCK|GRND_RANDOM|GRND_INSECURE))
		वापस -EINVAL;

	/*
	 * Requesting insecure and blocking अक्रमomness at the same समय makes
	 * no sense.
	 */
	अगर ((flags & (GRND_INSECURE|GRND_RANDOM)) == (GRND_INSECURE|GRND_RANDOM))
		वापस -EINVAL;

	अगर (count > पूर्णांक_उच्च)
		count = पूर्णांक_उच्च;

	अगर (!(flags & GRND_INSECURE) && !crng_पढ़ोy()) अणु
		अगर (flags & GRND_NONBLOCK)
			वापस -EAGAIN;
		ret = रुको_क्रम_अक्रमom_bytes();
		अगर (unlikely(ret))
			वापस ret;
	पूर्ण
	वापस uअक्रमom_पढ़ो_nowarn(शून्य, buf, count, शून्य);
पूर्ण

/********************************************************************
 *
 * Sysctl पूर्णांकerface
 *
 ********************************************************************/

#अगर_घोषित CONFIG_SYSCTL

#समावेश <linux/sysctl.h>

अटल पूर्णांक min_ग_लिखो_thresh;
अटल पूर्णांक max_ग_लिखो_thresh = INPUT_POOL_WORDS * 32;
अटल पूर्णांक अक्रमom_min_uअक्रमom_seed = 60;
अटल अक्षर sysctl_bootid[16];

/*
 * This function is used to वापस both the bootid UUID, and अक्रमom
 * UUID.  The dअगरference is in whether table->data is शून्य; अगर it is,
 * then a new UUID is generated and वापसed to the user.
 *
 * If the user accesses this via the proc पूर्णांकerface, the UUID will be
 * वापसed as an ASCII string in the standard UUID क्रमmat; अगर via the
 * sysctl प्रणाली call, as 16 bytes of binary data.
 */
अटल पूर्णांक proc_करो_uuid(काष्ठा ctl_table *table, पूर्णांक ग_लिखो,
			व्योम *buffer, माप_प्रकार *lenp, loff_t *ppos)
अणु
	काष्ठा ctl_table fake_table;
	अचिन्हित अक्षर buf[64], पंचांगp_uuid[16], *uuid;

	uuid = table->data;
	अगर (!uuid) अणु
		uuid = पंचांगp_uuid;
		generate_अक्रमom_uuid(uuid);
	पूर्ण अन्यथा अणु
		अटल DEFINE_SPINLOCK(bootid_spinlock);

		spin_lock(&bootid_spinlock);
		अगर (!uuid[8])
			generate_अक्रमom_uuid(uuid);
		spin_unlock(&bootid_spinlock);
	पूर्ण

	प्र_लिखो(buf, "%pU", uuid);

	fake_table.data = buf;
	fake_table.maxlen = माप(buf);

	वापस proc_करोstring(&fake_table, ग_लिखो, buffer, lenp, ppos);
पूर्ण

/*
 * Return entropy available scaled to पूर्णांकegral bits
 */
अटल पूर्णांक proc_करो_entropy(काष्ठा ctl_table *table, पूर्णांक ग_लिखो,
			   व्योम *buffer, माप_प्रकार *lenp, loff_t *ppos)
अणु
	काष्ठा ctl_table fake_table;
	पूर्णांक entropy_count;

	entropy_count = *(पूर्णांक *)table->data >> ENTROPY_SHIFT;

	fake_table.data = &entropy_count;
	fake_table.maxlen = माप(entropy_count);

	वापस proc_करोपूर्णांकvec(&fake_table, ग_लिखो, buffer, lenp, ppos);
पूर्ण

अटल पूर्णांक sysctl_poolsize = INPUT_POOL_WORDS * 32;
बाह्य काष्ठा ctl_table अक्रमom_table[];
काष्ठा ctl_table अक्रमom_table[] = अणु
	अणु
		.procname	= "poolsize",
		.data		= &sysctl_poolsize,
		.maxlen		= माप(पूर्णांक),
		.mode		= 0444,
		.proc_handler	= proc_करोपूर्णांकvec,
	पूर्ण,
	अणु
		.procname	= "entropy_avail",
		.maxlen		= माप(पूर्णांक),
		.mode		= 0444,
		.proc_handler	= proc_करो_entropy,
		.data		= &input_pool.entropy_count,
	पूर्ण,
	अणु
		.procname	= "write_wakeup_threshold",
		.data		= &अक्रमom_ग_लिखो_wakeup_bits,
		.maxlen		= माप(पूर्णांक),
		.mode		= 0644,
		.proc_handler	= proc_करोपूर्णांकvec_minmax,
		.extra1		= &min_ग_लिखो_thresh,
		.extra2		= &max_ग_लिखो_thresh,
	पूर्ण,
	अणु
		.procname	= "urandom_min_reseed_secs",
		.data		= &अक्रमom_min_uअक्रमom_seed,
		.maxlen		= माप(पूर्णांक),
		.mode		= 0644,
		.proc_handler	= proc_करोपूर्णांकvec,
	पूर्ण,
	अणु
		.procname	= "boot_id",
		.data		= &sysctl_bootid,
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_करो_uuid,
	पूर्ण,
	अणु
		.procname	= "uuid",
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_करो_uuid,
	पूर्ण,
#अगर_घोषित ADD_INTERRUPT_BENCH
	अणु
		.procname	= "add_interrupt_avg_cycles",
		.data		= &avg_cycles,
		.maxlen		= माप(avg_cycles),
		.mode		= 0444,
		.proc_handler	= proc_करोuदीर्घvec_minmax,
	पूर्ण,
	अणु
		.procname	= "add_interrupt_avg_deviation",
		.data		= &avg_deviation,
		.maxlen		= माप(avg_deviation),
		.mode		= 0444,
		.proc_handler	= proc_करोuदीर्घvec_minmax,
	पूर्ण,
#पूर्ण_अगर
	अणु पूर्ण
पूर्ण;
#पूर्ण_अगर 	/* CONFIG_SYSCTL */

काष्ठा batched_entropy अणु
	जोड़ अणु
		u64 entropy_u64[CHACHA_BLOCK_SIZE / माप(u64)];
		u32 entropy_u32[CHACHA_BLOCK_SIZE / माप(u32)];
	पूर्ण;
	अचिन्हित पूर्णांक position;
	spinlock_t batch_lock;
पूर्ण;

/*
 * Get a अक्रमom word क्रम पूर्णांकernal kernel use only. The quality of the अक्रमom
 * number is good as /dev/uअक्रमom, but there is no backtrack protection, with
 * the goal of being quite fast and not depleting entropy. In order to ensure
 * that the अक्रमomness provided by this function is okay, the function
 * रुको_क्रम_अक्रमom_bytes() should be called and वापस 0 at least once at any
 * poपूर्णांक prior.
 */
अटल DEFINE_PER_CPU(काष्ठा batched_entropy, batched_entropy_u64) = अणु
	.batch_lock	= __SPIN_LOCK_UNLOCKED(batched_entropy_u64.lock),
पूर्ण;

u64 get_अक्रमom_u64(व्योम)
अणु
	u64 ret;
	अचिन्हित दीर्घ flags;
	काष्ठा batched_entropy *batch;
	अटल व्योम *previous;

	warn_unseeded_अक्रमomness(&previous);

	batch = raw_cpu_ptr(&batched_entropy_u64);
	spin_lock_irqsave(&batch->batch_lock, flags);
	अगर (batch->position % ARRAY_SIZE(batch->entropy_u64) == 0) अणु
		extract_crng((u8 *)batch->entropy_u64);
		batch->position = 0;
	पूर्ण
	ret = batch->entropy_u64[batch->position++];
	spin_unlock_irqrestore(&batch->batch_lock, flags);
	वापस ret;
पूर्ण
EXPORT_SYMBOL(get_अक्रमom_u64);

अटल DEFINE_PER_CPU(काष्ठा batched_entropy, batched_entropy_u32) = अणु
	.batch_lock	= __SPIN_LOCK_UNLOCKED(batched_entropy_u32.lock),
पूर्ण;
u32 get_अक्रमom_u32(व्योम)
अणु
	u32 ret;
	अचिन्हित दीर्घ flags;
	काष्ठा batched_entropy *batch;
	अटल व्योम *previous;

	warn_unseeded_अक्रमomness(&previous);

	batch = raw_cpu_ptr(&batched_entropy_u32);
	spin_lock_irqsave(&batch->batch_lock, flags);
	अगर (batch->position % ARRAY_SIZE(batch->entropy_u32) == 0) अणु
		extract_crng((u8 *)batch->entropy_u32);
		batch->position = 0;
	पूर्ण
	ret = batch->entropy_u32[batch->position++];
	spin_unlock_irqrestore(&batch->batch_lock, flags);
	वापस ret;
पूर्ण
EXPORT_SYMBOL(get_अक्रमom_u32);

/* It's important to invalidate all potential batched entropy that might
 * be stored beक्रमe the crng is initialized, which we can करो lazily by
 * simply resetting the counter to zero so that it's re-extracted on the
 * next usage. */
अटल व्योम invalidate_batched_entropy(व्योम)
अणु
	पूर्णांक cpu;
	अचिन्हित दीर्घ flags;

	क्रम_each_possible_cpu (cpu) अणु
		काष्ठा batched_entropy *batched_entropy;

		batched_entropy = per_cpu_ptr(&batched_entropy_u32, cpu);
		spin_lock_irqsave(&batched_entropy->batch_lock, flags);
		batched_entropy->position = 0;
		spin_unlock(&batched_entropy->batch_lock);

		batched_entropy = per_cpu_ptr(&batched_entropy_u64, cpu);
		spin_lock(&batched_entropy->batch_lock);
		batched_entropy->position = 0;
		spin_unlock_irqrestore(&batched_entropy->batch_lock, flags);
	पूर्ण
पूर्ण

/**
 * अक्रमomize_page - Generate a अक्रमom, page aligned address
 * @start:	The smallest acceptable address the caller will take.
 * @range:	The size of the area, starting at @start, within which the
 *		अक्रमom address must fall.
 *
 * If @start + @range would overflow, @range is capped.
 *
 * NOTE: Historical use of अक्रमomize_range, which this replaces, presumed that
 * @start was alपढ़ोy page aligned.  We now align it regardless.
 *
 * Return: A page aligned address within [start, start + range).  On error,
 * @start is वापसed.
 */
अचिन्हित दीर्घ
अक्रमomize_page(अचिन्हित दीर्घ start, अचिन्हित दीर्घ range)
अणु
	अगर (!PAGE_ALIGNED(start)) अणु
		range -= PAGE_ALIGN(start) - start;
		start = PAGE_ALIGN(start);
	पूर्ण

	अगर (start > अच_दीर्घ_उच्च - range)
		range = अच_दीर्घ_उच्च - start;

	range >>= PAGE_SHIFT;

	अगर (range == 0)
		वापस start;

	वापस start + (get_अक्रमom_दीर्घ() % range << PAGE_SHIFT);
पूर्ण

/* Interface क्रम in-kernel drivers of true hardware RNGs.
 * Those devices may produce endless अक्रमom bits and will be throttled
 * when our pool is full.
 */
व्योम add_hwgenerator_अक्रमomness(स्थिर अक्षर *buffer, माप_प्रकार count,
				माप_प्रकार entropy)
अणु
	काष्ठा entropy_store *poolp = &input_pool;

	अगर (unlikely(crng_init == 0)) अणु
		crng_fast_load(buffer, count);
		वापस;
	पूर्ण

	/* Suspend writing अगर we're above the trickle threshold.
	 * We'll be woken up again once below अक्रमom_ग_लिखो_wakeup_thresh,
	 * or when the calling thपढ़ो is about to terminate.
	 */
	रुको_event_पूर्णांकerruptible(अक्रमom_ग_लिखो_रुको, kthपढ़ो_should_stop() ||
			ENTROPY_BITS(&input_pool) <= अक्रमom_ग_लिखो_wakeup_bits);
	mix_pool_bytes(poolp, buffer, count);
	credit_entropy_bits(poolp, entropy);
पूर्ण
EXPORT_SYMBOL_GPL(add_hwgenerator_अक्रमomness);

/* Handle अक्रमom seed passed by bootloader.
 * If the seed is trustworthy, it would be regarded as hardware RNGs. Otherwise
 * it would be regarded as device data.
 * The decision is controlled by CONFIG_RANDOM_TRUST_BOOTLOADER.
 */
व्योम add_bootloader_अक्रमomness(स्थिर व्योम *buf, अचिन्हित पूर्णांक size)
अणु
	अगर (IS_ENABLED(CONFIG_RANDOM_TRUST_BOOTLOADER))
		add_hwgenerator_अक्रमomness(buf, size, size * 8);
	अन्यथा
		add_device_अक्रमomness(buf, size);
पूर्ण
EXPORT_SYMBOL_GPL(add_bootloader_अक्रमomness);
