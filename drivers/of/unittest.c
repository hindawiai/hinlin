<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/*
 * Self tests क्रम device tree subप्रणाली
 */

#घोषणा pr_fmt(fmt) "### dt-test ### " fmt

#समावेश <linux/memblock.h>
#समावेश <linux/clk.h>
#समावेश <linux/dma-direct.h> /* to test phys_to_dma/dma_to_phys */
#समावेश <linux/err.h>
#समावेश <linux/त्रुटिसं.स>
#समावेश <linux/hashtable.h>
#समावेश <linux/libfdt.h>
#समावेश <linux/of.h>
#समावेश <linux/of_address.h>
#समावेश <linux/of_fdt.h>
#समावेश <linux/of_irq.h>
#समावेश <linux/of_platक्रमm.h>
#समावेश <linux/list.h>
#समावेश <linux/mutex.h>
#समावेश <linux/slab.h>
#समावेश <linux/device.h>
#समावेश <linux/platक्रमm_device.h>
#समावेश <linux/kernel.h>

#समावेश <linux/i2c.h>
#समावेश <linux/i2c-mux.h>
#समावेश <linux/gpio/driver.h>

#समावेश <linux/bitops.h>

#समावेश "of_private.h"

अटल काष्ठा unittest_results अणु
	पूर्णांक passed;
	पूर्णांक failed;
पूर्ण unittest_results;

#घोषणा unittest(result, fmt, ...) (अणु \
	bool failed = !(result); \
	अगर (failed) अणु \
		unittest_results.failed++; \
		pr_err("FAIL %s():%i " fmt, __func__, __LINE__, ##__VA_ARGS__); \
	पूर्ण अन्यथा अणु \
		unittest_results.passed++; \
		pr_debug("pass %s():%i\n", __func__, __LINE__); \
	पूर्ण \
	failed; \
पूर्ण)

/*
 * Expected message may have a message level other than KERN_INFO.
 * Prपूर्णांक the expected message only अगर the current loglevel will allow
 * the actual message to prपूर्णांक.
 *
 * Do not use EXPECT_BEGIN() or EXPECT_END() क्रम messages generated by
 * pr_debug().
 */
#घोषणा EXPECT_BEGIN(level, fmt, ...) \
	prपूर्णांकk(level pr_fmt("EXPECT \\ : ") fmt, ##__VA_ARGS__)

#घोषणा EXPECT_END(level, fmt, ...) \
	prपूर्णांकk(level pr_fmt("EXPECT / : ") fmt, ##__VA_ARGS__)

अटल व्योम __init of_unittest_find_node_by_name(व्योम)
अणु
	काष्ठा device_node *np;
	स्थिर अक्षर *options, *name;

	np = of_find_node_by_path("/testcase-data");
	name = kaप्र_लिखो(GFP_KERNEL, "%pOF", np);
	unittest(np && !म_भेद("/testcase-data", name),
		"find /testcase-data failed\n");
	of_node_put(np);
	kमुक्त(name);

	/* Test अगर trailing '/' works */
	np = of_find_node_by_path("/testcase-data/");
	unittest(!np, "trailing '/' on /testcase-data/ should fail\n");

	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
	name = kaप्र_लिखो(GFP_KERNEL, "%pOF", np);
	unittest(np && !म_भेद("/testcase-data/phandle-tests/consumer-a", name),
		"find /testcase-data/phandle-tests/consumer-a failed\n");
	of_node_put(np);
	kमुक्त(name);

	np = of_find_node_by_path("testcase-alias");
	name = kaप्र_लिखो(GFP_KERNEL, "%pOF", np);
	unittest(np && !म_भेद("/testcase-data", name),
		"find testcase-alias failed\n");
	of_node_put(np);
	kमुक्त(name);

	/* Test अगर trailing '/' works on aliases */
	np = of_find_node_by_path("testcase-alias/");
	unittest(!np, "trailing '/' on testcase-alias/ should fail\n");

	np = of_find_node_by_path("testcase-alias/phandle-tests/consumer-a");
	name = kaप्र_लिखो(GFP_KERNEL, "%pOF", np);
	unittest(np && !म_भेद("/testcase-data/phandle-tests/consumer-a", name),
		"find testcase-alias/phandle-tests/consumer-a failed\n");
	of_node_put(np);
	kमुक्त(name);

	np = of_find_node_by_path("/testcase-data/missing-path");
	unittest(!np, "non-existent path returned node %pOF\n", np);
	of_node_put(np);

	np = of_find_node_by_path("missing-alias");
	unittest(!np, "non-existent alias returned node %pOF\n", np);
	of_node_put(np);

	np = of_find_node_by_path("testcase-alias/missing-path");
	unittest(!np, "non-existent alias with relative path returned node %pOF\n", np);
	of_node_put(np);

	np = of_find_node_opts_by_path("/testcase-data:testoption", &options);
	unittest(np && !म_भेद("testoption", options),
		 "option path test failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("/testcase-data:test/option", &options);
	unittest(np && !म_भेद("test/option", options),
		 "option path test, subcase #1 failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("/testcase-data/testcase-device1:test/option", &options);
	unittest(np && !म_भेद("test/option", options),
		 "option path test, subcase #2 failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("/testcase-data:testoption", शून्य);
	unittest(np, "NULL option path test failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("testcase-alias:testaliasoption",
				       &options);
	unittest(np && !म_भेद("testaliasoption", options),
		 "option alias path test failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("testcase-alias:test/alias/option",
				       &options);
	unittest(np && !म_भेद("test/alias/option", options),
		 "option alias path test, subcase #1 failed\n");
	of_node_put(np);

	np = of_find_node_opts_by_path("testcase-alias:testaliasoption", शून्य);
	unittest(np, "NULL option alias path test failed\n");
	of_node_put(np);

	options = "testoption";
	np = of_find_node_opts_by_path("testcase-alias", &options);
	unittest(np && !options, "option clearing test failed\n");
	of_node_put(np);

	options = "testoption";
	np = of_find_node_opts_by_path("/", &options);
	unittest(np && !options, "option clearing root node test failed\n");
	of_node_put(np);
पूर्ण

अटल व्योम __init of_unittest_dynamic(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा property *prop;

	np = of_find_node_by_path("/testcase-data");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	/* Array of 4 properties क्रम the purpose of testing */
	prop = kसुस्मृति(4, माप(*prop), GFP_KERNEL);
	अगर (!prop) अणु
		unittest(0, "kzalloc() failed\n");
		वापस;
	पूर्ण

	/* Add a new property - should pass*/
	prop->name = "new-property";
	prop->value = "new-property-data";
	prop->length = म_माप(prop->value) + 1;
	unittest(of_add_property(np, prop) == 0, "Adding a new property failed\n");

	/* Try to add an existing property - should fail */
	prop++;
	prop->name = "new-property";
	prop->value = "new-property-data-should-fail";
	prop->length = म_माप(prop->value) + 1;
	unittest(of_add_property(np, prop) != 0,
		 "Adding an existing property should have failed\n");

	/* Try to modअगरy an existing property - should pass */
	prop->value = "modify-property-data-should-pass";
	prop->length = म_माप(prop->value) + 1;
	unittest(of_update_property(np, prop) == 0,
		 "Updating an existing property should have passed\n");

	/* Try to modअगरy non-existent property - should pass*/
	prop++;
	prop->name = "modify-property";
	prop->value = "modify-missing-property-data-should-pass";
	prop->length = म_माप(prop->value) + 1;
	unittest(of_update_property(np, prop) == 0,
		 "Updating a missing property should have passed\n");

	/* Remove property - should pass */
	unittest(of_हटाओ_property(np, prop) == 0,
		 "Removing a property should have passed\n");

	/* Adding very large property - should pass */
	prop++;
	prop->name = "large-property-PAGE_SIZEx8";
	prop->length = PAGE_SIZE * 8;
	prop->value = kzalloc(prop->length, GFP_KERNEL);
	unittest(prop->value != शून्य, "Unable to allocate large buffer\n");
	अगर (prop->value)
		unittest(of_add_property(np, prop) == 0,
			 "Adding a large property should have passed\n");
पूर्ण

अटल पूर्णांक __init of_unittest_check_node_linkage(काष्ठा device_node *np)
अणु
	काष्ठा device_node *child;
	पूर्णांक count = 0, rc;

	क्रम_each_child_of_node(np, child) अणु
		अगर (child->parent != np) अणु
			pr_err("Child node %pOFn links to wrong parent %pOFn\n",
				 child, np);
			rc = -EINVAL;
			जाओ put_child;
		पूर्ण

		rc = of_unittest_check_node_linkage(child);
		अगर (rc < 0)
			जाओ put_child;
		count += rc;
	पूर्ण

	वापस count + 1;
put_child:
	of_node_put(child);
	वापस rc;
पूर्ण

अटल व्योम __init of_unittest_check_tree_linkage(व्योम)
अणु
	काष्ठा device_node *np;
	पूर्णांक allnode_count = 0, child_count;

	अगर (!of_root)
		वापस;

	क्रम_each_of_allnodes(np)
		allnode_count++;
	child_count = of_unittest_check_node_linkage(of_root);

	unittest(child_count > 0, "Device node data structure is corrupted\n");
	unittest(child_count == allnode_count,
		 "allnodes list size (%i) doesn't match sibling lists size (%i)\n",
		 allnode_count, child_count);
	pr_debug("allnodes list size (%i); sibling lists size (%i)\n", allnode_count, child_count);
पूर्ण

अटल व्योम __init of_unittest_म_लिखो_one(काष्ठा device_node *np, स्थिर अक्षर *fmt,
					  स्थिर अक्षर *expected)
अणु
	अचिन्हित अक्षर *buf;
	पूर्णांक buf_size;
	पूर्णांक size, i;

	buf_size = म_माप(expected) + 10;
	buf = kदो_स्मृति(buf_size, GFP_KERNEL);
	अगर (!buf)
		वापस;

	/* Baseline; check conversion with a large size limit */
	स_रखो(buf, 0xff, buf_size);
	size = snम_लिखो(buf, buf_size - 2, fmt, np);

	/* use म_भेद() instead of म_भेदन() here to be असलolutely sure strings match */
	unittest((म_भेद(buf, expected) == 0) && (buf[size+1] == 0xff),
		"sprintf failed; fmt='%s' expected='%s' rslt='%s'\n",
		fmt, expected, buf);

	/* Make sure length limits work */
	size++;
	क्रम (i = 0; i < 2; i++, size--) अणु
		/* Clear the buffer, and make sure it works correctly still */
		स_रखो(buf, 0xff, buf_size);
		snम_लिखो(buf, size+1, fmt, np);
		unittest(म_भेदन(buf, expected, size) == 0 && (buf[size+1] == 0xff),
			"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
			size, fmt, expected, buf);
	पूर्ण
	kमुक्त(buf);
पूर्ण

अटल व्योम __init of_unittest_म_लिखो(व्योम)
अणु
	काष्ठा device_node *np;
	स्थिर अक्षर *full_name = "/testcase-data/platform-tests/test-device@1/dev@100";
	अक्षर phandle_str[16] = "";

	np = of_find_node_by_path(full_name);
	अगर (!np) अणु
		unittest(np, "testcase data missing\n");
		वापस;
	पूर्ण

	num_to_str(phandle_str, माप(phandle_str), np->phandle, 0);

	of_unittest_म_लिखो_one(np, "%pOF",  full_name);
	of_unittest_म_लिखो_one(np, "%pOFf", full_name);
	of_unittest_म_लिखो_one(np, "%pOFn", "dev");
	of_unittest_म_लिखो_one(np, "%2pOFn", "dev");
	of_unittest_म_लिखो_one(np, "%5pOFn", "  dev");
	of_unittest_म_लिखो_one(np, "%pOFnc", "dev:test-sub-device");
	of_unittest_म_लिखो_one(np, "%pOFp", phandle_str);
	of_unittest_म_लिखो_one(np, "%pOFP", "dev@100");
	of_unittest_म_लिखो_one(np, "ABC %pOFP ABC", "ABC dev@100 ABC");
	of_unittest_म_लिखो_one(np, "%10pOFP", "   dev@100");
	of_unittest_म_लिखो_one(np, "%-10pOFP", "dev@100   ");
	of_unittest_म_लिखो_one(of_root, "%pOFP", "/");
	of_unittest_म_लिखो_one(np, "%pOFF", "----");
	of_unittest_म_लिखो_one(np, "%pOFPF", "dev@100:----");
	of_unittest_म_लिखो_one(np, "%pOFPFPc", "dev@100:----:dev@100:test-sub-device");
	of_unittest_म_लिखो_one(np, "%pOFc", "test-sub-device");
	of_unittest_म_लिखो_one(np, "%pOFC",
			"\"test-sub-device\",\"test-compat2\",\"test-compat3\"");
पूर्ण

काष्ठा node_hash अणु
	काष्ठा hlist_node node;
	काष्ठा device_node *np;
पूर्ण;

अटल DEFINE_HASHTABLE(phandle_ht, 8);
अटल व्योम __init of_unittest_check_phandles(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा node_hash *nh;
	काष्ठा hlist_node *पंचांगp;
	पूर्णांक i, dup_count = 0, phandle_count = 0;

	क्रम_each_of_allnodes(np) अणु
		अगर (!np->phandle)
			जारी;

		hash_क्रम_each_possible(phandle_ht, nh, node, np->phandle) अणु
			अगर (nh->np->phandle == np->phandle) अणु
				pr_info("Duplicate phandle! %i used by %pOF and %pOF\n",
					np->phandle, nh->np, np);
				dup_count++;
				अवरोध;
			पूर्ण
		पूर्ण

		nh = kzalloc(माप(*nh), GFP_KERNEL);
		अगर (!nh)
			वापस;

		nh->np = np;
		hash_add(phandle_ht, &nh->node, np->phandle);
		phandle_count++;
	पूर्ण
	unittest(dup_count == 0, "Found %i duplicates in %i phandles\n",
		 dup_count, phandle_count);

	/* Clean up */
	hash_क्रम_each_safe(phandle_ht, i, पंचांगp, nh, node) अणु
		hash_del(&nh->node);
		kमुक्त(nh);
	पूर्ण
पूर्ण

अटल व्योम __init of_unittest_parse_phandle_with_args(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा of_phandle_args args;
	पूर्णांक i, rc;

	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	rc = of_count_phandle_with_args(np, "phandle-list", "#phandle-cells");
	unittest(rc == 7, "of_count_phandle_with_args() returned %i, expected 7\n", rc);

	क्रम (i = 0; i < 8; i++) अणु
		bool passed = true;

		स_रखो(&args, 0, माप(args));
		rc = of_parse_phandle_with_args(np, "phandle-list",
						"#phandle-cells", i, &args);

		/* Test the values from tests-phandle.dtsi */
		चयन (i) अणु
		हाल 0:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == (i + 1));
			अवरोध;
		हाल 1:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == (i + 1));
			passed &= (args.args[1] == 0);
			अवरोध;
		हाल 2:
			passed &= (rc == -ENOENT);
			अवरोध;
		हाल 3:
			passed &= !rc;
			passed &= (args.args_count == 3);
			passed &= (args.args[0] == (i + 1));
			passed &= (args.args[1] == 4);
			passed &= (args.args[2] == 3);
			अवरोध;
		हाल 4:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == (i + 1));
			passed &= (args.args[1] == 100);
			अवरोध;
		हाल 5:
			passed &= !rc;
			passed &= (args.args_count == 0);
			अवरोध;
		हाल 6:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == (i + 1));
			अवरोध;
		हाल 7:
			passed &= (rc == -ENOENT);
			अवरोध;
		शेष:
			passed = false;
		पूर्ण

		unittest(passed, "index %i - data error on node %pOF rc=%i\n",
			 i, args.np, rc);
	पूर्ण

	/* Check क्रम missing list property */
	स_रखो(&args, 0, माप(args));
	rc = of_parse_phandle_with_args(np, "phandle-list-missing",
					"#phandle-cells", 0, &args);
	unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);
	rc = of_count_phandle_with_args(np, "phandle-list-missing",
					"#phandle-cells");
	unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);

	/* Check क्रम missing cells property */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1");

	rc = of_parse_phandle_with_args(np, "phandle-list",
					"#phandle-cells-missing", 0, &args);

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1");

	rc = of_count_phandle_with_args(np, "phandle-list",
					"#phandle-cells-missing");

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: could not get #phandle-cells-missing for /testcase-data/phandle-tests/provider1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	/* Check क्रम bad phandle in list */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: could not find phandle");

	rc = of_parse_phandle_with_args(np, "phandle-list-bad-phandle",
					"#phandle-cells", 0, &args);

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: could not find phandle");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: could not find phandle");

	rc = of_count_phandle_with_args(np, "phandle-list-bad-phandle",
					"#phandle-cells");

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: could not find phandle");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	/* Check क्रम incorrectly क्रमmed argument list */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found -1");

	rc = of_parse_phandle_with_args(np, "phandle-list-bad-args",
					"#phandle-cells", 1, &args);

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found -1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found -1");

	rc = of_count_phandle_with_args(np, "phandle-list-bad-args",
					"#phandle-cells");

	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-a: #phandle-cells = 3 found -1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
पूर्ण

अटल व्योम __init of_unittest_parse_phandle_with_args_map(व्योम)
अणु
	काष्ठा device_node *np, *p0, *p1, *p2, *p3;
	काष्ठा of_phandle_args args;
	पूर्णांक i, rc;

	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-b");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	p0 = of_find_node_by_path("/testcase-data/phandle-tests/provider0");
	अगर (!p0) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	p1 = of_find_node_by_path("/testcase-data/phandle-tests/provider1");
	अगर (!p1) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	p2 = of_find_node_by_path("/testcase-data/phandle-tests/provider2");
	अगर (!p2) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	p3 = of_find_node_by_path("/testcase-data/phandle-tests/provider3");
	अगर (!p3) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	rc = of_count_phandle_with_args(np, "phandle-list", "#phandle-cells");
	unittest(rc == 7, "of_count_phandle_with_args() returned %i, expected 7\n", rc);

	क्रम (i = 0; i < 8; i++) अणु
		bool passed = true;

		स_रखो(&args, 0, माप(args));
		rc = of_parse_phandle_with_args_map(np, "phandle-list",
						    "phandle", i, &args);

		/* Test the values from tests-phandle.dtsi */
		चयन (i) अणु
		हाल 0:
			passed &= !rc;
			passed &= (args.np == p1);
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 1);
			अवरोध;
		हाल 1:
			passed &= !rc;
			passed &= (args.np == p3);
			passed &= (args.args_count == 3);
			passed &= (args.args[0] == 2);
			passed &= (args.args[1] == 5);
			passed &= (args.args[2] == 3);
			अवरोध;
		हाल 2:
			passed &= (rc == -ENOENT);
			अवरोध;
		हाल 3:
			passed &= !rc;
			passed &= (args.np == p0);
			passed &= (args.args_count == 0);
			अवरोध;
		हाल 4:
			passed &= !rc;
			passed &= (args.np == p1);
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 3);
			अवरोध;
		हाल 5:
			passed &= !rc;
			passed &= (args.np == p0);
			passed &= (args.args_count == 0);
			अवरोध;
		हाल 6:
			passed &= !rc;
			passed &= (args.np == p2);
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == 15);
			passed &= (args.args[1] == 0x20);
			अवरोध;
		हाल 7:
			passed &= (rc == -ENOENT);
			अवरोध;
		शेष:
			passed = false;
		पूर्ण

		unittest(passed, "index %i - data error on node %s rc=%i\n",
			 i, args.np->full_name, rc);
	पूर्ण

	/* Check क्रम missing list property */
	स_रखो(&args, 0, माप(args));
	rc = of_parse_phandle_with_args_map(np, "phandle-list-missing",
					    "phandle", 0, &args);
	unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);

	/* Check क्रम missing cells,map,mask property */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-b: could not get #phandle-missing-cells for /testcase-data/phandle-tests/provider1");

	rc = of_parse_phandle_with_args_map(np, "phandle-list",
					    "phandle-missing", 0, &args);
	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-b: could not get #phandle-missing-cells for /testcase-data/phandle-tests/provider1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	/* Check क्रम bad phandle in list */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-b: could not find phandle");

	rc = of_parse_phandle_with_args_map(np, "phandle-list-bad-phandle",
					    "phandle", 0, &args);
	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-b: could not find phandle");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);

	/* Check क्रम incorrectly क्रमmed argument list */
	स_रखो(&args, 0, माप(args));

	EXPECT_BEGIN(KERN_INFO,
		     "OF: /testcase-data/phandle-tests/consumer-b: #phandle-cells = 2 found -1");

	rc = of_parse_phandle_with_args_map(np, "phandle-list-bad-args",
					    "phandle", 1, &args);
	EXPECT_END(KERN_INFO,
		   "OF: /testcase-data/phandle-tests/consumer-b: #phandle-cells = 2 found -1");

	unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
पूर्ण

अटल व्योम __init of_unittest_property_string(व्योम)
अणु
	स्थिर अक्षर *strings[4];
	काष्ठा device_node *np;
	पूर्णांक rc;

	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
	अगर (!np) अणु
		pr_err("No testcase data in device tree\n");
		वापस;
	पूर्ण

	rc = of_property_match_string(np, "phandle-list-names", "first");
	unittest(rc == 0, "first expected:0 got:%i\n", rc);
	rc = of_property_match_string(np, "phandle-list-names", "second");
	unittest(rc == 1, "second expected:1 got:%i\n", rc);
	rc = of_property_match_string(np, "phandle-list-names", "third");
	unittest(rc == 2, "third expected:2 got:%i\n", rc);
	rc = of_property_match_string(np, "phandle-list-names", "fourth");
	unittest(rc == -ENODATA, "unmatched string; rc=%i\n", rc);
	rc = of_property_match_string(np, "missing-property", "blah");
	unittest(rc == -EINVAL, "missing property; rc=%i\n", rc);
	rc = of_property_match_string(np, "empty-property", "blah");
	unittest(rc == -ENODATA, "empty property; rc=%i\n", rc);
	rc = of_property_match_string(np, "unterminated-string", "blah");
	unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);

	/* of_property_count_strings() tests */
	rc = of_property_count_strings(np, "string-property");
	unittest(rc == 1, "Incorrect string count; rc=%i\n", rc);
	rc = of_property_count_strings(np, "phandle-list-names");
	unittest(rc == 3, "Incorrect string count; rc=%i\n", rc);
	rc = of_property_count_strings(np, "unterminated-string");
	unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
	rc = of_property_count_strings(np, "unterminated-string-list");
	unittest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);

	/* of_property_पढ़ो_string_index() tests */
	rc = of_property_पढ़ो_string_index(np, "string-property", 0, strings);
	unittest(rc == 0 && !म_भेद(strings[0], "foobar"), "of_property_read_string_index() failure; rc=%i\n", rc);
	strings[0] = शून्य;
	rc = of_property_पढ़ो_string_index(np, "string-property", 1, strings);
	unittest(rc == -ENODATA && strings[0] == शून्य, "of_property_read_string_index() failure; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_index(np, "phandle-list-names", 0, strings);
	unittest(rc == 0 && !म_भेद(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_index(np, "phandle-list-names", 1, strings);
	unittest(rc == 0 && !म_भेद(strings[0], "second"), "of_property_read_string_index() failure; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_index(np, "phandle-list-names", 2, strings);
	unittest(rc == 0 && !म_भेद(strings[0], "third"), "of_property_read_string_index() failure; rc=%i\n", rc);
	strings[0] = शून्य;
	rc = of_property_पढ़ो_string_index(np, "phandle-list-names", 3, strings);
	unittest(rc == -ENODATA && strings[0] == शून्य, "of_property_read_string_index() failure; rc=%i\n", rc);
	strings[0] = शून्य;
	rc = of_property_पढ़ो_string_index(np, "unterminated-string", 0, strings);
	unittest(rc == -EILSEQ && strings[0] == शून्य, "of_property_read_string_index() failure; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_index(np, "unterminated-string-list", 0, strings);
	unittest(rc == 0 && !म_भेद(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
	strings[0] = शून्य;
	rc = of_property_पढ़ो_string_index(np, "unterminated-string-list", 2, strings); /* should fail */
	unittest(rc == -EILSEQ && strings[0] == शून्य, "of_property_read_string_index() failure; rc=%i\n", rc);
	strings[1] = शून्य;

	/* of_property_पढ़ो_string_array() tests */
	rc = of_property_पढ़ो_string_array(np, "string-property", strings, 4);
	unittest(rc == 1, "Incorrect string count; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_array(np, "phandle-list-names", strings, 4);
	unittest(rc == 3, "Incorrect string count; rc=%i\n", rc);
	rc = of_property_पढ़ो_string_array(np, "unterminated-string", strings, 4);
	unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
	/* -- An incorrectly क्रमmed string should cause a failure */
	rc = of_property_पढ़ो_string_array(np, "unterminated-string-list", strings, 4);
	unittest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
	/* -- parsing the correctly क्रमmed strings should still work: */
	strings[2] = शून्य;
	rc = of_property_पढ़ो_string_array(np, "unterminated-string-list", strings, 2);
	unittest(rc == 2 && strings[2] == शून्य, "of_property_read_string_array() failure; rc=%i\n", rc);
	strings[1] = शून्य;
	rc = of_property_पढ़ो_string_array(np, "phandle-list-names", strings, 1);
	unittest(rc == 1 && strings[1] == शून्य, "Overwrote end of string array; rc=%i, str='%s'\n", rc, strings[1]);
पूर्ण

#घोषणा propcmp(p1, p2) (((p1)->length == (p2)->length) && \
			(p1)->value && (p2)->value && \
			!स_भेद((p1)->value, (p2)->value, (p1)->length) && \
			!म_भेद((p1)->name, (p2)->name))
अटल व्योम __init of_unittest_property_copy(व्योम)
अणु
#अगर_घोषित CONFIG_OF_DYNAMIC
	काष्ठा property p1 = अणु .name = "p1", .length = 0, .value = "" पूर्ण;
	काष्ठा property p2 = अणु .name = "p2", .length = 5, .value = "abcd" पूर्ण;
	काष्ठा property *new;

	new = __of_prop_dup(&p1, GFP_KERNEL);
	unittest(new && propcmp(&p1, new), "empty property didn't copy correctly\n");
	kमुक्त(new->value);
	kमुक्त(new->name);
	kमुक्त(new);

	new = __of_prop_dup(&p2, GFP_KERNEL);
	unittest(new && propcmp(&p2, new), "non-empty property didn't copy correctly\n");
	kमुक्त(new->value);
	kमुक्त(new->name);
	kमुक्त(new);
#पूर्ण_अगर
पूर्ण

अटल व्योम __init of_unittest_changeset(व्योम)
अणु
#अगर_घोषित CONFIG_OF_DYNAMIC
	काष्ठा property *ppadd, padd = अणु .name = "prop-add", .length = 1, .value = "" पूर्ण;
	काष्ठा property *ppname_n1,  pname_n1  = अणु .name = "name", .length = 3, .value = "n1"  पूर्ण;
	काष्ठा property *ppname_n2,  pname_n2  = अणु .name = "name", .length = 3, .value = "n2"  पूर्ण;
	काष्ठा property *ppname_n21, pname_n21 = अणु .name = "name", .length = 3, .value = "n21" पूर्ण;
	काष्ठा property *ppupdate, pupdate = अणु .name = "prop-update", .length = 5, .value = "abcd" पूर्ण;
	काष्ठा property *ppहटाओ;
	काष्ठा device_node *n1, *n2, *n21, *nchangeset, *nहटाओ, *parent, *np;
	काष्ठा of_changeset chgset;

	n1 = __of_node_dup(शून्य, "n1");
	unittest(n1, "testcase setup failure\n");

	n2 = __of_node_dup(शून्य, "n2");
	unittest(n2, "testcase setup failure\n");

	n21 = __of_node_dup(शून्य, "n21");
	unittest(n21, "testcase setup failure %p\n", n21);

	nchangeset = of_find_node_by_path("/testcase-data/changeset");
	nहटाओ = of_get_child_by_name(nchangeset, "node-remove");
	unittest(nहटाओ, "testcase setup failure\n");

	ppadd = __of_prop_dup(&padd, GFP_KERNEL);
	unittest(ppadd, "testcase setup failure\n");

	ppname_n1  = __of_prop_dup(&pname_n1, GFP_KERNEL);
	unittest(ppname_n1, "testcase setup failure\n");

	ppname_n2  = __of_prop_dup(&pname_n2, GFP_KERNEL);
	unittest(ppname_n2, "testcase setup failure\n");

	ppname_n21 = __of_prop_dup(&pname_n21, GFP_KERNEL);
	unittest(ppname_n21, "testcase setup failure\n");

	ppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);
	unittest(ppupdate, "testcase setup failure\n");

	parent = nchangeset;
	n1->parent = parent;
	n2->parent = parent;
	n21->parent = n2;

	ppहटाओ = of_find_property(parent, "prop-remove", शून्य);
	unittest(ppहटाओ, "failed to find removal prop");

	of_changeset_init(&chgset);

	unittest(!of_changeset_attach_node(&chgset, n1), "fail attach n1\n");
	unittest(!of_changeset_add_property(&chgset, n1, ppname_n1), "fail add prop name\n");

	unittest(!of_changeset_attach_node(&chgset, n2), "fail attach n2\n");
	unittest(!of_changeset_add_property(&chgset, n2, ppname_n2), "fail add prop name\n");

	unittest(!of_changeset_detach_node(&chgset, nहटाओ), "fail remove node\n");
	unittest(!of_changeset_add_property(&chgset, n21, ppname_n21), "fail add prop name\n");

	unittest(!of_changeset_attach_node(&chgset, n21), "fail attach n21\n");

	unittest(!of_changeset_add_property(&chgset, parent, ppadd), "fail add prop prop-add\n");
	unittest(!of_changeset_update_property(&chgset, parent, ppupdate), "fail update prop\n");
	unittest(!of_changeset_हटाओ_property(&chgset, parent, ppहटाओ), "fail remove prop\n");

	unittest(!of_changeset_apply(&chgset), "apply failed\n");

	of_node_put(nchangeset);

	/* Make sure node names are स्थिरructed correctly */
	unittest((np = of_find_node_by_path("/testcase-data/changeset/n2/n21")),
		 "'%pOF' not added\n", n21);
	of_node_put(np);

	unittest(!of_changeset_revert(&chgset), "revert failed\n");

	of_changeset_destroy(&chgset);

	of_node_put(n1);
	of_node_put(n2);
	of_node_put(n21);
#पूर्ण_अगर
पूर्ण

अटल व्योम __init of_unittest_dma_get_max_cpu_address(व्योम)
अणु
	काष्ठा device_node *np;
	phys_addr_t cpu_addr;

	अगर (!IS_ENABLED(CONFIG_OF_ADDRESS))
		वापस;

	np = of_find_node_by_path("/testcase-data/address-tests");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	cpu_addr = of_dma_get_max_cpu_address(np);
	unittest(cpu_addr == 0x4fffffff,
		 "of_dma_get_max_cpu_address: wrong CPU addr %pad (expecting %x)\n",
		 &cpu_addr, 0x4fffffff);
पूर्ण

अटल व्योम __init of_unittest_dma_ranges_one(स्थिर अक्षर *path,
		u64 expect_dma_addr, u64 expect_paddr)
अणु
#अगर_घोषित CONFIG_HAS_DMA
	काष्ठा device_node *np;
	स्थिर काष्ठा bus_dma_region *map = शून्य;
	पूर्णांक rc;

	np = of_find_node_by_path(path);
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	rc = of_dma_get_range(np, &map);

	unittest(!rc, "of_dma_get_range failed on node %pOF rc=%i\n", np, rc);

	अगर (!rc) अणु
		phys_addr_t	paddr;
		dma_addr_t	dma_addr;
		काष्ठा device	dev_bogus;

		dev_bogus.dma_range_map = map;
		paddr = dma_to_phys(&dev_bogus, expect_dma_addr);
		dma_addr = phys_to_dma(&dev_bogus, expect_paddr);

		unittest(paddr == expect_paddr,
			 "of_dma_get_range: wrong phys addr %pap (expecting %llx) on node %pOF\n",
			 &paddr, expect_paddr, np);
		unittest(dma_addr == expect_dma_addr,
			 "of_dma_get_range: wrong DMA addr %pad (expecting %llx) on node %pOF\n",
			 &dma_addr, expect_dma_addr, np);

		kमुक्त(map);
	पूर्ण
	of_node_put(np);
#पूर्ण_अगर
पूर्ण

अटल व्योम __init of_unittest_parse_dma_ranges(व्योम)
अणु
	of_unittest_dma_ranges_one("/testcase-data/address-tests/device@70000000",
		0x0, 0x20000000);
	of_unittest_dma_ranges_one("/testcase-data/address-tests/bus@80000000/device@1000",
		0x100000000, 0x20000000);
	of_unittest_dma_ranges_one("/testcase-data/address-tests/pci@90000000",
		0x80000000, 0x20000000);
पूर्ण

अटल व्योम __init of_unittest_pci_dma_ranges(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा of_pci_range range;
	काष्ठा of_pci_range_parser parser;
	पूर्णांक i = 0;

	अगर (!IS_ENABLED(CONFIG_PCI))
		वापस;

	np = of_find_node_by_path("/testcase-data/address-tests/pci@90000000");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	अगर (of_pci_dma_range_parser_init(&parser, np)) अणु
		pr_err("missing dma-ranges property\n");
		वापस;
	पूर्ण

	/*
	 * Get the dma-ranges from the device tree
	 */
	क्रम_each_of_pci_range(&parser, &range) अणु
		अगर (!i) अणु
			unittest(range.size == 0x10000000,
				 "for_each_of_pci_range wrong size on node %pOF size=%llx\n",
				 np, range.size);
			unittest(range.cpu_addr == 0x20000000,
				 "for_each_of_pci_range wrong CPU addr (%llx) on node %pOF",
				 range.cpu_addr, np);
			unittest(range.pci_addr == 0x80000000,
				 "for_each_of_pci_range wrong DMA addr (%llx) on node %pOF",
				 range.pci_addr, np);
		पूर्ण अन्यथा अणु
			unittest(range.size == 0x10000000,
				 "for_each_of_pci_range wrong size on node %pOF size=%llx\n",
				 np, range.size);
			unittest(range.cpu_addr == 0x40000000,
				 "for_each_of_pci_range wrong CPU addr (%llx) on node %pOF",
				 range.cpu_addr, np);
			unittest(range.pci_addr == 0xc0000000,
				 "for_each_of_pci_range wrong DMA addr (%llx) on node %pOF",
				 range.pci_addr, np);
		पूर्ण
		i++;
	पूर्ण

	of_node_put(np);
पूर्ण

अटल व्योम __init of_unittest_parse_पूर्णांकerrupts(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा of_phandle_args args;
	पूर्णांक i, rc;

	अगर (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
		वापस;

	np = of_find_node_by_path("/testcase-data/interrupts/interrupts0");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	क्रम (i = 0; i < 4; i++) अणु
		bool passed = true;

		स_रखो(&args, 0, माप(args));
		rc = of_irq_parse_one(np, i, &args);

		passed &= !rc;
		passed &= (args.args_count == 1);
		passed &= (args.args[0] == (i + 1));

		unittest(passed, "index %i - data error on node %pOF rc=%i\n",
			 i, args.np, rc);
	पूर्ण
	of_node_put(np);

	np = of_find_node_by_path("/testcase-data/interrupts/interrupts1");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	क्रम (i = 0; i < 4; i++) अणु
		bool passed = true;

		स_रखो(&args, 0, माप(args));
		rc = of_irq_parse_one(np, i, &args);

		/* Test the values from tests-phandle.dtsi */
		चयन (i) अणु
		हाल 0:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 9);
			अवरोध;
		हाल 1:
			passed &= !rc;
			passed &= (args.args_count == 3);
			passed &= (args.args[0] == 10);
			passed &= (args.args[1] == 11);
			passed &= (args.args[2] == 12);
			अवरोध;
		हाल 2:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == 13);
			passed &= (args.args[1] == 14);
			अवरोध;
		हाल 3:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == 15);
			passed &= (args.args[1] == 16);
			अवरोध;
		शेष:
			passed = false;
		पूर्ण
		unittest(passed, "index %i - data error on node %pOF rc=%i\n",
			 i, args.np, rc);
	पूर्ण
	of_node_put(np);
पूर्ण

अटल व्योम __init of_unittest_parse_पूर्णांकerrupts_extended(व्योम)
अणु
	काष्ठा device_node *np;
	काष्ठा of_phandle_args args;
	पूर्णांक i, rc;

	अगर (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
		वापस;

	np = of_find_node_by_path("/testcase-data/interrupts/interrupts-extended0");
	अगर (!np) अणु
		pr_err("missing testcase data\n");
		वापस;
	पूर्ण

	क्रम (i = 0; i < 7; i++) अणु
		bool passed = true;

		स_रखो(&args, 0, माप(args));
		rc = of_irq_parse_one(np, i, &args);

		/* Test the values from tests-phandle.dtsi */
		चयन (i) अणु
		हाल 0:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 1);
			अवरोध;
		हाल 1:
			passed &= !rc;
			passed &= (args.args_count == 3);
			passed &= (args.args[0] == 2);
			passed &= (args.args[1] == 3);
			passed &= (args.args[2] == 4);
			अवरोध;
		हाल 2:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == 5);
			passed &= (args.args[1] == 6);
			अवरोध;
		हाल 3:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 9);
			अवरोध;
		हाल 4:
			passed &= !rc;
			passed &= (args.args_count == 3);
			passed &= (args.args[0] == 10);
			passed &= (args.args[1] == 11);
			passed &= (args.args[2] == 12);
			अवरोध;
		हाल 5:
			passed &= !rc;
			passed &= (args.args_count == 2);
			passed &= (args.args[0] == 13);
			passed &= (args.args[1] == 14);
			अवरोध;
		हाल 6:
			passed &= !rc;
			passed &= (args.args_count == 1);
			passed &= (args.args[0] == 15);
			अवरोध;
		शेष:
			passed = false;
		पूर्ण

		unittest(passed, "index %i - data error on node %pOF rc=%i\n",
			 i, args.np, rc);
	पूर्ण
	of_node_put(np);
पूर्ण

अटल स्थिर काष्ठा of_device_id match_node_table[] = अणु
	अणु .data = "A", .name = "name0", पूर्ण, /* Name alone is lowest priority */
	अणु .data = "B", .type = "type1", पूर्ण, /* followed by type alone */

	अणु .data = "Ca", .name = "name2", .type = "type1", पूर्ण, /* followed by both together */
	अणु .data = "Cb", .name = "name2", पूर्ण, /* Only match when type करोesn't match */
	अणु .data = "Cc", .name = "name2", .type = "type2", पूर्ण,

	अणु .data = "E", .compatible = "compat3" पूर्ण,
	अणु .data = "G", .compatible = "compat2", पूर्ण,
	अणु .data = "H", .compatible = "compat2", .name = "name5", पूर्ण,
	अणु .data = "I", .compatible = "compat2", .type = "type1", पूर्ण,
	अणु .data = "J", .compatible = "compat2", .type = "type1", .name = "name8", पूर्ण,
	अणु .data = "K", .compatible = "compat2", .name = "name9", पूर्ण,
	अणुपूर्ण
पूर्ण;

अटल काष्ठा अणु
	स्थिर अक्षर *path;
	स्थिर अक्षर *data;
पूर्ण match_node_tests[] = अणु
	अणु .path = "/testcase-data/match-node/name0", .data = "A", पूर्ण,
	अणु .path = "/testcase-data/match-node/name1", .data = "B", पूर्ण,
	अणु .path = "/testcase-data/match-node/a/name2", .data = "Ca", पूर्ण,
	अणु .path = "/testcase-data/match-node/b/name2", .data = "Cb", पूर्ण,
	अणु .path = "/testcase-data/match-node/c/name2", .data = "Cc", पूर्ण,
	अणु .path = "/testcase-data/match-node/name3", .data = "E", पूर्ण,
	अणु .path = "/testcase-data/match-node/name4", .data = "G", पूर्ण,
	अणु .path = "/testcase-data/match-node/name5", .data = "H", पूर्ण,
	अणु .path = "/testcase-data/match-node/name6", .data = "G", पूर्ण,
	अणु .path = "/testcase-data/match-node/name7", .data = "I", पूर्ण,
	अणु .path = "/testcase-data/match-node/name8", .data = "J", पूर्ण,
	अणु .path = "/testcase-data/match-node/name9", .data = "K", पूर्ण,
पूर्ण;

अटल व्योम __init of_unittest_match_node(व्योम)
अणु
	काष्ठा device_node *np;
	स्थिर काष्ठा of_device_id *match;
	पूर्णांक i;

	क्रम (i = 0; i < ARRAY_SIZE(match_node_tests); i++) अणु
		np = of_find_node_by_path(match_node_tests[i].path);
		अगर (!np) अणु
			unittest(0, "missing testcase node %s\n",
				match_node_tests[i].path);
			जारी;
		पूर्ण

		match = of_match_node(match_node_table, np);
		अगर (!match) अणु
			unittest(0, "%s didn't match anything\n",
				match_node_tests[i].path);
			जारी;
		पूर्ण

		अगर (म_भेद(match->data, match_node_tests[i].data) != 0) अणु
			unittest(0, "%s got wrong match. expected %s, got %s\n",
				match_node_tests[i].path, match_node_tests[i].data,
				(स्थिर अक्षर *)match->data);
			जारी;
		पूर्ण
		unittest(1, "passed");
	पूर्ण
पूर्ण

अटल काष्ठा resource test_bus_res = अणु
	.start = 0xfffffff8,
	.end = 0xfffffff9,
	.flags = IORESOURCE_MEM,
पूर्ण;
अटल स्थिर काष्ठा platक्रमm_device_info test_bus_info = अणु
	.name = "unittest-bus",
पूर्ण;
अटल व्योम __init of_unittest_platक्रमm_populate(व्योम)
अणु
	पूर्णांक irq, rc;
	काष्ठा device_node *np, *child, *gअक्रमchild;
	काष्ठा platक्रमm_device *pdev, *test_bus;
	स्थिर काष्ठा of_device_id match[] = अणु
		अणु .compatible = "test-device", पूर्ण,
		अणुपूर्ण
	पूर्ण;

	np = of_find_node_by_path("/testcase-data");
	of_platक्रमm_शेष_populate(np, शून्य, शून्य);

	/* Test that a missing irq करोमुख्य वापसs -EPROBE_DEFER */
	np = of_find_node_by_path("/testcase-data/testcase-device1");
	pdev = of_find_device_by_node(np);
	unittest(pdev, "device 1 creation failed\n");

	अगर (!(of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)) अणु
		irq = platक्रमm_get_irq(pdev, 0);
		unittest(irq == -EPROBE_DEFER,
			 "device deferred probe failed - %d\n", irq);

		/* Test that a parsing failure करोes not वापस -EPROBE_DEFER */
		np = of_find_node_by_path("/testcase-data/testcase-device2");
		pdev = of_find_device_by_node(np);
		unittest(pdev, "device 2 creation failed\n");

		EXPECT_BEGIN(KERN_INFO,
			     "platform testcase-data:testcase-device2: IRQ index 0 not found");

		irq = platक्रमm_get_irq(pdev, 0);

		EXPECT_END(KERN_INFO,
			   "platform testcase-data:testcase-device2: IRQ index 0 not found");

		unittest(irq < 0 && irq != -EPROBE_DEFER,
			 "device parsing error failed - %d\n", irq);
	पूर्ण

	np = of_find_node_by_path("/testcase-data/platform-tests");
	unittest(np, "No testcase data in device tree\n");
	अगर (!np)
		वापस;

	test_bus = platक्रमm_device_रेजिस्टर_full(&test_bus_info);
	rc = PTR_ERR_OR_ZERO(test_bus);
	unittest(!rc, "testbus registration failed; rc=%i\n", rc);
	अगर (rc) अणु
		of_node_put(np);
		वापस;
	पूर्ण
	test_bus->dev.of_node = np;

	/*
	 * Add a dummy resource to the test bus node after it is
	 * रेजिस्टरed to catch problems with un-inserted resources. The
	 * DT code करोesn't insert the resources, and it has caused the
	 * kernel to oops in the past. This makes sure the same bug
	 * करोesn't crop up again.
	 */
	platक्रमm_device_add_resources(test_bus, &test_bus_res, 1);

	of_platक्रमm_populate(np, match, शून्य, &test_bus->dev);
	क्रम_each_child_of_node(np, child) अणु
		क्रम_each_child_of_node(child, gअक्रमchild) अणु
			pdev = of_find_device_by_node(gअक्रमchild);
			unittest(pdev,
				 "Could not create device for node '%pOFn'\n",
				 gअक्रमchild);
			platक्रमm_device_put(pdev);
		पूर्ण
	पूर्ण

	of_platक्रमm_depopulate(&test_bus->dev);
	क्रम_each_child_of_node(np, child) अणु
		क्रम_each_child_of_node(child, gअक्रमchild)
			unittest(!of_find_device_by_node(gअक्रमchild),
				 "device didn't get destroyed '%pOFn'\n",
				 gअक्रमchild);
	पूर्ण

	platक्रमm_device_unरेजिस्टर(test_bus);
	of_node_put(np);
पूर्ण

/**
 *	update_node_properties - adds the properties
 *	of np पूर्णांकo dup node (present in live tree) and
 *	updates parent of children of np to dup.
 *
 *	@np:	node whose properties are being added to the live tree
 *	@dup:	node present in live tree to be updated
 */
अटल व्योम update_node_properties(काष्ठा device_node *np,
					काष्ठा device_node *dup)
अणु
	काष्ठा property *prop;
	काष्ठा property *save_next;
	काष्ठा device_node *child;
	पूर्णांक ret;

	क्रम_each_child_of_node(np, child)
		child->parent = dup;

	/*
	 * "unittest internal error: unable to add testdata property"
	 *
	 *    If this message reports a property in node '/__symbols__' then
	 *    the respective unittest overlay contains a label that has the
	 *    same name as a label in the live devicetree.  The label will
	 *    be in the live devicetree only अगर the devicetree source was
	 *    compiled with the '-@' option.  If you encounter this error,
	 *    please consider renaming __all__ of the labels in the unittest
	 *    overlay dts files with an odd prefix that is unlikely to be
	 *    used in a real devicetree.
	 */

	/*
	 * खोलो code क्रम_each_property_of_node() because of_add_property()
	 * sets prop->next to शून्य
	 */
	क्रम (prop = np->properties; prop != शून्य; prop = save_next) अणु
		save_next = prop->next;
		ret = of_add_property(dup, prop);
		अगर (ret) अणु
			अगर (ret == -EEXIST && !म_भेद(prop->name, "name"))
				जारी;
			pr_err("unittest internal error: unable to add testdata property %pOF/%s",
			       np, prop->name);
		पूर्ण
	पूर्ण
पूर्ण

/**
 *	attach_node_and_children - attaches nodes
 *	and its children to live tree.
 *	CAUTION: misleading function name - अगर node @np alपढ़ोy exists in
 *	the live tree then children of @np are *not* attached to the live
 *	tree.  This works क्रम the current test devicetree nodes because such
 *	nodes करो not have child nodes.
 *
 *	@np:	Node to attach to live tree
 */
अटल व्योम attach_node_and_children(काष्ठा device_node *np)
अणु
	काष्ठा device_node *next, *dup, *child;
	अचिन्हित दीर्घ flags;
	स्थिर अक्षर *full_name;

	full_name = kaप्र_लिखो(GFP_KERNEL, "%pOF", np);

	अगर (!म_भेद(full_name, "/__local_fixups__") ||
	    !म_भेद(full_name, "/__fixups__")) अणु
		kमुक्त(full_name);
		वापस;
	पूर्ण

	dup = of_find_node_by_path(full_name);
	kमुक्त(full_name);
	अगर (dup) अणु
		update_node_properties(np, dup);
		वापस;
	पूर्ण

	child = np->child;
	np->child = शून्य;

	mutex_lock(&of_mutex);
	raw_spin_lock_irqsave(&devtree_lock, flags);
	np->sibling = np->parent->child;
	np->parent->child = np;
	of_node_clear_flag(np, OF_DETACHED);
	raw_spin_unlock_irqrestore(&devtree_lock, flags);

	__of_attach_node_sysfs(np);
	mutex_unlock(&of_mutex);

	जबतक (child) अणु
		next = child->sibling;
		attach_node_and_children(child);
		child = next;
	पूर्ण
पूर्ण

/**
 *	unittest_data_add - Reads, copies data from
 *	linked tree and attaches it to the live tree
 */
अटल पूर्णांक __init unittest_data_add(व्योम)
अणु
	व्योम *unittest_data;
	व्योम *unittest_data_align;
	काष्ठा device_node *unittest_data_node = शून्य, *np;
	/*
	 * __dtb_testहालs_begin[] and __dtb_testहालs_end[] are magically
	 * created by cmd_dt_S_dtb in scripts/Makefile.lib
	 */
	बाह्य uपूर्णांक8_t __dtb_testहालs_begin[];
	बाह्य uपूर्णांक8_t __dtb_testहालs_end[];
	स्थिर पूर्णांक size = __dtb_testहालs_end - __dtb_testहालs_begin;
	पूर्णांक rc;
	व्योम *ret;

	अगर (!size) अणु
		pr_warn("%s: testcases is empty\n", __func__);
		वापस -ENODATA;
	पूर्ण

	/* creating copy */
	unittest_data = kदो_स्मृति(size + FDT_ALIGN_SIZE, GFP_KERNEL);
	अगर (!unittest_data)
		वापस -ENOMEM;

	unittest_data_align = PTR_ALIGN(unittest_data, FDT_ALIGN_SIZE);
	स_नकल(unittest_data_align, __dtb_testहालs_begin, size);

	ret = of_fdt_unflatten_tree(unittest_data_align, शून्य, &unittest_data_node);
	अगर (!ret) अणु
		pr_warn("%s: unflatten testcases tree failed\n", __func__);
		kमुक्त(unittest_data);
		वापस -ENODATA;
	पूर्ण
	अगर (!unittest_data_node) अणु
		pr_warn("%s: testcases tree is empty\n", __func__);
		kमुक्त(unittest_data);
		वापस -ENODATA;
	पूर्ण

	/*
	 * This lock normally enबंदs of_resolve_phandles()
	 */
	of_overlay_mutex_lock();

	rc = of_resolve_phandles(unittest_data_node);
	अगर (rc) अणु
		pr_err("%s: Failed to resolve phandles (rc=%i)\n", __func__, rc);
		of_overlay_mutex_unlock();
		वापस -EINVAL;
	पूर्ण

	अगर (!of_root) अणु
		of_root = unittest_data_node;
		क्रम_each_of_allnodes(np)
			__of_attach_node_sysfs(np);
		of_aliases = of_find_node_by_path("/aliases");
		of_chosen = of_find_node_by_path("/chosen");
		of_overlay_mutex_unlock();
		वापस 0;
	पूर्ण

	EXPECT_BEGIN(KERN_INFO,
		     "Duplicate name in testcase-data, renamed to \"duplicate-name#1\"");

	/* attach the sub-tree to live tree */
	np = unittest_data_node->child;
	जबतक (np) अणु
		काष्ठा device_node *next = np->sibling;

		np->parent = of_root;
		attach_node_and_children(np);
		np = next;
	पूर्ण

	EXPECT_END(KERN_INFO,
		   "Duplicate name in testcase-data, renamed to \"duplicate-name#1\"");

	of_overlay_mutex_unlock();

	वापस 0;
पूर्ण

#अगर_घोषित CONFIG_OF_OVERLAY
अटल पूर्णांक __init overlay_data_apply(स्थिर अक्षर *overlay_name, पूर्णांक *overlay_id);

अटल पूर्णांक unittest_probe(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा device_node *np = dev->of_node;

	अगर (np == शून्य) अणु
		dev_err(dev, "No OF data for device\n");
		वापस -EINVAL;

	पूर्ण

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);

	of_platक्रमm_populate(np, शून्य, शून्य, &pdev->dev);

	वापस 0;
पूर्ण

अटल पूर्णांक unittest_हटाओ(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा device_node *np = dev->of_node;

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);
	वापस 0;
पूर्ण

अटल स्थिर काष्ठा of_device_id unittest_match[] = अणु
	अणु .compatible = "unittest", पूर्ण,
	अणुपूर्ण,
पूर्ण;

अटल काष्ठा platक्रमm_driver unittest_driver = अणु
	.probe			= unittest_probe,
	.हटाओ			= unittest_हटाओ,
	.driver = अणु
		.name		= "unittest",
		.of_match_table	= of_match_ptr(unittest_match),
	पूर्ण,
पूर्ण;

/* get the platक्रमm device instantiated at the path */
अटल काष्ठा platक्रमm_device *of_path_to_platक्रमm_device(स्थिर अक्षर *path)
अणु
	काष्ठा device_node *np;
	काष्ठा platक्रमm_device *pdev;

	np = of_find_node_by_path(path);
	अगर (np == शून्य)
		वापस शून्य;

	pdev = of_find_device_by_node(np);
	of_node_put(np);

	वापस pdev;
पूर्ण

/* find out अगर a platक्रमm device exists at that path */
अटल पूर्णांक of_path_platक्रमm_device_exists(स्थिर अक्षर *path)
अणु
	काष्ठा platक्रमm_device *pdev;

	pdev = of_path_to_platक्रमm_device(path);
	platक्रमm_device_put(pdev);
	वापस pdev != शून्य;
पूर्ण

#अगर_घोषित CONFIG_OF_GPIO

काष्ठा unittest_gpio_dev अणु
	काष्ठा gpio_chip chip;
पूर्ण;

अटल पूर्णांक unittest_gpio_chip_request_count;
अटल पूर्णांक unittest_gpio_probe_count;
अटल पूर्णांक unittest_gpio_probe_pass_count;

अटल पूर्णांक unittest_gpio_chip_request(काष्ठा gpio_chip *chip, अचिन्हित पूर्णांक offset)
अणु
	unittest_gpio_chip_request_count++;

	pr_debug("%s(): %s %d %d\n", __func__, chip->label, offset,
		 unittest_gpio_chip_request_count);
	वापस 0;
पूर्ण

अटल पूर्णांक unittest_gpio_probe(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा unittest_gpio_dev *devptr;
	पूर्णांक ret;

	unittest_gpio_probe_count++;

	devptr = kzalloc(माप(*devptr), GFP_KERNEL);
	अगर (!devptr)
		वापस -ENOMEM;

	platक्रमm_set_drvdata(pdev, devptr);

	devptr->chip.of_node = pdev->dev.of_node;
	devptr->chip.label = "of-unittest-gpio";
	devptr->chip.base = -1; /* dynamic allocation */
	devptr->chip.ngpio = 5;
	devptr->chip.request = unittest_gpio_chip_request;

	ret = gpiochip_add_data(&devptr->chip, शून्य);

	unittest(!ret,
		 "gpiochip_add_data() for node @%pOF failed, ret = %d\n", devptr->chip.of_node, ret);

	अगर (!ret)
		unittest_gpio_probe_pass_count++;
	वापस ret;
पूर्ण

अटल पूर्णांक unittest_gpio_हटाओ(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा unittest_gpio_dev *gdev = platक्रमm_get_drvdata(pdev);
	काष्ठा device *dev = &pdev->dev;
	काष्ठा device_node *np = pdev->dev.of_node;

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);

	अगर (!gdev)
		वापस -EINVAL;

	अगर (gdev->chip.base != -1)
		gpiochip_हटाओ(&gdev->chip);

	platक्रमm_set_drvdata(pdev, शून्य);
	kमुक्त(gdev);

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा of_device_id unittest_gpio_id[] = अणु
	अणु .compatible = "unittest-gpio", पूर्ण,
	अणुपूर्ण
पूर्ण;

अटल काष्ठा platक्रमm_driver unittest_gpio_driver = अणु
	.probe	= unittest_gpio_probe,
	.हटाओ	= unittest_gpio_हटाओ,
	.driver	= अणु
		.name		= "unittest-gpio",
		.of_match_table	= of_match_ptr(unittest_gpio_id),
	पूर्ण,
पूर्ण;

अटल व्योम __init of_unittest_overlay_gpio(व्योम)
अणु
	पूर्णांक chip_request_count;
	पूर्णांक probe_pass_count;
	पूर्णांक ret;

	/*
	 * tests: apply overlays beक्रमe रेजिस्टरing driver
	 * Similar to installing a driver as a module, the
	 * driver is रेजिस्टरed after applying the overlays.
	 *
	 * The overlays are applied by overlay_data_apply()
	 * instead of of_unittest_apply_overlay() so that they
	 * will not be tracked.  Thus they will not be हटाओd
	 * by of_unittest_destroy_tracked_overlays().
	 *
	 * - apply overlay_gpio_01
	 * - apply overlay_gpio_02a
	 * - apply overlay_gpio_02b
	 * - रेजिस्टर driver
	 *
	 * रेजिस्टर driver will result in
	 *   - probe and processing gpio hog क्रम overlay_gpio_01
	 *   - probe क्रम overlay_gpio_02a
	 *   - processing gpio क्रम overlay_gpio_02b
	 */

	probe_pass_count = unittest_gpio_probe_pass_count;
	chip_request_count = unittest_gpio_chip_request_count;

	/*
	 * overlay_gpio_01 contains gpio node and child gpio hog node
	 * overlay_gpio_02a contains gpio node
	 * overlay_gpio_02b contains child gpio hog node
	 */

	unittest(overlay_data_apply("overlay_gpio_01", शून्य),
		 "Adding overlay 'overlay_gpio_01' failed\n");

	unittest(overlay_data_apply("overlay_gpio_02a", शून्य),
		 "Adding overlay 'overlay_gpio_02a' failed\n");

	unittest(overlay_data_apply("overlay_gpio_02b", शून्य),
		 "Adding overlay 'overlay_gpio_02b' failed\n");

	/*
	 * messages are the result of the probes, after the
	 * driver is रेजिस्टरed
	 */

	EXPECT_BEGIN(KERN_INFO,
		     "GPIO line <<int>> (line-B-input) hogged as input\n");

	EXPECT_BEGIN(KERN_INFO,
		     "GPIO line <<int>> (line-A-input) hogged as input\n");

	ret = platक्रमm_driver_रेजिस्टर(&unittest_gpio_driver);
	अगर (unittest(ret == 0, "could not register unittest gpio driver\n"))
		वापस;

	EXPECT_END(KERN_INFO,
		   "GPIO line <<int>> (line-A-input) hogged as input\n");
	EXPECT_END(KERN_INFO,
		   "GPIO line <<int>> (line-B-input) hogged as input\n");

	unittest(probe_pass_count + 2 == unittest_gpio_probe_pass_count,
		 "unittest_gpio_probe() failed or not called\n");

	unittest(chip_request_count + 2 == unittest_gpio_chip_request_count,
		 "unittest_gpio_chip_request() called %d times (expected 1 time)\n",
		 unittest_gpio_chip_request_count - chip_request_count);

	/*
	 * tests: apply overlays after रेजिस्टरing driver
	 *
	 * Similar to a driver built-in to the kernel, the
	 * driver is रेजिस्टरed beक्रमe applying the overlays.
	 *
	 * overlay_gpio_03 contains gpio node and child gpio hog node
	 *
	 * - apply overlay_gpio_03
	 *
	 * apply overlay will result in
	 *   - probe and processing gpio hog.
	 */

	probe_pass_count = unittest_gpio_probe_pass_count;
	chip_request_count = unittest_gpio_chip_request_count;

	EXPECT_BEGIN(KERN_INFO,
		     "GPIO line <<int>> (line-D-input) hogged as input\n");

	/* overlay_gpio_03 contains gpio node and child gpio hog node */

	unittest(overlay_data_apply("overlay_gpio_03", शून्य),
		 "Adding overlay 'overlay_gpio_03' failed\n");

	EXPECT_END(KERN_INFO,
		   "GPIO line <<int>> (line-D-input) hogged as input\n");

	unittest(probe_pass_count + 1 == unittest_gpio_probe_pass_count,
		 "unittest_gpio_probe() failed or not called\n");

	unittest(chip_request_count + 1 == unittest_gpio_chip_request_count,
		 "unittest_gpio_chip_request() called %d times (expected 1 time)\n",
		 unittest_gpio_chip_request_count - chip_request_count);

	/*
	 * overlay_gpio_04a contains gpio node
	 *
	 * - apply overlay_gpio_04a
	 *
	 * apply the overlay will result in
	 *   - probe क्रम overlay_gpio_04a
	 */

	probe_pass_count = unittest_gpio_probe_pass_count;
	chip_request_count = unittest_gpio_chip_request_count;

	/* overlay_gpio_04a contains gpio node */

	unittest(overlay_data_apply("overlay_gpio_04a", शून्य),
		 "Adding overlay 'overlay_gpio_04a' failed\n");

	unittest(probe_pass_count + 1 == unittest_gpio_probe_pass_count,
		 "unittest_gpio_probe() failed or not called\n");

	/*
	 * overlay_gpio_04b contains child gpio hog node
	 *
	 * - apply overlay_gpio_04b
	 *
	 * apply the overlay will result in
	 *   - processing gpio क्रम overlay_gpio_04b
	 */

	EXPECT_BEGIN(KERN_INFO,
		     "GPIO line <<int>> (line-C-input) hogged as input\n");

	/* overlay_gpio_04b contains child gpio hog node */

	unittest(overlay_data_apply("overlay_gpio_04b", शून्य),
		 "Adding overlay 'overlay_gpio_04b' failed\n");

	EXPECT_END(KERN_INFO,
		   "GPIO line <<int>> (line-C-input) hogged as input\n");

	unittest(chip_request_count + 1 == unittest_gpio_chip_request_count,
		 "unittest_gpio_chip_request() called %d times (expected 1 time)\n",
		 unittest_gpio_chip_request_count - chip_request_count);
पूर्ण

#अन्यथा

अटल व्योम __init of_unittest_overlay_gpio(व्योम)
अणु
	/* skip tests */
पूर्ण

#पूर्ण_अगर

#अगर IS_BUILTIN(CONFIG_I2C)

/* get the i2c client device instantiated at the path */
अटल काष्ठा i2c_client *of_path_to_i2c_client(स्थिर अक्षर *path)
अणु
	काष्ठा device_node *np;
	काष्ठा i2c_client *client;

	np = of_find_node_by_path(path);
	अगर (np == शून्य)
		वापस शून्य;

	client = of_find_i2c_device_by_node(np);
	of_node_put(np);

	वापस client;
पूर्ण

/* find out अगर a i2c client device exists at that path */
अटल पूर्णांक of_path_i2c_client_exists(स्थिर अक्षर *path)
अणु
	काष्ठा i2c_client *client;

	client = of_path_to_i2c_client(path);
	अगर (client)
		put_device(&client->dev);
	वापस client != शून्य;
पूर्ण
#अन्यथा
अटल पूर्णांक of_path_i2c_client_exists(स्थिर अक्षर *path)
अणु
	वापस 0;
पूर्ण
#पूर्ण_अगर

क्रमागत overlay_type अणु
	PDEV_OVERLAY,
	I2C_OVERLAY
पूर्ण;

अटल पूर्णांक of_path_device_type_exists(स्थिर अक्षर *path,
		क्रमागत overlay_type ovtype)
अणु
	चयन (ovtype) अणु
	हाल PDEV_OVERLAY:
		वापस of_path_platक्रमm_device_exists(path);
	हाल I2C_OVERLAY:
		वापस of_path_i2c_client_exists(path);
	पूर्ण
	वापस 0;
पूर्ण

अटल स्थिर अक्षर *unittest_path(पूर्णांक nr, क्रमागत overlay_type ovtype)
अणु
	स्थिर अक्षर *base;
	अटल अक्षर buf[256];

	चयन (ovtype) अणु
	हाल PDEV_OVERLAY:
		base = "/testcase-data/overlay-node/test-bus";
		अवरोध;
	हाल I2C_OVERLAY:
		base = "/testcase-data/overlay-node/test-bus/i2c-test-bus";
		अवरोध;
	शेष:
		buf[0] = '\0';
		वापस buf;
	पूर्ण
	snम_लिखो(buf, माप(buf) - 1, "%s/test-unittest%d", base, nr);
	buf[माप(buf) - 1] = '\0';
	वापस buf;
पूर्ण

अटल पूर्णांक of_unittest_device_exists(पूर्णांक unittest_nr, क्रमागत overlay_type ovtype)
अणु
	स्थिर अक्षर *path;

	path = unittest_path(unittest_nr, ovtype);

	चयन (ovtype) अणु
	हाल PDEV_OVERLAY:
		वापस of_path_platक्रमm_device_exists(path);
	हाल I2C_OVERLAY:
		वापस of_path_i2c_client_exists(path);
	पूर्ण
	वापस 0;
पूर्ण

अटल स्थिर अक्षर *overlay_name_from_nr(पूर्णांक nr)
अणु
	अटल अक्षर buf[256];

	snम_लिखो(buf, माप(buf) - 1,
		"overlay_%d", nr);
	buf[माप(buf) - 1] = '\0';

	वापस buf;
पूर्ण

अटल स्थिर अक्षर *bus_path = "/testcase-data/overlay-node/test-bus";

/* FIXME: it is NOT guaranteed that overlay ids are asचिन्हित in sequence */

#घोषणा MAX_UNITTEST_OVERLAYS	256
अटल अचिन्हित दीर्घ overlay_id_bits[BITS_TO_LONGS(MAX_UNITTEST_OVERLAYS)];
अटल पूर्णांक overlay_first_id = -1;

अटल दीर्घ of_unittest_overlay_tracked(पूर्णांक id)
अणु
	अगर (WARN_ON(id >= MAX_UNITTEST_OVERLAYS))
		वापस 0;
	वापस overlay_id_bits[BIT_WORD(id)] & BIT_MASK(id);
पूर्ण

अटल व्योम of_unittest_track_overlay(पूर्णांक id)
अणु
	अगर (overlay_first_id < 0)
		overlay_first_id = id;
	id -= overlay_first_id;

	अगर (WARN_ON(id >= MAX_UNITTEST_OVERLAYS))
		वापस;
	overlay_id_bits[BIT_WORD(id)] |= BIT_MASK(id);
पूर्ण

अटल व्योम of_unittest_untrack_overlay(पूर्णांक id)
अणु
	अगर (overlay_first_id < 0)
		वापस;
	id -= overlay_first_id;
	अगर (WARN_ON(id >= MAX_UNITTEST_OVERLAYS))
		वापस;
	overlay_id_bits[BIT_WORD(id)] &= ~BIT_MASK(id);
पूर्ण

अटल व्योम of_unittest_destroy_tracked_overlays(व्योम)
अणु
	पूर्णांक id, ret, defers, ovcs_id;

	अगर (overlay_first_id < 0)
		वापस;

	/* try until no defers */
	करो अणु
		defers = 0;
		/* हटाओ in reverse order */
		क्रम (id = MAX_UNITTEST_OVERLAYS - 1; id >= 0; id--) अणु
			अगर (!of_unittest_overlay_tracked(id))
				जारी;

			ovcs_id = id + overlay_first_id;
			ret = of_overlay_हटाओ(&ovcs_id);
			अगर (ret == -ENODEV) अणु
				pr_warn("%s: no overlay to destroy for #%d\n",
					__func__, id + overlay_first_id);
				जारी;
			पूर्ण
			अगर (ret != 0) अणु
				defers++;
				pr_warn("%s: overlay destroy failed for #%d\n",
					__func__, id + overlay_first_id);
				जारी;
			पूर्ण

			of_unittest_untrack_overlay(id);
		पूर्ण
	पूर्ण जबतक (defers > 0);
पूर्ण

अटल पूर्णांक __init of_unittest_apply_overlay(पूर्णांक overlay_nr, पूर्णांक *overlay_id)
अणु
	स्थिर अक्षर *overlay_name;

	overlay_name = overlay_name_from_nr(overlay_nr);

	अगर (!overlay_data_apply(overlay_name, overlay_id)) अणु
		unittest(0, "could not apply overlay \"%s\"\n",
				overlay_name);
		वापस -EFAULT;
	पूर्ण
	of_unittest_track_overlay(*overlay_id);

	वापस 0;
पूर्ण

/* apply an overlay जबतक checking beक्रमe and after states */
अटल पूर्णांक __init of_unittest_apply_overlay_check(पूर्णांक overlay_nr,
		पूर्णांक unittest_nr, पूर्णांक beक्रमe, पूर्णांक after,
		क्रमागत overlay_type ovtype)
अणु
	पूर्णांक ret, ovcs_id;

	/* unittest device must not be in beक्रमe state */
	अगर (of_unittest_device_exists(unittest_nr, ovtype) != beक्रमe) अणु
		unittest(0, "%s with device @\"%s\" %s\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype),
				!beक्रमe ? "enabled" : "disabled");
		वापस -EINVAL;
	पूर्ण

	ovcs_id = 0;
	ret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);
	अगर (ret != 0) अणु
		/* of_unittest_apply_overlay alपढ़ोy called unittest() */
		वापस ret;
	पूर्ण

	/* unittest device must be to set to after state */
	अगर (of_unittest_device_exists(unittest_nr, ovtype) != after) अणु
		unittest(0, "%s failed to create @\"%s\" %s\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype),
				!after ? "enabled" : "disabled");
		वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

/* apply an overlay and then revert it जबतक checking beक्रमe, after states */
अटल पूर्णांक __init of_unittest_apply_revert_overlay_check(पूर्णांक overlay_nr,
		पूर्णांक unittest_nr, पूर्णांक beक्रमe, पूर्णांक after,
		क्रमागत overlay_type ovtype)
अणु
	पूर्णांक ret, ovcs_id, save_id;

	/* unittest device must be in beक्रमe state */
	अगर (of_unittest_device_exists(unittest_nr, ovtype) != beक्रमe) अणु
		unittest(0, "%s with device @\"%s\" %s\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype),
				!beक्रमe ? "enabled" : "disabled");
		वापस -EINVAL;
	पूर्ण

	/* apply the overlay */
	ovcs_id = 0;
	ret = of_unittest_apply_overlay(overlay_nr, &ovcs_id);
	अगर (ret != 0) अणु
		/* of_unittest_apply_overlay alपढ़ोy called unittest() */
		वापस ret;
	पूर्ण

	/* unittest device must be in after state */
	अगर (of_unittest_device_exists(unittest_nr, ovtype) != after) अणु
		unittest(0, "%s failed to create @\"%s\" %s\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype),
				!after ? "enabled" : "disabled");
		वापस -EINVAL;
	पूर्ण

	save_id = ovcs_id;
	ret = of_overlay_हटाओ(&ovcs_id);
	अगर (ret != 0) अणु
		unittest(0, "%s failed to be destroyed @\"%s\"\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype));
		वापस ret;
	पूर्ण
	of_unittest_untrack_overlay(save_id);

	/* unittest device must be again in beक्रमe state */
	अगर (of_unittest_device_exists(unittest_nr, PDEV_OVERLAY) != beक्रमe) अणु
		unittest(0, "%s with device @\"%s\" %s\n",
				overlay_name_from_nr(overlay_nr),
				unittest_path(unittest_nr, ovtype),
				!beक्रमe ? "enabled" : "disabled");
		वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

/* test activation of device */
अटल व्योम __init of_unittest_overlay_0(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status");

	/* device should enable */
	ret = of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 0);
पूर्ण

/* test deactivation of device */
अटल व्योम __init of_unittest_overlay_1(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status");

	/* device should disable */
	ret = of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 1);

पूर्ण

/* test activation of device */
अटल व्योम __init of_unittest_overlay_2(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status");

	/* device should enable */
	ret = of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status");

	अगर (ret)
		वापस;
	unittest(1, "overlay test %d passed\n", 2);
पूर्ण

/* test deactivation of device */
अटल व्योम __init of_unittest_overlay_3(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status");

	/* device should disable */
	ret = of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 3);
पूर्ण

/* test activation of a full device node */
अटल व्योम __init of_unittest_overlay_4(व्योम)
अणु
	/* device should disable */
	अगर (of_unittest_apply_overlay_check(4, 4, 0, 1, PDEV_OVERLAY))
		वापस;

	unittest(1, "overlay test %d passed\n", 4);
पूर्ण

/* test overlay apply/revert sequence */
अटल व्योम __init of_unittest_overlay_5(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status");

	/* device should disable */
	ret = of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 5);
पूर्ण

/* test overlay application in sequence */
अटल व्योम __init of_unittest_overlay_6(व्योम)
अणु
	पूर्णांक i, ov_id[2], ovcs_id;
	पूर्णांक overlay_nr = 6, unittest_nr = 6;
	पूर्णांक beक्रमe = 0, after = 1;
	स्थिर अक्षर *overlay_name;

	पूर्णांक ret;

	/* unittest device must be in beक्रमe state */
	क्रम (i = 0; i < 2; i++) अणु
		अगर (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
				!= beक्रमe) अणु
			unittest(0, "%s with device @\"%s\" %s\n",
					overlay_name_from_nr(overlay_nr + i),
					unittest_path(unittest_nr + i,
						PDEV_OVERLAY),
					!beक्रमe ? "enabled" : "disabled");
			वापस;
		पूर्ण
	पूर्ण

	/* apply the overlays */

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status");

	overlay_name = overlay_name_from_nr(overlay_nr + 0);

	ret = overlay_data_apply(overlay_name, &ovcs_id);

	अगर (!ret) अणु
		unittest(0, "could not apply overlay \"%s\"\n", overlay_name);
			वापस;
	पूर्ण
	ov_id[0] = ovcs_id;
	of_unittest_track_overlay(ov_id[0]);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status");

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status");

	overlay_name = overlay_name_from_nr(overlay_nr + 1);

	ret = overlay_data_apply(overlay_name, &ovcs_id);

	अगर (!ret) अणु
		unittest(0, "could not apply overlay \"%s\"\n", overlay_name);
			वापस;
	पूर्ण
	ov_id[1] = ovcs_id;
	of_unittest_track_overlay(ov_id[1]);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status");


	क्रम (i = 0; i < 2; i++) अणु
		/* unittest device must be in after state */
		अगर (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
				!= after) अणु
			unittest(0, "overlay @\"%s\" failed @\"%s\" %s\n",
					overlay_name_from_nr(overlay_nr + i),
					unittest_path(unittest_nr + i,
						PDEV_OVERLAY),
					!after ? "enabled" : "disabled");
			वापस;
		पूर्ण
	पूर्ण

	क्रम (i = 1; i >= 0; i--) अणु
		ovcs_id = ov_id[i];
		अगर (of_overlay_हटाओ(&ovcs_id)) अणु
			unittest(0, "%s failed destroy @\"%s\"\n",
					overlay_name_from_nr(overlay_nr + i),
					unittest_path(unittest_nr + i,
						PDEV_OVERLAY));
			वापस;
		पूर्ण
		of_unittest_untrack_overlay(ov_id[i]);
	पूर्ण

	क्रम (i = 0; i < 2; i++) अणु
		/* unittest device must be again in beक्रमe state */
		अगर (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
				!= beक्रमe) अणु
			unittest(0, "%s with device @\"%s\" %s\n",
					overlay_name_from_nr(overlay_nr + i),
					unittest_path(unittest_nr + i,
						PDEV_OVERLAY),
					!beक्रमe ? "enabled" : "disabled");
			वापस;
		पूर्ण
	पूर्ण

	unittest(1, "overlay test %d passed\n", 6);

पूर्ण

/* test overlay application in sequence */
अटल व्योम __init of_unittest_overlay_8(व्योम)
अणु
	पूर्णांक i, ov_id[2], ovcs_id;
	पूर्णांक overlay_nr = 8, unittest_nr = 8;
	स्थिर अक्षर *overlay_name;
	पूर्णांक ret;

	/* we करोn't care about device state in this test */

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status");

	overlay_name = overlay_name_from_nr(overlay_nr + 0);

	ret = overlay_data_apply(overlay_name, &ovcs_id);
	अगर (!ret)
		unittest(0, "could not apply overlay \"%s\"\n", overlay_name);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status");

	अगर (!ret)
		वापस;

	ov_id[0] = ovcs_id;
	of_unittest_track_overlay(ov_id[0]);

	overlay_name = overlay_name_from_nr(overlay_nr + 1);

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo");

	/* apply the overlays */
	ret = overlay_data_apply(overlay_name, &ovcs_id);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo");

	अगर (!ret) अणु
		unittest(0, "could not apply overlay \"%s\"\n", overlay_name);
		वापस;
	पूर्ण

	ov_id[1] = ovcs_id;
	of_unittest_track_overlay(ov_id[1]);

	/* now try to हटाओ first overlay (it should fail) */
	ovcs_id = ov_id[0];

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: node_overlaps_later_cs: #6 overlaps with #7 @/testcase-data/overlay-node/test-bus/test-unittest8");

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: overlay #6 is not topmost");

	ret = of_overlay_हटाओ(&ovcs_id);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: overlay #6 is not topmost");

	EXPECT_END(KERN_INFO,
		   "OF: overlay: node_overlaps_later_cs: #6 overlaps with #7 @/testcase-data/overlay-node/test-bus/test-unittest8");

	अगर (!ret) अणु
		unittest(0, "%s was destroyed @\"%s\"\n",
				overlay_name_from_nr(overlay_nr + 0),
				unittest_path(unittest_nr,
					PDEV_OVERLAY));
		वापस;
	पूर्ण

	/* removing them in order should work */
	क्रम (i = 1; i >= 0; i--) अणु
		ovcs_id = ov_id[i];
		अगर (of_overlay_हटाओ(&ovcs_id)) अणु
			unittest(0, "%s not destroyed @\"%s\"\n",
					overlay_name_from_nr(overlay_nr + i),
					unittest_path(unittest_nr,
						PDEV_OVERLAY));
			वापस;
		पूर्ण
		of_unittest_untrack_overlay(ov_id[i]);
	पूर्ण

	unittest(1, "overlay test %d passed\n", 8);
पूर्ण

/* test insertion of a bus with parent devices */
अटल व्योम __init of_unittest_overlay_10(व्योम)
अणु
	पूर्णांक ret;
	अक्षर *child_path;

	/* device should disable */
	ret = of_unittest_apply_overlay_check(10, 10, 0, 1, PDEV_OVERLAY);

	अगर (unittest(ret == 0,
			"overlay test %d failed; overlay application\n", 10))
		वापस;

	child_path = kaप्र_लिखो(GFP_KERNEL, "%s/test-unittest101",
			unittest_path(10, PDEV_OVERLAY));
	अगर (unittest(child_path, "overlay test %d failed; kasprintf\n", 10))
		वापस;

	ret = of_path_device_type_exists(child_path, PDEV_OVERLAY);
	kमुक्त(child_path);

	unittest(ret, "overlay test %d failed; no child device\n", 10);
पूर्ण

/* test insertion of a bus with parent devices (and revert) */
अटल व्योम __init of_unittest_overlay_11(व्योम)
अणु
	पूर्णांक ret;

	/* device should disable */
	ret = of_unittest_apply_revert_overlay_check(11, 11, 0, 1,
			PDEV_OVERLAY);

	unittest(ret == 0, "overlay test %d failed; overlay apply\n", 11);
पूर्ण

#अगर IS_BUILTIN(CONFIG_I2C) && IS_ENABLED(CONFIG_OF_OVERLAY)

काष्ठा unittest_i2c_bus_data अणु
	काष्ठा platक्रमm_device	*pdev;
	काष्ठा i2c_adapter	adap;
पूर्ण;

अटल पूर्णांक unittest_i2c_master_xfer(काष्ठा i2c_adapter *adap,
		काष्ठा i2c_msg *msgs, पूर्णांक num)
अणु
	काष्ठा unittest_i2c_bus_data *std = i2c_get_adapdata(adap);

	(व्योम)std;

	वापस num;
पूर्ण

अटल u32 unittest_i2c_functionality(काष्ठा i2c_adapter *adap)
अणु
	वापस I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
पूर्ण

अटल स्थिर काष्ठा i2c_algorithm unittest_i2c_algo = अणु
	.master_xfer	= unittest_i2c_master_xfer,
	.functionality	= unittest_i2c_functionality,
पूर्ण;

अटल पूर्णांक unittest_i2c_bus_probe(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा device_node *np = dev->of_node;
	काष्ठा unittest_i2c_bus_data *std;
	काष्ठा i2c_adapter *adap;
	पूर्णांक ret;

	अगर (np == शून्य) अणु
		dev_err(dev, "No OF data for device\n");
		वापस -EINVAL;

	पूर्ण

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);

	std = devm_kzalloc(dev, माप(*std), GFP_KERNEL);
	अगर (!std)
		वापस -ENOMEM;

	/* link them together */
	std->pdev = pdev;
	platक्रमm_set_drvdata(pdev, std);

	adap = &std->adap;
	i2c_set_adapdata(adap, std);
	adap->nr = -1;
	strlcpy(adap->name, pdev->name, माप(adap->name));
	adap->class = I2C_CLASS_DEPRECATED;
	adap->algo = &unittest_i2c_algo;
	adap->dev.parent = dev;
	adap->dev.of_node = dev->of_node;
	adap->समयout = 5 * HZ;
	adap->retries = 3;

	ret = i2c_add_numbered_adapter(adap);
	अगर (ret != 0) अणु
		dev_err(dev, "Failed to add I2C adapter\n");
		वापस ret;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक unittest_i2c_bus_हटाओ(काष्ठा platक्रमm_device *pdev)
अणु
	काष्ठा device *dev = &pdev->dev;
	काष्ठा device_node *np = dev->of_node;
	काष्ठा unittest_i2c_bus_data *std = platक्रमm_get_drvdata(pdev);

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);
	i2c_del_adapter(&std->adap);

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा of_device_id unittest_i2c_bus_match[] = अणु
	अणु .compatible = "unittest-i2c-bus", पूर्ण,
	अणुपूर्ण,
पूर्ण;

अटल काष्ठा platक्रमm_driver unittest_i2c_bus_driver = अणु
	.probe			= unittest_i2c_bus_probe,
	.हटाओ			= unittest_i2c_bus_हटाओ,
	.driver = अणु
		.name		= "unittest-i2c-bus",
		.of_match_table	= of_match_ptr(unittest_i2c_bus_match),
	पूर्ण,
पूर्ण;

अटल पूर्णांक unittest_i2c_dev_probe(काष्ठा i2c_client *client,
		स्थिर काष्ठा i2c_device_id *id)
अणु
	काष्ठा device *dev = &client->dev;
	काष्ठा device_node *np = client->dev.of_node;

	अगर (!np) अणु
		dev_err(dev, "No OF node\n");
		वापस -EINVAL;
	पूर्ण

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);

	वापस 0;
पूर्ण;

अटल पूर्णांक unittest_i2c_dev_हटाओ(काष्ठा i2c_client *client)
अणु
	काष्ठा device *dev = &client->dev;
	काष्ठा device_node *np = client->dev.of_node;

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);
	वापस 0;
पूर्ण

अटल स्थिर काष्ठा i2c_device_id unittest_i2c_dev_id[] = अणु
	अणु .name = "unittest-i2c-dev" पूर्ण,
	अणु पूर्ण
पूर्ण;

अटल काष्ठा i2c_driver unittest_i2c_dev_driver = अणु
	.driver = अणु
		.name = "unittest-i2c-dev",
	पूर्ण,
	.probe = unittest_i2c_dev_probe,
	.हटाओ = unittest_i2c_dev_हटाओ,
	.id_table = unittest_i2c_dev_id,
पूर्ण;

#अगर IS_BUILTIN(CONFIG_I2C_MUX)

अटल पूर्णांक unittest_i2c_mux_select_chan(काष्ठा i2c_mux_core *muxc, u32 chan)
अणु
	वापस 0;
पूर्ण

अटल पूर्णांक unittest_i2c_mux_probe(काष्ठा i2c_client *client,
		स्थिर काष्ठा i2c_device_id *id)
अणु
	पूर्णांक i, nchans;
	काष्ठा device *dev = &client->dev;
	काष्ठा i2c_adapter *adap = client->adapter;
	काष्ठा device_node *np = client->dev.of_node, *child;
	काष्ठा i2c_mux_core *muxc;
	u32 reg, max_reg;

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);

	अगर (!np) अणु
		dev_err(dev, "No OF node\n");
		वापस -EINVAL;
	पूर्ण

	max_reg = (u32)-1;
	क्रम_each_child_of_node(np, child) अणु
		अगर (of_property_पढ़ो_u32(child, "reg", &reg))
			जारी;
		अगर (max_reg == (u32)-1 || reg > max_reg)
			max_reg = reg;
	पूर्ण
	nchans = max_reg == (u32)-1 ? 0 : max_reg + 1;
	अगर (nchans == 0) अणु
		dev_err(dev, "No channels\n");
		वापस -EINVAL;
	पूर्ण

	muxc = i2c_mux_alloc(adap, dev, nchans, 0, 0,
			     unittest_i2c_mux_select_chan, शून्य);
	अगर (!muxc)
		वापस -ENOMEM;
	क्रम (i = 0; i < nchans; i++) अणु
		अगर (i2c_mux_add_adapter(muxc, 0, i, 0)) अणु
			dev_err(dev, "Failed to register mux #%d\n", i);
			i2c_mux_del_adapters(muxc);
			वापस -ENODEV;
		पूर्ण
	पूर्ण

	i2c_set_clientdata(client, muxc);

	वापस 0;
पूर्ण;

अटल पूर्णांक unittest_i2c_mux_हटाओ(काष्ठा i2c_client *client)
अणु
	काष्ठा device *dev = &client->dev;
	काष्ठा device_node *np = client->dev.of_node;
	काष्ठा i2c_mux_core *muxc = i2c_get_clientdata(client);

	dev_dbg(dev, "%s for node @%pOF\n", __func__, np);
	i2c_mux_del_adapters(muxc);
	वापस 0;
पूर्ण

अटल स्थिर काष्ठा i2c_device_id unittest_i2c_mux_id[] = अणु
	अणु .name = "unittest-i2c-mux" पूर्ण,
	अणु पूर्ण
पूर्ण;

अटल काष्ठा i2c_driver unittest_i2c_mux_driver = अणु
	.driver = अणु
		.name = "unittest-i2c-mux",
	पूर्ण,
	.probe = unittest_i2c_mux_probe,
	.हटाओ = unittest_i2c_mux_हटाओ,
	.id_table = unittest_i2c_mux_id,
पूर्ण;

#पूर्ण_अगर

अटल पूर्णांक of_unittest_overlay_i2c_init(व्योम)
अणु
	पूर्णांक ret;

	ret = i2c_add_driver(&unittest_i2c_dev_driver);
	अगर (unittest(ret == 0,
			"could not register unittest i2c device driver\n"))
		वापस ret;

	ret = platक्रमm_driver_रेजिस्टर(&unittest_i2c_bus_driver);

	अगर (unittest(ret == 0,
			"could not register unittest i2c bus driver\n"))
		वापस ret;

#अगर IS_BUILTIN(CONFIG_I2C_MUX)

	EXPECT_BEGIN(KERN_INFO,
		     "i2c i2c-1: Added multiplexed i2c bus 2");

	ret = i2c_add_driver(&unittest_i2c_mux_driver);

	EXPECT_END(KERN_INFO,
		   "i2c i2c-1: Added multiplexed i2c bus 2");

	अगर (unittest(ret == 0,
			"could not register unittest i2c mux driver\n"))
		वापस ret;
#पूर्ण_अगर

	वापस 0;
पूर्ण

अटल व्योम of_unittest_overlay_i2c_cleanup(व्योम)
अणु
#अगर IS_BUILTIN(CONFIG_I2C_MUX)
	i2c_del_driver(&unittest_i2c_mux_driver);
#पूर्ण_अगर
	platक्रमm_driver_unरेजिस्टर(&unittest_i2c_bus_driver);
	i2c_del_driver(&unittest_i2c_dev_driver);
पूर्ण

अटल व्योम __init of_unittest_overlay_i2c_12(व्योम)
अणु
	पूर्णांक ret;

	/* device should enable */
	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status");

	ret = of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 12);
पूर्ण

/* test deactivation of device */
अटल व्योम __init of_unittest_overlay_i2c_13(व्योम)
अणु
	पूर्णांक ret;

	EXPECT_BEGIN(KERN_INFO,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status");

	/* device should disable */
	ret = of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 13);
पूर्ण

/* just check क्रम i2c mux existence */
अटल व्योम of_unittest_overlay_i2c_14(व्योम)
अणु
पूर्ण

अटल व्योम __init of_unittest_overlay_i2c_15(व्योम)
अणु
	पूर्णांक ret;

	/* device should enable */
	EXPECT_BEGIN(KERN_INFO,
		     "i2c i2c-1: Added multiplexed i2c bus 3");

	ret = of_unittest_apply_overlay_check(15, 15, 0, 1, I2C_OVERLAY);

	EXPECT_END(KERN_INFO,
		   "i2c i2c-1: Added multiplexed i2c bus 3");

	अगर (ret)
		वापस;

	unittest(1, "overlay test %d passed\n", 15);
पूर्ण

#अन्यथा

अटल अंतरभूत व्योम of_unittest_overlay_i2c_14(व्योम) अणु पूर्ण
अटल अंतरभूत व्योम of_unittest_overlay_i2c_15(व्योम) अणु पूर्ण

#पूर्ण_अगर

अटल व्योम __init of_unittest_overlay(व्योम)
अणु
	काष्ठा device_node *bus_np = शून्य;

	अगर (platक्रमm_driver_रेजिस्टर(&unittest_driver)) अणु
		unittest(0, "could not register unittest driver\n");
		जाओ out;
	पूर्ण

	bus_np = of_find_node_by_path(bus_path);
	अगर (bus_np == शून्य) अणु
		unittest(0, "could not find bus_path \"%s\"\n", bus_path);
		जाओ out;
	पूर्ण

	अगर (of_platक्रमm_शेष_populate(bus_np, शून्य, शून्य)) अणु
		unittest(0, "could not populate bus @ \"%s\"\n", bus_path);
		जाओ out;
	पूर्ण

	अगर (!of_unittest_device_exists(100, PDEV_OVERLAY)) अणु
		unittest(0, "could not find unittest0 @ \"%s\"\n",
				unittest_path(100, PDEV_OVERLAY));
		जाओ out;
	पूर्ण

	अगर (of_unittest_device_exists(101, PDEV_OVERLAY)) अणु
		unittest(0, "unittest1 @ \"%s\" should not exist\n",
				unittest_path(101, PDEV_OVERLAY));
		जाओ out;
	पूर्ण

	unittest(1, "basic infrastructure of overlays passed");

	/* tests in sequence */
	of_unittest_overlay_0();
	of_unittest_overlay_1();
	of_unittest_overlay_2();
	of_unittest_overlay_3();
	of_unittest_overlay_4();
	of_unittest_overlay_5();
	of_unittest_overlay_6();
	of_unittest_overlay_8();

	of_unittest_overlay_10();
	of_unittest_overlay_11();

#अगर IS_BUILTIN(CONFIG_I2C)
	अगर (unittest(of_unittest_overlay_i2c_init() == 0, "i2c init failed\n"))
		जाओ out;

	of_unittest_overlay_i2c_12();
	of_unittest_overlay_i2c_13();
	of_unittest_overlay_i2c_14();
	of_unittest_overlay_i2c_15();

	of_unittest_overlay_i2c_cleanup();
#पूर्ण_अगर

	of_unittest_overlay_gpio();

	of_unittest_destroy_tracked_overlays();

out:
	of_node_put(bus_np);
पूर्ण

#अन्यथा
अटल अंतरभूत व्योम __init of_unittest_overlay(व्योम) अणु पूर्ण
#पूर्ण_अगर

#अगर_घोषित CONFIG_OF_OVERLAY

/*
 * __dtb_ot_begin[] and __dtb_ot_end[] are created by cmd_dt_S_dtb
 * in scripts/Makefile.lib
 */

#घोषणा OVERLAY_INFO_EXTERN(name) \
	बाह्य uपूर्णांक8_t __dtb_##name##_begin[]; \
	बाह्य uपूर्णांक8_t __dtb_##name##_end[]

#घोषणा OVERLAY_INFO(overlay_name, expected)             \
अणु	.dtb_begin       = __dtb_##overlay_name##_begin, \
	.dtb_end         = __dtb_##overlay_name##_end,   \
	.expected_result = expected,                     \
	.name            = #overlay_name,                \
पूर्ण

काष्ठा overlay_info अणु
	uपूर्णांक8_t		*dtb_begin;
	uपूर्णांक8_t		*dtb_end;
	पूर्णांक		expected_result;
	पूर्णांक		overlay_id;
	अक्षर		*name;
पूर्ण;

OVERLAY_INFO_EXTERN(overlay_base);
OVERLAY_INFO_EXTERN(overlay);
OVERLAY_INFO_EXTERN(overlay_0);
OVERLAY_INFO_EXTERN(overlay_1);
OVERLAY_INFO_EXTERN(overlay_2);
OVERLAY_INFO_EXTERN(overlay_3);
OVERLAY_INFO_EXTERN(overlay_4);
OVERLAY_INFO_EXTERN(overlay_5);
OVERLAY_INFO_EXTERN(overlay_6);
OVERLAY_INFO_EXTERN(overlay_7);
OVERLAY_INFO_EXTERN(overlay_8);
OVERLAY_INFO_EXTERN(overlay_9);
OVERLAY_INFO_EXTERN(overlay_10);
OVERLAY_INFO_EXTERN(overlay_11);
OVERLAY_INFO_EXTERN(overlay_12);
OVERLAY_INFO_EXTERN(overlay_13);
OVERLAY_INFO_EXTERN(overlay_15);
OVERLAY_INFO_EXTERN(overlay_gpio_01);
OVERLAY_INFO_EXTERN(overlay_gpio_02a);
OVERLAY_INFO_EXTERN(overlay_gpio_02b);
OVERLAY_INFO_EXTERN(overlay_gpio_03);
OVERLAY_INFO_EXTERN(overlay_gpio_04a);
OVERLAY_INFO_EXTERN(overlay_gpio_04b);
OVERLAY_INFO_EXTERN(overlay_bad_add_dup_node);
OVERLAY_INFO_EXTERN(overlay_bad_add_dup_prop);
OVERLAY_INFO_EXTERN(overlay_bad_phandle);
OVERLAY_INFO_EXTERN(overlay_bad_symbol);

/* entries found by name */
अटल काष्ठा overlay_info overlays[] = अणु
	OVERLAY_INFO(overlay_base, -9999),
	OVERLAY_INFO(overlay, 0),
	OVERLAY_INFO(overlay_0, 0),
	OVERLAY_INFO(overlay_1, 0),
	OVERLAY_INFO(overlay_2, 0),
	OVERLAY_INFO(overlay_3, 0),
	OVERLAY_INFO(overlay_4, 0),
	OVERLAY_INFO(overlay_5, 0),
	OVERLAY_INFO(overlay_6, 0),
	OVERLAY_INFO(overlay_7, 0),
	OVERLAY_INFO(overlay_8, 0),
	OVERLAY_INFO(overlay_9, 0),
	OVERLAY_INFO(overlay_10, 0),
	OVERLAY_INFO(overlay_11, 0),
	OVERLAY_INFO(overlay_12, 0),
	OVERLAY_INFO(overlay_13, 0),
	OVERLAY_INFO(overlay_15, 0),
	OVERLAY_INFO(overlay_gpio_01, 0),
	OVERLAY_INFO(overlay_gpio_02a, 0),
	OVERLAY_INFO(overlay_gpio_02b, 0),
	OVERLAY_INFO(overlay_gpio_03, 0),
	OVERLAY_INFO(overlay_gpio_04a, 0),
	OVERLAY_INFO(overlay_gpio_04b, 0),
	OVERLAY_INFO(overlay_bad_add_dup_node, -EINVAL),
	OVERLAY_INFO(overlay_bad_add_dup_prop, -EINVAL),
	OVERLAY_INFO(overlay_bad_phandle, -EINVAL),
	OVERLAY_INFO(overlay_bad_symbol, -EINVAL),
	/* end marker */
	अणु.dtb_begin = शून्य, .dtb_end = शून्य, .expected_result = 0, .name = शून्यपूर्ण
पूर्ण;

अटल काष्ठा device_node *overlay_base_root;

अटल व्योम * __init dt_alloc_memory(u64 size, u64 align)
अणु
	व्योम *ptr = memblock_alloc(size, align);

	अगर (!ptr)
		panic("%s: Failed to allocate %llu bytes align=0x%llx\n",
		      __func__, size, align);

	वापस ptr;
पूर्ण

/*
 * Create base device tree क्रम the overlay unittest.
 *
 * This is called from very early boot code.
 *
 * Do as much as possible the same way as करोne in __unflatten_device_tree
 * and other early boot steps क्रम the normal FDT so that the overlay base
 * unflattened tree will have the same अक्षरacteristics as the real tree
 * (such as having memory allocated by the early allocator).  The goal
 * is to test "the real thing" as much as possible, and test "test setup
 * code" as little as possible.
 *
 * Have to stop beक्रमe resolving phandles, because that uses kदो_स्मृति.
 */
व्योम __init unittest_unflatten_overlay_base(व्योम)
अणु
	काष्ठा overlay_info *info;
	u32 data_size;
	व्योम *new_fdt;
	u32 size;
	पूर्णांक found = 0;
	स्थिर अक्षर *overlay_name = "overlay_base";

	क्रम (info = overlays; info && info->name; info++) अणु
		अगर (!म_भेद(overlay_name, info->name)) अणु
			found = 1;
			अवरोध;
		पूर्ण
	पूर्ण
	अगर (!found) अणु
		pr_err("no overlay data for %s\n", overlay_name);
		वापस;
	पूर्ण

	info = &overlays[0];

	अगर (info->expected_result != -9999) अणु
		pr_err("No dtb 'overlay_base' to attach\n");
		वापस;
	पूर्ण

	data_size = info->dtb_end - info->dtb_begin;
	अगर (!data_size) अणु
		pr_err("No dtb 'overlay_base' to attach\n");
		वापस;
	पूर्ण

	size = fdt_totalsize(info->dtb_begin);
	अगर (size != data_size) अणु
		pr_err("dtb 'overlay_base' header totalsize != actual size");
		वापस;
	पूर्ण

	new_fdt = dt_alloc_memory(size, roundup_घात_of_two(FDT_V17_SIZE));
	अगर (!new_fdt) अणु
		pr_err("alloc for dtb 'overlay_base' failed");
		वापस;
	पूर्ण

	स_नकल(new_fdt, info->dtb_begin, size);

	__unflatten_device_tree(new_fdt, शून्य, &overlay_base_root,
				dt_alloc_memory, true);
पूर्ण

/*
 * The purpose of of_unittest_overlay_data_add is to add an
 * overlay in the normal fashion.  This is a test of the whole
 * picture, instead of testing inभागidual elements.
 *
 * A secondary purpose is to be able to verअगरy that the contents of
 * /proc/device-tree/ contains the updated काष्ठाure and values from
 * the overlay.  That must be verअगरied separately in user space.
 *
 * Return 0 on unexpected error.
 */
अटल पूर्णांक __init overlay_data_apply(स्थिर अक्षर *overlay_name, पूर्णांक *overlay_id)
अणु
	काष्ठा overlay_info *info;
	पूर्णांक found = 0;
	पूर्णांक ret;
	u32 size;

	क्रम (info = overlays; info && info->name; info++) अणु
		अगर (!म_भेद(overlay_name, info->name)) अणु
			found = 1;
			अवरोध;
		पूर्ण
	पूर्ण
	अगर (!found) अणु
		pr_err("no overlay data for %s\n", overlay_name);
		वापस 0;
	पूर्ण

	size = info->dtb_end - info->dtb_begin;
	अगर (!size)
		pr_err("no overlay data for %s\n", overlay_name);

	ret = of_overlay_fdt_apply(info->dtb_begin, size, &info->overlay_id);
	अगर (overlay_id)
		*overlay_id = info->overlay_id;
	अगर (ret < 0)
		जाओ out;

	pr_debug("%s applied\n", overlay_name);

out:
	अगर (ret != info->expected_result)
		pr_err("of_overlay_fdt_apply() expected %d, ret=%d, %s\n",
		       info->expected_result, ret, overlay_name);

	वापस (ret == info->expected_result);
पूर्ण

/*
 * The purpose of of_unittest_overlay_high_level is to add an overlay
 * in the normal fashion.  This is a test of the whole picture,
 * instead of inभागidual elements.
 *
 * The first part of the function is _not_ normal overlay usage; it is
 * finishing splicing the base overlay device tree पूर्णांकo the live tree.
 */
अटल __init व्योम of_unittest_overlay_high_level(व्योम)
अणु
	काष्ठा device_node *last_sibling;
	काष्ठा device_node *np;
	काष्ठा device_node *of_symbols;
	काष्ठा device_node *overlay_base_symbols;
	काष्ठा device_node **pprev;
	काष्ठा property *prop;
	पूर्णांक ret;

	अगर (!overlay_base_root) अणु
		unittest(0, "overlay_base_root not initialized\n");
		वापस;
	पूर्ण

	/*
	 * Could not fixup phandles in unittest_unflatten_overlay_base()
	 * because kदो_स्मृति() was not yet available.
	 */
	of_overlay_mutex_lock();
	of_resolve_phandles(overlay_base_root);
	of_overlay_mutex_unlock();


	/*
	 * करो not allow overlay_base to duplicate any node alपढ़ोy in
	 * tree, this greatly simplअगरies the code
	 */

	/*
	 * हटाओ overlay_base_root node "__local_fixups", after
	 * being used by of_resolve_phandles()
	 */
	pprev = &overlay_base_root->child;
	क्रम (np = overlay_base_root->child; np; np = np->sibling) अणु
		अगर (of_node_name_eq(np, "__local_fixups__")) अणु
			*pprev = np->sibling;
			अवरोध;
		पूर्ण
		pprev = &np->sibling;
	पूर्ण

	/* हटाओ overlay_base_root node "__symbols__" अगर in live tree */
	of_symbols = of_get_child_by_name(of_root, "__symbols__");
	अगर (of_symbols) अणु
		/* will have to graft properties from node पूर्णांकo live tree */
		pprev = &overlay_base_root->child;
		क्रम (np = overlay_base_root->child; np; np = np->sibling) अणु
			अगर (of_node_name_eq(np, "__symbols__")) अणु
				overlay_base_symbols = np;
				*pprev = np->sibling;
				अवरोध;
			पूर्ण
			pprev = &np->sibling;
		पूर्ण
	पूर्ण

	क्रम_each_child_of_node(overlay_base_root, np) अणु
		काष्ठा device_node *base_child;
		क्रम_each_child_of_node(of_root, base_child) अणु
			अगर (!म_भेद(np->full_name, base_child->full_name)) अणु
				unittest(0, "illegal node name in overlay_base %pOFn",
					 np);
				वापस;
			पूर्ण
		पूर्ण
	पूर्ण

	/*
	 * overlay 'overlay_base' is not allowed to have root
	 * properties, so only need to splice nodes पूर्णांकo मुख्य device tree.
	 *
	 * root node of *overlay_base_root will not be मुक्तd, it is lost
	 * memory.
	 */

	क्रम (np = overlay_base_root->child; np; np = np->sibling)
		np->parent = of_root;

	mutex_lock(&of_mutex);

	क्रम (last_sibling = np = of_root->child; np; np = np->sibling)
		last_sibling = np;

	अगर (last_sibling)
		last_sibling->sibling = overlay_base_root->child;
	अन्यथा
		of_root->child = overlay_base_root->child;

	क्रम_each_of_allnodes_from(overlay_base_root, np)
		__of_attach_node_sysfs(np);

	अगर (of_symbols) अणु
		काष्ठा property *new_prop;
		क्रम_each_property_of_node(overlay_base_symbols, prop) अणु

			new_prop = __of_prop_dup(prop, GFP_KERNEL);
			अगर (!new_prop) अणु
				unittest(0, "__of_prop_dup() of '%s' from overlay_base node __symbols__",
					 prop->name);
				जाओ err_unlock;
			पूर्ण
			अगर (__of_add_property(of_symbols, new_prop)) अणु
				kमुक्त(new_prop->name);
				kमुक्त(new_prop->value);
				kमुक्त(new_prop);
				/* "name" स्वतः-generated by unflatten */
				अगर (!म_भेद(prop->name, "name"))
					जारी;
				unittest(0, "duplicate property '%s' in overlay_base node __symbols__",
					 prop->name);
				जाओ err_unlock;
			पूर्ण
			अगर (__of_add_property_sysfs(of_symbols, new_prop)) अणु
				unittest(0, "unable to add property '%s' in overlay_base node __symbols__ to sysfs",
					 prop->name);
				जाओ err_unlock;
			पूर्ण
		पूर्ण
	पूर्ण

	mutex_unlock(&of_mutex);


	/* now करो the normal overlay usage test */

	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right");

	ret = overlay_data_apply("overlay", शून्य);

	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status");

	unittest(ret, "Adding overlay 'overlay' failed\n");

	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/controller");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/controller/name");

	unittest(overlay_data_apply("overlay_bad_add_dup_node", शून्य),
		 "Adding overlay 'overlay_bad_add_dup_node' failed\n");

	EXPECT_END(KERN_ERR,
		   "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/controller/name");
	EXPECT_END(KERN_ERR,
		   "OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/controller");

	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/electric");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/rpm_avail");
	EXPECT_BEGIN(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/name");

	unittest(overlay_data_apply("overlay_bad_add_dup_prop", शून्य),
		 "Adding overlay 'overlay_bad_add_dup_prop' failed\n");

	EXPECT_END(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/name");
	EXPECT_END(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add, update, and/or delete property /testcase-data-2/substation@100/motor-1/electric/rpm_avail");
	EXPECT_END(KERN_ERR,
		     "OF: overlay: ERROR: multiple fragments add and/or delete node /testcase-data-2/substation@100/motor-1/electric");

	unittest(overlay_data_apply("overlay_bad_phandle", शून्य),
		 "Adding overlay 'overlay_bad_phandle' failed\n");

	unittest(overlay_data_apply("overlay_bad_symbol", शून्य),
		 "Adding overlay 'overlay_bad_symbol' failed\n");

	वापस;

err_unlock:
	mutex_unlock(&of_mutex);
पूर्ण

#अन्यथा

अटल अंतरभूत __init व्योम of_unittest_overlay_high_level(व्योम) अणुपूर्ण

#पूर्ण_अगर

अटल पूर्णांक __init of_unittest(व्योम)
अणु
	काष्ठा device_node *np;
	पूर्णांक res;

	pr_info("start of unittest - you will see error messages\n");

	/* adding data क्रम unittest */

	अगर (IS_ENABLED(CONFIG_UML))
		unittest_unflatten_overlay_base();

	res = unittest_data_add();
	अगर (res)
		वापस res;
	अगर (!of_aliases)
		of_aliases = of_find_node_by_path("/aliases");

	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
	अगर (!np) अणु
		pr_info("No testcase data in device tree; not running tests\n");
		वापस 0;
	पूर्ण
	of_node_put(np);

	of_unittest_check_tree_linkage();
	of_unittest_check_phandles();
	of_unittest_find_node_by_name();
	of_unittest_dynamic();
	of_unittest_parse_phandle_with_args();
	of_unittest_parse_phandle_with_args_map();
	of_unittest_म_लिखो();
	of_unittest_property_string();
	of_unittest_property_copy();
	of_unittest_changeset();
	of_unittest_parse_पूर्णांकerrupts();
	of_unittest_parse_पूर्णांकerrupts_extended();
	of_unittest_dma_get_max_cpu_address();
	of_unittest_parse_dma_ranges();
	of_unittest_pci_dma_ranges();
	of_unittest_match_node();
	of_unittest_platक्रमm_populate();
	of_unittest_overlay();

	/* Double check linkage after removing testहाल data */
	of_unittest_check_tree_linkage();

	of_unittest_overlay_high_level();

	pr_info("end of unittest - %i passed, %i failed\n",
		unittest_results.passed, unittest_results.failed);

	वापस 0;
पूर्ण
late_initcall(of_unittest);
