<शैली गुरु>
// SPDX-License-Identअगरier: BSD-3-Clause OR GPL-2.0
/*******************************************************************************
 *
 * Module Name: uपंचांगath - Integer math support routines
 *
 ******************************************************************************/

#समावेश <acpi/acpi.h>
#समावेश "accommon.h"

#घोषणा _COMPONENT          ACPI_UTILITIES
ACPI_MODULE_NAME("utmath")

/* Structures used only क्रम 64-bit भागide */
प्रकार काष्ठा uपूर्णांक64_काष्ठा अणु
	u32 lo;
	u32 hi;

पूर्ण uपूर्णांक64_काष्ठा;

प्रकार जोड़ uपूर्णांक64_overlay अणु
	u64 full;
	काष्ठा uपूर्णांक64_काष्ठा part;

पूर्ण uपूर्णांक64_overlay;

/*
 * Optional support क्रम 64-bit द्विगुन-precision पूर्णांकeger multiply and shअगरt.
 * This code is configurable and is implemented in order to support 32-bit
 * kernel environments where a 64-bit द्विगुन-precision math library is not
 * available.
 */
#अगर_अघोषित ACPI_USE_NATIVE_MATH64

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_multiply
 *
 * PARAMETERS:  multiplicand        - 64-bit multiplicand
 *              multiplier          - 32-bit multiplier
 *              out_product         - Poपूर्णांकer to where the product is वापसed
 *
 * DESCRIPTION: Perक्रमm a लघु multiply.
 *
 ******************************************************************************/

acpi_status
acpi_ut_लघु_multiply(u64 multiplicand, u32 multiplier, u64 *out_product)
अणु
	जोड़ uपूर्णांक64_overlay multiplicand_ovl;
	जोड़ uपूर्णांक64_overlay product;
	u32 carry32;

	ACPI_FUNCTION_TRACE(ut_लघु_multiply);

	multiplicand_ovl.full = multiplicand;

	/*
	 * The Product is 64 bits, the carry is always 32 bits,
	 * and is generated by the second multiply.
	 */
	ACPI_MUL_64_BY_32(0, multiplicand_ovl.part.hi, multiplier,
			  product.part.hi, carry32);

	ACPI_MUL_64_BY_32(0, multiplicand_ovl.part.lo, multiplier,
			  product.part.lo, carry32);

	product.part.hi += carry32;

	/* Return only what was requested */

	अगर (out_product) अणु
		*out_product = product.full;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_shअगरt_left
 *
 * PARAMETERS:  opeअक्रम             - 64-bit shअगरt opeअक्रम
 *              count               - 32-bit shअगरt count
 *              out_result          - Poपूर्णांकer to where the result is वापसed
 *
 * DESCRIPTION: Perक्रमm a लघु left shअगरt.
 *
 ******************************************************************************/

acpi_status acpi_ut_लघु_shअगरt_left(u64 opeअक्रम, u32 count, u64 *out_result)
अणु
	जोड़ uपूर्णांक64_overlay opeअक्रम_ovl;

	ACPI_FUNCTION_TRACE(ut_लघु_shअगरt_left);

	opeअक्रम_ovl.full = opeअक्रम;

	अगर ((count & 63) >= 32) अणु
		opeअक्रम_ovl.part.hi = opeअक्रम_ovl.part.lo;
		opeअक्रम_ovl.part.lo = 0;
		count = (count & 63) - 32;
	पूर्ण
	ACPI_SHIFT_LEFT_64_BY_32(opeअक्रम_ovl.part.hi,
				 opeअक्रम_ovl.part.lo, count);

	/* Return only what was requested */

	अगर (out_result) अणु
		*out_result = opeअक्रम_ovl.full;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_shअगरt_right
 *
 * PARAMETERS:  opeअक्रम             - 64-bit shअगरt opeअक्रम
 *              count               - 32-bit shअगरt count
 *              out_result          - Poपूर्णांकer to where the result is वापसed
 *
 * DESCRIPTION: Perक्रमm a लघु right shअगरt.
 *
 ******************************************************************************/

acpi_status acpi_ut_लघु_shअगरt_right(u64 opeअक्रम, u32 count, u64 *out_result)
अणु
	जोड़ uपूर्णांक64_overlay opeअक्रम_ovl;

	ACPI_FUNCTION_TRACE(ut_लघु_shअगरt_right);

	opeअक्रम_ovl.full = opeअक्रम;

	अगर ((count & 63) >= 32) अणु
		opeअक्रम_ovl.part.lo = opeअक्रम_ovl.part.hi;
		opeअक्रम_ovl.part.hi = 0;
		count = (count & 63) - 32;
	पूर्ण
	ACPI_SHIFT_RIGHT_64_BY_32(opeअक्रम_ovl.part.hi,
				  opeअक्रम_ovl.part.lo, count);

	/* Return only what was requested */

	अगर (out_result) अणु
		*out_result = opeअक्रम_ovl.full;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण
#अन्यथा

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_multiply
 *
 * PARAMETERS:  See function headers above
 *
 * DESCRIPTION: Native version of the ut_लघु_multiply function.
 *
 ******************************************************************************/

acpi_status
acpi_ut_लघु_multiply(u64 multiplicand, u32 multiplier, u64 *out_product)
अणु

	ACPI_FUNCTION_TRACE(ut_लघु_multiply);

	/* Return only what was requested */

	अगर (out_product) अणु
		*out_product = multiplicand * multiplier;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_shअगरt_left
 *
 * PARAMETERS:  See function headers above
 *
 * DESCRIPTION: Native version of the ut_लघु_shअगरt_left function.
 *
 ******************************************************************************/

acpi_status acpi_ut_लघु_shअगरt_left(u64 opeअक्रम, u32 count, u64 *out_result)
अणु

	ACPI_FUNCTION_TRACE(ut_लघु_shअगरt_left);

	/* Return only what was requested */

	अगर (out_result) अणु
		*out_result = opeअक्रम << count;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_shअगरt_right
 *
 * PARAMETERS:  See function headers above
 *
 * DESCRIPTION: Native version of the ut_लघु_shअगरt_right function.
 *
 ******************************************************************************/

acpi_status acpi_ut_लघु_shअगरt_right(u64 opeअक्रम, u32 count, u64 *out_result)
अणु

	ACPI_FUNCTION_TRACE(ut_लघु_shअगरt_right);

	/* Return only what was requested */

	अगर (out_result) अणु
		*out_result = opeअक्रम >> count;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण
#पूर्ण_अगर

/*
 * Optional support क्रम 64-bit द्विगुन-precision पूर्णांकeger भागide. This code
 * is configurable and is implemented in order to support 32-bit kernel
 * environments where a 64-bit द्विगुन-precision math library is not available.
 *
 * Support क्रम a more normal 64-bit भागide/modulo (with check क्रम a भागide-
 * by-zero) appears after this optional section of code.
 */
#अगर_अघोषित ACPI_USE_NATIVE_DIVIDE

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_भागide
 *
 * PARAMETERS:  भागidend            - 64-bit भागidend
 *              भागisor             - 32-bit भागisor
 *              out_quotient        - Poपूर्णांकer to where the quotient is वापसed
 *              out_reमुख्यder       - Poपूर्णांकer to where the reमुख्यder is वापसed
 *
 * RETURN:      Status (Checks क्रम भागide-by-zero)
 *
 * DESCRIPTION: Perक्रमm a लघु (maximum 64 bits भागided by 32 bits)
 *              भागide and modulo. The result is a 64-bit quotient and a
 *              32-bit reमुख्यder.
 *
 ******************************************************************************/

acpi_status
acpi_ut_लघु_भागide(u64 भागidend,
		     u32 भागisor, u64 *out_quotient, u32 *out_reमुख्यder)
अणु
	जोड़ uपूर्णांक64_overlay भागidend_ovl;
	जोड़ uपूर्णांक64_overlay quotient;
	u32 reमुख्यder32;

	ACPI_FUNCTION_TRACE(ut_लघु_भागide);

	/* Always check क्रम a zero भागisor */

	अगर (भागisor == 0) अणु
		ACPI_ERROR((AE_INFO, "Divide by zero"));
		वापस_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
	पूर्ण

	भागidend_ovl.full = भागidend;

	/*
	 * The quotient is 64 bits, the reमुख्यder is always 32 bits,
	 * and is generated by the second भागide.
	 */
	ACPI_DIV_64_BY_32(0, भागidend_ovl.part.hi, भागisor,
			  quotient.part.hi, reमुख्यder32);

	ACPI_DIV_64_BY_32(reमुख्यder32, भागidend_ovl.part.lo, भागisor,
			  quotient.part.lo, reमुख्यder32);

	/* Return only what was requested */

	अगर (out_quotient) अणु
		*out_quotient = quotient.full;
	पूर्ण
	अगर (out_reमुख्यder) अणु
		*out_reमुख्यder = reमुख्यder32;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_भागide
 *
 * PARAMETERS:  in_भागidend         - Dividend
 *              in_भागisor          - Divisor
 *              out_quotient        - Poपूर्णांकer to where the quotient is वापसed
 *              out_reमुख्यder       - Poपूर्णांकer to where the reमुख्यder is वापसed
 *
 * RETURN:      Status (Checks क्रम भागide-by-zero)
 *
 * DESCRIPTION: Perक्रमm a भागide and modulo.
 *
 ******************************************************************************/

acpi_status
acpi_ut_भागide(u64 in_भागidend,
	       u64 in_भागisor, u64 *out_quotient, u64 *out_reमुख्यder)
अणु
	जोड़ uपूर्णांक64_overlay भागidend;
	जोड़ uपूर्णांक64_overlay भागisor;
	जोड़ uपूर्णांक64_overlay quotient;
	जोड़ uपूर्णांक64_overlay reमुख्यder;
	जोड़ uपूर्णांक64_overlay normalized_भागidend;
	जोड़ uपूर्णांक64_overlay normalized_भागisor;
	u32 partial1;
	जोड़ uपूर्णांक64_overlay partial2;
	जोड़ uपूर्णांक64_overlay partial3;

	ACPI_FUNCTION_TRACE(ut_भागide);

	/* Always check क्रम a zero भागisor */

	अगर (in_भागisor == 0) अणु
		ACPI_ERROR((AE_INFO, "Divide by zero"));
		वापस_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
	पूर्ण

	भागisor.full = in_भागisor;
	भागidend.full = in_भागidend;
	अगर (भागisor.part.hi == 0) अणु
		/*
		 * 1) Simplest हाल is where the भागisor is 32 bits, we can
		 * just करो two भागides
		 */
		reमुख्यder.part.hi = 0;

		/*
		 * The quotient is 64 bits, the reमुख्यder is always 32 bits,
		 * and is generated by the second भागide.
		 */
		ACPI_DIV_64_BY_32(0, भागidend.part.hi, भागisor.part.lo,
				  quotient.part.hi, partial1);

		ACPI_DIV_64_BY_32(partial1, भागidend.part.lo, भागisor.part.lo,
				  quotient.part.lo, reमुख्यder.part.lo);
	पूर्ण

	अन्यथा अणु
		/*
		 * 2) The general हाल where the भागisor is a full 64 bits
		 * is more dअगरficult
		 */
		quotient.part.hi = 0;
		normalized_भागidend = भागidend;
		normalized_भागisor = भागisor;

		/* Normalize the opeअक्रमs (shअगरt until the भागisor is < 32 bits) */

		करो अणु
			ACPI_SHIFT_RIGHT_64(normalized_भागisor.part.hi,
					    normalized_भागisor.part.lo);
			ACPI_SHIFT_RIGHT_64(normalized_भागidend.part.hi,
					    normalized_भागidend.part.lo);

		पूर्ण जबतक (normalized_भागisor.part.hi != 0);

		/* Partial भागide */

		ACPI_DIV_64_BY_32(normalized_भागidend.part.hi,
				  normalized_भागidend.part.lo,
				  normalized_भागisor.part.lo, quotient.part.lo,
				  partial1);

		/*
		 * The quotient is always 32 bits, and simply requires
		 * adjusपंचांगent. The 64-bit reमुख्यder must be generated.
		 */
		partial1 = quotient.part.lo * भागisor.part.hi;
		partial2.full = (u64) quotient.part.lo * भागisor.part.lo;
		partial3.full = (u64) partial2.part.hi + partial1;

		reमुख्यder.part.hi = partial3.part.lo;
		reमुख्यder.part.lo = partial2.part.lo;

		अगर (partial3.part.hi == 0) अणु
			अगर (partial3.part.lo >= भागidend.part.hi) अणु
				अगर (partial3.part.lo == भागidend.part.hi) अणु
					अगर (partial2.part.lo > भागidend.part.lo) अणु
						quotient.part.lo--;
						reमुख्यder.full -= भागisor.full;
					पूर्ण
				पूर्ण अन्यथा अणु
					quotient.part.lo--;
					reमुख्यder.full -= भागisor.full;
				पूर्ण
			पूर्ण

			reमुख्यder.full = reमुख्यder.full - भागidend.full;
			reमुख्यder.part.hi = (u32)-((s32)reमुख्यder.part.hi);
			reमुख्यder.part.lo = (u32)-((s32)reमुख्यder.part.lo);

			अगर (reमुख्यder.part.lo) अणु
				reमुख्यder.part.hi--;
			पूर्ण
		पूर्ण
	पूर्ण

	/* Return only what was requested */

	अगर (out_quotient) अणु
		*out_quotient = quotient.full;
	पूर्ण
	अगर (out_reमुख्यder) अणु
		*out_reमुख्यder = reमुख्यder.full;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

#अन्यथा

/*******************************************************************************
 *
 * FUNCTION:    acpi_ut_लघु_भागide, acpi_ut_भागide
 *
 * PARAMETERS:  See function headers above
 *
 * DESCRIPTION: Native versions of the ut_भागide functions. Use these अगर either
 *              1) The target is a 64-bit platक्रमm and thereक्रमe 64-bit
 *                 पूर्णांकeger math is supported directly by the machine.
 *              2) The target is a 32-bit or 16-bit platक्रमm, and the
 *                 द्विगुन-precision पूर्णांकeger math library is available to
 *                 perक्रमm the भागide.
 *
 ******************************************************************************/

acpi_status
acpi_ut_लघु_भागide(u64 in_भागidend,
		     u32 भागisor, u64 *out_quotient, u32 *out_reमुख्यder)
अणु

	ACPI_FUNCTION_TRACE(ut_लघु_भागide);

	/* Always check क्रम a zero भागisor */

	अगर (भागisor == 0) अणु
		ACPI_ERROR((AE_INFO, "Divide by zero"));
		वापस_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
	पूर्ण

	/* Return only what was requested */

	अगर (out_quotient) अणु
		*out_quotient = in_भागidend / भागisor;
	पूर्ण
	अगर (out_reमुख्यder) अणु
		*out_reमुख्यder = (u32) (in_भागidend % भागisor);
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

acpi_status
acpi_ut_भागide(u64 in_भागidend,
	       u64 in_भागisor, u64 *out_quotient, u64 *out_reमुख्यder)
अणु
	ACPI_FUNCTION_TRACE(ut_भागide);

	/* Always check क्रम a zero भागisor */

	अगर (in_भागisor == 0) अणु
		ACPI_ERROR((AE_INFO, "Divide by zero"));
		वापस_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);
	पूर्ण

	/* Return only what was requested */

	अगर (out_quotient) अणु
		*out_quotient = in_भागidend / in_भागisor;
	पूर्ण
	अगर (out_reमुख्यder) अणु
		*out_reमुख्यder = in_भागidend % in_भागisor;
	पूर्ण

	वापस_ACPI_STATUS(AE_OK);
पूर्ण

#पूर्ण_अगर
