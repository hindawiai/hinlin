<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*
 *		sonix sn9c102 (bayer) library
 *
 * Copyright (C) 2009-2011 Jean-Franथईois Moine <http://moinejf.मुक्त.fr>
 * Copyright (C) 2003 2004 Michel Xhaard mxhaard@magic.fr
 * Add Pas106 Stefano Mozzi (C) 2004
 */

/* Some करोcumentation on known sonixb रेजिस्टरs:

Reg	Use
sn9c101 / sn9c102:
0x10	high nibble red gain low nibble blue gain
0x11	low nibble green gain
sn9c103:
0x05	red gain 0-127
0x06	blue gain 0-127
0x07	green gain 0-127
all:
0x08-0x0f i2c / 3wire रेजिस्टरs
0x12	hstart
0x13	vstart
0x15	hsize (hsize = रेजिस्टर-value * 16)
0x16	vsize (vsize = रेजिस्टर-value * 16)
0x17	bit 0 toggle compression quality (according to sn9c102 driver)
0x18	bit 7 enables compression, bit 4-5 set image करोwn scaling:
	00 scale 1, 01 scale 1/2, 10, scale 1/4
0x19	high-nibble is sensor घड़ी भागider, changes exposure on sensors which
	use a घड़ी generated by the bridge. Some sensors have their own घड़ी.
0x1c	स्वतः_exposure area (क्रम avg_lum) startx (startx = रेजिस्टर-value * 32)
0x1d	स्वतः_exposure area (क्रम avg_lum) starty (starty = रेजिस्टर-value * 32)
0x1e	स्वतः_exposure area (क्रम avg_lum) stopx (hsize = (0x1e - 0x1c) * 32)
0x1f	स्वतः_exposure area (क्रम avg_lum) stopy (vsize = (0x1f - 0x1d) * 32)
*/

#घोषणा MODULE_NAME "sonixb"

#समावेश <linux/input.h>
#समावेश "gspca.h"

MODULE_AUTHOR("Jean-Franथईois Moine <http://moinejf.free.fr>");
MODULE_DESCRIPTION("GSPCA/SN9C102 USB Camera Driver");
MODULE_LICENSE("GPL");

/* specअगरic webcam descriptor */
काष्ठा sd अणु
	काष्ठा gspca_dev gspca_dev;	/* !! must be the first item */

	काष्ठा v4l2_ctrl *brightness;
	काष्ठा v4l2_ctrl *plfreq;

	atomic_t avg_lum;
	पूर्णांक prev_avg_lum;
	पूर्णांक exposure_knee;
	पूर्णांक header_पढ़ो;
	u8 header[12]; /* Header without sof marker */

	अचिन्हित अक्षर स्वतःgain_ignore_frames;
	अचिन्हित अक्षर frames_to_drop;

	__u8 bridge;			/* Type of bridge */
#घोषणा BRIDGE_101 0
#घोषणा BRIDGE_102 0 /* We make no dअगरference between 101 and 102 */
#घोषणा BRIDGE_103 1

	__u8 sensor;			/* Type of image sensor chip */
#घोषणा SENSOR_HV7131D 0
#घोषणा SENSOR_HV7131R 1
#घोषणा SENSOR_OV6650 2
#घोषणा SENSOR_OV7630 3
#घोषणा SENSOR_PAS106 4
#घोषणा SENSOR_PAS202 5
#घोषणा SENSOR_TAS5110C 6
#घोषणा SENSOR_TAS5110D 7
#घोषणा SENSOR_TAS5130CXX 8
	__u8 reg11;
पूर्ण;

प्रकार स्थिर __u8 sensor_init_t[8];

काष्ठा sensor_data अणु
	स्थिर __u8 *bridge_init;
	sensor_init_t *sensor_init;
	पूर्णांक sensor_init_size;
	पूर्णांक flags;
	__u8 sensor_addr;
पूर्ण;

/* sensor_data flags */
#घोषणा F_SIF		0x01	/* sअगर or vga */

/* priv field of काष्ठा v4l2_pix_क्रमmat flags (करो not use low nibble!) */
#घोषणा MODE_RAW 0x10		/* raw bayer mode */
#घोषणा MODE_REDUCED_SIF 0x20	/* vga mode (320x240 / 160x120) on sअगर cam */

#घोषणा COMP 0xc7		/* 0x87 //0x07 */
#घोषणा COMP1 0xc9		/* 0x89 //0x09 */

#घोषणा MCK_INIT 0x63
#घोषणा MCK_INIT1 0x20		/*fixme: Bayer - 0x50 क्रम JPEG ??*/

#घोषणा SYS_CLK 0x04

#घोषणा SENS(bridge, sensor, _flags, _sensor_addr) \
अणु \
	.bridge_init = bridge, \
	.sensor_init = sensor, \
	.sensor_init_size = माप(sensor), \
	.flags = _flags, .sensor_addr = _sensor_addr \
पूर्ण

/* We calculate the स्वतःgain at the end of the transfer of a frame, at this
   moment a frame with the old settings is being captured and transmitted. So
   अगर we adjust the gain or exposure we must ignore at least the next frame क्रम
   the new settings to come पूर्णांकo effect beक्रमe करोing any other adjusपंचांगents. */
#घोषणा AUTOGAIN_IGNORE_FRAMES 1

अटल स्थिर काष्ठा v4l2_pix_क्रमmat vga_mode[] = अणु
	अणु160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
		.bytesperline = 160,
		.sizeimage = 160 * 120,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 2 | MODE_RAWपूर्ण,
	अणु160, 120, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 160,
		.sizeimage = 160 * 120 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 2पूर्ण,
	अणु320, 240, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 320,
		.sizeimage = 320 * 240 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 1पूर्ण,
	अणु640, 480, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 640,
		.sizeimage = 640 * 480 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 0पूर्ण,
पूर्ण;
अटल स्थिर काष्ठा v4l2_pix_क्रमmat sअगर_mode[] = अणु
	अणु160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
		.bytesperline = 160,
		.sizeimage = 160 * 120,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 1 | MODE_RAW | MODE_REDUCED_SIFपूर्ण,
	अणु160, 120, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 160,
		.sizeimage = 160 * 120 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 1 | MODE_REDUCED_SIFपूर्ण,
	अणु176, 144, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,
		.bytesperline = 176,
		.sizeimage = 176 * 144,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 1 | MODE_RAWपूर्ण,
	अणु176, 144, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 176,
		.sizeimage = 176 * 144 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 1पूर्ण,
	अणु320, 240, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 320,
		.sizeimage = 320 * 240 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 0 | MODE_REDUCED_SIFपूर्ण,
	अणु352, 288, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,
		.bytesperline = 352,
		.sizeimage = 352 * 288 * 5 / 4,
		.colorspace = V4L2_COLORSPACE_SRGB,
		.priv = 0पूर्ण,
पूर्ण;

अटल स्थिर __u8 initHv7131d[] = अणु
	0x04, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x00,
	0x28, 0x1e, 0x60, 0x8e, 0x42,
पूर्ण;
अटल स्थिर __u8 hv7131d_sensor_init[][8] = अणु
	अणु0xa0, 0x11, 0x01, 0x04, 0x00, 0x00, 0x00, 0x17पूर्ण,
	अणु0xa0, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x17पूर्ण,
	अणु0xa0, 0x11, 0x28, 0x00, 0x00, 0x00, 0x00, 0x17पूर्ण,
	अणु0xa0, 0x11, 0x30, 0x30, 0x00, 0x00, 0x00, 0x17पूर्ण, /* reset level */
	अणु0xa0, 0x11, 0x34, 0x02, 0x00, 0x00, 0x00, 0x17पूर्ण, /* pixel bias volt */
पूर्ण;

अटल स्थिर __u8 initHv7131r[] = अणु
	0x46, 0x77, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x01, 0x00,
	0x28, 0x1e, 0x60, 0x8a, 0x20,
पूर्ण;
अटल स्थिर __u8 hv7131r_sensor_init[][8] = अणु
	अणु0xc0, 0x11, 0x31, 0x38, 0x2a, 0x2e, 0x00, 0x10पूर्ण,
	अणु0xa0, 0x11, 0x01, 0x08, 0x2a, 0x2e, 0x00, 0x10पूर्ण,
	अणु0xb0, 0x11, 0x20, 0x00, 0xd0, 0x2e, 0x00, 0x10पूर्ण,
	अणु0xc0, 0x11, 0x25, 0x03, 0x0e, 0x28, 0x00, 0x16पूर्ण,
	अणु0xa0, 0x11, 0x30, 0x10, 0x0e, 0x28, 0x00, 0x15पूर्ण,
पूर्ण;
अटल स्थिर __u8 initOv6650[] = अणु
	0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x0a, 0x16, 0x12, 0x68, 0x8b,
	0x10,
पूर्ण;
अटल स्थिर __u8 ov6650_sensor_init[][8] = अणु
	/* Bright, contrast, etc are set through SCBB पूर्णांकerface.
	 * AVCAP on win2 करो not send any data on this controls. */
	/* Anyway, some रेजिस्टरs appears to alter bright and स्थिरrat */

	/* Reset sensor */
	अणु0xa0, 0x60, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10पूर्ण,
	/* Set घड़ी रेजिस्टर 0x11 low nibble is घड़ी भागider */
	अणु0xd0, 0x60, 0x11, 0xc0, 0x1b, 0x18, 0xc1, 0x10पूर्ण,
	/* Next some unknown stuff */
	अणु0xb0, 0x60, 0x15, 0x00, 0x02, 0x18, 0xc1, 0x10पूर्ण,
/*	अणु0xa0, 0x60, 0x1b, 0x01, 0x02, 0x18, 0xc1, 0x10पूर्ण,
		 * THIS SET GREEN SCREEN
		 * (pixels could be innverted in decode kind of "brg",
		 * but blue wont be there. Aव्योम this data ... */
	अणु0xd0, 0x60, 0x26, 0x01, 0x14, 0xd8, 0xa4, 0x10पूर्ण, /* क्रमmat out? */
	अणु0xd0, 0x60, 0x26, 0x01, 0x14, 0xd8, 0xa4, 0x10पूर्ण,
	अणु0xa0, 0x60, 0x30, 0x3d, 0x0a, 0xd8, 0xa4, 0x10पूर्ण,
	/* Enable rgb brightness control */
	अणु0xa0, 0x60, 0x61, 0x08, 0x00, 0x00, 0x00, 0x10पूर्ण,
	/* HDG: Note winकरोws uses the line below, which sets both रेजिस्टर 0x60
	   and 0x61 I believe these रेजिस्टरs of the ov6650 are identical as
	   those of the ov7630, because अगर this is true the winकरोws settings
	   add a bit additional red gain and a lot additional blue gain, which
	   matches my findings that the winकरोws settings make blue much too
	   blue and red a little too red.
	अणु0xb0, 0x60, 0x60, 0x66, 0x68, 0xd8, 0xa4, 0x10पूर्ण, */
	/* Some more unknown stuff */
	अणु0xa0, 0x60, 0x68, 0x04, 0x68, 0xd8, 0xa4, 0x10पूर्ण,
	अणु0xd0, 0x60, 0x17, 0x24, 0xd6, 0x04, 0x94, 0x10पूर्ण, /* Clipreg */
पूर्ण;

अटल स्थिर __u8 initOv7630[] = अणु
	0x04, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,	/* r01 .. r08 */
	0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* r09 .. r10 */
	0x00, 0x01, 0x01, 0x0a,				/* r11 .. r14 */
	0x28, 0x1e,			/* H & V sizes     r15 .. r16 */
	0x68, 0x8f, MCK_INIT1,				/* r17 .. r19 */
पूर्ण;
अटल स्थिर __u8 ov7630_sensor_init[][8] = अणु
	अणु0xa0, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10पूर्ण,
	अणु0xb0, 0x21, 0x01, 0x77, 0x3a, 0x00, 0x00, 0x10पूर्ण,
/*	अणु0xd0, 0x21, 0x12, 0x7c, 0x01, 0x80, 0x34, 0x10पूर्ण,	   jfm */
	अणु0xd0, 0x21, 0x12, 0x5c, 0x00, 0x80, 0x34, 0x10पूर्ण,	/* jfm */
	अणु0xa0, 0x21, 0x1b, 0x04, 0x00, 0x80, 0x34, 0x10पूर्ण,
	अणु0xa0, 0x21, 0x20, 0x44, 0x00, 0x80, 0x34, 0x10पूर्ण,
	अणु0xa0, 0x21, 0x23, 0xee, 0x00, 0x80, 0x34, 0x10पूर्ण,
	अणु0xd0, 0x21, 0x26, 0xa0, 0x9a, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xb0, 0x21, 0x2a, 0x80, 0x00, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xb0, 0x21, 0x2f, 0x3d, 0x24, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xa0, 0x21, 0x32, 0x86, 0x24, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xb0, 0x21, 0x60, 0xa9, 0x4a, 0xa0, 0x30, 0x10पूर्ण,
/*	अणु0xb0, 0x21, 0x60, 0xa9, 0x42, 0xa0, 0x30, 0x10पूर्ण,	 * jfm */
	अणु0xa0, 0x21, 0x65, 0x00, 0x42, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xa0, 0x21, 0x69, 0x38, 0x42, 0xa0, 0x30, 0x10पूर्ण,
	अणु0xc0, 0x21, 0x6f, 0x88, 0x0b, 0x00, 0x30, 0x10पूर्ण,
	अणु0xc0, 0x21, 0x74, 0x21, 0x8e, 0x00, 0x30, 0x10पूर्ण,
	अणु0xa0, 0x21, 0x7d, 0xf7, 0x8e, 0x00, 0x30, 0x10पूर्ण,
	अणु0xd0, 0x21, 0x17, 0x1c, 0xbd, 0x06, 0xf6, 0x10पूर्ण,
पूर्ण;

अटल स्थिर __u8 initPas106[] = अणु
	0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x01, 0x00,
	0x16, 0x12, 0x24, COMP1, MCK_INIT1,
पूर्ण;
/* compression 0x86 mckinit1 0x2b */

/* "Known" PAS106B रेजिस्टरs:
  0x02 घड़ी भागider
  0x03 Variable framerate bits 4-11
  0x04 Var framerate bits 0-3, one must leave the 4 msb's at 0 !!
       The variable framerate control must never be set lower then 300,
       which sets the framerate at 90 / reg02, otherwise vsync is lost.
  0x05 Shutter Time Line Offset, this can be used as an exposure control:
       0 = use full frame समय, 255 = no exposure at all
       Note this may never be larger then "var-framerate control" / 2 - 2.
       When var-framerate control is < 514, no exposure is reached at the max
       allowed value क्रम the framerate control value, rather then at 255.
  0x06 Shutter Time Pixel Offset, like reg05 this influences exposure, but
       only a very little bit, leave at 0xcd
  0x07 offset sign bit (bit0 1 > negative offset)
  0x08 offset
  0x09 Blue Gain
  0x0a Green1 Gain
  0x0b Green2 Gain
  0x0c Red Gain
  0x0e Global gain
  0x13 Write 1 to commit settings to sensor
*/

अटल स्थिर __u8 pas106_sensor_init[][8] = अणु
	/* Pixel Clock Divider 6 */
	अणु 0xa1, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Frame Time MSB (also seen as 0x12) */
	अणु 0xa1, 0x40, 0x03, 0x13, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Frame Time LSB (also seen as 0x05) */
	अणु 0xa1, 0x40, 0x04, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Shutter Time Line Offset (also seen as 0x6d) */
	अणु 0xa1, 0x40, 0x05, 0x65, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Shutter Time Pixel Offset (also seen as 0xb1) */
	अणु 0xa1, 0x40, 0x06, 0xcd, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Black Level Subtract Sign (also seen 0x00) */
	अणु 0xa1, 0x40, 0x07, 0xc1, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Black Level Subtract Level (also seen 0x01) */
	अणु 0xa1, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	अणु 0xa1, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Color Gain B Pixel 5 a */
	अणु 0xa1, 0x40, 0x09, 0x05, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Color Gain G1 Pixel 1 5 */
	अणु 0xa1, 0x40, 0x0a, 0x04, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Color Gain G2 Pixel 1 0 5 */
	अणु 0xa1, 0x40, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Color Gain R Pixel 3 1 */
	अणु 0xa1, 0x40, 0x0c, 0x05, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Color GainH  Pixel */
	अणु 0xa1, 0x40, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Global Gain */
	अणु 0xa1, 0x40, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Contrast */
	अणु 0xa1, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* H&V synchro polarity */
	अणु 0xa1, 0x40, 0x10, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* ?शेष */
	अणु 0xa1, 0x40, 0x11, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* DAC scale */
	अणु 0xa1, 0x40, 0x12, 0x06, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* ?शेष */
	अणु 0xa1, 0x40, 0x14, 0x02, 0x00, 0x00, 0x00, 0x14 पूर्ण,
	/* Validate Settings */
	अणु 0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14 पूर्ण,
पूर्ण;

अटल स्थिर __u8 initPas202[] = अणु
	0x44, 0x44, 0x21, 0x30, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x06, 0x03, 0x0a,
	0x28, 0x1e, 0x20, 0x89, 0x20,
पूर्ण;

/* "Known" PAS202BCB रेजिस्टरs:
  0x02 घड़ी भागider
  0x04 Variable framerate bits 6-11 (*)
  0x05 Var framerate  bits 0-5, one must leave the 2 msb's at 0 !!
  0x07 Blue Gain
  0x08 Green Gain
  0x09 Red Gain
  0x0b offset sign bit (bit0 1 > negative offset)
  0x0c offset
  0x0e Unknown image is slightly brighter when bit 0 is 0, अगर reg0f is 0 too,
       leave at 1 otherwise we get a jump in our exposure control
  0x0f Exposure 0-255, 0 = use full frame समय, 255 = no exposure at all
  0x10 Master gain 0 - 31
  0x11 ग_लिखो 1 to apply changes
  (*) The variable framerate control must never be set lower then 500
      which sets the framerate at 30 / reg02, otherwise vsync is lost.
*/
अटल स्थिर __u8 pas202_sensor_init[][8] = अणु
	/* Set the घड़ी भागider to 4 -> 30 / 4 = 7.5 fps, we would like
	   to set it lower, but क्रम some reason the bridge starts missing
	   vsync's then */
	अणु0xa0, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x10पूर्ण,
	अणु0xd0, 0x40, 0x04, 0x07, 0x34, 0x00, 0x09, 0x10पूर्ण,
	अणु0xd0, 0x40, 0x08, 0x01, 0x00, 0x00, 0x01, 0x10पूर्ण,
	अणु0xd0, 0x40, 0x0c, 0x00, 0x0c, 0x01, 0x32, 0x10पूर्ण,
	अणु0xd0, 0x40, 0x10, 0x00, 0x01, 0x00, 0x63, 0x10पूर्ण,
	अणु0xa0, 0x40, 0x15, 0x70, 0x01, 0x00, 0x63, 0x10पूर्ण,
	अणु0xa0, 0x40, 0x18, 0x00, 0x01, 0x00, 0x63, 0x10पूर्ण,
	अणु0xa0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10पूर्ण,
	अणु0xa0, 0x40, 0x03, 0x56, 0x01, 0x00, 0x63, 0x10पूर्ण,
	अणु0xa0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10पूर्ण,
पूर्ण;

अटल स्थिर __u8 initTas5110c[] = अणु
	0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x45, 0x09, 0x0a,
	0x16, 0x12, 0x60, 0x86, 0x2b,
पूर्ण;
/* Same as above, except a dअगरferent hstart */
अटल स्थिर __u8 initTas5110d[] = अणु
	0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x41, 0x09, 0x0a,
	0x16, 0x12, 0x60, 0x86, 0x2b,
पूर्ण;
/* tas5110c is 3 wire, tas5110d is 2 wire (regular i2c) */
अटल स्थिर __u8 tas5110c_sensor_init[][8] = अणु
	अणु0x30, 0x11, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x10पूर्ण,
	अणु0x30, 0x11, 0x02, 0x20, 0xa9, 0x00, 0x00, 0x10पूर्ण,
पूर्ण;
/* Known TAS5110D रेजिस्टरs
 * reg02: gain, bit order reversed!! 0 == max gain, 255 == min gain
 * reg03: bit3: vflip, bit4: ~hflip, bit7: ~gainboost (~ == inverted)
 *        Note: writing reg03 seems to only work when written together with 02
 */
अटल स्थिर __u8 tas5110d_sensor_init[][8] = अणु
	अणु0xa0, 0x61, 0x9a, 0xca, 0x00, 0x00, 0x00, 0x17पूर्ण, /* reset */
पूर्ण;

अटल स्थिर __u8 initTas5130[] = अणु
	0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00,
	0x00, 0x00, 0x00, 0x68, 0x0c, 0x0a,
	0x28, 0x1e, 0x60, COMP, MCK_INIT,
पूर्ण;
अटल स्थिर __u8 tas5130_sensor_init[][8] = अणु
/*	अणु0x30, 0x11, 0x00, 0x40, 0x47, 0x00, 0x00, 0x10पूर्ण,
					* shutter 0x47 लघु exposure? */
	अणु0x30, 0x11, 0x00, 0x40, 0x01, 0x00, 0x00, 0x10पूर्ण,
					/* shutter 0x01 दीर्घ exposure */
	अणु0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10पूर्ण,
पूर्ण;

अटल स्थिर काष्ठा sensor_data sensor_data[] = अणु
	SENS(initHv7131d, hv7131d_sensor_init, 0, 0),
	SENS(initHv7131r, hv7131r_sensor_init, 0, 0),
	SENS(initOv6650, ov6650_sensor_init, F_SIF, 0x60),
	SENS(initOv7630, ov7630_sensor_init, 0, 0x21),
	SENS(initPas106, pas106_sensor_init, F_SIF, 0),
	SENS(initPas202, pas202_sensor_init, 0, 0),
	SENS(initTas5110c, tas5110c_sensor_init, F_SIF, 0),
	SENS(initTas5110d, tas5110d_sensor_init, F_SIF, 0),
	SENS(initTas5130, tas5130_sensor_init, 0, 0),
पूर्ण;

/* get one byte in gspca_dev->usb_buf */
अटल व्योम reg_r(काष्ठा gspca_dev *gspca_dev,
		  __u16 value)
अणु
	पूर्णांक res;

	अगर (gspca_dev->usb_err < 0)
		वापस;

	res = usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			0,			/* request */
			USB_सूची_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,
			value,
			0,			/* index */
			gspca_dev->usb_buf, 1,
			500);

	अगर (res < 0) अणु
		dev_err(gspca_dev->v4l2_dev.dev,
			"Error reading register %02x: %d\n", value, res);
		gspca_dev->usb_err = res;
		/*
		 * Make sure the result is zeroed to aव्योम uninitialized
		 * values.
		 */
		gspca_dev->usb_buf[0] = 0;
	पूर्ण
पूर्ण

अटल व्योम reg_w(काष्ठा gspca_dev *gspca_dev,
		  __u16 value,
		  स्थिर __u8 *buffer,
		  पूर्णांक len)
अणु
	पूर्णांक res;

	अगर (gspca_dev->usb_err < 0)
		वापस;

	स_नकल(gspca_dev->usb_buf, buffer, len);
	res = usb_control_msg(gspca_dev->dev,
			usb_sndctrlpipe(gspca_dev->dev, 0),
			0x08,			/* request */
			USB_सूची_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,
			value,
			0,			/* index */
			gspca_dev->usb_buf, len,
			500);

	अगर (res < 0) अणु
		dev_err(gspca_dev->v4l2_dev.dev,
			"Error writing register %02x: %d\n", value, res);
		gspca_dev->usb_err = res;
	पूर्ण
पूर्ण

अटल व्योम i2c_w(काष्ठा gspca_dev *gspca_dev, स्थिर u8 *buf)
अणु
	पूर्णांक retry = 60;

	अगर (gspca_dev->usb_err < 0)
		वापस;

	/* is i2c पढ़ोy */
	reg_w(gspca_dev, 0x08, buf, 8);
	जबतक (retry--) अणु
		अगर (gspca_dev->usb_err < 0)
			वापस;
		msleep(1);
		reg_r(gspca_dev, 0x08);
		अगर (gspca_dev->usb_buf[0] & 0x04) अणु
			अगर (gspca_dev->usb_buf[0] & 0x08) अणु
				dev_err(gspca_dev->v4l2_dev.dev,
					"i2c error writing %8ph\n", buf);
				gspca_dev->usb_err = -EIO;
			पूर्ण
			वापस;
		पूर्ण
	पूर्ण

	dev_err(gspca_dev->v4l2_dev.dev, "i2c write timeout\n");
	gspca_dev->usb_err = -EIO;
पूर्ण

अटल व्योम i2c_w_vector(काष्ठा gspca_dev *gspca_dev,
			स्थिर __u8 buffer[][8], पूर्णांक len)
अणु
	क्रम (;;) अणु
		अगर (gspca_dev->usb_err < 0)
			वापस;
		i2c_w(gspca_dev, *buffer);
		len -= 8;
		अगर (len <= 0)
			अवरोध;
		buffer++;
	पूर्ण
पूर्ण

अटल व्योम setbrightness(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;

	चयन (sd->sensor) अणु
	हाल  SENSOR_OV6650:
	हाल  SENSOR_OV7630: अणु
		__u8 i2cOV[] =
			अणु0xa0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x10पूर्ण;

		/* change reg 0x06 */
		i2cOV[1] = sensor_data[sd->sensor].sensor_addr;
		i2cOV[3] = sd->brightness->val;
		i2c_w(gspca_dev, i2cOV);
		अवरोध;
	पूर्ण
	हाल SENSOR_PAS106:
	हाल SENSOR_PAS202: अणु
		__u8 i2cpbright[] =
			अणु0xb0, 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x16पूर्ण;
		__u8 i2cpकरोit[] =
			अणु0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16पूर्ण;

		/* PAS106 uses reg 7 and 8 instead of b and c */
		अगर (sd->sensor == SENSOR_PAS106) अणु
			i2cpbright[2] = 7;
			i2cpकरोit[2] = 0x13;
		पूर्ण

		अगर (sd->brightness->val < 127) अणु
			/* change reg 0x0b, signreg */
			i2cpbright[3] = 0x01;
			/* set reg 0x0c, offset */
			i2cpbright[4] = 127 - sd->brightness->val;
		पूर्ण अन्यथा
			i2cpbright[4] = sd->brightness->val - 127;

		i2c_w(gspca_dev, i2cpbright);
		i2c_w(gspca_dev, i2cpकरोit);
		अवरोध;
	पूर्ण
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल व्योम setgain(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	u8 gain = gspca_dev->gain->val;

	चयन (sd->sensor) अणु
	हाल SENSOR_HV7131D: अणु
		__u8 i2c[] =
			अणु0xc0, 0x11, 0x31, 0x00, 0x00, 0x00, 0x00, 0x17पूर्ण;

		i2c[3] = 0x3f - gain;
		i2c[4] = 0x3f - gain;
		i2c[5] = 0x3f - gain;

		i2c_w(gspca_dev, i2c);
		अवरोध;
	पूर्ण
	हाल SENSOR_TAS5110C:
	हाल SENSOR_TAS5130CXX: अणु
		__u8 i2c[] =
			अणु0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10पूर्ण;

		i2c[4] = 255 - gain;
		i2c_w(gspca_dev, i2c);
		अवरोध;
	पूर्ण
	हाल SENSOR_TAS5110D: अणु
		__u8 i2c[] = अणु
			0xb0, 0x61, 0x02, 0x00, 0x10, 0x00, 0x00, 0x17 पूर्ण;
		gain = 255 - gain;
		/* The bits in the रेजिस्टर are the wrong way around!! */
		i2c[3] |= (gain & 0x80) >> 7;
		i2c[3] |= (gain & 0x40) >> 5;
		i2c[3] |= (gain & 0x20) >> 3;
		i2c[3] |= (gain & 0x10) >> 1;
		i2c[3] |= (gain & 0x08) << 1;
		i2c[3] |= (gain & 0x04) << 3;
		i2c[3] |= (gain & 0x02) << 5;
		i2c[3] |= (gain & 0x01) << 7;
		i2c_w(gspca_dev, i2c);
		अवरोध;
	पूर्ण
	हाल SENSOR_OV6650:
	हाल SENSOR_OV7630: अणु
		__u8 i2c[] = अणु0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10पूर्ण;

		/*
		 * The ov7630's gain is weird, at 32 the gain drops to the
		 * same level as at 16, so skip 32-47 (of the 0-63 scale).
		 */
		अगर (sd->sensor == SENSOR_OV7630 && gain >= 32)
			gain += 16;

		i2c[1] = sensor_data[sd->sensor].sensor_addr;
		i2c[3] = gain;
		i2c_w(gspca_dev, i2c);
		अवरोध;
	पूर्ण
	हाल SENSOR_PAS106:
	हाल SENSOR_PAS202: अणु
		__u8 i2cpgain[] =
			अणु0xa0, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x15पूर्ण;
		__u8 i2cpcolorgain[] =
			अणु0xc0, 0x40, 0x07, 0x00, 0x00, 0x00, 0x00, 0x15पूर्ण;
		__u8 i2cpकरोit[] =
			अणु0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16पूर्ण;

		/* PAS106 uses dअगरferent regs (and has split green gains) */
		अगर (sd->sensor == SENSOR_PAS106) अणु
			i2cpgain[2] = 0x0e;
			i2cpcolorgain[0] = 0xd0;
			i2cpcolorgain[2] = 0x09;
			i2cpकरोit[2] = 0x13;
		पूर्ण

		i2cpgain[3] = gain;
		i2cpcolorgain[3] = gain >> 1;
		i2cpcolorgain[4] = gain >> 1;
		i2cpcolorgain[5] = gain >> 1;
		i2cpcolorgain[6] = gain >> 1;

		i2c_w(gspca_dev, i2cpgain);
		i2c_w(gspca_dev, i2cpcolorgain);
		i2c_w(gspca_dev, i2cpकरोit);
		अवरोध;
	पूर्ण
	शेष:
		अगर (sd->bridge == BRIDGE_103) अणु
			u8 buf[3] = अणु gain, gain, gain पूर्ण; /* R, G, B */
			reg_w(gspca_dev, 0x05, buf, 3);
		पूर्ण अन्यथा अणु
			u8 buf[2];
			buf[0] = gain << 4 | gain; /* Red and blue */
			buf[1] = gain; /* Green */
			reg_w(gspca_dev, 0x10, buf, 2);
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम setexposure(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;

	चयन (sd->sensor) अणु
	हाल SENSOR_HV7131D: अणु
		/* Note the datasheet wrongly says line mode exposure uses reg
		   0x26 and 0x27, testing has shown 0x25 + 0x26 */
		__u8 i2c[] = अणु0xc0, 0x11, 0x25, 0x00, 0x00, 0x00, 0x00, 0x17पूर्ण;
		u16 reg = gspca_dev->exposure->val;

		i2c[3] = reg >> 8;
		i2c[4] = reg & 0xff;
		i2c_w(gspca_dev, i2c);
		अवरोध;
	पूर्ण
	हाल SENSOR_TAS5110C:
	हाल SENSOR_TAS5110D: अणु
		/* रेजिस्टर 19's high nibble contains the sn9c10x घड़ी भागider
		   The high nibble configures the no fps according to the
		   क्रमmula: 60 / high_nibble. With a maximum of 30 fps */
		u8 reg = gspca_dev->exposure->val;

		reg = (reg << 4) | 0x0b;
		reg_w(gspca_dev, 0x19, &reg, 1);
		अवरोध;
	पूर्ण
	हाल SENSOR_OV6650:
	हाल SENSOR_OV7630: अणु
		/* The ov6650 / ov7630 have 2 रेजिस्टरs which both influence
		   exposure, रेजिस्टर 11, whose low nibble sets the nr off fps
		   according to: fps = 30 / (low_nibble + 1)

		   The fps configures the maximum exposure setting, but it is
		   possible to use less exposure then what the fps maximum
		   allows by setting रेजिस्टर 10. रेजिस्टर 10 configures the
		   actual exposure as quotient of the full exposure, with 0
		   being no exposure at all (not very useful) and reg10_max
		   being max exposure possible at that framerate.

		   The code maps our 0 - 510 ms exposure ctrl to these 2
		   रेजिस्टरs, trying to keep fps as high as possible.
		*/
		__u8 i2c[] = अणु0xb0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10पूर्ण;
		पूर्णांक reg10, reg11, reg10_max;

		/* ov6645 datasheet says reg10_max is 9a, but that uses
		   tline * 2 * reg10 as क्रमmula क्रम calculating texpo, the
		   ov6650 probably uses the same क्रमmula as the 7730 which uses
		   tline * 4 * reg10, which explains why the reg10max we've
		   found experimentally क्रम the ov6650 is exactly half that of
		   the ov6645. The ov7630 datasheet says the max is 0x41. */
		अगर (sd->sensor == SENSOR_OV6650) अणु
			reg10_max = 0x4d;
			i2c[4] = 0xc0; /* OV6650 needs non शेष vsync pol */
		पूर्ण अन्यथा
			reg10_max = 0x41;

		reg11 = (15 * gspca_dev->exposure->val + 999) / 1000;
		अगर (reg11 < 1)
			reg11 = 1;
		अन्यथा अगर (reg11 > 16)
			reg11 = 16;

		/* In 640x480, अगर the reg11 has less than 4, the image is
		   unstable (the bridge goes पूर्णांकo a higher compression mode
		   which we have not reverse engineered yet). */
		अगर (gspca_dev->pixfmt.width == 640 && reg11 < 4)
			reg11 = 4;

		/* frame exposure समय in ms = 1000 * reg11 / 30    ->
		reg10 = (gspca_dev->exposure->val / 2) * reg10_max
				/ (1000 * reg11 / 30) */
		reg10 = (gspca_dev->exposure->val * 15 * reg10_max)
				/ (1000 * reg11);

		/* Don't allow this to get below 10 when using स्वतःgain, the
		   steps become very large (relatively) when below 10 causing
		   the image to oscillate from much too dark, to much too bright
		   and back again. */
		अगर (gspca_dev->स्वतःgain->val && reg10 < 10)
			reg10 = 10;
		अन्यथा अगर (reg10 > reg10_max)
			reg10 = reg10_max;

		/* Write reg 10 and reg11 low nibble */
		i2c[1] = sensor_data[sd->sensor].sensor_addr;
		i2c[3] = reg10;
		i2c[4] |= reg11 - 1;

		/* If रेजिस्टर 11 didn't change, don't change it */
		अगर (sd->reg11 == reg11)
			i2c[0] = 0xa0;

		i2c_w(gspca_dev, i2c);
		अगर (gspca_dev->usb_err == 0)
			sd->reg11 = reg11;
		अवरोध;
	पूर्ण
	हाल SENSOR_PAS202: अणु
		__u8 i2cpframerate[] =
			अणु0xb0, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x16पूर्ण;
		__u8 i2cpexpo[] =
			अणु0xa0, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x16पूर्ण;
		स्थिर __u8 i2cpकरोit[] =
			अणु0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16पूर्ण;
		पूर्णांक framerate_ctrl;

		/* The exposure knee क्रम the स्वतःgain algorithm is 200
		   (100 ms / 10 fps on other sensors), क्रम values below this
		   use the control क्रम setting the partial frame expose समय,
		   above that use variable framerate. This way we run at max
		   framerate (640x480@7.5 fps, 320x240@10fps) until the knee
		   is reached. Using the variable framerate control above 200
		   is better then playing around with both घड़ीभाग + partial
		   frame exposure बार (like we are करोing with the ov chips),
		   as that someबार leads to jumps in the exposure control,
		   which are bad क्रम स्वतः exposure. */
		अगर (gspca_dev->exposure->val < 200) अणु
			i2cpexpo[3] = 255 - (gspca_dev->exposure->val * 255)
						/ 200;
			framerate_ctrl = 500;
		पूर्ण अन्यथा अणु
			/* The PAS202's exposure control goes from 0 - 4095,
			   but anything below 500 causes vsync issues, so scale
			   our 200-1023 to 500-4095 */
			framerate_ctrl = (gspca_dev->exposure->val - 200)
							* 1000 / 229 +  500;
		पूर्ण

		i2cpframerate[3] = framerate_ctrl >> 6;
		i2cpframerate[4] = framerate_ctrl & 0x3f;
		i2c_w(gspca_dev, i2cpframerate);
		i2c_w(gspca_dev, i2cpexpo);
		i2c_w(gspca_dev, i2cpकरोit);
		अवरोध;
	पूर्ण
	हाल SENSOR_PAS106: अणु
		__u8 i2cpframerate[] =
			अणु0xb1, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x14पूर्ण;
		__u8 i2cpexpo[] =
			अणु0xa1, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x14पूर्ण;
		स्थिर __u8 i2cpकरोit[] =
			अणु0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14पूर्ण;
		पूर्णांक framerate_ctrl;

		/* For values below 150 use partial frame exposure, above
		   that use framerate ctrl */
		अगर (gspca_dev->exposure->val < 150) अणु
			i2cpexpo[3] = 150 - gspca_dev->exposure->val;
			framerate_ctrl = 300;
		पूर्ण अन्यथा अणु
			/* The PAS106's exposure control goes from 0 - 4095,
			   but anything below 300 causes vsync issues, so scale
			   our 150-1023 to 300-4095 */
			framerate_ctrl = (gspca_dev->exposure->val - 150)
						* 1000 / 230 + 300;
		पूर्ण

		i2cpframerate[3] = framerate_ctrl >> 4;
		i2cpframerate[4] = framerate_ctrl & 0x0f;
		i2c_w(gspca_dev, i2cpframerate);
		i2c_w(gspca_dev, i2cpexpo);
		i2c_w(gspca_dev, i2cpकरोit);
		अवरोध;
	पूर्ण
	शेष:
		अवरोध;
	पूर्ण
पूर्ण

अटल व्योम setfreq(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;

	अगर (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630) अणु
		/* Framerate adjust रेजिस्टर क्रम artअगरicial light 50 hz flicker
		   compensation, क्रम the ov6650 this is identical to ov6630
		   0x2b रेजिस्टर, see ov6630 datasheet.
		   0x4f / 0x8a -> (30 fps -> 25 fps), 0x00 -> no adjusपंचांगent */
		__u8 i2c[] = अणु0xa0, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10पूर्ण;
		चयन (sd->plfreq->val) अणु
		शेष:
/*		हाल 0:			 * no filter*/
/*		हाल 2:			 * 60 hz */
			i2c[3] = 0;
			अवरोध;
		हाल 1:			/* 50 hz */
			i2c[3] = (sd->sensor == SENSOR_OV6650)
					? 0x4f : 0x8a;
			अवरोध;
		पूर्ण
		i2c[1] = sensor_data[sd->sensor].sensor_addr;
		i2c_w(gspca_dev, i2c);
	पूर्ण
पूर्ण

अटल व्योम करो_स्वतःgain(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	पूर्णांक deadzone, desired_avg_lum, avg_lum;

	avg_lum = atomic_पढ़ो(&sd->avg_lum);
	अगर (avg_lum == -1)
		वापस;

	अगर (sd->स्वतःgain_ignore_frames > 0) अणु
		sd->स्वतःgain_ignore_frames--;
		वापस;
	पूर्ण

	/* SIF / VGA sensors have a dअगरferent स्वतःexposure area and thus
	   dअगरferent avg_lum values क्रम the same picture brightness */
	अगर (sensor_data[sd->sensor].flags & F_SIF) अणु
		deadzone = 500;
		/* SIF sensors tend to overexpose, so keep this small */
		desired_avg_lum = 5000;
	पूर्ण अन्यथा अणु
		deadzone = 1500;
		desired_avg_lum = 13000;
	पूर्ण

	अगर (sd->brightness)
		desired_avg_lum = sd->brightness->val * desired_avg_lum / 127;

	अगर (gspca_dev->exposure->maximum < 500) अणु
		अगर (gspca_coarse_grained_expo_स्वतःgain(gspca_dev, avg_lum,
				desired_avg_lum, deadzone))
			sd->स्वतःgain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;
	पूर्ण अन्यथा अणु
		पूर्णांक gain_knee = (s32)gspca_dev->gain->maximum * 9 / 10;
		अगर (gspca_expo_स्वतःgain(gspca_dev, avg_lum, desired_avg_lum,
				deadzone, gain_knee, sd->exposure_knee))
			sd->स्वतःgain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;
	पूर्ण
पूर्ण

/* this function is called at probe समय */
अटल पूर्णांक sd_config(काष्ठा gspca_dev *gspca_dev,
			स्थिर काष्ठा usb_device_id *id)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	काष्ठा cam *cam;

	reg_r(gspca_dev, 0x00);
	अगर (gspca_dev->usb_buf[0] != 0x10)
		वापस -ENODEV;

	/* copy the webcam info from the device id */
	sd->sensor = id->driver_info >> 8;
	sd->bridge = id->driver_info & 0xff;

	cam = &gspca_dev->cam;
	अगर (!(sensor_data[sd->sensor].flags & F_SIF)) अणु
		cam->cam_mode = vga_mode;
		cam->nmodes = ARRAY_SIZE(vga_mode);
	पूर्ण अन्यथा अणु
		cam->cam_mode = sअगर_mode;
		cam->nmodes = ARRAY_SIZE(sअगर_mode);
	पूर्ण
	cam->npkt = 36;			/* 36 packets per ISOC message */

	वापस 0;
पूर्ण

/* this function is called at probe and resume समय */
अटल पूर्णांक sd_init(काष्ठा gspca_dev *gspca_dev)
अणु
	स्थिर __u8 stop = 0x09; /* Disable stream turn of LED */

	reg_w(gspca_dev, 0x01, &stop, 1);

	वापस gspca_dev->usb_err;
पूर्ण

अटल पूर्णांक sd_s_ctrl(काष्ठा v4l2_ctrl *ctrl)
अणु
	काष्ठा gspca_dev *gspca_dev =
		container_of(ctrl->handler, काष्ठा gspca_dev, ctrl_handler);
	काष्ठा sd *sd = (काष्ठा sd *)gspca_dev;

	gspca_dev->usb_err = 0;

	अगर (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) अणु
		/* when चयनing to स्वतःgain set शेषs to make sure
		   we are on a valid poपूर्णांक of the स्वतःgain gain /
		   exposure knee graph, and give this change समय to
		   take effect beक्रमe करोing स्वतःgain. */
		gspca_dev->gain->val = gspca_dev->gain->शेष_value;
		gspca_dev->exposure->val = gspca_dev->exposure->शेष_value;
		sd->स्वतःgain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;
	पूर्ण

	अगर (!gspca_dev->streaming)
		वापस 0;

	चयन (ctrl->id) अणु
	हाल V4L2_CID_BRIGHTNESS:
		setbrightness(gspca_dev);
		अवरोध;
	हाल V4L2_CID_AUTOGAIN:
		अगर (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))
			setexposure(gspca_dev);
		अगर (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))
			setgain(gspca_dev);
		अवरोध;
	हाल V4L2_CID_POWER_LINE_FREQUENCY:
		setfreq(gspca_dev);
		अवरोध;
	शेष:
		वापस -EINVAL;
	पूर्ण
	वापस gspca_dev->usb_err;
पूर्ण

अटल स्थिर काष्ठा v4l2_ctrl_ops sd_ctrl_ops = अणु
	.s_ctrl = sd_s_ctrl,
पूर्ण;

/* this function is called at probe समय */
अटल पूर्णांक sd_init_controls(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	काष्ठा v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;

	gspca_dev->vdev.ctrl_handler = hdl;
	v4l2_ctrl_handler_init(hdl, 5);

	अगर (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630 ||
	    sd->sensor == SENSOR_PAS106 || sd->sensor == SENSOR_PAS202)
		sd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_BRIGHTNESS, 0, 255, 1, 127);

	/* Gain range is sensor dependent */
	चयन (sd->sensor) अणु
	हाल SENSOR_OV6650:
	हाल SENSOR_PAS106:
	हाल SENSOR_PAS202:
		gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_GAIN, 0, 31, 1, 15);
		अवरोध;
	हाल SENSOR_OV7630:
		gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_GAIN, 0, 47, 1, 31);
		अवरोध;
	हाल SENSOR_HV7131D:
		gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_GAIN, 0, 63, 1, 31);
		अवरोध;
	हाल SENSOR_TAS5110C:
	हाल SENSOR_TAS5110D:
	हाल SENSOR_TAS5130CXX:
		gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_GAIN, 0, 255, 1, 127);
		अवरोध;
	शेष:
		अगर (sd->bridge == BRIDGE_103) अणु
			gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
						V4L2_CID_GAIN, 0, 127, 1, 63);
		पूर्ण अन्यथा अणु
			gspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
						V4L2_CID_GAIN, 0, 15, 1, 7);
		पूर्ण
	पूर्ण

	/* Exposure range is sensor dependent, and not all have exposure */
	चयन (sd->sensor) अणु
	हाल SENSOR_HV7131D:
		gspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_EXPOSURE, 0, 8191, 1, 482);
		sd->exposure_knee = 964;
		अवरोध;
	हाल SENSOR_OV6650:
	हाल SENSOR_OV7630:
	हाल SENSOR_PAS106:
	हाल SENSOR_PAS202:
		gspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_EXPOSURE, 0, 1023, 1, 66);
		sd->exposure_knee = 200;
		अवरोध;
	हाल SENSOR_TAS5110C:
	हाल SENSOR_TAS5110D:
		gspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
					V4L2_CID_EXPOSURE, 2, 15, 1, 2);
		अवरोध;
	पूर्ण

	अगर (gspca_dev->exposure) अणु
		gspca_dev->स्वतःgain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,
						V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
	पूर्ण

	अगर (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630)
		sd->plfreq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,
			V4L2_CID_POWER_LINE_FREQUENCY,
			V4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,
			V4L2_CID_POWER_LINE_FREQUENCY_DISABLED);

	अगर (hdl->error) अणु
		pr_err("Could not initialize controls\n");
		वापस hdl->error;
	पूर्ण

	अगर (gspca_dev->स्वतःgain)
		v4l2_ctrl_स्वतः_cluster(3, &gspca_dev->स्वतःgain, 0, false);

	वापस 0;
पूर्ण

/* -- start the camera -- */
अटल पूर्णांक sd_start(काष्ठा gspca_dev *gspca_dev)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	काष्ठा cam *cam = &gspca_dev->cam;
	पूर्णांक i, mode;
	__u8 regs[0x31];

	mode = cam->cam_mode[gspca_dev->curr_mode].priv & 0x07;
	/* Copy रेजिस्टरs 0x01 - 0x19 from the ढाँचा */
	स_नकल(&regs[0x01], sensor_data[sd->sensor].bridge_init, 0x19);
	/* Set the mode */
	regs[0x18] |= mode << 4;

	/* Set bridge gain to 1.0 */
	अगर (sd->bridge == BRIDGE_103) अणु
		regs[0x05] = 0x20; /* Red */
		regs[0x06] = 0x20; /* Green */
		regs[0x07] = 0x20; /* Blue */
	पूर्ण अन्यथा अणु
		regs[0x10] = 0x00; /* Red and blue */
		regs[0x11] = 0x00; /* Green */
	पूर्ण

	/* Setup pixel numbers and स्वतः exposure winकरोw */
	अगर (sensor_data[sd->sensor].flags & F_SIF) अणु
		regs[0x1a] = 0x14; /* HO_SIZE 640, makes no sense */
		regs[0x1b] = 0x0a; /* VO_SIZE 320, makes no sense */
		regs[0x1c] = 0x02; /* AE H-start 64 */
		regs[0x1d] = 0x02; /* AE V-start 64 */
		regs[0x1e] = 0x09; /* AE H-end 288 */
		regs[0x1f] = 0x07; /* AE V-end 224 */
	पूर्ण अन्यथा अणु
		regs[0x1a] = 0x1d; /* HO_SIZE 960, makes no sense */
		regs[0x1b] = 0x10; /* VO_SIZE 512, makes no sense */
		regs[0x1c] = 0x05; /* AE H-start 160 */
		regs[0x1d] = 0x03; /* AE V-start 96 */
		regs[0x1e] = 0x0f; /* AE H-end 480 */
		regs[0x1f] = 0x0c; /* AE V-end 384 */
	पूर्ण

	/* Setup the gamma table (only used with the sn9c103 bridge) */
	क्रम (i = 0; i < 16; i++)
		regs[0x20 + i] = i * 16;
	regs[0x20 + i] = 255;

	/* Special हालs where some regs depend on mode or bridge */
	चयन (sd->sensor) अणु
	हाल SENSOR_TAS5130CXX:
		/* FIXME / TESTME
		   probably not mode specअगरic at all most likely the upper
		   nibble of 0x19 is exposure (घड़ी भागider) just as with
		   the tas5110, we need someone to test this. */
		regs[0x19] = mode ? 0x23 : 0x43;
		अवरोध;
	हाल SENSOR_OV7630:
		/* FIXME / TESTME क्रम some reason with the 101/102 bridge the
		   घड़ी is set to 12 Mhz (reg1 == 0x04), rather then 24.
		   Also the hstart needs to go from 1 to 2 when using a 103,
		   which is likely related. This करोes not seem right. */
		अगर (sd->bridge == BRIDGE_103) अणु
			regs[0x01] = 0x44; /* Select 24 Mhz घड़ी */
			regs[0x12] = 0x02; /* Set hstart to 2 */
		पूर्ण
		अवरोध;
	हाल SENSOR_PAS202:
		/* For some unknown reason we need to increase hstart by 1 on
		   the sn9c103, otherwise we get wrong colors (bayer shअगरt). */
		अगर (sd->bridge == BRIDGE_103)
			regs[0x12] += 1;
		अवरोध;
	पूर्ण
	/* Disable compression when the raw bayer क्रमmat has been selected */
	अगर (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW)
		regs[0x18] &= ~0x80;

	/* Vga mode emulation on SIF sensor? */
	अगर (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_REDUCED_SIF) अणु
		regs[0x12] += 16;	/* hstart adjust */
		regs[0x13] += 24;	/* vstart adjust */
		regs[0x15]  = 320 / 16; /* hsize */
		regs[0x16]  = 240 / 16; /* vsize */
	पूर्ण

	/* reg 0x01 bit 2 video transfert on */
	reg_w(gspca_dev, 0x01, &regs[0x01], 1);
	/* reg 0x17 SensorClk enable inv Clk 0x60 */
	reg_w(gspca_dev, 0x17, &regs[0x17], 1);
	/* Set the रेजिस्टरs from the ढाँचा */
	reg_w(gspca_dev, 0x01, &regs[0x01],
	      (sd->bridge == BRIDGE_103) ? 0x30 : 0x1f);

	/* Init the sensor */
	i2c_w_vector(gspca_dev, sensor_data[sd->sensor].sensor_init,
			sensor_data[sd->sensor].sensor_init_size);

	/* Mode / bridge specअगरic sensor setup */
	चयन (sd->sensor) अणु
	हाल SENSOR_PAS202: अणु
		स्थिर __u8 i2cpघड़ीभाग[] =
			अणु0xa0, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x10पूर्ण;
		/* घड़ीभाग from 4 to 3 (7.5 -> 10 fps) when in low res mode */
		अगर (mode)
			i2c_w(gspca_dev, i2cpघड़ीभाग);
		अवरोध;
	    पूर्ण
	हाल SENSOR_OV7630:
		/* FIXME / TESTME We should be able to handle this identical
		   क्रम the 101/102 and the 103 हाल */
		अगर (sd->bridge == BRIDGE_103) अणु
			स्थिर __u8 i2c[] = अणु 0xa0, 0x21, 0x13,
					     0x80, 0x00, 0x00, 0x00, 0x10 पूर्ण;
			i2c_w(gspca_dev, i2c);
		पूर्ण
		अवरोध;
	पूर्ण
	/* H_size V_size 0x28, 0x1e -> 640x480. 0x16, 0x12 -> 352x288 */
	reg_w(gspca_dev, 0x15, &regs[0x15], 2);
	/* compression रेजिस्टर */
	reg_w(gspca_dev, 0x18, &regs[0x18], 1);
	/* H_start */
	reg_w(gspca_dev, 0x12, &regs[0x12], 1);
	/* V_START */
	reg_w(gspca_dev, 0x13, &regs[0x13], 1);
	/* reset 0x17 SensorClk enable inv Clk 0x60 */
				/*fixme: ov7630 [17]=68 8f (+20 अगर 102)*/
	reg_w(gspca_dev, 0x17, &regs[0x17], 1);
	/*MCKSIZE ->3 */	/*fixme: not ov7630*/
	reg_w(gspca_dev, 0x19, &regs[0x19], 1);
	/* AE_STRX AE_STRY AE_ENDX AE_ENDY */
	reg_w(gspca_dev, 0x1c, &regs[0x1c], 4);
	/* Enable video transfert */
	reg_w(gspca_dev, 0x01, &regs[0x01], 1);
	/* Compression */
	reg_w(gspca_dev, 0x18, &regs[0x18], 2);
	msleep(20);

	sd->reg11 = -1;

	setgain(gspca_dev);
	setbrightness(gspca_dev);
	setexposure(gspca_dev);
	setfreq(gspca_dev);

	sd->frames_to_drop = 0;
	sd->स्वतःgain_ignore_frames = 0;
	gspca_dev->exp_too_high_cnt = 0;
	gspca_dev->exp_too_low_cnt = 0;
	atomic_set(&sd->avg_lum, -1);
	वापस gspca_dev->usb_err;
पूर्ण

अटल व्योम sd_stopN(काष्ठा gspca_dev *gspca_dev)
अणु
	sd_init(gspca_dev);
पूर्ण

अटल u8* find_sof(काष्ठा gspca_dev *gspca_dev, u8 *data, पूर्णांक len)
अणु
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	पूर्णांक i, header_size = (sd->bridge == BRIDGE_103) ? 18 : 12;

	/* frames start with:
	 *	ff ff 00 c4 c4 96	synchro
	 *	00		(unknown)
	 *	xx		(frame sequence / size / compression)
	 *	(xx)		(idem - extra byte क्रम sn9c103)
	 *	ll mm		brightness sum inside स्वतः exposure
	 *	ll mm		brightness sum outside स्वतः exposure
	 *	(xx xx xx xx xx)	audio values क्रम snc103
	 */
	क्रम (i = 0; i < len; i++) अणु
		चयन (sd->header_पढ़ो) अणु
		हाल 0:
			अगर (data[i] == 0xff)
				sd->header_पढ़ो++;
			अवरोध;
		हाल 1:
			अगर (data[i] == 0xff)
				sd->header_पढ़ो++;
			अन्यथा
				sd->header_पढ़ो = 0;
			अवरोध;
		हाल 2:
			अगर (data[i] == 0x00)
				sd->header_पढ़ो++;
			अन्यथा अगर (data[i] != 0xff)
				sd->header_पढ़ो = 0;
			अवरोध;
		हाल 3:
			अगर (data[i] == 0xc4)
				sd->header_पढ़ो++;
			अन्यथा अगर (data[i] == 0xff)
				sd->header_पढ़ो = 1;
			अन्यथा
				sd->header_पढ़ो = 0;
			अवरोध;
		हाल 4:
			अगर (data[i] == 0xc4)
				sd->header_पढ़ो++;
			अन्यथा अगर (data[i] == 0xff)
				sd->header_पढ़ो = 1;
			अन्यथा
				sd->header_पढ़ो = 0;
			अवरोध;
		हाल 5:
			अगर (data[i] == 0x96)
				sd->header_पढ़ो++;
			अन्यथा अगर (data[i] == 0xff)
				sd->header_पढ़ो = 1;
			अन्यथा
				sd->header_पढ़ो = 0;
			अवरोध;
		शेष:
			sd->header[sd->header_पढ़ो - 6] = data[i];
			sd->header_पढ़ो++;
			अगर (sd->header_पढ़ो == header_size) अणु
				sd->header_पढ़ो = 0;
				वापस data + i + 1;
			पूर्ण
		पूर्ण
	पूर्ण
	वापस शून्य;
पूर्ण

अटल व्योम sd_pkt_scan(काष्ठा gspca_dev *gspca_dev,
			u8 *data,			/* isoc packet */
			पूर्णांक len)			/* iso packet length */
अणु
	पूर्णांक fr_h_sz = 0, lum_offset = 0, len_after_sof = 0;
	काष्ठा sd *sd = (काष्ठा sd *) gspca_dev;
	काष्ठा cam *cam = &gspca_dev->cam;
	u8 *sof;

	sof = find_sof(gspca_dev, data, len);
	अगर (sof) अणु
		अगर (sd->bridge == BRIDGE_103) अणु
			fr_h_sz = 18;
			lum_offset = 3;
		पूर्ण अन्यथा अणु
			fr_h_sz = 12;
			lum_offset = 2;
		पूर्ण

		len_after_sof = len - (sof - data);
		len = (sof - data) - fr_h_sz;
		अगर (len < 0)
			len = 0;
	पूर्ण

	अगर (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW) अणु
		/* In raw mode we someबार get some garbage after the frame
		   ignore this */
		पूर्णांक used;
		पूर्णांक size = cam->cam_mode[gspca_dev->curr_mode].sizeimage;

		used = gspca_dev->image_len;
		अगर (used + len > size)
			len = size - used;
	पूर्ण

	gspca_frame_add(gspca_dev, INTER_PACKET, data, len);

	अगर (sof) अणु
		पूर्णांक  lum = sd->header[lum_offset] +
			  (sd->header[lum_offset + 1] << 8);

		/* When exposure changes midway a frame we
		   get a lum of 0 in this हाल drop 2 frames
		   as the frames directly after an exposure
		   change have an unstable image. Someबार lum
		   *really* is 0 (cam used in low light with
		   low exposure setting), so करो not drop frames
		   अगर the previous lum was 0 too. */
		अगर (lum == 0 && sd->prev_avg_lum != 0) अणु
			lum = -1;
			sd->frames_to_drop = 2;
			sd->prev_avg_lum = 0;
		पूर्ण अन्यथा
			sd->prev_avg_lum = lum;
		atomic_set(&sd->avg_lum, lum);

		अगर (sd->frames_to_drop)
			sd->frames_to_drop--;
		अन्यथा
			gspca_frame_add(gspca_dev, LAST_PACKET, शून्य, 0);

		gspca_frame_add(gspca_dev, FIRST_PACKET, sof, len_after_sof);
	पूर्ण
पूर्ण

#अगर IS_ENABLED(CONFIG_INPUT)
अटल पूर्णांक sd_पूर्णांक_pkt_scan(काष्ठा gspca_dev *gspca_dev,
			u8 *data,		/* पूर्णांकerrupt packet data */
			पूर्णांक len)		/* पूर्णांकerrupt packet length */
अणु
	पूर्णांक ret = -EINVAL;

	अगर (len == 1 && data[0] == 1) अणु
		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);
		input_sync(gspca_dev->input_dev);
		input_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);
		input_sync(gspca_dev->input_dev);
		ret = 0;
	पूर्ण

	वापस ret;
पूर्ण
#पूर्ण_अगर

/* sub-driver description */
अटल स्थिर काष्ठा sd_desc sd_desc = अणु
	.name = MODULE_NAME,
	.config = sd_config,
	.init = sd_init,
	.init_controls = sd_init_controls,
	.start = sd_start,
	.stopN = sd_stopN,
	.pkt_scan = sd_pkt_scan,
	.dq_callback = करो_स्वतःgain,
#अगर IS_ENABLED(CONFIG_INPUT)
	.पूर्णांक_pkt_scan = sd_पूर्णांक_pkt_scan,
#पूर्ण_अगर
पूर्ण;

/* -- module initialisation -- */
#घोषणा SB(sensor, bridge) \
	.driver_info = (SENSOR_ ## sensor << 8) | BRIDGE_ ## bridge


अटल स्थिर काष्ठा usb_device_id device_table[] = अणु
	अणुUSB_DEVICE(0x0c45, 0x6001), SB(TAS5110C, 102)पूर्ण, /* TAS5110C1B */
	अणुUSB_DEVICE(0x0c45, 0x6005), SB(TAS5110C, 101)पूर्ण, /* TAS5110C1B */
	अणुUSB_DEVICE(0x0c45, 0x6007), SB(TAS5110D, 101)पूर्ण, /* TAS5110D */
	अणुUSB_DEVICE(0x0c45, 0x6009), SB(PAS106, 101)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x600d), SB(PAS106, 101)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6011), SB(OV6650, 101)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6019), SB(OV7630, 101)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6024), SB(TAS5130CXX, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6025), SB(TAS5130CXX, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6027), SB(OV7630, 101)पूर्ण, /* Genius Eye 310 */
	अणुUSB_DEVICE(0x0c45, 0x6028), SB(PAS202, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x6029), SB(PAS106, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x602a), SB(HV7131D, 102)पूर्ण,
	/* अणुUSB_DEVICE(0x0c45, 0x602b), SB(MI0343, 102)पूर्ण, */
	अणुUSB_DEVICE(0x0c45, 0x602c), SB(OV7630, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x602d), SB(HV7131R, 102)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x602e), SB(OV7630, 102)पूर्ण,
	/* अणुUSB_DEVICE(0x0c45, 0x6030), SB(MI03XX, 102)पूर्ण, */ /* MI0343 MI0360 MI0330 */
	/* अणुUSB_DEVICE(0x0c45, 0x6082), SB(MI03XX, 103)पूर्ण, */ /* MI0343 MI0360 */
	अणुUSB_DEVICE(0x0c45, 0x6083), SB(HV7131D, 103)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x608c), SB(HV7131R, 103)पूर्ण,
	/* अणुUSB_DEVICE(0x0c45, 0x608e), SB(CISVF10, 103)पूर्ण, */
	अणुUSB_DEVICE(0x0c45, 0x608f), SB(OV7630, 103)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x60a8), SB(PAS106, 103)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x60aa), SB(TAS5130CXX, 103)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x60af), SB(PAS202, 103)पूर्ण,
	अणुUSB_DEVICE(0x0c45, 0x60b0), SB(OV7630, 103)पूर्ण,
	अणुपूर्ण
पूर्ण;
MODULE_DEVICE_TABLE(usb, device_table);

/* -- device connect -- */
अटल पूर्णांक sd_probe(काष्ठा usb_पूर्णांकerface *पूर्णांकf,
			स्थिर काष्ठा usb_device_id *id)
अणु
	वापस gspca_dev_probe(पूर्णांकf, id, &sd_desc, माप(काष्ठा sd),
				THIS_MODULE);
पूर्ण

अटल काष्ठा usb_driver sd_driver = अणु
	.name = MODULE_NAME,
	.id_table = device_table,
	.probe = sd_probe,
	.disconnect = gspca_disconnect,
#अगर_घोषित CONFIG_PM
	.suspend = gspca_suspend,
	.resume = gspca_resume,
	.reset_resume = gspca_resume,
#पूर्ण_अगर
पूर्ण;

module_usb_driver(sd_driver);
