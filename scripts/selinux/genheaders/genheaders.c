<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0

/* NOTE: we really करो want to use the kernel headers here */
#घोषणा __EXPORTED_HEADERS__

#समावेश <मानकपन.स>
#समावेश <मानककोष.स>
#समावेश <unistd.h>
#समावेश <माला.स>
#समावेश <त्रुटिसं.स>
#समावेश <प्रकार.स>

काष्ठा security_class_mapping अणु
	स्थिर अक्षर *name;
	स्थिर अक्षर *perms[माप(अचिन्हित) * 8 + 1];
पूर्ण;

#समावेश "classmap.h"
#समावेश "initial_sid_to_string.h"

स्थिर अक्षर *progname;

अटल व्योम usage(व्योम)
अणु
	म_लिखो("usage: %s flask.h av_permissions.h\n", progname);
	निकास(1);
पूर्ण

अटल अक्षर *sबड़ेx(स्थिर अक्षर *s)
अणु
	अक्षर *s2 = strdup(s);
	अक्षर *p;

	अगर (!s2) अणु
		ख_लिखो(मानक_त्रुटि, "%s:  out of memory\n", progname);
		निकास(3);
	पूर्ण

	क्रम (p = s2; *p; p++)
		*p = बड़े(*p);
	वापस s2;
पूर्ण

पूर्णांक मुख्य(पूर्णांक argc, अक्षर *argv[])
अणु
	पूर्णांक i, j;
	पूर्णांक isids_len;
	खाता *fout;

	progname = argv[0];

	अगर (argc < 3)
		usage();

	fout = ख_खोलो(argv[1], "w");
	अगर (!fout) अणु
		ख_लिखो(मानक_त्रुटि, "Could not open %s for writing:  %s\n",
			argv[1], म_त्रुटि(त्रुटि_सं));
		निकास(2);
	पूर्ण

	क्रम (i = 0; secclass_map[i].name; i++) अणु
		काष्ठा security_class_mapping *map = &secclass_map[i];
		map->name = sबड़ेx(map->name);
		क्रम (j = 0; map->perms[j]; j++)
			map->perms[j] = sबड़ेx(map->perms[j]);
	पूर्ण

	isids_len = माप(initial_sid_to_string) / माप (अक्षर *);
	क्रम (i = 1; i < isids_len; i++) अणु
		स्थिर अक्षर *s = initial_sid_to_string[i];

		अगर (s)
			initial_sid_to_string[i] = sबड़ेx(s);
	पूर्ण

	ख_लिखो(fout, "/* This file is automatically generated.  Do not edit. */\n");
	ख_लिखो(fout, "#ifndef _SELINUX_FLASK_H_\n#define _SELINUX_FLASK_H_\n\n");

	क्रम (i = 0; secclass_map[i].name; i++) अणु
		काष्ठा security_class_mapping *map = &secclass_map[i];
		ख_लिखो(fout, "#define SECCLASS_%-39s %2d\n", map->name, i+1);
	पूर्ण

	ख_लिखो(fout, "\n");

	क्रम (i = 1; i < isids_len; i++) अणु
		स्थिर अक्षर *s = initial_sid_to_string[i];
		अगर (s)
			ख_लिखो(fout, "#define SECINITSID_%-39s %2d\n", s, i);
	पूर्ण
	ख_लिखो(fout, "\n#define SECINITSID_NUM %d\n", i-1);
	ख_लिखो(fout, "\nstatic inline bool security_is_socket_class(u16 kern_tclass)\n");
	ख_लिखो(fout, "{\n");
	ख_लिखो(fout, "\tbool sock = false;\n\n");
	ख_लिखो(fout, "\tswitch (kern_tclass) {\n");
	क्रम (i = 0; secclass_map[i].name; i++) अणु
		अटल अक्षर s[] = "SOCKET";
		काष्ठा security_class_mapping *map = &secclass_map[i];
		पूर्णांक len = म_माप(map->name), l = माप(s) - 1;
		अगर (len >= l && स_भेद(map->name + len - l, s, l) == 0)
			ख_लिखो(fout, "\tcase SECCLASS_%s:\n", map->name);
	पूर्ण
	ख_लिखो(fout, "\t\tsock = true;\n");
	ख_लिखो(fout, "\t\tbreak;\n");
	ख_लिखो(fout, "\tdefault:\n");
	ख_लिखो(fout, "\t\tbreak;\n");
	ख_लिखो(fout, "\t}\n\n");
	ख_लिखो(fout, "\treturn sock;\n");
	ख_लिखो(fout, "}\n");

	ख_लिखो(fout, "\n#endif\n");
	ख_बंद(fout);

	fout = ख_खोलो(argv[2], "w");
	अगर (!fout) अणु
		ख_लिखो(मानक_त्रुटि, "Could not open %s for writing:  %s\n",
			argv[2], म_त्रुटि(त्रुटि_सं));
		निकास(4);
	पूर्ण

	ख_लिखो(fout, "/* This file is automatically generated.  Do not edit. */\n");
	ख_लिखो(fout, "#ifndef _SELINUX_AV_PERMISSIONS_H_\n#define _SELINUX_AV_PERMISSIONS_H_\n\n");

	क्रम (i = 0; secclass_map[i].name; i++) अणु
		काष्ठा security_class_mapping *map = &secclass_map[i];
		पूर्णांक len = म_माप(map->name);
		क्रम (j = 0; map->perms[j]; j++) अणु
			अगर (j >= 32) अणु
				ख_लिखो(मानक_त्रुटि, "Too many permissions to fit into an access vector at (%s, %s).\n",
					map->name, map->perms[j]);
				निकास(5);
			पूर्ण
			ख_लिखो(fout, "#define %s__%-*s 0x%08xU\n", map->name,
				39-len, map->perms[j], 1U<<j);
		पूर्ण
	पूर्ण

	ख_लिखो(fout, "\n#endif\n");
	ख_बंद(fout);
	निकास(0);
पूर्ण
