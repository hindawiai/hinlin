<शैली गुरु>
/*
 * Copyright (c) 2013, Kenneth MacKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary क्रमms, with or without
 * modअगरication, are permitted provided that the following conditions are
 * met:
 *  * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary क्रमm must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    करोcumentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY सूचीECT, INसूचीECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#अगर_अघोषित _CRYPTO_ECC_H
#घोषणा _CRYPTO_ECC_H

#समावेश <crypto/ecc_curve.h>

/* One digit is u64 qword. */
#घोषणा ECC_CURVE_NIST_P192_DIGITS  3
#घोषणा ECC_CURVE_NIST_P256_DIGITS  4
#घोषणा ECC_CURVE_NIST_P384_DIGITS  6
#घोषणा ECC_MAX_DIGITS              (512 / 64) /* due to ecrdsa */

#घोषणा ECC_DIGITS_TO_BYTES_SHIFT 3

#घोषणा ECC_MAX_BYTES (ECC_MAX_DIGITS << ECC_DIGITS_TO_BYTES_SHIFT)

#घोषणा ECC_POINT_INIT(x, y, ndigits)	(काष्ठा ecc_poपूर्णांक) अणु x, y, ndigits पूर्ण

/**
 * ecc_swap_digits() - Copy ndigits from big endian array to native array
 * @in:       Input array
 * @out:      Output array
 * @ndigits:  Number of digits to copy
 */
अटल अंतरभूत व्योम ecc_swap_digits(स्थिर u64 *in, u64 *out, अचिन्हित पूर्णांक ndigits)
अणु
	स्थिर __be64 *src = (__क्रमce __be64 *)in;
	पूर्णांक i;

	क्रम (i = 0; i < ndigits; i++)
		out[i] = be64_to_cpu(src[ndigits - 1 - i]);
पूर्ण

/**
 * ecc_is_key_valid() - Validate a given ECDH निजी key
 *
 * @curve_id:		id representing the curve to use
 * @ndigits:		curve's number of digits
 * @निजी_key:	निजी key to be used क्रम the given curve
 * @निजी_key_len:	निजी key length
 *
 * Returns 0 अगर the key is acceptable, a negative value otherwise
 */
पूर्णांक ecc_is_key_valid(अचिन्हित पूर्णांक curve_id, अचिन्हित पूर्णांक ndigits,
		     स्थिर u64 *निजी_key, अचिन्हित पूर्णांक निजी_key_len);

/**
 * ecc_gen_privkey() -  Generates an ECC निजी key.
 * The निजी key is a अक्रमom पूर्णांकeger in the range 0 < अक्रमom < n, where n is a
 * prime that is the order of the cyclic subgroup generated by the distinguished
 * poपूर्णांक G.
 * @curve_id:		id representing the curve to use
 * @ndigits:		curve number of digits
 * @निजी_key:	buffer क्रम storing the generated निजी key
 *
 * Returns 0 अगर the निजी key was generated successfully, a negative value
 * अगर an error occurred.
 */
पूर्णांक ecc_gen_privkey(अचिन्हित पूर्णांक curve_id, अचिन्हित पूर्णांक ndigits, u64 *privkey);

/**
 * ecc_make_pub_key() - Compute an ECC खुला key
 *
 * @curve_id:		id representing the curve to use
 * @ndigits:		curve's number of digits
 * @निजी_key:	pregenerated निजी key क्रम the given curve
 * @खुला_key:		buffer क्रम storing the generated खुला key
 *
 * Returns 0 अगर the खुला key was generated successfully, a negative value
 * अगर an error occurred.
 */
पूर्णांक ecc_make_pub_key(स्थिर अचिन्हित पूर्णांक curve_id, अचिन्हित पूर्णांक ndigits,
		     स्थिर u64 *निजी_key, u64 *खुला_key);

/**
 * crypto_ecdh_shared_secret() - Compute a shared secret
 *
 * @curve_id:		id representing the curve to use
 * @ndigits:		curve's number of digits
 * @निजी_key:	निजी key of part A
 * @खुला_key:		खुला key of counterpart B
 * @secret:		buffer क्रम storing the calculated shared secret
 *
 * Note: It is recommended that you hash the result of crypto_ecdh_shared_secret
 * beक्रमe using it क्रम symmetric encryption or HMAC.
 *
 * Returns 0 अगर the shared secret was generated successfully, a negative value
 * अगर an error occurred.
 */
पूर्णांक crypto_ecdh_shared_secret(अचिन्हित पूर्णांक curve_id, अचिन्हित पूर्णांक ndigits,
			      स्थिर u64 *निजी_key, स्थिर u64 *खुला_key,
			      u64 *secret);

/**
 * ecc_is_pubkey_valid_partial() - Partial खुला key validation
 *
 * @curve:		elliptic curve करोमुख्य parameters
 * @pk:			खुला key as a poपूर्णांक
 *
 * Valdiate खुला key according to SP800-56A section 5.6.2.3.4 ECC Partial
 * Public-Key Validation Routine.
 *
 * Note: There is no check that the खुला key is in the correct elliptic curve
 * subgroup.
 *
 * Return: 0 अगर validation is successful, -EINVAL अगर validation is failed.
 */
पूर्णांक ecc_is_pubkey_valid_partial(स्थिर काष्ठा ecc_curve *curve,
				काष्ठा ecc_poपूर्णांक *pk);

/**
 * ecc_is_pubkey_valid_full() - Full खुला key validation
 *
 * @curve:		elliptic curve करोमुख्य parameters
 * @pk:			खुला key as a poपूर्णांक
 *
 * Valdiate खुला key according to SP800-56A section 5.6.2.3.3 ECC Full
 * Public-Key Validation Routine.
 *
 * Return: 0 अगर validation is successful, -EINVAL अगर validation is failed.
 */
पूर्णांक ecc_is_pubkey_valid_full(स्थिर काष्ठा ecc_curve *curve,
			     काष्ठा ecc_poपूर्णांक *pk);

/**
 * vli_is_zero() - Determine is vli is zero
 *
 * @vli:		vli to check.
 * @ndigits:		length of the @vli
 */
bool vli_is_zero(स्थिर u64 *vli, अचिन्हित पूर्णांक ndigits);

/**
 * vli_cmp() - compare left and right vlis
 *
 * @left:		vli
 * @right:		vli
 * @ndigits:		length of both vlis
 *
 * Returns sign of @left - @right, i.e. -1 अगर @left < @right,
 * 0 अगर @left == @right, 1 अगर @left > @right.
 */
पूर्णांक vli_cmp(स्थिर u64 *left, स्थिर u64 *right, अचिन्हित पूर्णांक ndigits);

/**
 * vli_sub() - Subtracts right from left
 *
 * @result:		where to ग_लिखो result
 * @left:		vli
 * @right		vli
 * @ndigits:		length of all vlis
 *
 * Note: can modअगरy in-place.
 *
 * Return: carry bit.
 */
u64 vli_sub(u64 *result, स्थिर u64 *left, स्थिर u64 *right,
	    अचिन्हित पूर्णांक ndigits);

/**
 * vli_from_be64() - Load vli from big-endian u64 array
 *
 * @dest:		destination vli
 * @src:		source array of u64 BE values
 * @ndigits:		length of both vli and array
 */
व्योम vli_from_be64(u64 *dest, स्थिर व्योम *src, अचिन्हित पूर्णांक ndigits);

/**
 * vli_from_le64() - Load vli from little-endian u64 array
 *
 * @dest:		destination vli
 * @src:		source array of u64 LE values
 * @ndigits:		length of both vli and array
 */
व्योम vli_from_le64(u64 *dest, स्थिर व्योम *src, अचिन्हित पूर्णांक ndigits);

/**
 * vli_mod_inv() - Modular inversion
 *
 * @result:		where to ग_लिखो vli number
 * @input:		vli value to operate on
 * @mod:		modulus
 * @ndigits:		length of all vlis
 */
व्योम vli_mod_inv(u64 *result, स्थिर u64 *input, स्थिर u64 *mod,
		 अचिन्हित पूर्णांक ndigits);

/**
 * vli_mod_mult_slow() - Modular multiplication
 *
 * @result:		where to ग_लिखो result value
 * @left:		vli number to multiply with @right
 * @right:		vli number to multiply with @left
 * @mod:		modulus
 * @ndigits:		length of all vlis
 *
 * Note: Assumes that mod is big enough curve order.
 */
व्योम vli_mod_mult_slow(u64 *result, स्थिर u64 *left, स्थिर u64 *right,
		       स्थिर u64 *mod, अचिन्हित पूर्णांक ndigits);

/**
 * ecc_poपूर्णांक_mult_shamir() - Add two poपूर्णांकs multiplied by scalars
 *
 * @result:		resulting poपूर्णांक
 * @x:			scalar to multiply with @p
 * @p:			poपूर्णांक to multiply with @x
 * @y:			scalar to multiply with @q
 * @q:			poपूर्णांक to multiply with @y
 * @curve:		curve
 *
 * Returns result = x * p + x * q over the curve.
 * This works faster than two multiplications and addition.
 */
व्योम ecc_poपूर्णांक_mult_shamir(स्थिर काष्ठा ecc_poपूर्णांक *result,
			   स्थिर u64 *x, स्थिर काष्ठा ecc_poपूर्णांक *p,
			   स्थिर u64 *y, स्थिर काष्ठा ecc_poपूर्णांक *q,
			   स्थिर काष्ठा ecc_curve *curve);
#पूर्ण_अगर
