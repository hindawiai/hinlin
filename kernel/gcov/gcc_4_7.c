<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/*
 *  This code provides functions to handle gcc's profiling data क्रमmat
 *  पूर्णांकroduced with gcc 4.7.
 *
 *  This file is based heavily on gcc_3_4.c file.
 *
 *  For a better understanding, refer to gcc source:
 *  gcc/gcov-पन.स
 *  libgcc/libgcov.c
 *
 *  Uses gcc-पूर्णांकernal data definitions.
 */

#समावेश <linux/त्रुटिसं.स>
#समावेश <linux/slab.h>
#समावेश <linux/माला.स>
#समावेश <linux/mm.h>
#समावेश "gcov.h"

#अगर (__GNUC__ >= 10)
#घोषणा GCOV_COUNTERS			8
#या_अगर (__GNUC__ >= 7)
#घोषणा GCOV_COUNTERS			9
#या_अगर (__GNUC__ > 5) || (__GNUC__ == 5 && __GNUC_MINOR__ >= 1)
#घोषणा GCOV_COUNTERS			10
#अन्यथा
#घोषणा GCOV_COUNTERS			9
#पूर्ण_अगर

#घोषणा GCOV_TAG_FUNCTION_LENGTH	3

अटल काष्ठा gcov_info *gcov_info_head;

/**
 * काष्ठा gcov_ctr_info - inक्रमmation about counters क्रम a single function
 * @num: number of counter values क्रम this type
 * @values: array of counter values क्रम this type
 *
 * This data is generated by gcc during compilation and करोesn't change
 * at run-समय with the exception of the values array.
 */
काष्ठा gcov_ctr_info अणु
	अचिन्हित पूर्णांक num;
	gcov_type *values;
पूर्ण;

/**
 * काष्ठा gcov_fn_info - profiling meta data per function
 * @key: comdat key
 * @ident: unique ident of function
 * @lineno_checksum: function lineo_checksum
 * @cfg_checksum: function cfg checksum
 * @ctrs: instrumented counters
 *
 * This data is generated by gcc during compilation and करोesn't change
 * at run-समय.
 *
 * Inक्रमmation about a single function.  This uses the trailing array
 * idiom. The number of counters is determined from the merge poपूर्णांकer
 * array in gcov_info.  The key is used to detect which of a set of
 * comdat functions was selected -- it poपूर्णांकs to the gcov_info object
 * of the object file containing the selected comdat function.
 */
काष्ठा gcov_fn_info अणु
	स्थिर काष्ठा gcov_info *key;
	अचिन्हित पूर्णांक ident;
	अचिन्हित पूर्णांक lineno_checksum;
	अचिन्हित पूर्णांक cfg_checksum;
	काष्ठा gcov_ctr_info ctrs[];
पूर्ण;

/**
 * काष्ठा gcov_info - profiling data per object file
 * @version: gcov version magic indicating the gcc version used क्रम compilation
 * @next: list head क्रम a singly-linked list
 * @stamp: uniquअगरying समय stamp
 * @filename: name of the associated gcov data file
 * @merge: merge functions (null क्रम unused counter type)
 * @n_functions: number of instrumented functions
 * @functions: poपूर्णांकer to poपूर्णांकers to function inक्रमmation
 *
 * This data is generated by gcc during compilation and करोesn't change
 * at run-समय with the exception of the next poपूर्णांकer.
 */
काष्ठा gcov_info अणु
	अचिन्हित पूर्णांक version;
	काष्ठा gcov_info *next;
	अचिन्हित पूर्णांक stamp;
	स्थिर अक्षर *filename;
	व्योम (*merge[GCOV_COUNTERS])(gcov_type *, अचिन्हित पूर्णांक);
	अचिन्हित पूर्णांक n_functions;
	काष्ठा gcov_fn_info **functions;
पूर्ण;

/**
 * gcov_info_filename - वापस info filename
 * @info: profiling data set
 */
स्थिर अक्षर *gcov_info_filename(काष्ठा gcov_info *info)
अणु
	वापस info->filename;
पूर्ण

/**
 * gcov_info_version - वापस info version
 * @info: profiling data set
 */
अचिन्हित पूर्णांक gcov_info_version(काष्ठा gcov_info *info)
अणु
	वापस info->version;
पूर्ण

/**
 * gcov_info_next - वापस next profiling data set
 * @info: profiling data set
 *
 * Returns next gcov_info following @info or first gcov_info in the chain अगर
 * @info is %शून्य.
 */
काष्ठा gcov_info *gcov_info_next(काष्ठा gcov_info *info)
अणु
	अगर (!info)
		वापस gcov_info_head;

	वापस info->next;
पूर्ण

/**
 * gcov_info_link - link/add profiling data set to the list
 * @info: profiling data set
 */
व्योम gcov_info_link(काष्ठा gcov_info *info)
अणु
	info->next = gcov_info_head;
	gcov_info_head = info;
पूर्ण

/**
 * gcov_info_unlink - unlink/हटाओ profiling data set from the list
 * @prev: previous profiling data set
 * @info: profiling data set
 */
व्योम gcov_info_unlink(काष्ठा gcov_info *prev, काष्ठा gcov_info *info)
अणु
	अगर (prev)
		prev->next = info->next;
	अन्यथा
		gcov_info_head = info->next;
पूर्ण

/**
 * gcov_info_within_module - check अगर a profiling data set beदीर्घs to a module
 * @info: profiling data set
 * @mod: module
 *
 * Returns true अगर profiling data beदीर्घs module, false otherwise.
 */
bool gcov_info_within_module(काष्ठा gcov_info *info, काष्ठा module *mod)
अणु
	वापस within_module((अचिन्हित दीर्घ)info, mod);
पूर्ण

/* Symbolic links to be created क्रम each profiling data file. */
स्थिर काष्ठा gcov_link gcov_link[] = अणु
	अणु OBJ_TREE, "gcno" पूर्ण,	/* Link to .gcno file in $(objtree). */
	अणु 0, शून्यपूर्ण,
पूर्ण;

/*
 * Determine whether a counter is active. Doesn't change at run-समय.
 */
अटल पूर्णांक counter_active(काष्ठा gcov_info *info, अचिन्हित पूर्णांक type)
अणु
	वापस info->merge[type] ? 1 : 0;
पूर्ण

/* Determine number of active counters. Based on gcc magic. */
अटल अचिन्हित पूर्णांक num_counter_active(काष्ठा gcov_info *info)
अणु
	अचिन्हित पूर्णांक i;
	अचिन्हित पूर्णांक result = 0;

	क्रम (i = 0; i < GCOV_COUNTERS; i++) अणु
		अगर (counter_active(info, i))
			result++;
	पूर्ण
	वापस result;
पूर्ण

/**
 * gcov_info_reset - reset profiling data to zero
 * @info: profiling data set
 */
व्योम gcov_info_reset(काष्ठा gcov_info *info)
अणु
	काष्ठा gcov_ctr_info *ci_ptr;
	अचिन्हित पूर्णांक fi_idx;
	अचिन्हित पूर्णांक ct_idx;

	क्रम (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) अणु
		ci_ptr = info->functions[fi_idx]->ctrs;

		क्रम (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) अणु
			अगर (!counter_active(info, ct_idx))
				जारी;

			स_रखो(ci_ptr->values, 0,
					माप(gcov_type) * ci_ptr->num);
			ci_ptr++;
		पूर्ण
	पूर्ण
पूर्ण

/**
 * gcov_info_is_compatible - check अगर profiling data can be added
 * @info1: first profiling data set
 * @info2: second profiling data set
 *
 * Returns non-zero अगर profiling data can be added, zero otherwise.
 */
पूर्णांक gcov_info_is_compatible(काष्ठा gcov_info *info1, काष्ठा gcov_info *info2)
अणु
	वापस (info1->stamp == info2->stamp);
पूर्ण

/**
 * gcov_info_add - add up profiling data
 * @dst: profiling data set to which data is added
 * @src: profiling data set which is added
 *
 * Adds profiling counts of @src to @dst.
 */
व्योम gcov_info_add(काष्ठा gcov_info *dst, काष्ठा gcov_info *src)
अणु
	काष्ठा gcov_ctr_info *dci_ptr;
	काष्ठा gcov_ctr_info *sci_ptr;
	अचिन्हित पूर्णांक fi_idx;
	अचिन्हित पूर्णांक ct_idx;
	अचिन्हित पूर्णांक val_idx;

	क्रम (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) अणु
		dci_ptr = dst->functions[fi_idx]->ctrs;
		sci_ptr = src->functions[fi_idx]->ctrs;

		क्रम (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) अणु
			अगर (!counter_active(src, ct_idx))
				जारी;

			क्रम (val_idx = 0; val_idx < sci_ptr->num; val_idx++)
				dci_ptr->values[val_idx] +=
					sci_ptr->values[val_idx];

			dci_ptr++;
			sci_ptr++;
		पूर्ण
	पूर्ण
पूर्ण

/**
 * gcov_info_dup - duplicate profiling data set
 * @info: profiling data set to duplicate
 *
 * Return newly allocated duplicate on success, %शून्य on error.
 */
काष्ठा gcov_info *gcov_info_dup(काष्ठा gcov_info *info)
अणु
	काष्ठा gcov_info *dup;
	काष्ठा gcov_ctr_info *dci_ptr; /* dst counter info */
	काष्ठा gcov_ctr_info *sci_ptr; /* src counter info */
	अचिन्हित पूर्णांक active;
	अचिन्हित पूर्णांक fi_idx; /* function info idx */
	अचिन्हित पूर्णांक ct_idx; /* counter type idx */
	माप_प्रकार fi_size; /* function info size */
	माप_प्रकार cv_size; /* counter values size */

	dup = kmemdup(info, माप(*dup), GFP_KERNEL);
	अगर (!dup)
		वापस शून्य;

	dup->next = शून्य;
	dup->filename = शून्य;
	dup->functions = शून्य;

	dup->filename = kstrdup(info->filename, GFP_KERNEL);
	अगर (!dup->filename)
		जाओ err_मुक्त;

	dup->functions = kसुस्मृति(info->n_functions,
				 माप(काष्ठा gcov_fn_info *), GFP_KERNEL);
	अगर (!dup->functions)
		जाओ err_मुक्त;

	active = num_counter_active(info);
	fi_size = माप(काष्ठा gcov_fn_info);
	fi_size += माप(काष्ठा gcov_ctr_info) * active;

	क्रम (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) अणु
		dup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);
		अगर (!dup->functions[fi_idx])
			जाओ err_मुक्त;

		*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);

		sci_ptr = info->functions[fi_idx]->ctrs;
		dci_ptr = dup->functions[fi_idx]->ctrs;

		क्रम (ct_idx = 0; ct_idx < active; ct_idx++) अणु

			cv_size = माप(gcov_type) * sci_ptr->num;

			dci_ptr->values = kvदो_स्मृति(cv_size, GFP_KERNEL);

			अगर (!dci_ptr->values)
				जाओ err_मुक्त;

			dci_ptr->num = sci_ptr->num;
			स_नकल(dci_ptr->values, sci_ptr->values, cv_size);

			sci_ptr++;
			dci_ptr++;
		पूर्ण
	पूर्ण

	वापस dup;
err_मुक्त:
	gcov_info_मुक्त(dup);
	वापस शून्य;
पूर्ण

/**
 * gcov_info_मुक्त - release memory क्रम profiling data set duplicate
 * @info: profiling data set duplicate to मुक्त
 */
व्योम gcov_info_मुक्त(काष्ठा gcov_info *info)
अणु
	अचिन्हित पूर्णांक active;
	अचिन्हित पूर्णांक fi_idx;
	अचिन्हित पूर्णांक ct_idx;
	काष्ठा gcov_ctr_info *ci_ptr;

	अगर (!info->functions)
		जाओ मुक्त_info;

	active = num_counter_active(info);

	क्रम (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) अणु
		अगर (!info->functions[fi_idx])
			जारी;

		ci_ptr = info->functions[fi_idx]->ctrs;

		क्रम (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)
			kvमुक्त(ci_ptr->values);

		kमुक्त(info->functions[fi_idx]);
	पूर्ण

मुक्त_info:
	kमुक्त(info->functions);
	kमुक्त(info->filename);
	kमुक्त(info);
पूर्ण

/**
 * convert_to_gcda - convert profiling data set to gcda file क्रमmat
 * @buffer: the buffer to store file data or %शून्य अगर no data should be stored
 * @info: profiling data set to be converted
 *
 * Returns the number of bytes that were/would have been stored पूर्णांकo the buffer.
 */
माप_प्रकार convert_to_gcda(अक्षर *buffer, काष्ठा gcov_info *info)
अणु
	काष्ठा gcov_fn_info *fi_ptr;
	काष्ठा gcov_ctr_info *ci_ptr;
	अचिन्हित पूर्णांक fi_idx;
	अचिन्हित पूर्णांक ct_idx;
	अचिन्हित पूर्णांक cv_idx;
	माप_प्रकार pos = 0;

	/* File header. */
	pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
	pos += store_gcov_u32(buffer, pos, info->version);
	pos += store_gcov_u32(buffer, pos, info->stamp);

	क्रम (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) अणु
		fi_ptr = info->functions[fi_idx];

		/* Function record. */
		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
		pos += store_gcov_u32(buffer, pos, fi_ptr->ident);
		pos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);
		pos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);

		ci_ptr = fi_ptr->ctrs;

		क्रम (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) अणु
			अगर (!counter_active(info, ct_idx))
				जारी;

			/* Counter record. */
			pos += store_gcov_u32(buffer, pos,
					      GCOV_TAG_FOR_COUNTER(ct_idx));
			pos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);

			क्रम (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) अणु
				pos += store_gcov_u64(buffer, pos,
						      ci_ptr->values[cv_idx]);
			पूर्ण

			ci_ptr++;
		पूर्ण
	पूर्ण

	वापस pos;
पूर्ण
