<शैली गुरु>
/*
 * Copyright 2016 Intel Corp.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modअगरy, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to करो so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#अगर_अघोषित _DRM_VBLANK_H_
#घोषणा _DRM_VBLANK_H_

#समावेश <linux/seqlock.h>
#समावेश <linux/idr.h>
#समावेश <linux/poll.h>
#समावेश <linux/kthपढ़ो.h>

#समावेश <drm/drm_file.h>
#समावेश <drm/drm_modes.h>

काष्ठा drm_device;
काष्ठा drm_crtc;
काष्ठा drm_vblank_work;

/**
 * काष्ठा drm_pending_vblank_event - pending vblank event tracking
 */
काष्ठा drm_pending_vblank_event अणु
	/**
	 * @base: Base काष्ठाure क्रम tracking pending DRM events.
	 */
	काष्ठा drm_pending_event base;
	/**
	 * @pipe: drm_crtc_index() of the &drm_crtc this event is क्रम.
	 */
	अचिन्हित पूर्णांक pipe;
	/**
	 * @sequence: frame event should be triggered at
	 */
	u64 sequence;
	/**
	 * @event: Actual event which will be sent to userspace.
	 */
	जोड़ अणु
		/**
		 * @event.base: DRM event base class.
		 */
		काष्ठा drm_event base;

		/**
		 * @event.vbl:
		 *
		 * Event payload क्रम vblank events, requested through
		 * either the MODE_PAGE_FLIP or MODE_ATOMIC IOCTL. Also
		 * generated by the legacy WAIT_VBLANK IOCTL, but new userspace
		 * should use MODE_QUEUE_SEQUENCE and &event.seq instead.
		 */
		काष्ठा drm_event_vblank vbl;

		/**
		 * @event.seq: Event payload क्रम the MODE_QUEUEU_SEQUENCE IOCTL.
		 */
		काष्ठा drm_event_crtc_sequence seq;
	पूर्ण event;
पूर्ण;

/**
 * काष्ठा drm_vblank_crtc - vblank tracking क्रम a CRTC
 *
 * This काष्ठाure tracks the vblank state क्रम one CRTC.
 *
 * Note that क्रम historical reasons - the vblank handling code is still shared
 * with legacy/non-kms drivers - this is a मुक्त-standing काष्ठाure not directly
 * connected to &काष्ठा drm_crtc. But all खुला पूर्णांकerface functions are taking
 * a &काष्ठा drm_crtc to hide this implementation detail.
 */
काष्ठा drm_vblank_crtc अणु
	/**
	 * @dev: Poपूर्णांकer to the &drm_device.
	 */
	काष्ठा drm_device *dev;
	/**
	 * @queue: Wait queue क्रम vblank रुकोers.
	 */
	रुको_queue_head_t queue;
	/**
	 * @disable_समयr: Disable समयr क्रम the delayed vblank disabling
	 * hysteresis logic. Vblank disabling is controlled through the
	 * drm_vblank_offdelay module option and the setting of the
	 * &drm_device.max_vblank_count value.
	 */
	काष्ठा समयr_list disable_समयr;

	/**
	 * @seqlock: Protect vblank count and समय.
	 */
	seqlock_t seqlock;

	/**
	 * @count:
	 *
	 * Current software vblank counter.
	 *
	 * Note that क्रम a given vblank counter value drm_crtc_handle_vblank()
	 * and drm_crtc_vblank_count() or drm_crtc_vblank_count_and_समय()
	 * provide a barrier: Any ग_लिखोs करोne beक्रमe calling
	 * drm_crtc_handle_vblank() will be visible to callers of the later
	 * functions, अगरf the vblank count is the same or a later one.
	 *
	 * IMPORTANT: This guarantee requires barriers, thereक्रम never access
	 * this field directly. Use drm_crtc_vblank_count() instead.
	 */
	atomic64_t count;
	/**
	 * @समय: Vblank बारtamp corresponding to @count.
	 */
	kसमय_प्रकार समय;

	/**
	 * @refcount: Number of users/रुकोers of the vblank पूर्णांकerrupt. Only when
	 * this refcount reaches 0 can the hardware पूर्णांकerrupt be disabled using
	 * @disable_समयr.
	 */
	atomic_t refcount;
	/**
	 * @last: Protected by &drm_device.vbl_lock, used क्रम wraparound handling.
	 */
	u32 last;
	/**
	 * @max_vblank_count:
	 *
	 * Maximum value of the vblank रेजिस्टरs क्रम this crtc. This value +1
	 * will result in a wrap-around of the vblank रेजिस्टर. It is used
	 * by the vblank core to handle wrap-arounds.
	 *
	 * If set to zero the vblank core will try to guess the elapsed vblanks
	 * between बार when the vblank पूर्णांकerrupt is disabled through
	 * high-precision बारtamps. That approach is suffering from small
	 * races and imprecision over दीर्घer समय periods, hence exposing a
	 * hardware vblank counter is always recommended.
	 *
	 * This is the runसमय configurable per-crtc maximum set through
	 * drm_crtc_set_max_vblank_count(). If this is used the driver
	 * must leave the device wide &drm_device.max_vblank_count at zero.
	 *
	 * If non-zero, &drm_crtc_funcs.get_vblank_counter must be set.
	 */
	u32 max_vblank_count;
	/**
	 * @inmodeset: Tracks whether the vblank is disabled due to a modeset.
	 * For legacy driver bit 2 additionally tracks whether an additional
	 * temporary vblank reference has been acquired to paper over the
	 * hardware counter resetting/jumping. KMS drivers should instead just
	 * call drm_crtc_vblank_off() and drm_crtc_vblank_on(), which explicitly
	 * save and restore the vblank count.
	 */
	अचिन्हित पूर्णांक inmodeset;
	/**
	 * @pipe: drm_crtc_index() of the &drm_crtc corresponding to this
	 * काष्ठाure.
	 */
	अचिन्हित पूर्णांक pipe;
	/**
	 * @framedur_ns: Frame/Field duration in ns, used by
	 * drm_crtc_vblank_helper_get_vblank_बारtamp() and computed by
	 * drm_calc_बारtamping_स्थिरants().
	 */
	पूर्णांक framedur_ns;
	/**
	 * @linedur_ns: Line duration in ns, used by
	 * drm_crtc_vblank_helper_get_vblank_बारtamp() and computed by
	 * drm_calc_बारtamping_स्थिरants().
	 */
	पूर्णांक linedur_ns;

	/**
	 * @hwmode:
	 *
	 * Cache of the current hardware display mode. Only valid when @enabled
	 * is set. This is used by helpers like
	 * drm_crtc_vblank_helper_get_vblank_बारtamp(). We can't just access
	 * the hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
	 * because that one is really hard to get from पूर्णांकerrupt context.
	 */
	काष्ठा drm_display_mode hwmode;

	/**
	 * @enabled: Tracks the enabling state of the corresponding &drm_crtc to
	 * aव्योम द्विगुन-disabling and hence corrupting saved state. Needed by
	 * drivers not using atomic KMS, since those might go through their CRTC
	 * disabling functions multiple बार.
	 */
	bool enabled;

	/**
	 * @worker: The &kthपढ़ो_worker used क्रम executing vblank works.
	 */
	काष्ठा kthपढ़ो_worker *worker;

	/**
	 * @pending_work: A list of scheduled &drm_vblank_work items that are
	 * रुकोing क्रम a future vblank.
	 */
	काष्ठा list_head pending_work;

	/**
	 * @work_रुको_queue: The रुको queue used क्रम संकेतing that a
	 * &drm_vblank_work item has either finished executing, or was
	 * cancelled.
	 */
	रुको_queue_head_t work_रुको_queue;
पूर्ण;

पूर्णांक drm_vblank_init(काष्ठा drm_device *dev, अचिन्हित पूर्णांक num_crtcs);
bool drm_dev_has_vblank(स्थिर काष्ठा drm_device *dev);
u64 drm_crtc_vblank_count(काष्ठा drm_crtc *crtc);
u64 drm_crtc_vblank_count_and_समय(काष्ठा drm_crtc *crtc,
				   kसमय_प्रकार *vblankसमय);
व्योम drm_crtc_send_vblank_event(काष्ठा drm_crtc *crtc,
			       काष्ठा drm_pending_vblank_event *e);
व्योम drm_crtc_arm_vblank_event(काष्ठा drm_crtc *crtc,
			      काष्ठा drm_pending_vblank_event *e);
व्योम drm_vblank_set_event(काष्ठा drm_pending_vblank_event *e,
			  u64 *seq,
			  kसमय_प्रकार *now);
bool drm_handle_vblank(काष्ठा drm_device *dev, अचिन्हित पूर्णांक pipe);
bool drm_crtc_handle_vblank(काष्ठा drm_crtc *crtc);
पूर्णांक drm_crtc_vblank_get(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_vblank_put(काष्ठा drm_crtc *crtc);
व्योम drm_रुको_one_vblank(काष्ठा drm_device *dev, अचिन्हित पूर्णांक pipe);
व्योम drm_crtc_रुको_one_vblank(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_vblank_off(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_vblank_reset(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_vblank_on(काष्ठा drm_crtc *crtc);
u64 drm_crtc_accurate_vblank_count(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_vblank_restore(काष्ठा drm_crtc *crtc);

व्योम drm_calc_बारtamping_स्थिरants(काष्ठा drm_crtc *crtc,
				     स्थिर काष्ठा drm_display_mode *mode);
रुको_queue_head_t *drm_crtc_vblank_रुकोqueue(काष्ठा drm_crtc *crtc);
व्योम drm_crtc_set_max_vblank_count(काष्ठा drm_crtc *crtc,
				   u32 max_vblank_count);

/*
 * Helpers क्रम काष्ठा drm_crtc_funcs
 */

प्रकार bool (*drm_vblank_get_scanout_position_func)(काष्ठा drm_crtc *crtc,
						     bool in_vblank_irq,
						     पूर्णांक *vpos, पूर्णांक *hpos,
						     kसमय_प्रकार *sसमय,
						     kसमय_प्रकार *eसमय,
						     स्थिर काष्ठा drm_display_mode *mode);

bool
drm_crtc_vblank_helper_get_vblank_बारtamp_पूर्णांकernal(काष्ठा drm_crtc *crtc,
						     पूर्णांक *max_error,
						     kसमय_प्रकार *vblank_समय,
						     bool in_vblank_irq,
						     drm_vblank_get_scanout_position_func get_scanout_position);
bool drm_crtc_vblank_helper_get_vblank_बारtamp(काष्ठा drm_crtc *crtc,
						 पूर्णांक *max_error,
						 kसमय_प्रकार *vblank_समय,
						 bool in_vblank_irq);

#पूर्ण_अगर
