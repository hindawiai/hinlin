<शैली गुरु>
/*
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, मुक्त of अक्षरge, to any person obtaining a
 * copy of this software and associated करोcumentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modअगरy, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to करो so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#अगर_अघोषित _UAPI_I915_DRM_H_
#घोषणा _UAPI_I915_DRM_H_

#समावेश "drm.h"

#अगर defined(__cplusplus)
बाह्य "C" अणु
#पूर्ण_अगर

/* Please note that modअगरications to all काष्ठाs defined here are
 * subject to backwards-compatibility स्थिरraपूर्णांकs.
 */

/**
 * DOC: uevents generated by i915 on it's device node
 *
 * I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch
 *	event from the gpu l3 cache. Additional inक्रमmation supplied is ROW,
 *	BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
 *	track of these events and अगर a specअगरic cache-line seems to have a
 *	persistent error remap it with the l3 remapping tool supplied in
 *	पूर्णांकel-gpu-tools.  The value supplied with the event is always 1.
 *
 * I915_ERROR_UEVENT - Generated upon error detection, currently only via
 *	hangcheck. The error detection event is a good indicator of when things
 *	began to go badly. The value supplied with the event is a 1 upon error
 *	detection, and a 0 upon reset completion, signअगरying no more error
 *	exists. NOTE: Disabling hangcheck or reset via module parameter will
 *	cause the related events to not be seen.
 *
 * I915_RESET_UEVENT - Event is generated just beक्रमe an attempt to reset the
 *	GPU. The value supplied with the event is always 1. NOTE: Disable
 *	reset via module parameter will cause this event to not be seen.
 */
#घोषणा I915_L3_PARITY_UEVENT		"L3_PARITY_ERROR"
#घोषणा I915_ERROR_UEVENT		"ERROR"
#घोषणा I915_RESET_UEVENT		"RESET"

/*
 * i915_user_extension: Base class क्रम defining a chain of extensions
 *
 * Many पूर्णांकerfaces need to grow over समय. In most हालs we can simply
 * extend the काष्ठा and have userspace pass in more data. Another option,
 * as demonstrated by Vulkan's approach to providing extensions क्रम क्रमward
 * and backward compatibility, is to use a list of optional काष्ठाs to
 * provide those extra details.
 *
 * The key advantage to using an extension chain is that it allows us to
 * redefine the पूर्णांकerface more easily than an ever growing काष्ठा of
 * increasing complनिकासy, and क्रम large parts of that पूर्णांकerface to be
 * entirely optional. The करोwnside is more poपूर्णांकer chasing; chasing across
 * the __user boundary with poपूर्णांकers encapsulated inside u64.
 */
काष्ठा i915_user_extension अणु
	__u64 next_extension;
	__u32 name;
	__u32 flags; /* All undefined bits must be zero. */
	__u32 rsvd[4]; /* Reserved क्रम future use; must be zero. */
पूर्ण;

/*
 * MOCS indexes used क्रम GPU surfaces, defining the cacheability of the
 * surface data and the coherency क्रम this data wrt. CPU vs. GPU accesses.
 */
क्रमागत i915_mocs_table_index अणु
	/*
	 * Not cached anywhere, coherency between CPU and GPU accesses is
	 * guaranteed.
	 */
	I915_MOCS_UNCACHED,
	/*
	 * Cacheability and coherency controlled by the kernel स्वतःmatically
	 * based on the DRM_I915_GEM_SET_CACHING IOCTL setting and the current
	 * usage of the surface (used क्रम display scanout or not).
	 */
	I915_MOCS_PTE,
	/*
	 * Cached in all GPU caches available on the platक्रमm.
	 * Coherency between CPU and GPU accesses to the surface is not
	 * guaranteed without extra synchronization.
	 */
	I915_MOCS_CACHED,
पूर्ण;

/*
 * Dअगरferent engines serve dअगरferent roles, and there may be more than one
 * engine serving each role. क्रमागत drm_i915_gem_engine_class provides a
 * classअगरication of the role of the engine, which may be used when requesting
 * operations to be perक्रमmed on a certain subset of engines, or क्रम providing
 * inक्रमmation about that group.
 */
क्रमागत drm_i915_gem_engine_class अणु
	I915_ENGINE_CLASS_RENDER	= 0,
	I915_ENGINE_CLASS_COPY		= 1,
	I915_ENGINE_CLASS_VIDEO		= 2,
	I915_ENGINE_CLASS_VIDEO_ENHANCE	= 3,

	/* should be kept compact */

	I915_ENGINE_CLASS_INVALID	= -1
पूर्ण;

/*
 * There may be more than one engine fulfilling any role within the प्रणाली.
 * Each engine of a class is given a unique instance number and thereक्रमe
 * any engine can be specअगरied by its class:instance tuplet. APIs that allow
 * access to any engine in the प्रणाली will use काष्ठा i915_engine_class_instance
 * क्रम this identअगरication.
 */
काष्ठा i915_engine_class_instance अणु
	__u16 engine_class; /* see क्रमागत drm_i915_gem_engine_class */
	__u16 engine_instance;
#घोषणा I915_ENGINE_CLASS_INVALID_NONE -1
#घोषणा I915_ENGINE_CLASS_INVALID_VIRTUAL -2
पूर्ण;

/**
 * DOC: perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915
 *
 */

क्रमागत drm_i915_pmu_engine_sample अणु
	I915_SAMPLE_BUSY = 0,
	I915_SAMPLE_WAIT = 1,
	I915_SAMPLE_SEMA = 2
पूर्ण;

#घोषणा I915_PMU_SAMPLE_BITS (4)
#घोषणा I915_PMU_SAMPLE_MASK (0xf)
#घोषणा I915_PMU_SAMPLE_INSTANCE_BITS (8)
#घोषणा I915_PMU_CLASS_SHIFT \
	(I915_PMU_SAMPLE_BITS + I915_PMU_SAMPLE_INSTANCE_BITS)

#घोषणा __I915_PMU_ENGINE(class, instance, sample) \
	((class) << I915_PMU_CLASS_SHIFT | \
	(instance) << I915_PMU_SAMPLE_BITS | \
	(sample))

#घोषणा I915_PMU_ENGINE_BUSY(class, instance) \
	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_BUSY)

#घोषणा I915_PMU_ENGINE_WAIT(class, instance) \
	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_WAIT)

#घोषणा I915_PMU_ENGINE_SEMA(class, instance) \
	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_SEMA)

#घोषणा __I915_PMU_OTHER(x) (__I915_PMU_ENGINE(0xff, 0xff, 0xf) + 1 + (x))

#घोषणा I915_PMU_ACTUAL_FREQUENCY	__I915_PMU_OTHER(0)
#घोषणा I915_PMU_REQUESTED_FREQUENCY	__I915_PMU_OTHER(1)
#घोषणा I915_PMU_INTERRUPTS		__I915_PMU_OTHER(2)
#घोषणा I915_PMU_RC6_RESIDENCY		__I915_PMU_OTHER(3)
#घोषणा I915_PMU_SOFTWARE_GT_AWAKE_TIME	__I915_PMU_OTHER(4)

#घोषणा I915_PMU_LAST /* Deprecated - करो not use */ I915_PMU_RC6_RESIDENCY

/* Each region is a minimum of 16k, and there are at most 255 of them.
 */
#घोषणा I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use
				 * of अक्षरs क्रम next/prev indices */
#घोषणा I915_LOG_MIN_TEX_REGION_SIZE 14

प्रकार काष्ठा _drm_i915_init अणु
	क्रमागत अणु
		I915_INIT_DMA = 0x01,
		I915_CLEANUP_DMA = 0x02,
		I915_RESUME_DMA = 0x03
	पूर्ण func;
	अचिन्हित पूर्णांक mmio_offset;
	पूर्णांक sarea_priv_offset;
	अचिन्हित पूर्णांक ring_start;
	अचिन्हित पूर्णांक ring_end;
	अचिन्हित पूर्णांक ring_size;
	अचिन्हित पूर्णांक front_offset;
	अचिन्हित पूर्णांक back_offset;
	अचिन्हित पूर्णांक depth_offset;
	अचिन्हित पूर्णांक w;
	अचिन्हित पूर्णांक h;
	अचिन्हित पूर्णांक pitch;
	अचिन्हित पूर्णांक pitch_bits;
	अचिन्हित पूर्णांक back_pitch;
	अचिन्हित पूर्णांक depth_pitch;
	अचिन्हित पूर्णांक cpp;
	अचिन्हित पूर्णांक chipset;
पूर्ण drm_i915_init_t;

प्रकार काष्ठा _drm_i915_sarea अणु
	काष्ठा drm_tex_region texList[I915_NR_TEX_REGIONS + 1];
	पूर्णांक last_upload;	/* last समय texture was uploaded */
	पूर्णांक last_enqueue;	/* last समय a buffer was enqueued */
	पूर्णांक last_dispatch;	/* age of the most recently dispatched buffer */
	पूर्णांक ctxOwner;		/* last context to upload state */
	पूर्णांक texAge;
	पूर्णांक pf_enabled;		/* is pageflipping allowed? */
	पूर्णांक pf_active;
	पूर्णांक pf_current_page;	/* which buffer is being displayed? */
	पूर्णांक perf_boxes;		/* perक्रमmance boxes to be displayed */
	पूर्णांक width, height;      /* screen size in pixels */

	drm_handle_t front_handle;
	पूर्णांक front_offset;
	पूर्णांक front_size;

	drm_handle_t back_handle;
	पूर्णांक back_offset;
	पूर्णांक back_size;

	drm_handle_t depth_handle;
	पूर्णांक depth_offset;
	पूर्णांक depth_size;

	drm_handle_t tex_handle;
	पूर्णांक tex_offset;
	पूर्णांक tex_size;
	पूर्णांक log_tex_granularity;
	पूर्णांक pitch;
	पूर्णांक rotation;           /* 0, 90, 180 or 270 */
	पूर्णांक rotated_offset;
	पूर्णांक rotated_size;
	पूर्णांक rotated_pitch;
	पूर्णांक भवX, भवY;

	अचिन्हित पूर्णांक front_tiled;
	अचिन्हित पूर्णांक back_tiled;
	अचिन्हित पूर्णांक depth_tiled;
	अचिन्हित पूर्णांक rotated_tiled;
	अचिन्हित पूर्णांक rotated2_tiled;

	पूर्णांक pipeA_x;
	पूर्णांक pipeA_y;
	पूर्णांक pipeA_w;
	पूर्णांक pipeA_h;
	पूर्णांक pipeB_x;
	पूर्णांक pipeB_y;
	पूर्णांक pipeB_w;
	पूर्णांक pipeB_h;

	/* fill out some space क्रम old userspace triple buffer */
	drm_handle_t unused_handle;
	__u32 unused1, unused2, unused3;

	/* buffer object handles क्रम अटल buffers. May change
	 * over the lअगरeसमय of the client.
	 */
	__u32 front_bo_handle;
	__u32 back_bo_handle;
	__u32 unused_bo_handle;
	__u32 depth_bo_handle;

पूर्ण drm_i915_sarea_t;

/* due to userspace building against these headers we need some compat here */
#घोषणा planeA_x pipeA_x
#घोषणा planeA_y pipeA_y
#घोषणा planeA_w pipeA_w
#घोषणा planeA_h pipeA_h
#घोषणा planeB_x pipeB_x
#घोषणा planeB_y pipeB_y
#घोषणा planeB_w pipeB_w
#घोषणा planeB_h pipeB_h

/* Flags क्रम perf_boxes
 */
#घोषणा I915_BOX_RING_EMPTY    0x1
#घोषणा I915_BOX_FLIP          0x2
#घोषणा I915_BOX_WAIT          0x4
#घोषणा I915_BOX_TEXTURE_LOAD  0x8
#घोषणा I915_BOX_LOST_CONTEXT  0x10

/*
 * i915 specअगरic ioctls.
 *
 * The device specअगरic ioctl range is [DRM_COMMAND_BASE, DRM_COMMAND_END) ie
 * [0x40, 0xa0) (a0 is excluded). The numbers below are defined as offset
 * against DRM_COMMAND_BASE and should be between [0x0, 0x60).
 */
#घोषणा DRM_I915_INIT		0x00
#घोषणा DRM_I915_FLUSH		0x01
#घोषणा DRM_I915_FLIP		0x02
#घोषणा DRM_I915_BATCHBUFFER	0x03
#घोषणा DRM_I915_IRQ_EMIT	0x04
#घोषणा DRM_I915_IRQ_WAIT	0x05
#घोषणा DRM_I915_GETPARAM	0x06
#घोषणा DRM_I915_SETPARAM	0x07
#घोषणा DRM_I915_ALLOC		0x08
#घोषणा DRM_I915_FREE		0x09
#घोषणा DRM_I915_INIT_HEAP	0x0a
#घोषणा DRM_I915_CMDBUFFER	0x0b
#घोषणा DRM_I915_DESTROY_HEAP	0x0c
#घोषणा DRM_I915_SET_VBLANK_PIPE	0x0d
#घोषणा DRM_I915_GET_VBLANK_PIPE	0x0e
#घोषणा DRM_I915_VBLANK_SWAP	0x0f
#घोषणा DRM_I915_HWS_ADDR	0x11
#घोषणा DRM_I915_GEM_INIT	0x13
#घोषणा DRM_I915_GEM_EXECBUFFER	0x14
#घोषणा DRM_I915_GEM_PIN	0x15
#घोषणा DRM_I915_GEM_UNPIN	0x16
#घोषणा DRM_I915_GEM_BUSY	0x17
#घोषणा DRM_I915_GEM_THROTTLE	0x18
#घोषणा DRM_I915_GEM_ENTERVT	0x19
#घोषणा DRM_I915_GEM_LEAVEVT	0x1a
#घोषणा DRM_I915_GEM_CREATE	0x1b
#घोषणा DRM_I915_GEM_PREAD	0x1c
#घोषणा DRM_I915_GEM_PWRITE	0x1d
#घोषणा DRM_I915_GEM_MMAP	0x1e
#घोषणा DRM_I915_GEM_SET_DOMAIN	0x1f
#घोषणा DRM_I915_GEM_SW_FINISH	0x20
#घोषणा DRM_I915_GEM_SET_TILING	0x21
#घोषणा DRM_I915_GEM_GET_TILING	0x22
#घोषणा DRM_I915_GEM_GET_APERTURE 0x23
#घोषणा DRM_I915_GEM_MMAP_GTT	0x24
#घोषणा DRM_I915_GET_PIPE_FROM_CRTC_ID	0x25
#घोषणा DRM_I915_GEM_MADVISE	0x26
#घोषणा DRM_I915_OVERLAY_PUT_IMAGE	0x27
#घोषणा DRM_I915_OVERLAY_ATTRS	0x28
#घोषणा DRM_I915_GEM_EXECBUFFER2	0x29
#घोषणा DRM_I915_GEM_EXECBUFFER2_WR	DRM_I915_GEM_EXECBUFFER2
#घोषणा DRM_I915_GET_SPRITE_COLORKEY	0x2a
#घोषणा DRM_I915_SET_SPRITE_COLORKEY	0x2b
#घोषणा DRM_I915_GEM_WAIT	0x2c
#घोषणा DRM_I915_GEM_CONTEXT_CREATE	0x2d
#घोषणा DRM_I915_GEM_CONTEXT_DESTROY	0x2e
#घोषणा DRM_I915_GEM_SET_CACHING	0x2f
#घोषणा DRM_I915_GEM_GET_CACHING	0x30
#घोषणा DRM_I915_REG_READ		0x31
#घोषणा DRM_I915_GET_RESET_STATS	0x32
#घोषणा DRM_I915_GEM_USERPTR		0x33
#घोषणा DRM_I915_GEM_CONTEXT_GETPARAM	0x34
#घोषणा DRM_I915_GEM_CONTEXT_SETPARAM	0x35
#घोषणा DRM_I915_PERF_OPEN		0x36
#घोषणा DRM_I915_PERF_ADD_CONFIG	0x37
#घोषणा DRM_I915_PERF_REMOVE_CONFIG	0x38
#घोषणा DRM_I915_QUERY			0x39
#घोषणा DRM_I915_GEM_VM_CREATE		0x3a
#घोषणा DRM_I915_GEM_VM_DESTROY		0x3b
/* Must be kept compact -- no holes */

#घोषणा DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
#घोषणा DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
#घोषणा DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
#घोषणा DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)
#घोषणा DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)
#घोषणा DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_रुको_t)
#घोषणा DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)
#घोषणा DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)
#घोषणा DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)
#घोषणा DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_मुक्त_t)
#घोषणा DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)
#घोषणा DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)
#घोषणा DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)
#घोषणा DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
#घोषणा DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
#घोषणा DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
#घोषणा DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, काष्ठा drm_i915_gem_init)
#घोषणा DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, काष्ठा drm_i915_gem_init)
#घोषणा DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, काष्ठा drm_i915_gem_execbuffer)
#घोषणा DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, काष्ठा drm_i915_gem_execbuffer2)
#घोषणा DRM_IOCTL_I915_GEM_EXECBUFFER2_WR	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2_WR, काष्ठा drm_i915_gem_execbuffer2)
#घोषणा DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, काष्ठा drm_i915_gem_pin)
#घोषणा DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, काष्ठा drm_i915_gem_unpin)
#घोषणा DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, काष्ठा drm_i915_gem_busy)
#घोषणा DRM_IOCTL_I915_GEM_SET_CACHING		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_SET_CACHING, काष्ठा drm_i915_gem_caching)
#घोषणा DRM_IOCTL_I915_GEM_GET_CACHING		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_GET_CACHING, काष्ठा drm_i915_gem_caching)
#घोषणा DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)
#घोषणा DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)
#घोषणा DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)
#घोषणा DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, काष्ठा drm_i915_gem_create)
#घोषणा DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, काष्ठा drm_i915_gem_pपढ़ो)
#घोषणा DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, काष्ठा drm_i915_gem_pग_लिखो)
#घोषणा DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, काष्ठा drm_i915_gem_mmap)
#घोषणा DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, काष्ठा drm_i915_gem_mmap_gtt)
#घोषणा DRM_IOCTL_I915_GEM_MMAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, काष्ठा drm_i915_gem_mmap_offset)
#घोषणा DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, काष्ठा drm_i915_gem_set_करोमुख्य)
#घोषणा DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, काष्ठा drm_i915_gem_sw_finish)
#घोषणा DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, काष्ठा drm_i915_gem_set_tiling)
#घोषणा DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, काष्ठा drm_i915_gem_get_tiling)
#घोषणा DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, काष्ठा drm_i915_gem_get_aperture)
#घोषणा DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, काष्ठा drm_i915_get_pipe_from_crtc_id)
#घोषणा DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, काष्ठा drm_i915_gem_madvise)
#घोषणा DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, काष्ठा drm_पूर्णांकel_overlay_put_image)
#घोषणा DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, काष्ठा drm_पूर्णांकel_overlay_attrs)
#घोषणा DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, काष्ठा drm_पूर्णांकel_sprite_colorkey)
#घोषणा DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_SPRITE_COLORKEY, काष्ठा drm_पूर्णांकel_sprite_colorkey)
#घोषणा DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, काष्ठा drm_i915_gem_रुको)
#घोषणा DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, काष्ठा drm_i915_gem_context_create)
#घोषणा DRM_IOCTL_I915_GEM_CONTEXT_CREATE_EXT	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, काष्ठा drm_i915_gem_context_create_ext)
#घोषणा DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, काष्ठा drm_i915_gem_context_destroy)
#घोषणा DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, काष्ठा drm_i915_reg_पढ़ो)
#घोषणा DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, काष्ठा drm_i915_reset_stats)
#घोषणा DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, काष्ठा drm_i915_gem_userptr)
#घोषणा DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_GETPARAM, काष्ठा drm_i915_gem_context_param)
#घोषणा DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, काष्ठा drm_i915_gem_context_param)
#घोषणा DRM_IOCTL_I915_PERF_OPEN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_OPEN, काष्ठा drm_i915_perf_खोलो_param)
#घोषणा DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, काष्ठा drm_i915_perf_oa_config)
#घोषणा DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
#घोषणा DRM_IOCTL_I915_QUERY			DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_QUERY, काष्ठा drm_i915_query)
#घोषणा DRM_IOCTL_I915_GEM_VM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_VM_CREATE, काष्ठा drm_i915_gem_vm_control)
#घोषणा DRM_IOCTL_I915_GEM_VM_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_VM_DESTROY, काष्ठा drm_i915_gem_vm_control)

/* Allow drivers to submit batchbuffers directly to hardware, relying
 * on the security mechanisms provided by hardware.
 */
प्रकार काष्ठा drm_i915_batchbuffer अणु
	पूर्णांक start;		/* agp offset */
	पूर्णांक used;		/* nr bytes in use */
	पूर्णांक DR1;		/* hw flags क्रम GFX_OP_DRAWRECT_INFO */
	पूर्णांक DR4;		/* winकरोw origin क्रम GFX_OP_DRAWRECT_INFO */
	पूर्णांक num_cliprects;	/* mulitpass with multiple cliprects? */
	काष्ठा drm_clip_rect __user *cliprects;	/* poपूर्णांकer to userspace cliprects */
पूर्ण drm_i915_batchbuffer_t;

/* As above, but pass a poपूर्णांकer to userspace buffer which can be
 * validated by the kernel prior to sending to hardware.
 */
प्रकार काष्ठा _drm_i915_cmdbuffer अणु
	अक्षर __user *buf;	/* poपूर्णांकer to userspace command buffer */
	पूर्णांक sz;			/* nr bytes in buf */
	पूर्णांक DR1;		/* hw flags क्रम GFX_OP_DRAWRECT_INFO */
	पूर्णांक DR4;		/* winकरोw origin क्रम GFX_OP_DRAWRECT_INFO */
	पूर्णांक num_cliprects;	/* mulitpass with multiple cliprects? */
	काष्ठा drm_clip_rect __user *cliprects;	/* poपूर्णांकer to userspace cliprects */
पूर्ण drm_i915_cmdbuffer_t;

/* Userspace can request & रुको on irq's:
 */
प्रकार काष्ठा drm_i915_irq_emit अणु
	पूर्णांक __user *irq_seq;
पूर्ण drm_i915_irq_emit_t;

प्रकार काष्ठा drm_i915_irq_रुको अणु
	पूर्णांक irq_seq;
पूर्ण drm_i915_irq_रुको_t;

/*
 * Dअगरferent modes of per-process Graphics Translation Table,
 * see I915_PARAM_HAS_ALIASING_PPGTT
 */
#घोषणा I915_GEM_PPGTT_NONE	0
#घोषणा I915_GEM_PPGTT_ALIASING	1
#घोषणा I915_GEM_PPGTT_FULL	2

/* Ioctl to query kernel params:
 */
#घोषणा I915_PARAM_IRQ_ACTIVE            1
#घोषणा I915_PARAM_ALLOW_BATCHBUFFER     2
#घोषणा I915_PARAM_LAST_DISPATCH         3
#घोषणा I915_PARAM_CHIPSET_ID            4
#घोषणा I915_PARAM_HAS_GEM               5
#घोषणा I915_PARAM_NUM_FENCES_AVAIL      6
#घोषणा I915_PARAM_HAS_OVERLAY           7
#घोषणा I915_PARAM_HAS_PAGEFLIPPING	 8
#घोषणा I915_PARAM_HAS_EXECBUF2          9
#घोषणा I915_PARAM_HAS_BSD		 10
#घोषणा I915_PARAM_HAS_BLT		 11
#घोषणा I915_PARAM_HAS_RELAXED_FENCING	 12
#घोषणा I915_PARAM_HAS_COHERENT_RINGS	 13
#घोषणा I915_PARAM_HAS_EXEC_CONSTANTS	 14
#घोषणा I915_PARAM_HAS_RELAXED_DELTA	 15
#घोषणा I915_PARAM_HAS_GEN7_SOL_RESET	 16
#घोषणा I915_PARAM_HAS_LLC     	 	 17
#घोषणा I915_PARAM_HAS_ALIASING_PPGTT	 18
#घोषणा I915_PARAM_HAS_WAIT_TIMEOUT	 19
#घोषणा I915_PARAM_HAS_SEMAPHORES	 20
#घोषणा I915_PARAM_HAS_PRIME_VMAP_FLUSH	 21
#घोषणा I915_PARAM_HAS_VEBOX		 22
#घोषणा I915_PARAM_HAS_SECURE_BATCHES	 23
#घोषणा I915_PARAM_HAS_PINNED_BATCHES	 24
#घोषणा I915_PARAM_HAS_EXEC_NO_RELOC	 25
#घोषणा I915_PARAM_HAS_EXEC_HANDLE_LUT   26
#घोषणा I915_PARAM_HAS_WT     	 	 27
#घोषणा I915_PARAM_CMD_PARSER_VERSION	 28
#घोषणा I915_PARAM_HAS_COHERENT_PHYS_GTT 29
#घोषणा I915_PARAM_MMAP_VERSION          30
#घोषणा I915_PARAM_HAS_BSD2		 31
#घोषणा I915_PARAM_REVISION              32
#घोषणा I915_PARAM_SUBSLICE_TOTAL	 33
#घोषणा I915_PARAM_EU_TOTAL		 34
#घोषणा I915_PARAM_HAS_GPU_RESET	 35
#घोषणा I915_PARAM_HAS_RESOURCE_STREAMER 36
#घोषणा I915_PARAM_HAS_EXEC_SOFTPIN	 37
#घोषणा I915_PARAM_HAS_POOLED_EU	 38
#घोषणा I915_PARAM_MIN_EU_IN_POOL	 39
#घोषणा I915_PARAM_MMAP_GTT_VERSION	 40

/*
 * Query whether DRM_I915_GEM_EXECBUFFER2 supports user defined execution
 * priorities and the driver will attempt to execute batches in priority order.
 * The param वापसs a capability biपंचांगask, nonzero implies that the scheduler
 * is enabled, with dअगरferent features present according to the mask.
 *
 * The initial priority क्रम each batch is supplied by the context and is
 * controlled via I915_CONTEXT_PARAM_PRIORITY.
 */
#घोषणा I915_PARAM_HAS_SCHEDULER	 41
#घोषणा   I915_SCHEDULER_CAP_ENABLED	(1ul << 0)
#घोषणा   I915_SCHEDULER_CAP_PRIORITY	(1ul << 1)
#घोषणा   I915_SCHEDULER_CAP_PREEMPTION	(1ul << 2)
#घोषणा   I915_SCHEDULER_CAP_SEMAPHORES	(1ul << 3)
#घोषणा   I915_SCHEDULER_CAP_ENGINE_BUSY_STATS	(1ul << 4)

#घोषणा I915_PARAM_HUC_STATUS		 42

/* Query whether DRM_I915_GEM_EXECBUFFER2 supports the ability to opt-out of
 * synchronisation with implicit fencing on inभागidual objects.
 * See EXEC_OBJECT_ASYNC.
 */
#घोषणा I915_PARAM_HAS_EXEC_ASYNC	 43

/* Query whether DRM_I915_GEM_EXECBUFFER2 supports explicit fence support -
 * both being able to pass in a sync_file fd to रुको upon beक्रमe executing,
 * and being able to वापस a new sync_file fd that is संकेतed when the
 * current request is complete. See I915_EXEC_FENCE_IN and I915_EXEC_FENCE_OUT.
 */
#घोषणा I915_PARAM_HAS_EXEC_FENCE	 44

/* Query whether DRM_I915_GEM_EXECBUFFER2 supports the ability to capture
 * user specअगरied bufffers क्रम post-mortem debugging of GPU hangs. See
 * EXEC_OBJECT_CAPTURE.
 */
#घोषणा I915_PARAM_HAS_EXEC_CAPTURE	 45

#घोषणा I915_PARAM_SLICE_MASK		 46

/* Assuming it's unअगरorm क्रम each slice, this queries the mask of subslices
 * per-slice क्रम this प्रणाली.
 */
#घोषणा I915_PARAM_SUBSLICE_MASK	 47

/*
 * Query whether DRM_I915_GEM_EXECBUFFER2 supports supplying the batch buffer
 * as the first execobject as opposed to the last. See I915_EXEC_BATCH_FIRST.
 */
#घोषणा I915_PARAM_HAS_EXEC_BATCH_FIRST	 48

/* Query whether DRM_I915_GEM_EXECBUFFER2 supports supplying an array of
 * drm_i915_gem_exec_fence काष्ठाures.  See I915_EXEC_FENCE_ARRAY.
 */
#घोषणा I915_PARAM_HAS_EXEC_FENCE_ARRAY  49

/*
 * Query whether every context (both per-file शेष and user created) is
 * isolated (insofar as HW supports). If this parameter is not true, then
 * freshly created contexts may inherit values from an existing context,
 * rather than शेष HW values. If true, it also ensures (insofar as HW
 * supports) that all state set by this context will not leak to any other
 * context.
 *
 * As not every engine across every gen support contexts, the वापसed
 * value reports the support of context isolation क्रम inभागidual engines by
 * वापसing a biपंचांगask of each engine class set to true अगर that class supports
 * isolation.
 */
#घोषणा I915_PARAM_HAS_CONTEXT_ISOLATION 50

/* Frequency of the command streamer बारtamps given by the *_TIMESTAMP
 * रेजिस्टरs. This used to be fixed per platक्रमm but from CNL onwards, this
 * might vary depending on the parts.
 */
#घोषणा I915_PARAM_CS_TIMESTAMP_FREQUENCY 51

/*
 * Once upon a समय we supposed that ग_लिखोs through the GGTT would be
 * immediately in physical memory (once flushed out of the CPU path). However,
 * on a few dअगरferent processors and chipsets, this is not necessarily the हाल
 * as the ग_लिखोs appear to be buffered पूर्णांकernally. Thus a पढ़ो of the backing
 * storage (physical memory) via a dअगरferent path (with dअगरferent physical tags
 * to the indirect ग_लिखो via the GGTT) will see stale values from beक्रमe
 * the GGTT ग_लिखो. Inside the kernel, we can क्रम the most part keep track of
 * the dअगरferent पढ़ो/ग_लिखो करोमुख्यs in use (e.g. set-करोमुख्य), but the assumption
 * of coherency is baked पूर्णांकo the ABI, hence reporting its true state in this
 * parameter.
 *
 * Reports true when ग_लिखोs via mmap_gtt are immediately visible following an
 * lfence to flush the WCB.
 *
 * Reports false when ग_लिखोs via mmap_gtt are indeterminately delayed in an in
 * पूर्णांकernal buffer and are _not_ immediately visible to third parties accessing
 * directly via mmap_cpu/mmap_wc. Use of mmap_gtt as part of an IPC
 * communications channel when reporting false is strongly disadvised.
 */
#घोषणा I915_PARAM_MMAP_GTT_COHERENT	52

/*
 * Query whether DRM_I915_GEM_EXECBUFFER2 supports coordination of parallel
 * execution through use of explicit fence support.
 * See I915_EXEC_FENCE_OUT and I915_EXEC_FENCE_SUBMIT.
 */
#घोषणा I915_PARAM_HAS_EXEC_SUBMIT_FENCE 53

/*
 * Revision of the i915-perf uAPI. The value वापसed helps determine what
 * i915-perf features are available. See drm_i915_perf_property_id.
 */
#घोषणा I915_PARAM_PERF_REVISION	54

/* Query whether DRM_I915_GEM_EXECBUFFER2 supports supplying an array of
 * समयline syncobj through drm_i915_gem_execbuffer_ext_समयline_fences. See
 * I915_EXEC_USE_EXTENSIONS.
 */
#घोषणा I915_PARAM_HAS_EXEC_TIMELINE_FENCES 55

/* Must be kept compact -- no holes and well करोcumented */

प्रकार काष्ठा drm_i915_getparam अणु
	__s32 param;
	/*
	 * WARNING: Using poपूर्णांकers instead of fixed-size u64 means we need to ग_लिखो
	 * compat32 code. Don't repeat this mistake.
	 */
	पूर्णांक __user *value;
पूर्ण drm_i915_getparam_t;

/* Ioctl to set kernel params:
 */
#घोषणा I915_SETPARAM_USE_MI_BATCHBUFFER_START            1
#घोषणा I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2
#घोषणा I915_SETPARAM_ALLOW_BATCHBUFFER                   3
#घोषणा I915_SETPARAM_NUM_USED_FENCES                     4
/* Must be kept compact -- no holes */

प्रकार काष्ठा drm_i915_setparam अणु
	पूर्णांक param;
	पूर्णांक value;
पूर्ण drm_i915_setparam_t;

/* A memory manager क्रम regions of shared memory:
 */
#घोषणा I915_MEM_REGION_AGP 1

प्रकार काष्ठा drm_i915_mem_alloc अणु
	पूर्णांक region;
	पूर्णांक alignment;
	पूर्णांक size;
	पूर्णांक __user *region_offset;	/* offset from start of fb or agp */
पूर्ण drm_i915_mem_alloc_t;

प्रकार काष्ठा drm_i915_mem_मुक्त अणु
	पूर्णांक region;
	पूर्णांक region_offset;
पूर्ण drm_i915_mem_मुक्त_t;

प्रकार काष्ठा drm_i915_mem_init_heap अणु
	पूर्णांक region;
	पूर्णांक size;
	पूर्णांक start;
पूर्ण drm_i915_mem_init_heap_t;

/* Allow memory manager to be torn करोwn and re-initialized (eg on
 * rotate):
 */
प्रकार काष्ठा drm_i915_mem_destroy_heap अणु
	पूर्णांक region;
पूर्ण drm_i915_mem_destroy_heap_t;

/* Allow X server to configure which pipes to monitor क्रम vblank संकेतs
 */
#घोषणा	DRM_I915_VBLANK_PIPE_A	1
#घोषणा	DRM_I915_VBLANK_PIPE_B	2

प्रकार काष्ठा drm_i915_vblank_pipe अणु
	पूर्णांक pipe;
पूर्ण drm_i915_vblank_pipe_t;

/* Schedule buffer swap at given vertical blank:
 */
प्रकार काष्ठा drm_i915_vblank_swap अणु
	drm_drawable_t drawable;
	क्रमागत drm_vblank_seq_type seqtype;
	अचिन्हित पूर्णांक sequence;
पूर्ण drm_i915_vblank_swap_t;

प्रकार काष्ठा drm_i915_hws_addr अणु
	__u64 addr;
पूर्ण drm_i915_hws_addr_t;

काष्ठा drm_i915_gem_init अणु
	/**
	 * Beginning offset in the GTT to be managed by the DRM memory
	 * manager.
	 */
	__u64 gtt_start;
	/**
	 * Ending offset in the GTT to be managed by the DRM memory
	 * manager.
	 */
	__u64 gtt_end;
पूर्ण;

काष्ठा drm_i915_gem_create अणु
	/**
	 * Requested size क्रम the object.
	 *
	 * The (page-aligned) allocated size क्रम the object will be वापसed.
	 */
	__u64 size;
	/**
	 * Returned handle क्रम the object.
	 *
	 * Object handles are nonzero.
	 */
	__u32 handle;
	__u32 pad;
पूर्ण;

काष्ठा drm_i915_gem_pपढ़ो अणु
	/** Handle क्रम the object being पढ़ो. */
	__u32 handle;
	__u32 pad;
	/** Offset पूर्णांकo the object to पढ़ो from */
	__u64 offset;
	/** Length of data to पढ़ो */
	__u64 size;
	/**
	 * Poपूर्णांकer to ग_लिखो the data पूर्णांकo.
	 *
	 * This is a fixed-size type क्रम 32/64 compatibility.
	 */
	__u64 data_ptr;
पूर्ण;

काष्ठा drm_i915_gem_pग_लिखो अणु
	/** Handle क्रम the object being written to. */
	__u32 handle;
	__u32 pad;
	/** Offset पूर्णांकo the object to ग_लिखो to */
	__u64 offset;
	/** Length of data to ग_लिखो */
	__u64 size;
	/**
	 * Poपूर्णांकer to पढ़ो the data from.
	 *
	 * This is a fixed-size type क्रम 32/64 compatibility.
	 */
	__u64 data_ptr;
पूर्ण;

काष्ठा drm_i915_gem_mmap अणु
	/** Handle क्रम the object being mapped. */
	__u32 handle;
	__u32 pad;
	/** Offset in the object to map. */
	__u64 offset;
	/**
	 * Length of data to map.
	 *
	 * The value will be page-aligned.
	 */
	__u64 size;
	/**
	 * Returned poपूर्णांकer the data was mapped at.
	 *
	 * This is a fixed-size type क्रम 32/64 compatibility.
	 */
	__u64 addr_ptr;

	/**
	 * Flags क्रम extended behaviour.
	 *
	 * Added in version 2.
	 */
	__u64 flags;
#घोषणा I915_MMAP_WC 0x1
पूर्ण;

काष्ठा drm_i915_gem_mmap_gtt अणु
	/** Handle क्रम the object being mapped. */
	__u32 handle;
	__u32 pad;
	/**
	 * Fake offset to use क्रम subsequent mmap call
	 *
	 * This is a fixed-size type क्रम 32/64 compatibility.
	 */
	__u64 offset;
पूर्ण;

काष्ठा drm_i915_gem_mmap_offset अणु
	/** Handle क्रम the object being mapped. */
	__u32 handle;
	__u32 pad;
	/**
	 * Fake offset to use क्रम subsequent mmap call
	 *
	 * This is a fixed-size type क्रम 32/64 compatibility.
	 */
	__u64 offset;

	/**
	 * Flags क्रम extended behaviour.
	 *
	 * It is mandatory that one of the MMAP_OFFSET types
	 * (GTT, WC, WB, UC, etc) should be included.
	 */
	__u64 flags;
#घोषणा I915_MMAP_OFFSET_GTT 0
#घोषणा I915_MMAP_OFFSET_WC  1
#घोषणा I915_MMAP_OFFSET_WB  2
#घोषणा I915_MMAP_OFFSET_UC  3

	/*
	 * Zero-terminated chain of extensions.
	 *
	 * No current extensions defined; mbz.
	 */
	__u64 extensions;
पूर्ण;

काष्ठा drm_i915_gem_set_करोमुख्य अणु
	/** Handle क्रम the object */
	__u32 handle;

	/** New पढ़ो करोमुख्यs */
	__u32 पढ़ो_करोमुख्यs;

	/** New ग_लिखो करोमुख्य */
	__u32 ग_लिखो_करोमुख्य;
पूर्ण;

काष्ठा drm_i915_gem_sw_finish अणु
	/** Handle क्रम the object */
	__u32 handle;
पूर्ण;

काष्ठा drm_i915_gem_relocation_entry अणु
	/**
	 * Handle of the buffer being poपूर्णांकed to by this relocation entry.
	 *
	 * It's appealing to make this be an index पूर्णांकo the mm_validate_entry
	 * list to refer to the buffer, but this allows the driver to create
	 * a relocation list क्रम state buffers and not re-ग_लिखो it per
	 * exec using the buffer.
	 */
	__u32 target_handle;

	/**
	 * Value to be added to the offset of the target buffer to make up
	 * the relocation entry.
	 */
	__u32 delta;

	/** Offset in the buffer the relocation entry will be written पूर्णांकo */
	__u64 offset;

	/**
	 * Offset value of the target buffer that the relocation entry was last
	 * written as.
	 *
	 * If the buffer has the same offset as last समय, we can skip syncing
	 * and writing the relocation.  This value is written back out by
	 * the execbuffer ioctl when the relocation is written.
	 */
	__u64 presumed_offset;

	/**
	 * Target memory करोमुख्यs पढ़ो by this operation.
	 */
	__u32 पढ़ो_करोमुख्यs;

	/**
	 * Target memory करोमुख्यs written by this operation.
	 *
	 * Note that only one करोमुख्य may be written by the whole
	 * execbuffer operation, so that where there are conflicts,
	 * the application will get -EINVAL back.
	 */
	__u32 ग_लिखो_करोमुख्य;
पूर्ण;

/** @अणु
 * Intel memory करोमुख्यs
 *
 * Most of these just align with the various caches in
 * the प्रणाली and are used to flush and invalidate as
 * objects end up cached in dअगरferent करोमुख्यs.
 */
/** CPU cache */
#घोषणा I915_GEM_DOMAIN_CPU		0x00000001
/** Render cache, used by 2D and 3D drawing */
#घोषणा I915_GEM_DOMAIN_RENDER		0x00000002
/** Sampler cache, used by texture engine */
#घोषणा I915_GEM_DOMAIN_SAMPLER		0x00000004
/** Command queue, used to load batch buffers */
#घोषणा I915_GEM_DOMAIN_COMMAND		0x00000008
/** Inकाष्ठाion cache, used by shader programs */
#घोषणा I915_GEM_DOMAIN_INSTRUCTION	0x00000010
/** Vertex address cache */
#घोषणा I915_GEM_DOMAIN_VERTEX		0x00000020
/** GTT करोमुख्य - aperture and scanout */
#घोषणा I915_GEM_DOMAIN_GTT		0x00000040
/** WC करोमुख्य - uncached access */
#घोषणा I915_GEM_DOMAIN_WC		0x00000080
/** @पूर्ण */

काष्ठा drm_i915_gem_exec_object अणु
	/**
	 * User's handle क्रम a buffer to be bound पूर्णांकo the GTT क्रम this
	 * operation.
	 */
	__u32 handle;

	/** Number of relocations to be perक्रमmed on this buffer */
	__u32 relocation_count;
	/**
	 * Poपूर्णांकer to array of काष्ठा drm_i915_gem_relocation_entry containing
	 * the relocations to be perक्रमmed in this buffer.
	 */
	__u64 relocs_ptr;

	/** Required alignment in graphics aperture */
	__u64 alignment;

	/**
	 * Returned value of the updated offset of the object, क्रम future
	 * presumed_offset ग_लिखोs.
	 */
	__u64 offset;
पूर्ण;

/* DRM_IOCTL_I915_GEM_EXECBUFFER was हटाओd in Linux 5.13 */
काष्ठा drm_i915_gem_execbuffer अणु
	/**
	 * List of buffers to be validated with their relocations to be
	 * perक्रमmend on them.
	 *
	 * This is a poपूर्णांकer to an array of काष्ठा drm_i915_gem_validate_entry.
	 *
	 * These buffers must be listed in an order such that all relocations
	 * a buffer is perक्रमming refer to buffers that have alपढ़ोy appeared
	 * in the validate list.
	 */
	__u64 buffers_ptr;
	__u32 buffer_count;

	/** Offset in the batchbuffer to start execution from. */
	__u32 batch_start_offset;
	/** Bytes used in batchbuffer from batch_start_offset */
	__u32 batch_len;
	__u32 DR1;
	__u32 DR4;
	__u32 num_cliprects;
	/** This is a काष्ठा drm_clip_rect *cliprects */
	__u64 cliprects_ptr;
पूर्ण;

काष्ठा drm_i915_gem_exec_object2 अणु
	/**
	 * User's handle क्रम a buffer to be bound पूर्णांकo the GTT क्रम this
	 * operation.
	 */
	__u32 handle;

	/** Number of relocations to be perक्रमmed on this buffer */
	__u32 relocation_count;
	/**
	 * Poपूर्णांकer to array of काष्ठा drm_i915_gem_relocation_entry containing
	 * the relocations to be perक्रमmed in this buffer.
	 */
	__u64 relocs_ptr;

	/** Required alignment in graphics aperture */
	__u64 alignment;

	/**
	 * When the EXEC_OBJECT_PINNED flag is specअगरied this is populated by
	 * the user with the GTT offset at which this object will be pinned.
	 * When the I915_EXEC_NO_RELOC flag is specअगरied this must contain the
	 * presumed_offset of the object.
	 * During execbuffer2 the kernel populates it with the value of the
	 * current GTT offset of the object, क्रम future presumed_offset ग_लिखोs.
	 */
	__u64 offset;

#घोषणा EXEC_OBJECT_NEEDS_FENCE		 (1<<0)
#घोषणा EXEC_OBJECT_NEEDS_GTT		 (1<<1)
#घोषणा EXEC_OBJECT_WRITE		 (1<<2)
#घोषणा EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
#घोषणा EXEC_OBJECT_PINNED		 (1<<4)
#घोषणा EXEC_OBJECT_PAD_TO_SIZE		 (1<<5)
/* The kernel implicitly tracks GPU activity on all GEM objects, and
 * synchronises operations with outstanding rendering. This includes
 * rendering on other devices अगर exported via dma-buf. However, someबार
 * this tracking is too coarse and the user knows better. For example,
 * अगर the object is split पूर्णांकo non-overlapping ranges shared between dअगरferent
 * clients or engines (i.e. suballocating objects), the implicit tracking
 * by kernel assumes that each operation affects the whole object rather
 * than an inभागidual range, causing needless synchronisation between clients.
 * The kernel will also क्रमgo any CPU cache flushes prior to rendering from
 * the object as the client is expected to be also handling such करोमुख्य
 * tracking.
 *
 * The kernel मुख्यtains the implicit tracking in order to manage resources
 * used by the GPU - this flag only disables the synchronisation prior to
 * rendering with this object in this execbuf.
 *
 * Opting out of implicit synhronisation requires the user to करो its own
 * explicit tracking to aव्योम rendering corruption. See, क्रम example,
 * I915_PARAM_HAS_EXEC_FENCE to order execbufs and execute them asynchronously.
 */
#घोषणा EXEC_OBJECT_ASYNC		(1<<6)
/* Request that the contents of this execobject be copied पूर्णांकo the error
 * state upon a GPU hang involving this batch क्रम post-mortem debugging.
 * These buffers are recorded in no particular order as "user" in
 * /sys/class/drm/cardN/error. Query I915_PARAM_HAS_EXEC_CAPTURE to see
 * अगर the kernel supports this flag.
 */
#घोषणा EXEC_OBJECT_CAPTURE		(1<<7)
/* All reमुख्यing bits are MBZ and RESERVED FOR FUTURE USE */
#घोषणा __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_CAPTURE<<1)
	__u64 flags;

	जोड़ अणु
		__u64 rsvd1;
		__u64 pad_to_size;
	पूर्ण;
	__u64 rsvd2;
पूर्ण;

काष्ठा drm_i915_gem_exec_fence अणु
	/**
	 * User's handle क्रम a drm_syncobj to रुको on or संकेत.
	 */
	__u32 handle;

#घोषणा I915_EXEC_FENCE_WAIT            (1<<0)
#घोषणा I915_EXEC_FENCE_SIGNAL          (1<<1)
#घोषणा __I915_EXEC_FENCE_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_SIGNAL << 1))
	__u32 flags;
पूर्ण;

/**
 * See drm_i915_gem_execbuffer_ext_समयline_fences.
 */
#घोषणा DRM_I915_GEM_EXECBUFFER_EXT_TIMELINE_FENCES 0

/**
 * This काष्ठाure describes an array of drm_syncobj and associated poपूर्णांकs क्रम
 * समयline variants of drm_syncobj. It is invalid to append this काष्ठाure to
 * the execbuf अगर I915_EXEC_FENCE_ARRAY is set.
 */
काष्ठा drm_i915_gem_execbuffer_ext_समयline_fences अणु
	काष्ठा i915_user_extension base;

	/**
	 * Number of element in the handles_ptr & value_ptr arrays.
	 */
	__u64 fence_count;

	/**
	 * Poपूर्णांकer to an array of काष्ठा drm_i915_gem_exec_fence of length
	 * fence_count.
	 */
	__u64 handles_ptr;

	/**
	 * Poपूर्णांकer to an array of u64 values of length fence_count. Values
	 * must be 0 क्रम a binary drm_syncobj. A Value of 0 क्रम a समयline
	 * drm_syncobj is invalid as it turns a drm_syncobj पूर्णांकo a binary one.
	 */
	__u64 values_ptr;
पूर्ण;

काष्ठा drm_i915_gem_execbuffer2 अणु
	/**
	 * List of gem_exec_object2 काष्ठाs
	 */
	__u64 buffers_ptr;
	__u32 buffer_count;

	/** Offset in the batchbuffer to start execution from. */
	__u32 batch_start_offset;
	/** Bytes used in batchbuffer from batch_start_offset */
	__u32 batch_len;
	__u32 DR1;
	__u32 DR4;
	__u32 num_cliprects;
	/**
	 * This is a काष्ठा drm_clip_rect *cliprects अगर I915_EXEC_FENCE_ARRAY
	 * & I915_EXEC_USE_EXTENSIONS are not set.
	 *
	 * If I915_EXEC_FENCE_ARRAY is set, then this is a poपूर्णांकer to an array
	 * of काष्ठा drm_i915_gem_exec_fence and num_cliprects is the length
	 * of the array.
	 *
	 * If I915_EXEC_USE_EXTENSIONS is set, then this is a poपूर्णांकer to a
	 * single काष्ठा i915_user_extension and num_cliprects is 0.
	 */
	__u64 cliprects_ptr;
#घोषणा I915_EXEC_RING_MASK              (0x3f)
#घोषणा I915_EXEC_DEFAULT                (0<<0)
#घोषणा I915_EXEC_RENDER                 (1<<0)
#घोषणा I915_EXEC_BSD                    (2<<0)
#घोषणा I915_EXEC_BLT                    (3<<0)
#घोषणा I915_EXEC_VEBOX                  (4<<0)

/* Used क्रम चयनing the स्थिरants addressing mode on gen4+ RENDER ring.
 * Gen6+ only supports relative addressing to dynamic state (शेष) and
 * असलolute addressing.
 *
 * These flags are ignored क्रम the BSD and BLT rings.
 */
#घोषणा I915_EXEC_CONSTANTS_MASK 	(3<<6)
#घोषणा I915_EXEC_CONSTANTS_REL_GENERAL (0<<6) /* शेष */
#घोषणा I915_EXEC_CONSTANTS_ABSOLUTE 	(1<<6)
#घोषणा I915_EXEC_CONSTANTS_REL_SURFACE (2<<6) /* gen4/5 only */
	__u64 flags;
	__u64 rsvd1; /* now used क्रम context info */
	__u64 rsvd2;
पूर्ण;

/** Resets the SO ग_लिखो offset रेजिस्टरs क्रम transक्रमm feedback on gen7. */
#घोषणा I915_EXEC_GEN7_SOL_RESET	(1<<8)

/** Request a privileged ("secure") batch buffer. Note only available क्रम
 * DRM_ROOT_ONLY | DRM_MASTER processes.
 */
#घोषणा I915_EXEC_SECURE		(1<<9)

/** Inक्रमm the kernel that the batch is and will always be pinned. This
 * negates the requirement क्रम a workaround to be perक्रमmed to aव्योम
 * an incoherent CS (such as can be found on 830/845). If this flag is
 * not passed, the kernel will endeavour to make sure the batch is
 * coherent with the CS beक्रमe execution. If this flag is passed,
 * userspace assumes the responsibility क्रम ensuring the same.
 */
#घोषणा I915_EXEC_IS_PINNED		(1<<10)

/** Provide a hपूर्णांक to the kernel that the command stream and auxiliary
 * state buffers alपढ़ोy holds the correct presumed addresses and so the
 * relocation process may be skipped अगर no buffers need to be moved in
 * preparation क्रम the execbuffer.
 */
#घोषणा I915_EXEC_NO_RELOC		(1<<11)

/** Use the reloc.handle as an index पूर्णांकo the exec object array rather
 * than as the per-file handle.
 */
#घोषणा I915_EXEC_HANDLE_LUT		(1<<12)

/** Used क्रम चयनing BSD rings on the platक्रमms with two BSD rings */
#घोषणा I915_EXEC_BSD_SHIFT	 (13)
#घोषणा I915_EXEC_BSD_MASK	 (3 << I915_EXEC_BSD_SHIFT)
/* शेष ping-pong mode */
#घोषणा I915_EXEC_BSD_DEFAULT	 (0 << I915_EXEC_BSD_SHIFT)
#घोषणा I915_EXEC_BSD_RING1	 (1 << I915_EXEC_BSD_SHIFT)
#घोषणा I915_EXEC_BSD_RING2	 (2 << I915_EXEC_BSD_SHIFT)

/** Tell the kernel that the batchbuffer is processed by
 *  the resource streamer.
 */
#घोषणा I915_EXEC_RESOURCE_STREAMER     (1<<15)

/* Setting I915_EXEC_FENCE_IN implies that lower_32_bits(rsvd2) represent
 * a sync_file fd to रुको upon (in a nonblocking manner) prior to executing
 * the batch.
 *
 * Returns -EINVAL अगर the sync_file fd cannot be found.
 */
#घोषणा I915_EXEC_FENCE_IN		(1<<16)

/* Setting I915_EXEC_FENCE_OUT causes the ioctl to वापस a sync_file fd
 * in the upper_32_bits(rsvd2) upon success. Ownership of the fd is given
 * to the caller, and it should be बंद() after use. (The fd is a regular
 * file descriptor and will be cleaned up on process termination. It holds
 * a reference to the request, but nothing अन्यथा.)
 *
 * The sync_file fd can be combined with other sync_file and passed either
 * to execbuf using I915_EXEC_FENCE_IN, to atomic KMS ioctls (so that a flip
 * will only occur after this request completes), or to other devices.
 *
 * Using I915_EXEC_FENCE_OUT requires use of
 * DRM_IOCTL_I915_GEM_EXECBUFFER2_WR ioctl so that the result is written
 * back to userspace. Failure to करो so will cause the out-fence to always
 * be reported as zero, and the real fence fd to be leaked.
 */
#घोषणा I915_EXEC_FENCE_OUT		(1<<17)

/*
 * Traditionally the execbuf ioctl has only considered the final element in
 * the execobject[] to be the executable batch. Often though, the client
 * will known the batch object prior to स्थिरruction and being able to place
 * it पूर्णांकo the execobject[] array first can simplअगरy the relocation tracking.
 * Setting I915_EXEC_BATCH_FIRST tells execbuf to use element 0 of the
 * execobject[] as the * batch instead (the शेष is to use the last
 * element).
 */
#घोषणा I915_EXEC_BATCH_FIRST		(1<<18)

/* Setting I915_FENCE_ARRAY implies that num_cliprects and cliprects_ptr
 * define an array of i915_gem_exec_fence काष्ठाures which specअगरy a set of
 * dma fences to रुको upon or संकेत.
 */
#घोषणा I915_EXEC_FENCE_ARRAY   (1<<19)

/*
 * Setting I915_EXEC_FENCE_SUBMIT implies that lower_32_bits(rsvd2) represent
 * a sync_file fd to रुको upon (in a nonblocking manner) prior to executing
 * the batch.
 *
 * Returns -EINVAL अगर the sync_file fd cannot be found.
 */
#घोषणा I915_EXEC_FENCE_SUBMIT		(1 << 20)

/*
 * Setting I915_EXEC_USE_EXTENSIONS implies that
 * drm_i915_gem_execbuffer2.cliprects_ptr is treated as a poपूर्णांकer to an linked
 * list of i915_user_extension. Each i915_user_extension node is the base of a
 * larger काष्ठाure. The list of supported काष्ठाures are listed in the
 * drm_i915_gem_execbuffer_ext क्रमागत.
 */
#घोषणा I915_EXEC_USE_EXTENSIONS	(1 << 21)

#घोषणा __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_USE_EXTENSIONS << 1))

#घोषणा I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
#घोषणा i915_execbuffer2_set_context_id(eb2, context) \
	(eb2).rsvd1 = context & I915_EXEC_CONTEXT_ID_MASK
#घोषणा i915_execbuffer2_get_context_id(eb2) \
	((eb2).rsvd1 & I915_EXEC_CONTEXT_ID_MASK)

काष्ठा drm_i915_gem_pin अणु
	/** Handle of the buffer to be pinned. */
	__u32 handle;
	__u32 pad;

	/** alignment required within the aperture */
	__u64 alignment;

	/** Returned GTT offset of the buffer. */
	__u64 offset;
पूर्ण;

काष्ठा drm_i915_gem_unpin अणु
	/** Handle of the buffer to be unpinned. */
	__u32 handle;
	__u32 pad;
पूर्ण;

काष्ठा drm_i915_gem_busy अणु
	/** Handle of the buffer to check क्रम busy */
	__u32 handle;

	/** Return busy status
	 *
	 * A वापस of 0 implies that the object is idle (after
	 * having flushed any pending activity), and a non-zero वापस that
	 * the object is still in-flight on the GPU. (The GPU has not yet
	 * संकेतed completion क्रम all pending requests that reference the
	 * object.) An object is guaranteed to become idle eventually (so
	 * दीर्घ as no new GPU commands are executed upon it). Due to the
	 * asynchronous nature of the hardware, an object reported
	 * as busy may become idle beक्रमe the ioctl is completed.
	 *
	 * Furthermore, अगर the object is busy, which engine is busy is only
	 * provided as a guide and only indirectly by reporting its class
	 * (there may be more than one engine in each class). There are race
	 * conditions which prevent the report of which engines are busy from
	 * being always accurate.  However, the converse is not true. If the
	 * object is idle, the result of the ioctl, that all engines are idle,
	 * is accurate.
	 *
	 * The वापसed dword is split पूर्णांकo two fields to indicate both
	 * the engine classess on which the object is being पढ़ो, and the
	 * engine class on which it is currently being written (अगर any).
	 *
	 * The low word (bits 0:15) indicate अगर the object is being written
	 * to by any engine (there can only be one, as the GEM implicit
	 * synchronisation rules क्रमce ग_लिखोs to be serialised). Only the
	 * engine class (offset by 1, I915_ENGINE_CLASS_RENDER is reported as
	 * 1 not 0 etc) क्रम the last ग_लिखो is reported.
	 *
	 * The high word (bits 16:31) are a biपंचांगask of which engines classes
	 * are currently पढ़ोing from the object. Multiple engines may be
	 * पढ़ोing from the object simultaneously.
	 *
	 * The value of each engine class is the same as specअगरied in the
	 * I915_CONTEXT_SET_ENGINES parameter and via perf, i.e.
	 * I915_ENGINE_CLASS_RENDER, I915_ENGINE_CLASS_COPY, etc.
	 * reported as active itself. Some hardware may have parallel
	 * execution engines, e.g. multiple media engines, which are
	 * mapped to the same class identअगरier and so are not separately
	 * reported क्रम busyness.
	 *
	 * Caveat emptor:
	 * Only the boolean result of this query is reliable; that is whether
	 * the object is idle or busy. The report of which engines are busy
	 * should be only used as a heuristic.
	 */
	__u32 busy;
पूर्ण;

/**
 * I915_CACHING_NONE
 *
 * GPU access is not coherent with cpu caches. Default क्रम machines without an
 * LLC.
 */
#घोषणा I915_CACHING_NONE		0
/**
 * I915_CACHING_CACHED
 *
 * GPU access is coherent with cpu caches and furthermore the data is cached in
 * last-level caches shared between cpu cores and the gpu GT. Default on
 * machines with HAS_LLC.
 */
#घोषणा I915_CACHING_CACHED		1
/**
 * I915_CACHING_DISPLAY
 *
 * Special GPU caching mode which is coherent with the scanout engines.
 * Transparently falls back to I915_CACHING_NONE on platक्रमms where no special
 * cache mode (like ग_लिखो-through or gfdt flushing) is available. The kernel
 * स्वतःmatically sets this mode when using a buffer as a scanout target.
 * Userspace can manually set this mode to aव्योम a costly stall and clflush in
 * the hotpath of drawing the first frame.
 */
#घोषणा I915_CACHING_DISPLAY		2

काष्ठा drm_i915_gem_caching अणु
	/**
	 * Handle of the buffer to set/get the caching level of. */
	__u32 handle;

	/**
	 * Cacheing level to apply or वापस value
	 *
	 * bits0-15 are क्रम generic caching control (i.e. the above defined
	 * values). bits16-31 are reserved क्रम platक्रमm-specअगरic variations
	 * (e.g. l3$ caching on gen7). */
	__u32 caching;
पूर्ण;

#घोषणा I915_TILING_NONE	0
#घोषणा I915_TILING_X		1
#घोषणा I915_TILING_Y		2
#घोषणा I915_TILING_LAST	I915_TILING_Y

#घोषणा I915_BIT_6_SWIZZLE_NONE		0
#घोषणा I915_BIT_6_SWIZZLE_9		1
#घोषणा I915_BIT_6_SWIZZLE_9_10		2
#घोषणा I915_BIT_6_SWIZZLE_9_11		3
#घोषणा I915_BIT_6_SWIZZLE_9_10_11	4
/* Not seen by userland */
#घोषणा I915_BIT_6_SWIZZLE_UNKNOWN	5
/* Seen by userland. */
#घोषणा I915_BIT_6_SWIZZLE_9_17		6
#घोषणा I915_BIT_6_SWIZZLE_9_10_17	7

काष्ठा drm_i915_gem_set_tiling अणु
	/** Handle of the buffer to have its tiling state updated */
	__u32 handle;

	/**
	 * Tiling mode क्रम the object (I915_TILING_NONE, I915_TILING_X,
	 * I915_TILING_Y).
	 *
	 * This value is to be set on request, and will be updated by the
	 * kernel on successful वापस with the actual chosen tiling layout.
	 *
	 * The tiling mode may be demoted to I915_TILING_NONE when the प्रणाली
	 * has bit 6 swizzling that can't be managed correctly by GEM.
	 *
	 * Buffer contents become undefined when changing tiling_mode.
	 */
	__u32 tiling_mode;

	/**
	 * Stride in bytes क्रम the object when in I915_TILING_X or
	 * I915_TILING_Y.
	 */
	__u32 stride;

	/**
	 * Returned address bit 6 swizzling required क्रम CPU access through
	 * mmap mapping.
	 */
	__u32 swizzle_mode;
पूर्ण;

काष्ठा drm_i915_gem_get_tiling अणु
	/** Handle of the buffer to get tiling state क्रम. */
	__u32 handle;

	/**
	 * Current tiling mode क्रम the object (I915_TILING_NONE, I915_TILING_X,
	 * I915_TILING_Y).
	 */
	__u32 tiling_mode;

	/**
	 * Returned address bit 6 swizzling required क्रम CPU access through
	 * mmap mapping.
	 */
	__u32 swizzle_mode;

	/**
	 * Returned address bit 6 swizzling required क्रम CPU access through
	 * mmap mapping whilst bound.
	 */
	__u32 phys_swizzle_mode;
पूर्ण;

काष्ठा drm_i915_gem_get_aperture अणु
	/** Total size of the aperture used by i915_gem_execbuffer, in bytes */
	__u64 aper_size;

	/**
	 * Available space in the aperture used by i915_gem_execbuffer, in
	 * bytes
	 */
	__u64 aper_available_size;
पूर्ण;

काष्ठा drm_i915_get_pipe_from_crtc_id अणु
	/** ID of CRTC being requested **/
	__u32 crtc_id;

	/** pipe of requested CRTC **/
	__u32 pipe;
पूर्ण;

#घोषणा I915_MADV_WILLNEED 0
#घोषणा I915_MADV_DONTNEED 1
#घोषणा __I915_MADV_PURGED 2 /* पूर्णांकernal state */

काष्ठा drm_i915_gem_madvise अणु
	/** Handle of the buffer to change the backing store advice */
	__u32 handle;

	/* Advice: either the buffer will be needed again in the near future,
	 *         or wont be and could be discarded under memory pressure.
	 */
	__u32 madv;

	/** Whether the backing store still exists. */
	__u32 retained;
पूर्ण;

/* flags */
#घोषणा I915_OVERLAY_TYPE_MASK 		0xff
#घोषणा I915_OVERLAY_YUV_PLANAR 	0x01
#घोषणा I915_OVERLAY_YUV_PACKED 	0x02
#घोषणा I915_OVERLAY_RGB		0x03

#घोषणा I915_OVERLAY_DEPTH_MASK		0xff00
#घोषणा I915_OVERLAY_RGB24		0x1000
#घोषणा I915_OVERLAY_RGB16		0x2000
#घोषणा I915_OVERLAY_RGB15		0x3000
#घोषणा I915_OVERLAY_YUV422		0x0100
#घोषणा I915_OVERLAY_YUV411		0x0200
#घोषणा I915_OVERLAY_YUV420		0x0300
#घोषणा I915_OVERLAY_YUV410		0x0400

#घोषणा I915_OVERLAY_SWAP_MASK		0xff0000
#घोषणा I915_OVERLAY_NO_SWAP		0x000000
#घोषणा I915_OVERLAY_UV_SWAP		0x010000
#घोषणा I915_OVERLAY_Y_SWAP		0x020000
#घोषणा I915_OVERLAY_Y_AND_UV_SWAP	0x030000

#घोषणा I915_OVERLAY_FLAGS_MASK		0xff000000
#घोषणा I915_OVERLAY_ENABLE		0x01000000

काष्ठा drm_पूर्णांकel_overlay_put_image अणु
	/* various flags and src क्रमmat description */
	__u32 flags;
	/* source picture description */
	__u32 bo_handle;
	/* stride values and offsets are in bytes, buffer relative */
	__u16 stride_Y; /* stride क्रम packed क्रमmats */
	__u16 stride_UV;
	__u32 offset_Y; /* offset क्रम packet क्रमmats */
	__u32 offset_U;
	__u32 offset_V;
	/* in pixels */
	__u16 src_width;
	__u16 src_height;
	/* to compensate the scaling factors क्रम partially covered surfaces */
	__u16 src_scan_width;
	__u16 src_scan_height;
	/* output crtc description */
	__u32 crtc_id;
	__u16 dst_x;
	__u16 dst_y;
	__u16 dst_width;
	__u16 dst_height;
पूर्ण;

/* flags */
#घोषणा I915_OVERLAY_UPDATE_ATTRS	(1<<0)
#घोषणा I915_OVERLAY_UPDATE_GAMMA	(1<<1)
#घोषणा I915_OVERLAY_DISABLE_DEST_COLORKEY	(1<<2)
काष्ठा drm_पूर्णांकel_overlay_attrs अणु
	__u32 flags;
	__u32 color_key;
	__s32 brightness;
	__u32 contrast;
	__u32 saturation;
	__u32 gamma0;
	__u32 gamma1;
	__u32 gamma2;
	__u32 gamma3;
	__u32 gamma4;
	__u32 gamma5;
पूर्ण;

/*
 * Intel sprite handling
 *
 * Color keying works with a min/mask/max tuple.  Both source and destination
 * color keying is allowed.
 *
 * Source keying:
 * Sprite pixels within the min & max values, masked against the color channels
 * specअगरied in the mask field, will be transparent.  All other pixels will
 * be displayed on top of the primary plane.  For RGB surfaces, only the min
 * and mask fields will be used; ranged compares are not allowed.
 *
 * Destination keying:
 * Primary plane pixels that match the min value, masked against the color
 * channels specअगरied in the mask field, will be replaced by corresponding
 * pixels from the sprite plane.
 *
 * Note that source & destination keying are exclusive; only one can be
 * active on a given plane.
 */

#घोषणा I915_SET_COLORKEY_NONE		(1<<0) /* Deprecated. Instead set
						* flags==0 to disable colorkeying.
						*/
#घोषणा I915_SET_COLORKEY_DESTINATION	(1<<1)
#घोषणा I915_SET_COLORKEY_SOURCE	(1<<2)
काष्ठा drm_पूर्णांकel_sprite_colorkey अणु
	__u32 plane_id;
	__u32 min_value;
	__u32 channel_mask;
	__u32 max_value;
	__u32 flags;
पूर्ण;

काष्ठा drm_i915_gem_रुको अणु
	/** Handle of BO we shall रुको on */
	__u32 bo_handle;
	__u32 flags;
	/** Number of nanoseconds to रुको, Returns समय reमुख्यing. */
	__s64 समयout_ns;
पूर्ण;

काष्ठा drm_i915_gem_context_create अणु
	__u32 ctx_id; /* output: id of new context*/
	__u32 pad;
पूर्ण;

काष्ठा drm_i915_gem_context_create_ext अणु
	__u32 ctx_id; /* output: id of new context*/
	__u32 flags;
#घोषणा I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS	(1u << 0)
#घोषणा I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE	(1u << 1)
#घोषणा I915_CONTEXT_CREATE_FLAGS_UNKNOWN \
	(-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE << 1))
	__u64 extensions;
पूर्ण;

काष्ठा drm_i915_gem_context_param अणु
	__u32 ctx_id;
	__u32 size;
	__u64 param;
#घोषणा I915_CONTEXT_PARAM_BAN_PERIOD	0x1
#घोषणा I915_CONTEXT_PARAM_NO_ZEROMAP	0x2
#घोषणा I915_CONTEXT_PARAM_GTT_SIZE	0x3
#घोषणा I915_CONTEXT_PARAM_NO_ERROR_CAPTURE	0x4
#घोषणा I915_CONTEXT_PARAM_BANNABLE	0x5
#घोषणा I915_CONTEXT_PARAM_PRIORITY	0x6
#घोषणा   I915_CONTEXT_MAX_USER_PRIORITY	1023 /* inclusive */
#घोषणा   I915_CONTEXT_DEFAULT_PRIORITY		0
#घोषणा   I915_CONTEXT_MIN_USER_PRIORITY	-1023 /* inclusive */
	/*
	 * When using the following param, value should be a poपूर्णांकer to
	 * drm_i915_gem_context_param_sseu.
	 */
#घोषणा I915_CONTEXT_PARAM_SSEU		0x7

/*
 * Not all clients may want to attempt स्वतःmatic recover of a context after
 * a hang (क्रम example, some clients may only submit very small incremental
 * batches relying on known logical state of previous batches which will never
 * recover correctly and each attempt will hang), and so would prefer that
 * the context is क्रमever banned instead.
 *
 * If set to false (0), after a reset, subsequent (and in flight) rendering
 * from this context is discarded, and the client will need to create a new
 * context to use instead.
 *
 * If set to true (1), the kernel will स्वतःmatically attempt to recover the
 * context by skipping the hanging batch and executing the next batch starting
 * from the शेष context state (discarding the incomplete logical context
 * state lost due to the reset).
 *
 * On creation, all new contexts are marked as recoverable.
 */
#घोषणा I915_CONTEXT_PARAM_RECOVERABLE	0x8

	/*
	 * The id of the associated भव memory address space (ppGTT) of
	 * this context. Can be retrieved and passed to another context
	 * (on the same fd) क्रम both to use the same ppGTT and so share
	 * address layouts, and aव्योम reloading the page tables on context
	 * चयनes between themselves.
	 *
	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
	 */
#घोषणा I915_CONTEXT_PARAM_VM		0x9

/*
 * I915_CONTEXT_PARAM_ENGINES:
 *
 * Bind this context to operate on this subset of available engines. Henceक्रमth,
 * the I915_EXEC_RING selector क्रम DRM_IOCTL_I915_GEM_EXECBUFFER2 operates as
 * an index पूर्णांकo this array of engines; I915_EXEC_DEFAULT selecting engine[0]
 * and upwards. Slots 0...N are filled in using the specअगरied (class, instance).
 * Use
 *	engine_class: I915_ENGINE_CLASS_INVALID,
 *	engine_instance: I915_ENGINE_CLASS_INVALID_NONE
 * to specअगरy a gap in the array that can be filled in later, e.g. by a
 * भव engine used क्रम load balancing.
 *
 * Setting the number of engines bound to the context to 0, by passing a zero
 * sized argument, will revert back to शेष settings.
 *
 * See काष्ठा i915_context_param_engines.
 *
 * Extensions:
 *   i915_context_engines_load_balance (I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE)
 *   i915_context_engines_bond (I915_CONTEXT_ENGINES_EXT_BOND)
 */
#घोषणा I915_CONTEXT_PARAM_ENGINES	0xa

/*
 * I915_CONTEXT_PARAM_PERSISTENCE:
 *
 * Allow the context and active rendering to survive the process until
 * completion. Persistence allows fire-and-क्रमget clients to queue up a
 * bunch of work, hand the output over to a display server and then quit.
 * If the context is marked as not persistent, upon closing (either via
 * an explicit DRM_I915_GEM_CONTEXT_DESTROY or implicitly from file closure
 * or process termination), the context and any outstanding requests will be
 * cancelled (and exported fences क्रम cancelled requests marked as -EIO).
 *
 * By शेष, new contexts allow persistence.
 */
#घोषणा I915_CONTEXT_PARAM_PERSISTENCE	0xb

/*
 * I915_CONTEXT_PARAM_RINGSIZE:
 *
 * Sets the size of the CS ringbuffer to use क्रम logical ring contexts. This
 * applies a limit of how many batches can be queued to HW beक्रमe the caller
 * is blocked due to lack of space क्रम more commands.
 *
 * Only reliably possible to be set prior to first use, i.e. during
 * स्थिरruction. At any later poपूर्णांक, the current execution must be flushed as
 * the ring can only be changed जबतक the context is idle. Note, the ringsize
 * can be specअगरied as a स्थिरructor property, see
 * I915_CONTEXT_CREATE_EXT_SETPARAM, but can also be set later अगर required.
 *
 * Only applies to the current set of engine and lost when those engines
 * are replaced by a new mapping (see I915_CONTEXT_PARAM_ENGINES).
 *
 * Must be between 4 - 512 KiB, in पूर्णांकervals of page size [4 KiB].
 * Default is 16 KiB.
 */
#घोषणा I915_CONTEXT_PARAM_RINGSIZE	0xc
/* Must be kept compact -- no holes and well करोcumented */

	__u64 value;
पूर्ण;

/**
 * Context SSEU programming
 *
 * It may be necessary क्रम either functional or perक्रमmance reason to configure
 * a context to run with a reduced number of SSEU (where SSEU stands क्रम Slice/
 * Sub-slice/EU).
 *
 * This is करोne by configuring SSEU configuration using the below
 * @काष्ठा drm_i915_gem_context_param_sseu क्रम every supported engine which
 * userspace पूर्णांकends to use.
 *
 * Not all GPUs or engines support this functionality in which हाल an error
 * code -ENODEV will be वापसed.
 *
 * Also, flexibility of possible SSEU configuration permutations varies between
 * GPU generations and software imposed limitations. Requesting such a
 * combination will वापस an error code of -EINVAL.
 *
 * NOTE: When perf/OA is active the context's SSEU configuration is ignored in
 * favour of a single global setting.
 */
काष्ठा drm_i915_gem_context_param_sseu अणु
	/*
	 * Engine class & instance to be configured or queried.
	 */
	काष्ठा i915_engine_class_instance engine;

	/*
	 * Unknown flags must be cleared to zero.
	 */
	__u32 flags;
#घोषणा I915_CONTEXT_SSEU_FLAG_ENGINE_INDEX (1u << 0)

	/*
	 * Mask of slices to enable क्रम the context. Valid values are a subset
	 * of the biपंचांगask value वापसed क्रम I915_PARAM_SLICE_MASK.
	 */
	__u64 slice_mask;

	/*
	 * Mask of subslices to enable क्रम the context. Valid values are a
	 * subset of the biपंचांगask value वापस by I915_PARAM_SUBSLICE_MASK.
	 */
	__u64 subslice_mask;

	/*
	 * Minimum/Maximum number of EUs to enable per subslice क्रम the
	 * context. min_eus_per_subslice must be inferior or equal to
	 * max_eus_per_subslice.
	 */
	__u16 min_eus_per_subslice;
	__u16 max_eus_per_subslice;

	/*
	 * Unused क्रम now. Must be cleared to zero.
	 */
	__u32 rsvd;
पूर्ण;

/*
 * i915_context_engines_load_balance:
 *
 * Enable load balancing across this set of engines.
 *
 * Into the I915_EXEC_DEFAULT slot [0], a भव engine is created that when
 * used will proxy the execbuffer request onto one of the set of engines
 * in such a way as to distribute the load evenly across the set.
 *
 * The set of engines must be compatible (e.g. the same HW class) as they
 * will share the same logical GPU context and ring.
 *
 * To पूर्णांकermix rendering with the भव engine and direct rendering onto
 * the backing engines (bypassing the load balancing proxy), the context must
 * be defined to use a single समयline क्रम all engines.
 */
काष्ठा i915_context_engines_load_balance अणु
	काष्ठा i915_user_extension base;

	__u16 engine_index;
	__u16 num_siblings;
	__u32 flags; /* all undefined flags must be zero */

	__u64 mbz64; /* reserved क्रम future use; must be zero */

	काष्ठा i915_engine_class_instance engines[0];
पूर्ण __attribute__((packed));

#घोषणा I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE(name__, N__) काष्ठा अणु \
	काष्ठा i915_user_extension base; \
	__u16 engine_index; \
	__u16 num_siblings; \
	__u32 flags; \
	__u64 mbz64; \
	काष्ठा i915_engine_class_instance engines[N__]; \
पूर्ण __attribute__((packed)) name__

/*
 * i915_context_engines_bond:
 *
 * Conकाष्ठाed bonded pairs क्रम execution within a भव engine.
 *
 * All engines are equal, but some are more equal than others. Given
 * the distribution of resources in the HW, it may be preferable to run
 * a request on a given subset of engines in parallel to a request on a
 * specअगरic engine. We enable this selection of engines within a भव
 * engine by specअगरying bonding pairs, क्रम any given master engine we will
 * only execute on one of the corresponding siblings within the भव engine.
 *
 * To execute a request in parallel on the master engine and a sibling requires
 * coordination with a I915_EXEC_FENCE_SUBMIT.
 */
काष्ठा i915_context_engines_bond अणु
	काष्ठा i915_user_extension base;

	काष्ठा i915_engine_class_instance master;

	__u16 भव_index; /* index of भव engine in ctx->engines[] */
	__u16 num_bonds;

	__u64 flags; /* all undefined flags must be zero */
	__u64 mbz64[4]; /* reserved क्रम future use; must be zero */

	काष्ठा i915_engine_class_instance engines[0];
पूर्ण __attribute__((packed));

#घोषणा I915_DEFINE_CONTEXT_ENGINES_BOND(name__, N__) काष्ठा अणु \
	काष्ठा i915_user_extension base; \
	काष्ठा i915_engine_class_instance master; \
	__u16 भव_index; \
	__u16 num_bonds; \
	__u64 flags; \
	__u64 mbz64[4]; \
	काष्ठा i915_engine_class_instance engines[N__]; \
पूर्ण __attribute__((packed)) name__

काष्ठा i915_context_param_engines अणु
	__u64 extensions; /* linked chain of extension blocks, 0 terminates */
#घोषणा I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE 0 /* see i915_context_engines_load_balance */
#घोषणा I915_CONTEXT_ENGINES_EXT_BOND 1 /* see i915_context_engines_bond */
	काष्ठा i915_engine_class_instance engines[0];
पूर्ण __attribute__((packed));

#घोषणा I915_DEFINE_CONTEXT_PARAM_ENGINES(name__, N__) काष्ठा अणु \
	__u64 extensions; \
	काष्ठा i915_engine_class_instance engines[N__]; \
पूर्ण __attribute__((packed)) name__

काष्ठा drm_i915_gem_context_create_ext_setparam अणु
#घोषणा I915_CONTEXT_CREATE_EXT_SETPARAM 0
	काष्ठा i915_user_extension base;
	काष्ठा drm_i915_gem_context_param param;
पूर्ण;

काष्ठा drm_i915_gem_context_create_ext_clone अणु
#घोषणा I915_CONTEXT_CREATE_EXT_CLONE 1
	काष्ठा i915_user_extension base;
	__u32 clone_id;
	__u32 flags;
#घोषणा I915_CONTEXT_CLONE_ENGINES	(1u << 0)
#घोषणा I915_CONTEXT_CLONE_FLAGS	(1u << 1)
#घोषणा I915_CONTEXT_CLONE_SCHEDATTR	(1u << 2)
#घोषणा I915_CONTEXT_CLONE_SSEU		(1u << 3)
#घोषणा I915_CONTEXT_CLONE_TIMELINE	(1u << 4)
#घोषणा I915_CONTEXT_CLONE_VM		(1u << 5)
#घोषणा I915_CONTEXT_CLONE_UNKNOWN -(I915_CONTEXT_CLONE_VM << 1)
	__u64 rsvd;
पूर्ण;

काष्ठा drm_i915_gem_context_destroy अणु
	__u32 ctx_id;
	__u32 pad;
पूर्ण;

/*
 * DRM_I915_GEM_VM_CREATE -
 *
 * Create a new भव memory address space (ppGTT) क्रम use within a context
 * on the same file. Extensions can be provided to configure exactly how the
 * address space is setup upon creation.
 *
 * The id of new VM (bound to the fd) क्रम use with I915_CONTEXT_PARAM_VM is
 * वापसed in the outparam @id.
 *
 * No flags are defined, with all bits reserved and must be zero.
 *
 * An extension chain maybe provided, starting with @extensions, and terminated
 * by the @next_extension being 0. Currently, no extensions are defined.
 *
 * DRM_I915_GEM_VM_DESTROY -
 *
 * Destroys a previously created VM id, specअगरied in @id.
 *
 * No extensions or flags are allowed currently, and so must be zero.
 */
काष्ठा drm_i915_gem_vm_control अणु
	__u64 extensions;
	__u32 flags;
	__u32 vm_id;
पूर्ण;

काष्ठा drm_i915_reg_पढ़ो अणु
	/*
	 * Register offset.
	 * For 64bit wide रेजिस्टरs where the upper 32bits करोn't immediately
	 * follow the lower 32bits, the offset of the lower 32bits must
	 * be specअगरied
	 */
	__u64 offset;
#घोषणा I915_REG_READ_8B_WA (1ul << 0)

	__u64 val; /* Return value */
पूर्ण;

/* Known रेजिस्टरs:
 *
 * Render engine बारtamp - 0x2358 + 64bit - gen7+
 * - Note this रेजिस्टर वापसs an invalid value अगर using the शेष
 *   single inकाष्ठाion 8byte पढ़ो, in order to workaround that pass
 *   flag I915_REG_READ_8B_WA in offset field.
 *
 */

काष्ठा drm_i915_reset_stats अणु
	__u32 ctx_id;
	__u32 flags;

	/* All resets since boot/module reload, क्रम all contexts */
	__u32 reset_count;

	/* Number of batches lost when active in GPU, क्रम this context */
	__u32 batch_active;

	/* Number of batches lost pending क्रम execution, क्रम this context */
	__u32 batch_pending;

	__u32 pad;
पूर्ण;

काष्ठा drm_i915_gem_userptr अणु
	__u64 user_ptr;
	__u64 user_size;
	__u32 flags;
#घोषणा I915_USERPTR_READ_ONLY 0x1
#घोषणा I915_USERPTR_UNSYNCHRONIZED 0x80000000
	/**
	 * Returned handle क्रम the object.
	 *
	 * Object handles are nonzero.
	 */
	__u32 handle;
पूर्ण;

क्रमागत drm_i915_oa_क्रमmat अणु
	I915_OA_FORMAT_A13 = 1,	    /* HSW only */
	I915_OA_FORMAT_A29,	    /* HSW only */
	I915_OA_FORMAT_A13_B8_C8,   /* HSW only */
	I915_OA_FORMAT_B4_C8,	    /* HSW only */
	I915_OA_FORMAT_A45_B8_C8,   /* HSW only */
	I915_OA_FORMAT_B4_C8_A16,   /* HSW only */
	I915_OA_FORMAT_C4_B8,	    /* HSW+ */

	/* Gen8+ */
	I915_OA_FORMAT_A12,
	I915_OA_FORMAT_A12_B8_C8,
	I915_OA_FORMAT_A32u40_A4u32_B8_C8,

	I915_OA_FORMAT_MAX	    /* non-ABI */
पूर्ण;

क्रमागत drm_i915_perf_property_id अणु
	/**
	 * Open the stream क्रम a specअगरic context handle (as used with
	 * execbuffer2). A stream खोलोed क्रम a specअगरic context this way
	 * won't typically require root privileges.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_CTX_HANDLE = 1,

	/**
	 * A value of 1 requests the inclusion of raw OA unit reports as
	 * part of stream samples.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_SAMPLE_OA,

	/**
	 * The value specअगरies which set of OA unit metrics should be
	 * configured, defining the contents of any OA unit reports.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_METRICS_SET,

	/**
	 * The value specअगरies the size and layout of OA unit reports.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_FORMAT,

	/**
	 * Specअगरying this property implicitly requests periodic OA unit
	 * sampling and (at least on Haswell) the sampling frequency is derived
	 * from this exponent as follows:
	 *
	 *   80ns * 2^(period_exponent + 1)
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_EXPONENT,

	/**
	 * Specअगरying this property is only valid when specअगरy a context to
	 * filter with DRM_I915_PERF_PROP_CTX_HANDLE. Specअगरying this property
	 * will hold preemption of the particular context we want to gather
	 * perक्रमmance data about. The execbuf2 submissions must include a
	 * drm_i915_gem_execbuffer_ext_perf parameter क्रम this to apply.
	 *
	 * This property is available in perf revision 3.
	 */
	DRM_I915_PERF_PROP_HOLD_PREEMPTION,

	/**
	 * Specअगरying this pins all contexts to the specअगरied SSEU घातer
	 * configuration क्रम the duration of the recording.
	 *
	 * This parameter's value is a poपूर्णांकer to a काष्ठा
	 * drm_i915_gem_context_param_sseu.
	 *
	 * This property is available in perf revision 4.
	 */
	DRM_I915_PERF_PROP_GLOBAL_SSEU,

	/**
	 * This optional parameter specअगरies the समयr पूर्णांकerval in nanoseconds
	 * at which the i915 driver will check the OA buffer क्रम available data.
	 * Minimum allowed value is 100 microseconds. A शेष value is used by
	 * the driver अगर this parameter is not specअगरied. Note that larger समयr
	 * values will reduce cpu consumption during OA perf captures. However,
	 * excessively large values would potentially result in OA buffer
	 * overग_लिखोs as captures reach end of the OA buffer.
	 *
	 * This property is available in perf revision 5.
	 */
	DRM_I915_PERF_PROP_POLL_OA_PERIOD,

	DRM_I915_PERF_PROP_MAX /* non-ABI */
पूर्ण;

काष्ठा drm_i915_perf_खोलो_param अणु
	__u32 flags;
#घोषणा I915_PERF_FLAG_FD_CLOEXEC	(1<<0)
#घोषणा I915_PERF_FLAG_FD_NONBLOCK	(1<<1)
#घोषणा I915_PERF_FLAG_DISABLED		(1<<2)

	/** The number of u64 (id, value) pairs */
	__u32 num_properties;

	/**
	 * Poपूर्णांकer to array of u64 (id, value) pairs configuring the stream
	 * to खोलो.
	 */
	__u64 properties_ptr;
पूर्ण;

/**
 * Enable data capture क्रम a stream that was either खोलोed in a disabled state
 * via I915_PERF_FLAG_DISABLED or was later disabled via
 * I915_PERF_IOCTL_DISABLE.
 *
 * It is पूर्णांकended to be cheaper to disable and enable a stream than it may be
 * to बंद and re-खोलो a stream with the same configuration.
 *
 * It's undefined whether any pending data क्रम the stream will be lost.
 *
 * This ioctl is available in perf revision 1.
 */
#घोषणा I915_PERF_IOCTL_ENABLE	_IO('i', 0x0)

/**
 * Disable data capture क्रम a stream.
 *
 * It is an error to try and पढ़ो a stream that is disabled.
 *
 * This ioctl is available in perf revision 1.
 */
#घोषणा I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)

/**
 * Change metrics_set captured by a stream.
 *
 * If the stream is bound to a specअगरic context, the configuration change
 * will perक्रमmed अंतरभूत with that context such that it takes effect beक्रमe
 * the next execbuf submission.
 *
 * Returns the previously bound metrics set id, or a negative error code.
 *
 * This ioctl is available in perf revision 2.
 */
#घोषणा I915_PERF_IOCTL_CONFIG	_IO('i', 0x2)

/**
 * Common to all i915 perf records
 */
काष्ठा drm_i915_perf_record_header अणु
	__u32 type;
	__u16 pad;
	__u16 size;
पूर्ण;

क्रमागत drm_i915_perf_record_type अणु

	/**
	 * Samples are the work horse record type whose contents are extensible
	 * and defined when खोलोing an i915 perf stream based on the given
	 * properties.
	 *
	 * Boolean properties following the naming convention
	 * DRM_I915_PERF_SAMPLE_xyz_PROP request the inclusion of 'xyz' data in
	 * every sample.
	 *
	 * The order of these sample properties given by userspace has no
	 * affect on the ordering of data within a sample. The order is
	 * करोcumented here.
	 *
	 * काष्ठा अणु
	 *     काष्ठा drm_i915_perf_record_header header;
	 *
	 *     अणु u32 oa_report[]; पूर्ण && DRM_I915_PERF_PROP_SAMPLE_OA
	 * पूर्ण;
	 */
	DRM_I915_PERF_RECORD_SAMPLE = 1,

	/*
	 * Indicates that one or more OA reports were not written by the
	 * hardware. This can happen क्रम example अगर an MI_REPORT_PERF_COUNT
	 * command collides with periodic sampling - which would be more likely
	 * at higher sampling frequencies.
	 */
	DRM_I915_PERF_RECORD_OA_REPORT_LOST = 2,

	/**
	 * An error occurred that resulted in all pending OA reports being lost.
	 */
	DRM_I915_PERF_RECORD_OA_BUFFER_LOST = 3,

	DRM_I915_PERF_RECORD_MAX /* non-ABI */
पूर्ण;

/**
 * Structure to upload perf dynamic configuration पूर्णांकo the kernel.
 */
काष्ठा drm_i915_perf_oa_config अणु
	/** String क्रमmatted like "%08x-%04x-%04x-%04x-%012x" */
	अक्षर uuid[36];

	__u32 n_mux_regs;
	__u32 n_boolean_regs;
	__u32 n_flex_regs;

	/*
	 * These fields are poपूर्णांकers to tuples of u32 values (रेजिस्टर address,
	 * value). For example the expected length of the buffer poपूर्णांकed by
	 * mux_regs_ptr is (2 * माप(u32) * n_mux_regs).
	 */
	__u64 mux_regs_ptr;
	__u64 boolean_regs_ptr;
	__u64 flex_regs_ptr;
पूर्ण;

काष्ठा drm_i915_query_item अणु
	__u64 query_id;
#घोषणा DRM_I915_QUERY_TOPOLOGY_INFO    1
#घोषणा DRM_I915_QUERY_ENGINE_INFO	2
#घोषणा DRM_I915_QUERY_PERF_CONFIG      3
/* Must be kept compact -- no holes and well करोcumented */

	/*
	 * When set to zero by userspace, this is filled with the size of the
	 * data to be written at the data_ptr poपूर्णांकer. The kernel sets this
	 * value to a negative value to संकेत an error on a particular query
	 * item.
	 */
	__s32 length;

	/*
	 * When query_id == DRM_I915_QUERY_TOPOLOGY_INFO, must be 0.
	 *
	 * When query_id == DRM_I915_QUERY_PERF_CONFIG, must be one of the
	 * following :
	 *         - DRM_I915_QUERY_PERF_CONFIG_LIST
	 *         - DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID
	 *         - DRM_I915_QUERY_PERF_CONFIG_FOR_UUID
	 */
	__u32 flags;
#घोषणा DRM_I915_QUERY_PERF_CONFIG_LIST          1
#घोषणा DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2
#घोषणा DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3

	/*
	 * Data will be written at the location poपूर्णांकed by data_ptr when the
	 * value of length matches the length of the data to be written by the
	 * kernel.
	 */
	__u64 data_ptr;
पूर्ण;

काष्ठा drm_i915_query अणु
	__u32 num_items;

	/*
	 * Unused क्रम now. Must be cleared to zero.
	 */
	__u32 flags;

	/*
	 * This poपूर्णांकs to an array of num_items drm_i915_query_item काष्ठाures.
	 */
	__u64 items_ptr;
पूर्ण;

/*
 * Data written by the kernel with query DRM_I915_QUERY_TOPOLOGY_INFO :
 *
 * data: contains the 3 pieces of inक्रमmation :
 *
 * - the slice mask with one bit per slice telling whether a slice is
 *   available. The availability of slice X can be queried with the following
 *   क्रमmula :
 *
 *           (data[X / 8] >> (X % 8)) & 1
 *
 * - the subslice mask क्रम each slice with one bit per subslice telling
 *   whether a subslice is available. Gen12 has dual-subslices, which are
 *   similar to two gen11 subslices. For gen12, this array represents dual-
 *   subslices. The availability of subslice Y in slice X can be queried
 *   with the following क्रमmula :
 *
 *           (data[subslice_offset +
 *                 X * subslice_stride +
 *                 Y / 8] >> (Y % 8)) & 1
 *
 * - the EU mask क्रम each subslice in each slice with one bit per EU telling
 *   whether an EU is available. The availability of EU Z in subslice Y in
 *   slice X can be queried with the following क्रमmula :
 *
 *           (data[eu_offset +
 *                 (X * max_subslices + Y) * eu_stride +
 *                 Z / 8] >> (Z % 8)) & 1
 */
काष्ठा drm_i915_query_topology_info अणु
	/*
	 * Unused क्रम now. Must be cleared to zero.
	 */
	__u16 flags;

	__u16 max_slices;
	__u16 max_subslices;
	__u16 max_eus_per_subslice;

	/*
	 * Offset in data[] at which the subslice masks are stored.
	 */
	__u16 subslice_offset;

	/*
	 * Stride at which each of the subslice masks क्रम each slice are
	 * stored.
	 */
	__u16 subslice_stride;

	/*
	 * Offset in data[] at which the EU masks are stored.
	 */
	__u16 eu_offset;

	/*
	 * Stride at which each of the EU masks क्रम each subslice are stored.
	 */
	__u16 eu_stride;

	__u8 data[];
पूर्ण;

/**
 * काष्ठा drm_i915_engine_info
 *
 * Describes one engine and it's capabilities as known to the driver.
 */
काष्ठा drm_i915_engine_info अणु
	/** Engine class and instance. */
	काष्ठा i915_engine_class_instance engine;

	/** Reserved field. */
	__u32 rsvd0;

	/** Engine flags. */
	__u64 flags;

	/** Capabilities of this engine. */
	__u64 capabilities;
#घोषणा I915_VIDEO_CLASS_CAPABILITY_HEVC		(1 << 0)
#घोषणा I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC	(1 << 1)

	/** Reserved fields. */
	__u64 rsvd1[4];
पूर्ण;

/**
 * काष्ठा drm_i915_query_engine_info
 *
 * Engine info query क्रमागतerates all engines known to the driver by filling in
 * an array of काष्ठा drm_i915_engine_info काष्ठाures.
 */
काष्ठा drm_i915_query_engine_info अणु
	/** Number of काष्ठा drm_i915_engine_info काष्ठाs following. */
	__u32 num_engines;

	/** MBZ */
	__u32 rsvd[3];

	/** Marker क्रम drm_i915_engine_info काष्ठाures. */
	काष्ठा drm_i915_engine_info engines[];
पूर्ण;

/*
 * Data written by the kernel with query DRM_I915_QUERY_PERF_CONFIG.
 */
काष्ठा drm_i915_query_perf_config अणु
	जोड़ अणु
		/*
		 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 sets
		 * this fields to the number of configurations available.
		 */
		__u64 n_configs;

		/*
		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID,
		 * i915 will use the value in this field as configuration
		 * identअगरier to decide what data to ग_लिखो पूर्णांकo config_ptr.
		 */
		__u64 config;

		/*
		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID,
		 * i915 will use the value in this field as configuration
		 * identअगरier to decide what data to ग_लिखो पूर्णांकo config_ptr.
		 *
		 * String क्रमmatted like "%08x-%04x-%04x-%04x-%012x"
		 */
		अक्षर uuid[36];
	पूर्ण;

	/*
	 * Unused क्रम now. Must be cleared to zero.
	 */
	__u32 flags;

	/*
	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 will
	 * ग_लिखो an array of __u64 of configuration identअगरiers.
	 *
	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_DATA, i915 will
	 * ग_लिखो a काष्ठा drm_i915_perf_oa_config. If the following fields of
	 * drm_i915_perf_oa_config are set not set to 0, i915 will ग_लिखो पूर्णांकo
	 * the associated poपूर्णांकers the values of submitted when the
	 * configuration was created :
	 *
	 *         - n_mux_regs
	 *         - n_boolean_regs
	 *         - n_flex_regs
	 */
	__u8 data[];
पूर्ण;

#अगर defined(__cplusplus)
पूर्ण
#पूर्ण_अगर

#पूर्ण_अगर /* _UAPI_I915_DRM_H_ */
