<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/*
 * Copyright IBM Corp. 2018
 * Auxtrace support क्रम s390 CPU-Measurement Sampling Facility
 *
 * Author(s):  Thomas Richter <पंचांगricht@linux.ibm.com>
 *
 * Auxiliary traces are collected during 'perf record' using rbd000 event.
 * Several PERF_RECORD_XXX are generated during recording:
 *
 * PERF_RECORD_AUX:
 *	Records that new data landed in the AUX buffer part.
 * PERF_RECORD_AUXTRACE:
 *	Defines auxtrace data. Followed by the actual data. The contents of
 *	the auxtrace data is dependent on the event and the CPU.
 *	This record is generated by perf record command. For details
 *	see Documentation/perf.data-file-क्रमmat.txt.
 * PERF_RECORD_AUXTRACE_INFO:
 *	Defines a table of contains क्रम PERF_RECORD_AUXTRACE records. This
 *	record is generated during 'perf record' command. Each record contains
 *	up to 256 entries describing offset and size of the AUXTRACE data in the
 *	perf.data file.
 * PERF_RECORD_AUXTRACE_ERROR:
 *	Indicates an error during AUXTRACE collection such as buffer overflow.
 * PERF_RECORD_FINISHED_ROUND:
 *	Perf events are not necessarily in समय stamp order, as they can be
 *	collected in parallel on dअगरferent CPUs. If the events should be
 *	processed in समय order they need to be sorted first.
 *	Perf report guarantees that there is no reordering over a
 *	PERF_RECORD_FINISHED_ROUND boundary event. All perf records with a
 *	समय stamp lower than this record are processed (and displayed) beक्रमe
 *	the succeeding perf record are processed.
 *
 * These records are evaluated during perf report command.
 *
 * 1. PERF_RECORD_AUXTRACE_INFO is used to set up the infraकाष्ठाure क्रम
 * auxiliary trace data processing. See s390_cpumsf_process_auxtrace_info()
 * below.
 * Auxiliary trace data is collected per CPU. To merge the data पूर्णांकo the report
 * an auxtrace_queue is created क्रम each CPU. It is assumed that the auxtrace
 * data is in ascending order.
 *
 * Each queue has a द्विगुन linked list of auxtrace_buffers. This list contains
 * the offset and size of a CPU's auxtrace data. During auxtrace processing
 * the data portion is mmap()'ed.
 *
 * To sort the queues in chronological order, all queue access is controlled
 * by the auxtrace_heap. This is basically a stack, each stack element has two
 * entries, the queue number and a समय stamp. However the stack is sorted by
 * the समय stamps. The highest समय stamp is at the bottom the lowest
 * (nearest) समय stamp is at the top. That sort order is मुख्यtained at all
 * बार!
 *
 * After the auxtrace infraकाष्ठाure has been setup, the auxtrace queues are
 * filled with data (offset/size pairs) and the auxtrace_heap is populated.
 *
 * 2. PERF_RECORD_XXX processing triggers access to the auxtrace_queues.
 * Each record is handled by s390_cpumsf_process_event(). The समय stamp of
 * the perf record is compared with the समय stamp located on the auxtrace_heap
 * top element. If that समय stamp is lower than the समय stamp from the
 * record sample, the auxtrace queues will be processed. As auxtrace queues
 * control many auxtrace_buffers and each buffer can be quite large, the
 * auxtrace buffer might be processed only partially. In this हाल the
 * position in the auxtrace_buffer of that queue is remembered and the समय
 * stamp of the last processed entry of the auxtrace_buffer replaces the
 * current auxtrace_heap top.
 *
 * 3. Auxtrace_queues might run of out data and are fed by the
 * PERF_RECORD_AUXTRACE handling, see s390_cpumsf_process_auxtrace_event().
 *
 * Event Generation
 * Each sampling-data entry in the auxiliary trace data generates a perf sample.
 * This sample is filled
 * with data from the auxtrace such as PID/TID, inकाष्ठाion address, CPU state,
 * etc. This sample is processed with perf_session__deliver_synth_event() to
 * be included पूर्णांकo the GUI.
 *
 * 4. PERF_RECORD_FINISHED_ROUND event is used to process all the reमुख्यing
 * auxiliary traces entries until the समय stamp of this record is reached
 * auxtrace_heap top. This is triggered by ordered_event->deliver().
 *
 *
 * Perf event processing.
 * Event processing of PERF_RECORD_XXX entries relies on समय stamp entries.
 * This is the function call sequence:
 *
 * __cmd_report()
 * |
 * perf_session__process_events()
 * |
 * __perf_session__process_events()
 * |
 * perf_session__process_event()
 * |  This functions splits the PERF_RECORD_XXX records.
 * |  - Those generated by perf record command (type number equal or higher
 * |    than PERF_RECORD_USER_TYPE_START) are handled by
 * |    perf_session__process_user_event(see below)
 * |  - Those generated by the kernel are handled by
 * |    evlist__parse_sample_बारtamp()
 * |
 * evlist__parse_sample_बारtamp()
 * |  Extract समय stamp from sample data.
 * |
 * perf_session__queue_event()
 * |  If बारtamp is positive the sample is entered पूर्णांकo an ordered_event
 * |  list, sort order is the बारtamp. The event processing is deferred until
 * |  later (see perf_session__process_user_event()).
 * |  Other बारtamps (0 or -1) are handled immediately by
 * |  perf_session__deliver_event(). These are events generated at start up
 * |  of command perf record. They create PERF_RECORD_COMM and PERF_RECORD_MMAP*
 * |  records. They are needed to create a list of running processes and its
 * |  memory mappings and layout. They are needed at the beginning to enable
 * |  command perf report to create process trees and memory mappings.
 * |
 * perf_session__deliver_event()
 * |  Delivers a PERF_RECORD_XXX entry क्रम handling.
 * |
 * auxtrace__process_event()
 * |  The बारtamp of the PERF_RECORD_XXX entry is taken to correlate with
 * |  समय stamps from the auxiliary trace buffers. This enables
 * |  synchronization between auxiliary trace data and the events on the
 * |  perf.data file.
 * |
 * machine__deliver_event()
 * |  Handles the PERF_RECORD_XXX event. This depends on the record type.
 *    It might update the process tree, update a process memory map or enter
 *    a sample with IP and call back chain data पूर्णांकo GUI data pool.
 *
 *
 * Deferred processing determined by perf_session__process_user_event() is
 * finally processed when a PERF_RECORD_FINISHED_ROUND is encountered. These
 * are generated during command perf record.
 * The बारtamp of PERF_RECORD_FINISHED_ROUND event is taken to process all
 * PERF_RECORD_XXX entries stored in the ordered_event list. This list was
 * built up जबतक पढ़ोing the perf.data file.
 * Each event is now processed by calling perf_session__deliver_event().
 * This enables समय synchronization between the data in the perf.data file and
 * the data in the auxiliary trace buffers.
 */

#समावेश <endian.h>
#समावेश <त्रुटिसं.स>
#समावेश <byteswap.h>
#समावेश <पूर्णांकtypes.h>
#समावेश <linux/kernel.h>
#समावेश <linux/types.h>
#समावेश <linux/bitops.h>
#समावेश <linux/log2.h>
#समावेश <linux/zभाग.स>

#समावेश <sys/स्थिति.स>
#समावेश <sys/types.h>

#समावेश "color.h"
#समावेश "evsel.h"
#समावेश "evlist.h"
#समावेश "machine.h"
#समावेश "session.h"
#समावेश "tool.h"
#समावेश "debug.h"
#समावेश "auxtrace.h"
#समावेश "s390-cpumsf.h"
#समावेश "s390-cpumsf-kernel.h"
#समावेश "s390-cpumcf-kernel.h"
#समावेश "config.h"

काष्ठा s390_cpumsf अणु
	काष्ठा auxtrace		auxtrace;
	काष्ठा auxtrace_queues	queues;
	काष्ठा auxtrace_heap	heap;
	काष्ठा perf_session	*session;
	काष्ठा machine		*machine;
	u32			auxtrace_type;
	u32			pmu_type;
	u16			machine_type;
	bool			data_queued;
	bool			use_logfile;
	अक्षर			*logdir;
पूर्ण;

काष्ठा s390_cpumsf_queue अणु
	काष्ठा s390_cpumsf	*sf;
	अचिन्हित पूर्णांक		queue_nr;
	काष्ठा auxtrace_buffer	*buffer;
	पूर्णांक			cpu;
	खाता			*logfile;
	खाता			*logfile_ctr;
पूर्ण;

/* Check अगर the raw data should be dumped to file. If this is the हाल and
 * the file to dump to has not been खोलोed क्रम writing, करो so.
 *
 * Return 0 on success and greater zero on error so processing जारीs.
 */
अटल पूर्णांक s390_cpumcf_dumpctr(काष्ठा s390_cpumsf *sf,
			       काष्ठा perf_sample *sample)
अणु
	काष्ठा s390_cpumsf_queue *sfq;
	काष्ठा auxtrace_queue *q;
	पूर्णांक rc = 0;

	अगर (!sf->use_logfile || sf->queues.nr_queues <= sample->cpu)
		वापस rc;

	q = &sf->queues.queue_array[sample->cpu];
	sfq = q->priv;
	अगर (!sfq)		/* Queue not yet allocated */
		वापस rc;

	अगर (!sfq->logfile_ctr) अणु
		अक्षर *name;

		rc = (sf->logdir)
			? aप्र_लिखो(&name, "%s/aux.ctr.%02x",
				 sf->logdir, sample->cpu)
			: aप्र_लिखो(&name, "aux.ctr.%02x", sample->cpu);
		अगर (rc > 0)
			sfq->logfile_ctr = ख_खोलो(name, "w");
		अगर (sfq->logfile_ctr == शून्य) अणु
			pr_err("Failed to open counter set log file %s, "
			       "continue...\n", name);
			rc = 1;
		पूर्ण
		मुक्त(name);
	पूर्ण

	अगर (sfq->logfile_ctr) अणु
		/* See comment above क्रम -4 */
		माप_प्रकार n = ख_डालो(sample->raw_data, sample->raw_size - 4, 1,
				  sfq->logfile_ctr);
		अगर (n != 1) अणु
			pr_err("Failed to write counter set data\n");
			rc = 1;
		पूर्ण
	पूर्ण
	वापस rc;
पूर्ण

/* Display s390 CPU measurement facility basic-sampling data entry
 * Data written on s390 in big endian byte order and contains bit
 * fields across byte boundaries.
 */
अटल bool s390_cpumsf_basic_show(स्थिर अक्षर *color, माप_प्रकार pos,
				   काष्ठा hws_basic_entry *basicp)
अणु
	काष्ठा hws_basic_entry *basic = basicp;
#अगर __BYTE_ORDER == __LITTLE_ENDIAN
	काष्ठा hws_basic_entry local;
	अचिन्हित दीर्घ दीर्घ word = be64toh(*(अचिन्हित दीर्घ दीर्घ *)basicp);

	स_रखो(&local, 0, माप(local));
	local.def = be16toh(basicp->def);
	local.prim_asn = word & 0xffff;
	local.CL = word >> 30 & 0x3;
	local.I = word >> 32 & 0x1;
	local.AS = word >> 33 & 0x3;
	local.P = word >> 35 & 0x1;
	local.W = word >> 36 & 0x1;
	local.T = word >> 37 & 0x1;
	local.U = word >> 40 & 0xf;
	local.ia = be64toh(basicp->ia);
	local.gpp = be64toh(basicp->gpp);
	local.hpp = be64toh(basicp->hpp);
	basic = &local;
#पूर्ण_अगर
	अगर (basic->def != 1) अणु
		pr_err("Invalid AUX trace basic entry [%#08zx]\n", pos);
		वापस false;
	पूर्ण
	color_ख_लिखो(मानक_निकास, color, "    [%#08zx] Basic   Def:%04x Inst:%#04x"
		      " %c%c%c%c AS:%d ASN:%#04x IA:%#018llx\n"
		      "\t\tCL:%d HPP:%#018llx GPP:%#018llx\n",
		      pos, basic->def, basic->U,
		      basic->T ? 'T' : ' ',
		      basic->W ? 'W' : ' ',
		      basic->P ? 'P' : ' ',
		      basic->I ? 'I' : ' ',
		      basic->AS, basic->prim_asn, basic->ia, basic->CL,
		      basic->hpp, basic->gpp);
	वापस true;
पूर्ण

/* Display s390 CPU measurement facility diagnostic-sampling data entry.
 * Data written on s390 in big endian byte order and contains bit
 * fields across byte boundaries.
 */
अटल bool s390_cpumsf_diag_show(स्थिर अक्षर *color, माप_प्रकार pos,
				  काष्ठा hws_diag_entry *diagp)
अणु
	काष्ठा hws_diag_entry *diag = diagp;
#अगर __BYTE_ORDER == __LITTLE_ENDIAN
	काष्ठा hws_diag_entry local;
	अचिन्हित दीर्घ दीर्घ word = be64toh(*(अचिन्हित दीर्घ दीर्घ *)diagp);

	local.def = be16toh(diagp->def);
	local.I = word >> 32 & 0x1;
	diag = &local;
#पूर्ण_अगर
	अगर (diag->def < S390_CPUMSF_DIAG_DEF_FIRST) अणु
		pr_err("Invalid AUX trace diagnostic entry [%#08zx]\n", pos);
		वापस false;
	पूर्ण
	color_ख_लिखो(मानक_निकास, color, "    [%#08zx] Diag    Def:%04x %c\n",
		      pos, diag->def, diag->I ? 'I' : ' ');
	वापस true;
पूर्ण

/* Return TOD बारtamp contained in an trailer entry */
अटल अचिन्हित दीर्घ दीर्घ trailer_बारtamp(काष्ठा hws_trailer_entry *te,
					    पूर्णांक idx)
अणु
	/* te->t set: TOD in STCKE क्रमmat, bytes 8-15
	 * to->t not set: TOD in STCK क्रमmat, bytes 0-7
	 */
	अचिन्हित दीर्घ दीर्घ ts;

	स_नकल(&ts, &te->बारtamp[idx], माप(ts));
	वापस be64toh(ts);
पूर्ण

/* Display s390 CPU measurement facility trailer entry */
अटल bool s390_cpumsf_trailer_show(स्थिर अक्षर *color, माप_प्रकार pos,
				     काष्ठा hws_trailer_entry *te)
अणु
#अगर __BYTE_ORDER == __LITTLE_ENDIAN
	काष्ठा hws_trailer_entry local;
	स्थिर अचिन्हित दीर्घ दीर्घ flags = be64toh(te->flags);

	स_रखो(&local, 0, माप(local));
	local.f = flags >> 63 & 0x1;
	local.a = flags >> 62 & 0x1;
	local.t = flags >> 61 & 0x1;
	local.bsdes = be16toh((flags >> 16 & 0xffff));
	local.dsdes = be16toh((flags & 0xffff));
	स_नकल(&local.बारtamp, te->बारtamp, माप(te->बारtamp));
	local.overflow = be64toh(te->overflow);
	local.घड़ी_base = be64toh(te->progusage[0]) >> 63 & 1;
	local.progusage2 = be64toh(te->progusage2);
	te = &local;
#पूर्ण_अगर
	अगर (te->bsdes != माप(काष्ठा hws_basic_entry)) अणु
		pr_err("Invalid AUX trace trailer entry [%#08zx]\n", pos);
		वापस false;
	पूर्ण
	color_ख_लिखो(मानक_निकास, color, "    [%#08zx] Trailer %c%c%c bsdes:%d"
		      " dsdes:%d Overflow:%lld Time:%#llx\n"
		      "\t\tC:%d TOD:%#lx\n",
		      pos,
		      te->f ? 'F' : ' ',
		      te->a ? 'A' : ' ',
		      te->t ? 'T' : ' ',
		      te->bsdes, te->dsdes, te->overflow,
		      trailer_बारtamp(te, te->घड़ी_base),
		      te->घड़ी_base, te->progusage2);
	वापस true;
पूर्ण

/* Test a sample data block. It must be 4KB or a multiple thereof in size and
 * 4KB page aligned. Each sample data page has a trailer entry at the
 * end which contains the sample entry data sizes.
 *
 * Return true अगर the sample data block passes the checks and set the
 * basic set entry size and diagnostic set entry size.
 *
 * Return false on failure.
 *
 * Note: Old hardware करोes not set the basic or diagnostic entry sizes
 * in the trailer entry. Use the type number instead.
 */
अटल bool s390_cpumsf_validate(पूर्णांक machine_type,
				 अचिन्हित अक्षर *buf, माप_प्रकार len,
				 अचिन्हित लघु *bsdes,
				 अचिन्हित लघु *dsdes)
अणु
	काष्ठा hws_basic_entry *basic = (काष्ठा hws_basic_entry *)buf;
	काष्ठा hws_trailer_entry *te;

	*dsdes = *bsdes = 0;
	अगर (len & (S390_CPUMSF_PAGESZ - 1))	/* Illegal size */
		वापस false;
	अगर (be16toh(basic->def) != 1)	/* No basic set entry, must be first */
		वापस false;
	/* Check क्रम trailer entry at end of SDB */
	te = (काष्ठा hws_trailer_entry *)(buf + S390_CPUMSF_PAGESZ
					      - माप(*te));
	*bsdes = be16toh(te->bsdes);
	*dsdes = be16toh(te->dsdes);
	अगर (!te->bsdes && !te->dsdes) अणु
		/* Very old hardware, use CPUID */
		चयन (machine_type) अणु
		हाल 2097:
		हाल 2098:
			*dsdes = 64;
			*bsdes = 32;
			अवरोध;
		हाल 2817:
		हाल 2818:
			*dsdes = 74;
			*bsdes = 32;
			अवरोध;
		हाल 2827:
		हाल 2828:
			*dsdes = 85;
			*bsdes = 32;
			अवरोध;
		हाल 2964:
		हाल 2965:
			*dsdes = 112;
			*bsdes = 32;
			अवरोध;
		शेष:
			/* Illegal trailer entry */
			वापस false;
		पूर्ण
	पूर्ण
	वापस true;
पूर्ण

/* Return true अगर there is room क्रम another entry */
अटल bool s390_cpumsf_reached_trailer(माप_प्रकार entry_sz, माप_प्रकार pos)
अणु
	माप_प्रकार payload = S390_CPUMSF_PAGESZ - माप(काष्ठा hws_trailer_entry);

	अगर (payload - (pos & (S390_CPUMSF_PAGESZ - 1)) < entry_sz)
		वापस false;
	वापस true;
पूर्ण

/* Dump an auxiliary buffer. These buffers are multiple of
 * 4KB SDB pages.
 */
अटल व्योम s390_cpumsf_dump(काष्ठा s390_cpumsf *sf,
			     अचिन्हित अक्षर *buf, माप_प्रकार len)
अणु
	स्थिर अक्षर *color = PERF_COLOR_BLUE;
	काष्ठा hws_basic_entry *basic;
	काष्ठा hws_diag_entry *diag;
	अचिन्हित लघु bsdes, dsdes;
	माप_प्रकार pos = 0;

	color_ख_लिखो(मानक_निकास, color,
		      ". ... s390 AUX data: size %zu bytes\n",
		      len);

	अगर (!s390_cpumsf_validate(sf->machine_type, buf, len, &bsdes,
				  &dsdes)) अणु
		pr_err("Invalid AUX trace data block size:%zu"
		       " (type:%d bsdes:%hd dsdes:%hd)\n",
		       len, sf->machine_type, bsdes, dsdes);
		वापस;
	पूर्ण

	/* s390 kernel always वापसs 4KB blocks fully occupied,
	 * no partially filled SDBs.
	 */
	जबतक (pos < len) अणु
		/* Handle Basic entry */
		basic = (काष्ठा hws_basic_entry *)(buf + pos);
		अगर (s390_cpumsf_basic_show(color, pos, basic))
			pos += bsdes;
		अन्यथा
			वापस;

		/* Handle Diagnostic entry */
		diag = (काष्ठा hws_diag_entry *)(buf + pos);
		अगर (s390_cpumsf_diag_show(color, pos, diag))
			pos += dsdes;
		अन्यथा
			वापस;

		/* Check क्रम trailer entry */
		अगर (!s390_cpumsf_reached_trailer(bsdes + dsdes, pos)) अणु
			/* Show trailer entry */
			काष्ठा hws_trailer_entry te;

			pos = (pos + S390_CPUMSF_PAGESZ)
			       & ~(S390_CPUMSF_PAGESZ - 1);
			pos -= माप(te);
			स_नकल(&te, buf + pos, माप(te));
			/* Set descriptor sizes in हाल of old hardware
			 * where these values are not set.
			 */
			te.bsdes = bsdes;
			te.dsdes = dsdes;
			अगर (s390_cpumsf_trailer_show(color, pos, &te))
				pos += माप(te);
			अन्यथा
				वापस;
		पूर्ण
	पूर्ण
पूर्ण

अटल व्योम s390_cpumsf_dump_event(काष्ठा s390_cpumsf *sf, अचिन्हित अक्षर *buf,
				   माप_प्रकार len)
अणु
	म_लिखो(".\n");
	s390_cpumsf_dump(sf, buf, len);
पूर्ण

#घोषणा	S390_LPP_PID_MASK	0xffffffff

अटल bool s390_cpumsf_make_event(माप_प्रकार pos,
				   काष्ठा hws_basic_entry *basic,
				   काष्ठा s390_cpumsf_queue *sfq)
अणु
	काष्ठा perf_sample sample = अणु
				.ip = basic->ia,
				.pid = basic->hpp & S390_LPP_PID_MASK,
				.tid = basic->hpp & S390_LPP_PID_MASK,
				.cpumode = PERF_RECORD_MISC_CPUMODE_UNKNOWN,
				.cpu = sfq->cpu,
				.period = 1
			    पूर्ण;
	जोड़ perf_event event;

	स_रखो(&event, 0, माप(event));
	अगर (basic->CL == 1)	/* Native LPAR mode */
		sample.cpumode = basic->P ? PERF_RECORD_MISC_USER
					  : PERF_RECORD_MISC_KERNEL;
	अन्यथा अगर (basic->CL == 2)	/* Guest kernel/user space */
		sample.cpumode = basic->P ? PERF_RECORD_MISC_GUEST_USER
					  : PERF_RECORD_MISC_GUEST_KERNEL;
	अन्यथा अगर (basic->gpp || basic->prim_asn != 0xffff)
		/* Use heuristics on old hardware */
		sample.cpumode = basic->P ? PERF_RECORD_MISC_GUEST_USER
					  : PERF_RECORD_MISC_GUEST_KERNEL;
	अन्यथा
		sample.cpumode = basic->P ? PERF_RECORD_MISC_USER
					  : PERF_RECORD_MISC_KERNEL;

	event.sample.header.type = PERF_RECORD_SAMPLE;
	event.sample.header.misc = sample.cpumode;
	event.sample.header.size = माप(काष्ठा perf_event_header);

	pr_debug4("%s pos:%#zx ip:%#" PRIx64 " P:%d CL:%d pid:%d.%d cpumode:%d cpu:%d\n",
		 __func__, pos, sample.ip, basic->P, basic->CL, sample.pid,
		 sample.tid, sample.cpumode, sample.cpu);
	अगर (perf_session__deliver_synth_event(sfq->sf->session, &event,
					      &sample)) अणु
		pr_err("s390 Auxiliary Trace: failed to deliver event\n");
		वापस false;
	पूर्ण
	वापस true;
पूर्ण

अटल अचिन्हित दीर्घ दीर्घ get_trailer_समय(स्थिर अचिन्हित अक्षर *buf)
अणु
	काष्ठा hws_trailer_entry *te;
	अचिन्हित दीर्घ दीर्घ aux_समय, progusage2;
	bool घड़ी_base;

	te = (काष्ठा hws_trailer_entry *)(buf + S390_CPUMSF_PAGESZ
					      - माप(*te));

#अगर __BYTE_ORDER == __LITTLE_ENDIAN
	घड़ी_base = be64toh(te->progusage[0]) >> 63 & 0x1;
	progusage2 = be64toh(te->progusage[1]);
#अन्यथा
	घड़ी_base = te->घड़ी_base;
	progusage2 = te->progusage2;
#पूर्ण_अगर
	अगर (!घड़ी_base)	/* TOD_CLOCK_BASE value missing */
		वापस 0;

	/* Correct calculation to convert समय stamp in trailer entry to
	 * nano seconds (taken from arch/s390 function tod_to_ns()).
	 * TOD_CLOCK_BASE is stored in trailer entry member progusage2.
	 */
	aux_समय = trailer_बारtamp(te, घड़ी_base) - progusage2;
	aux_समय = (aux_समय >> 9) * 125 + (((aux_समय & 0x1ff) * 125) >> 9);
	वापस aux_समय;
पूर्ण

/* Process the data samples of a single queue. The first parameter is a
 * poपूर्णांकer to the queue, the second parameter is the समय stamp. This
 * is the समय stamp:
 * - of the event that triggered this processing.
 * - or the समय stamp when the last processing of this queue stopped.
 *   In this हाल it stopped at a 4KB page boundary and record the
 *   position on where to जारी processing on the next invocation
 *   (see buffer->use_data and buffer->use_size).
 *
 * When this function वापसs the second parameter is updated to
 * reflect the समय stamp of the last processed auxiliary data entry
 * (taken from the trailer entry of that page). The caller uses this
 * वापसed समय stamp to record the last processed entry in this
 * queue.
 *
 * The function वापसs:
 * 0:  Processing successful. The second parameter वापसs the
 *     समय stamp from the trailer entry until which position
 *     processing took place. Subsequent calls resume from this
 *     position.
 * <0: An error occurred during processing. The second parameter
 *     वापसs the maximum समय stamp.
 * >0: Done on this queue. The second parameter वापसs the
 *     maximum समय stamp.
 */
अटल पूर्णांक s390_cpumsf_samples(काष्ठा s390_cpumsf_queue *sfq, u64 *ts)
अणु
	काष्ठा s390_cpumsf *sf = sfq->sf;
	अचिन्हित अक्षर *buf = sfq->buffer->use_data;
	माप_प्रकार len = sfq->buffer->use_size;
	काष्ठा hws_basic_entry *basic;
	अचिन्हित लघु bsdes, dsdes;
	माप_प्रकार pos = 0;
	पूर्णांक err = 1;
	u64 aux_ts;

	अगर (!s390_cpumsf_validate(sf->machine_type, buf, len, &bsdes,
				  &dsdes)) अणु
		*ts = ~0ULL;
		वापस -1;
	पूर्ण

	/* Get trailer entry समय stamp and check अगर entries in
	 * this auxiliary page are पढ़ोy क्रम processing. If the
	 * समय stamp of the first entry is too high, whole buffer
	 * can be skipped. In this हाल वापस समय stamp.
	 */
	aux_ts = get_trailer_समय(buf);
	अगर (!aux_ts) अणु
		pr_err("[%#08" PRIx64 "] Invalid AUX trailer entry TOD clock base\n",
		       (s64)sfq->buffer->data_offset);
		aux_ts = ~0ULL;
		जाओ out;
	पूर्ण
	अगर (aux_ts > *ts) अणु
		*ts = aux_ts;
		वापस 0;
	पूर्ण

	जबतक (pos < len) अणु
		/* Handle Basic entry */
		basic = (काष्ठा hws_basic_entry *)(buf + pos);
		अगर (s390_cpumsf_make_event(pos, basic, sfq))
			pos += bsdes;
		अन्यथा अणु
			err = -EBADF;
			जाओ out;
		पूर्ण

		pos += dsdes;	/* Skip diagnostic entry */

		/* Check क्रम trailer entry */
		अगर (!s390_cpumsf_reached_trailer(bsdes + dsdes, pos)) अणु
			pos = (pos + S390_CPUMSF_PAGESZ)
			       & ~(S390_CPUMSF_PAGESZ - 1);
			/* Check existence of next page */
			अगर (pos >= len)
				अवरोध;
			aux_ts = get_trailer_समय(buf + pos);
			अगर (!aux_ts) अणु
				aux_ts = ~0ULL;
				जाओ out;
			पूर्ण
			अगर (aux_ts > *ts) अणु
				*ts = aux_ts;
				sfq->buffer->use_data += pos;
				sfq->buffer->use_size -= pos;
				वापस 0;
			पूर्ण
		पूर्ण
	पूर्ण
out:
	*ts = aux_ts;
	sfq->buffer->use_size = 0;
	sfq->buffer->use_data = शून्य;
	वापस err;	/* Buffer completely scanned or error */
पूर्ण

/* Run the s390 auxiliary trace decoder.
 * Select the queue buffer to operate on, the caller alपढ़ोy selected
 * the proper queue, depending on second parameter 'ts'.
 * This is the समय stamp until which the auxiliary entries should
 * be processed. This value is updated by called functions and
 * वापसed to the caller.
 *
 * Resume processing in the current buffer. If there is no buffer
 * get a new buffer from the queue and setup start position क्रम
 * processing.
 * When a buffer is completely processed हटाओ it from the queue
 * beक्रमe वापसing.
 *
 * This function वापसs
 * 1: When the queue is empty. Second parameter will be set to
 *    maximum समय stamp.
 * 0: Normal processing करोne.
 * <0: Error during queue buffer setup. This causes the caller
 *     to stop processing completely.
 */
अटल पूर्णांक s390_cpumsf_run_decoder(काष्ठा s390_cpumsf_queue *sfq,
				   u64 *ts)
अणु

	काष्ठा auxtrace_buffer *buffer;
	काष्ठा auxtrace_queue *queue;
	पूर्णांक err;

	queue = &sfq->sf->queues.queue_array[sfq->queue_nr];

	/* Get buffer and last position in buffer to resume
	 * decoding the auxiliary entries. One buffer might be large
	 * and decoding might stop in between. This depends on the समय
	 * stamp of the trailer entry in each page of the auxiliary
	 * data and the समय stamp of the event triggering the decoding.
	 */
	अगर (sfq->buffer == शून्य) अणु
		sfq->buffer = buffer = auxtrace_buffer__next(queue,
							     sfq->buffer);
		अगर (!buffer) अणु
			*ts = ~0ULL;
			वापस 1;	/* Processing करोne on this queue */
		पूर्ण
		/* Start with a new buffer on this queue */
		अगर (buffer->data) अणु
			buffer->use_size = buffer->size;
			buffer->use_data = buffer->data;
		पूर्ण
		अगर (sfq->logfile) अणु	/* Write पूर्णांकo log file */
			माप_प्रकार rc = ख_डालो(buffer->data, buffer->size, 1,
					   sfq->logfile);
			अगर (rc != 1)
				pr_err("Failed to write auxiliary data\n");
		पूर्ण
	पूर्ण अन्यथा
		buffer = sfq->buffer;

	अगर (!buffer->data) अणु
		पूर्णांक fd = perf_data__fd(sfq->sf->session->data);

		buffer->data = auxtrace_buffer__get_data(buffer, fd);
		अगर (!buffer->data)
			वापस -ENOMEM;
		buffer->use_size = buffer->size;
		buffer->use_data = buffer->data;

		अगर (sfq->logfile) अणु	/* Write पूर्णांकo log file */
			माप_प्रकार rc = ख_डालो(buffer->data, buffer->size, 1,
					   sfq->logfile);
			अगर (rc != 1)
				pr_err("Failed to write auxiliary data\n");
		पूर्ण
	पूर्ण
	pr_debug4("%s queue_nr:%d buffer:%" PRId64 " offset:%#" PRIx64 " size:%#zx rest:%#zx\n",
		  __func__, sfq->queue_nr, buffer->buffer_nr, buffer->offset,
		  buffer->size, buffer->use_size);
	err = s390_cpumsf_samples(sfq, ts);

	/* If non-zero, there is either an error (err < 0) or the buffer is
	 * completely करोne (err > 0). The error is unrecoverable, usually
	 * some descriptors could not be पढ़ो successfully, so जारी with
	 * the next buffer.
	 * In both हालs the parameter 'ts' has been updated.
	 */
	अगर (err) अणु
		sfq->buffer = शून्य;
		list_del_init(&buffer->list);
		auxtrace_buffer__मुक्त(buffer);
		अगर (err > 0)		/* Buffer करोne, no error */
			err = 0;
	पूर्ण
	वापस err;
पूर्ण

अटल काष्ठा s390_cpumsf_queue *
s390_cpumsf_alloc_queue(काष्ठा s390_cpumsf *sf, अचिन्हित पूर्णांक queue_nr)
अणु
	काष्ठा s390_cpumsf_queue *sfq;

	sfq = zalloc(माप(काष्ठा s390_cpumsf_queue));
	अगर (sfq == शून्य)
		वापस शून्य;

	sfq->sf = sf;
	sfq->queue_nr = queue_nr;
	sfq->cpu = -1;
	अगर (sf->use_logfile) अणु
		अक्षर *name;
		पूर्णांक rc;

		rc = (sf->logdir)
			? aप्र_लिखो(&name, "%s/aux.smp.%02x",
				 sf->logdir, queue_nr)
			: aप्र_लिखो(&name, "aux.smp.%02x", queue_nr);
		अगर (rc > 0)
			sfq->logfile = ख_खोलो(name, "w");
		अगर (sfq->logfile == शून्य) अणु
			pr_err("Failed to open auxiliary log file %s,"
			       "continue...\n", name);
			sf->use_logfile = false;
		पूर्ण
		मुक्त(name);
	पूर्ण
	वापस sfq;
पूर्ण

अटल पूर्णांक s390_cpumsf_setup_queue(काष्ठा s390_cpumsf *sf,
				   काष्ठा auxtrace_queue *queue,
				   अचिन्हित पूर्णांक queue_nr, u64 ts)
अणु
	काष्ठा s390_cpumsf_queue *sfq = queue->priv;

	अगर (list_empty(&queue->head))
		वापस 0;

	अगर (sfq == शून्य) अणु
		sfq = s390_cpumsf_alloc_queue(sf, queue_nr);
		अगर (!sfq)
			वापस -ENOMEM;
		queue->priv = sfq;

		अगर (queue->cpu != -1)
			sfq->cpu = queue->cpu;
	पूर्ण
	वापस auxtrace_heap__add(&sf->heap, queue_nr, ts);
पूर्ण

अटल पूर्णांक s390_cpumsf_setup_queues(काष्ठा s390_cpumsf *sf, u64 ts)
अणु
	अचिन्हित पूर्णांक i;
	पूर्णांक ret = 0;

	क्रम (i = 0; i < sf->queues.nr_queues; i++) अणु
		ret = s390_cpumsf_setup_queue(sf, &sf->queues.queue_array[i],
					      i, ts);
		अगर (ret)
			अवरोध;
	पूर्ण
	वापस ret;
पूर्ण

अटल पूर्णांक s390_cpumsf_update_queues(काष्ठा s390_cpumsf *sf, u64 ts)
अणु
	अगर (!sf->queues.new_data)
		वापस 0;

	sf->queues.new_data = false;
	वापस s390_cpumsf_setup_queues(sf, ts);
पूर्ण

अटल पूर्णांक s390_cpumsf_process_queues(काष्ठा s390_cpumsf *sf, u64 बारtamp)
अणु
	अचिन्हित पूर्णांक queue_nr;
	u64 ts;
	पूर्णांक ret;

	जबतक (1) अणु
		काष्ठा auxtrace_queue *queue;
		काष्ठा s390_cpumsf_queue *sfq;

		अगर (!sf->heap.heap_cnt)
			वापस 0;

		अगर (sf->heap.heap_array[0].ordinal >= बारtamp)
			वापस 0;

		queue_nr = sf->heap.heap_array[0].queue_nr;
		queue = &sf->queues.queue_array[queue_nr];
		sfq = queue->priv;

		auxtrace_heap__pop(&sf->heap);
		अगर (sf->heap.heap_cnt) अणु
			ts = sf->heap.heap_array[0].ordinal + 1;
			अगर (ts > बारtamp)
				ts = बारtamp;
		पूर्ण अन्यथा अणु
			ts = बारtamp;
		पूर्ण

		ret = s390_cpumsf_run_decoder(sfq, &ts);
		अगर (ret < 0) अणु
			auxtrace_heap__add(&sf->heap, queue_nr, ts);
			वापस ret;
		पूर्ण
		अगर (!ret) अणु
			ret = auxtrace_heap__add(&sf->heap, queue_nr, ts);
			अगर (ret < 0)
				वापस ret;
		पूर्ण
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक s390_cpumsf_synth_error(काष्ठा s390_cpumsf *sf, पूर्णांक code, पूर्णांक cpu,
				   pid_t pid, pid_t tid, u64 ip, u64 बारtamp)
अणु
	अक्षर msg[MAX_AUXTRACE_ERROR_MSG];
	जोड़ perf_event event;
	पूर्णांक err;

	म_नकलन(msg, "Lost Auxiliary Trace Buffer", माप(msg) - 1);
	auxtrace_synth_error(&event.auxtrace_error, PERF_AUXTRACE_ERROR_ITRACE,
			     code, cpu, pid, tid, ip, msg, बारtamp);

	err = perf_session__deliver_synth_event(sf->session, &event, शून्य);
	अगर (err)
		pr_err("s390 Auxiliary Trace: failed to deliver error event,"
			"error %d\n", err);
	वापस err;
पूर्ण

अटल पूर्णांक s390_cpumsf_lost(काष्ठा s390_cpumsf *sf, काष्ठा perf_sample *sample)
अणु
	वापस s390_cpumsf_synth_error(sf, 1, sample->cpu,
				       sample->pid, sample->tid, 0,
				       sample->समय);
पूर्ण

अटल पूर्णांक
s390_cpumsf_process_event(काष्ठा perf_session *session,
			  जोड़ perf_event *event,
			  काष्ठा perf_sample *sample,
			  काष्ठा perf_tool *tool)
अणु
	काष्ठा s390_cpumsf *sf = container_of(session->auxtrace,
					      काष्ठा s390_cpumsf,
					      auxtrace);
	u64 बारtamp = sample->समय;
	काष्ठा evsel *ev_bc000;

	पूर्णांक err = 0;

	अगर (dump_trace)
		वापस 0;

	अगर (!tool->ordered_events) अणु
		pr_err("s390 Auxiliary Trace requires ordered events\n");
		वापस -EINVAL;
	पूर्ण

	अगर (event->header.type == PERF_RECORD_SAMPLE &&
	    sample->raw_size) अणु
		/* Handle event with raw data */
		ev_bc000 = evlist__event2evsel(session->evlist, event);
		अगर (ev_bc000 &&
		    ev_bc000->core.attr.config == PERF_EVENT_CPUM_CF_DIAG)
			err = s390_cpumcf_dumpctr(sf, sample);
		वापस err;
	पूर्ण

	अगर (event->header.type == PERF_RECORD_AUX &&
	    event->aux.flags & PERF_AUX_FLAG_TRUNCATED)
		वापस s390_cpumsf_lost(sf, sample);

	अगर (बारtamp) अणु
		err = s390_cpumsf_update_queues(sf, बारtamp);
		अगर (!err)
			err = s390_cpumsf_process_queues(sf, बारtamp);
	पूर्ण
	वापस err;
पूर्ण

काष्ठा s390_cpumsf_synth अणु
	काष्ठा perf_tool cpumsf_tool;
	काष्ठा perf_session *session;
पूर्ण;

अटल पूर्णांक
s390_cpumsf_process_auxtrace_event(काष्ठा perf_session *session,
				   जोड़ perf_event *event __maybe_unused,
				   काष्ठा perf_tool *tool __maybe_unused)
अणु
	काष्ठा s390_cpumsf *sf = container_of(session->auxtrace,
					      काष्ठा s390_cpumsf,
					      auxtrace);

	पूर्णांक fd = perf_data__fd(session->data);
	काष्ठा auxtrace_buffer *buffer;
	off_t data_offset;
	पूर्णांक err;

	अगर (sf->data_queued)
		वापस 0;

	अगर (perf_data__is_pipe(session->data)) अणु
		data_offset = 0;
	पूर्ण अन्यथा अणु
		data_offset = lseek(fd, 0, प्रस्तुत_से);
		अगर (data_offset == -1)
			वापस -त्रुटि_सं;
	पूर्ण

	err = auxtrace_queues__add_event(&sf->queues, session, event,
					 data_offset, &buffer);
	अगर (err)
		वापस err;

	/* Dump here after copying piped trace out of the pipe */
	अगर (dump_trace) अणु
		अगर (auxtrace_buffer__get_data(buffer, fd)) अणु
			s390_cpumsf_dump_event(sf, buffer->data,
					       buffer->size);
			auxtrace_buffer__put_data(buffer);
		पूर्ण
	पूर्ण
	वापस 0;
पूर्ण

अटल व्योम s390_cpumsf_मुक्त_events(काष्ठा perf_session *session __maybe_unused)
अणु
पूर्ण

अटल पूर्णांक s390_cpumsf_flush(काष्ठा perf_session *session __maybe_unused,
			     काष्ठा perf_tool *tool __maybe_unused)
अणु
	वापस 0;
पूर्ण

अटल व्योम s390_cpumsf_मुक्त_queues(काष्ठा perf_session *session)
अणु
	काष्ठा s390_cpumsf *sf = container_of(session->auxtrace,
					      काष्ठा s390_cpumsf,
					      auxtrace);
	काष्ठा auxtrace_queues *queues = &sf->queues;
	अचिन्हित पूर्णांक i;

	क्रम (i = 0; i < queues->nr_queues; i++) अणु
		काष्ठा s390_cpumsf_queue *sfq = (काष्ठा s390_cpumsf_queue *)
						queues->queue_array[i].priv;

		अगर (sfq != शून्य) अणु
			अगर (sfq->logfile) अणु
				ख_बंद(sfq->logfile);
				sfq->logfile = शून्य;
			पूर्ण
			अगर (sfq->logfile_ctr) अणु
				ख_बंद(sfq->logfile_ctr);
				sfq->logfile_ctr = शून्य;
			पूर्ण
		पूर्ण
		zमुक्त(&queues->queue_array[i].priv);
	पूर्ण
	auxtrace_queues__मुक्त(queues);
पूर्ण

अटल व्योम s390_cpumsf_मुक्त(काष्ठा perf_session *session)
अणु
	काष्ठा s390_cpumsf *sf = container_of(session->auxtrace,
					      काष्ठा s390_cpumsf,
					      auxtrace);

	auxtrace_heap__मुक्त(&sf->heap);
	s390_cpumsf_मुक्त_queues(session);
	session->auxtrace = शून्य;
	zमुक्त(&sf->logdir);
	मुक्त(sf);
पूर्ण

अटल bool
s390_cpumsf_evsel_is_auxtrace(काष्ठा perf_session *session __maybe_unused,
			      काष्ठा evsel *evsel)
अणु
	वापस evsel->core.attr.type == PERF_TYPE_RAW &&
	       evsel->core.attr.config == PERF_EVENT_CPUM_SF_DIAG;
पूर्ण

अटल पूर्णांक s390_cpumsf_get_type(स्थिर अक्षर *cpuid)
अणु
	पूर्णांक ret, family = 0;

	ret = माला_पूछो(cpuid, "%*[^,],%u", &family);
	वापस (ret == 1) ? family : 0;
पूर्ण

/* Check itrace options set on perf report command.
 * Return true, अगर none are set or all options specअगरied can be
 * handled on s390 (currently only option 'd' क्रम logging.
 * Return false otherwise.
 */
अटल bool check_auxtrace_itrace(काष्ठा itrace_synth_opts *itops)
अणु
	bool ison = false;

	अगर (!itops || !itops->set)
		वापस true;
	ison = itops->inject || itops->inकाष्ठाions || itops->branches ||
		itops->transactions || itops->ptग_लिखोs ||
		itops->pwr_events || itops->errors ||
		itops->करोnt_decode || itops->calls || itops->वापसs ||
		itops->callchain || itops->thपढ़ो_stack ||
		itops->last_branch || itops->add_callchain ||
		itops->add_last_branch;
	अगर (!ison)
		वापस true;
	pr_err("Unsupported --itrace options specified\n");
	वापस false;
पूर्ण

/* Check क्रम AUXTRACE dump directory अगर it is needed.
 * On failure prपूर्णांक an error message but जारी.
 * Return 0 on wrong keyword in config file and 1 otherwise.
 */
अटल पूर्णांक s390_cpumsf__config(स्थिर अक्षर *var, स्थिर अक्षर *value, व्योम *cb)
अणु
	काष्ठा s390_cpumsf *sf = cb;
	काष्ठा stat stbuf;
	पूर्णांक rc;

	अगर (म_भेद(var, "auxtrace.dumpdir"))
		वापस 0;
	sf->logdir = strdup(value);
	अगर (sf->logdir == शून्य) अणु
		pr_err("Failed to find auxtrace log directory %s,"
		       " continue with current directory...\n", value);
		वापस 1;
	पूर्ण
	rc = stat(sf->logdir, &stbuf);
	अगर (rc == -1 || !S_ISसूची(stbuf.st_mode)) अणु
		pr_err("Missing auxtrace log directory %s,"
		       " continue with current directory...\n", value);
		zमुक्त(&sf->logdir);
	पूर्ण
	वापस 1;
पूर्ण

पूर्णांक s390_cpumsf_process_auxtrace_info(जोड़ perf_event *event,
				      काष्ठा perf_session *session)
अणु
	काष्ठा perf_record_auxtrace_info *auxtrace_info = &event->auxtrace_info;
	काष्ठा s390_cpumsf *sf;
	पूर्णांक err;

	अगर (auxtrace_info->header.size < माप(काष्ठा perf_record_auxtrace_info))
		वापस -EINVAL;

	sf = zalloc(माप(काष्ठा s390_cpumsf));
	अगर (sf == शून्य)
		वापस -ENOMEM;

	अगर (!check_auxtrace_itrace(session->itrace_synth_opts)) अणु
		err = -EINVAL;
		जाओ err_मुक्त;
	पूर्ण
	sf->use_logfile = session->itrace_synth_opts->log;
	अगर (sf->use_logfile)
		perf_config(s390_cpumsf__config, sf);

	err = auxtrace_queues__init(&sf->queues);
	अगर (err)
		जाओ err_मुक्त;

	sf->session = session;
	sf->machine = &session->machines.host; /* No kvm support */
	sf->auxtrace_type = auxtrace_info->type;
	sf->pmu_type = PERF_TYPE_RAW;
	sf->machine_type = s390_cpumsf_get_type(session->evlist->env->cpuid);

	sf->auxtrace.process_event = s390_cpumsf_process_event;
	sf->auxtrace.process_auxtrace_event = s390_cpumsf_process_auxtrace_event;
	sf->auxtrace.flush_events = s390_cpumsf_flush;
	sf->auxtrace.मुक्त_events = s390_cpumsf_मुक्त_events;
	sf->auxtrace.मुक्त = s390_cpumsf_मुक्त;
	sf->auxtrace.evsel_is_auxtrace = s390_cpumsf_evsel_is_auxtrace;
	session->auxtrace = &sf->auxtrace;

	अगर (dump_trace)
		वापस 0;

	err = auxtrace_queues__process_index(&sf->queues, session);
	अगर (err)
		जाओ err_मुक्त_queues;

	अगर (sf->queues.populated)
		sf->data_queued = true;

	वापस 0;

err_मुक्त_queues:
	auxtrace_queues__मुक्त(&sf->queues);
	session->auxtrace = शून्य;
err_मुक्त:
	zमुक्त(&sf->logdir);
	मुक्त(sf);
	वापस err;
पूर्ण
