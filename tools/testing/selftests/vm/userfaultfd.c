<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 * Stress userfaultfd syscall.
 *
 *  Copyright (C) 2015  Red Hat, Inc.
 *
 * This test allocates two भव areas and bounces the physical
 * memory across the two भव areas (from area_src to area_dst)
 * using userfaultfd.
 *
 * There are three thपढ़ोs running per CPU:
 *
 * 1) one per-CPU thपढ़ो takes a per-page pthपढ़ो_mutex in a अक्रमom
 *    page of the area_dst (जबतक the physical page may still be in
 *    area_src), and increments a per-page counter in the same page,
 *    and checks its value against a verअगरication region.
 *
 * 2) another per-CPU thपढ़ो handles the userfaults generated by
 *    thपढ़ो 1 above. userfaultfd blocking पढ़ोs or poll() modes are
 *    exercised पूर्णांकerleaved.
 *
 * 3) one last per-CPU thपढ़ो transfers the memory in the background
 *    at maximum bandwidth (अगर not alपढ़ोy transferred by thपढ़ो
 *    2). Each cpu thपढ़ो takes cares of transferring a portion of the
 *    area.
 *
 * When all thपढ़ोs of type 3 completed the transfer, one bounce is
 * complete. area_src and area_dst are then swapped. All thपढ़ोs are
 * respawned and so the bounce is immediately restarted in the
 * opposite direction.
 *
 * per-CPU thपढ़ोs 1 by triggering userfaults inside
 * pthपढ़ो_mutex_lock will also verअगरy the atomicity of the memory
 * transfer (UFFDIO_COPY).
 */

#घोषणा _GNU_SOURCE
#समावेश <मानकपन.स>
#समावेश <त्रुटिसं.स>
#समावेश <unistd.h>
#समावेश <मानककोष.स>
#समावेश <sys/types.h>
#समावेश <sys/स्थिति.स>
#समावेश <fcntl.h>
#समावेश <समय.स>
#समावेश <संकेत.स>
#समावेश <poll.h>
#समावेश <माला.स>
#समावेश <sys/mman.h>
#समावेश <sys/syscall.h>
#समावेश <sys/ioctl.h>
#समावेश <sys/रुको.h>
#समावेश <pthपढ़ो.h>
#समावेश <linux/userfaultfd.h>
#समावेश <समलाँघ.स>
#समावेश <stdbool.h>
#समावेश <निश्चित.स>
#समावेश <पूर्णांकtypes.h>
#समावेश <मानक_निवेशt.h>

#समावेश "../kselftest.h"

#अगर_घोषित __NR_userfaultfd

अटल अचिन्हित दीर्घ nr_cpus, nr_pages, nr_pages_per_cpu, page_size;

#घोषणा BOUNCE_RANDOM		(1<<0)
#घोषणा BOUNCE_RACINGFAULTS	(1<<1)
#घोषणा BOUNCE_VERIFY		(1<<2)
#घोषणा BOUNCE_POLL		(1<<3)
अटल पूर्णांक bounces;

#घोषणा TEST_ANON	1
#घोषणा TEST_HUGETLB	2
#घोषणा TEST_SHMEM	3
अटल पूर्णांक test_type;

/* exercise the test_uffdio_*_eexist every ALARM_INTERVAL_SECS */
#घोषणा ALARM_INTERVAL_SECS 10
अटल अस्थिर bool test_uffdio_copy_eexist = true;
अटल अस्थिर bool test_uffdio_zeropage_eexist = true;
/* Whether to test uffd ग_लिखो-protection */
अटल bool test_uffdio_wp = false;
/* Whether to test uffd minor faults */
अटल bool test_uffdio_minor = false;

अटल bool map_shared;
अटल पूर्णांक huge_fd;
अटल अक्षर *huge_fd_off0;
अटल अचिन्हित दीर्घ दीर्घ *count_verअगरy;
अटल पूर्णांक uffd, uffd_flags, finished, *pipefd;
अटल अक्षर *area_src, *area_src_alias, *area_dst, *area_dst_alias;
अटल अक्षर *zeropage;
pthपढ़ो_attr_t attr;

/* Userfaultfd test statistics */
काष्ठा uffd_stats अणु
	पूर्णांक cpu;
	अचिन्हित दीर्घ missing_faults;
	अचिन्हित दीर्घ wp_faults;
	अचिन्हित दीर्घ minor_faults;
पूर्ण;

/* pthपढ़ो_mutex_t starts at page offset 0 */
#घोषणा area_mutex(___area, ___nr)					\
	((pthपढ़ो_mutex_t *) ((___area) + (___nr)*page_size))
/*
 * count is placed in the page after pthपढ़ो_mutex_t naturally aligned
 * to aव्योम non alignment faults on non-x86 archs.
 */
#घोषणा area_count(___area, ___nr)					\
	((अस्थिर अचिन्हित दीर्घ दीर्घ *) ((अचिन्हित दीर्घ)		\
				 ((___area) + (___nr)*page_size +	\
				  माप(pthपढ़ो_mutex_t) +		\
				  माप(अचिन्हित दीर्घ दीर्घ) - 1) &	\
				 ~(अचिन्हित दीर्घ)(माप(अचिन्हित दीर्घ दीर्घ) \
						  -  1)))

स्थिर अक्षर *examples =
    "# Run anonymous memory test on 100MiB region with 99999 bounces:\n"
    "./userfaultfd anon 100 99999\n\n"
    "# Run share memory test on 1GiB region with 99 bounces:\n"
    "./userfaultfd shmem 1000 99\n\n"
    "# Run hugetlb memory test on 256MiB region with 50 bounces (using /dev/hugepages/hugefile):\n"
    "./userfaultfd hugetlb 256 50 /dev/hugepages/hugefile\n\n"
    "# Run the same hugetlb test but using shmem:\n"
    "./userfaultfd hugetlb_shared 256 50 /dev/hugepages/hugefile\n\n"
    "# 10MiB-~6GiB 999 bounces anonymous test, "
    "continue forever unless an error triggers\n"
    "while ./userfaultfd anon $[RANDOM % 6000 + 10] 999; do true; done\n\n";

अटल व्योम usage(व्योम)
अणु
	ख_लिखो(मानक_त्रुटि, "\nUsage: ./userfaultfd <test type> <MiB> <bounces> "
		"[hugetlbfs_file]\n\n");
	ख_लिखो(मानक_त्रुटि, "Supported <test type>: anon, hugetlb, "
		"hugetlb_shared, shmem\n\n");
	ख_लिखो(मानक_त्रुटि, "Examples:\n\n");
	ख_लिखो(मानक_त्रुटि, "%s", examples);
	निकास(1);
पूर्ण

#घोषणा uffd_error(code, fmt, ...)                                             \
	करो अणु                                                                   \
		ख_लिखो(मानक_त्रुटि, fmt, ##__VA_ARGS__);                           \
		ख_लिखो(मानक_त्रुटि, ": %" PRId64 "\n", (पूर्णांक64_t)(code));           \
		निकास(1);                                                       \
	पूर्ण जबतक (0)

अटल व्योम uffd_stats_reset(काष्ठा uffd_stats *uffd_stats,
			     अचिन्हित दीर्घ n_cpus)
अणु
	पूर्णांक i;

	क्रम (i = 0; i < n_cpus; i++) अणु
		uffd_stats[i].cpu = i;
		uffd_stats[i].missing_faults = 0;
		uffd_stats[i].wp_faults = 0;
		uffd_stats[i].minor_faults = 0;
	पूर्ण
पूर्ण

अटल व्योम uffd_stats_report(काष्ठा uffd_stats *stats, पूर्णांक n_cpus)
अणु
	पूर्णांक i;
	अचिन्हित दीर्घ दीर्घ miss_total = 0, wp_total = 0, minor_total = 0;

	क्रम (i = 0; i < n_cpus; i++) अणु
		miss_total += stats[i].missing_faults;
		wp_total += stats[i].wp_faults;
		minor_total += stats[i].minor_faults;
	पूर्ण

	म_लिखो("userfaults: %llu missing (", miss_total);
	क्रम (i = 0; i < n_cpus; i++)
		म_लिखो("%lu+", stats[i].missing_faults);
	म_लिखो("\b), %llu wp (", wp_total);
	क्रम (i = 0; i < n_cpus; i++)
		म_लिखो("%lu+", stats[i].wp_faults);
	म_लिखो("\b), %llu minor (", minor_total);
	क्रम (i = 0; i < n_cpus; i++)
		म_लिखो("%lu+", stats[i].minor_faults);
	म_लिखो("\b)\n");
पूर्ण

अटल पूर्णांक anon_release_pages(अक्षर *rel_area)
अणु
	पूर्णांक ret = 0;

	अगर (madvise(rel_area, nr_pages * page_size, MADV_DONTNEED)) अणु
		लिखो_त्रुटि("madvise");
		ret = 1;
	पूर्ण

	वापस ret;
पूर्ण

अटल व्योम anon_allocate_area(व्योम **alloc_area)
अणु
	अगर (posix_memalign(alloc_area, page_size, nr_pages * page_size)) अणु
		ख_लिखो(मानक_त्रुटि, "out of memory\n");
		*alloc_area = शून्य;
	पूर्ण
पूर्ण

अटल व्योम noop_alias_mapping(__u64 *start, माप_प्रकार len, अचिन्हित दीर्घ offset)
अणु
पूर्ण

/* HugeTLB memory */
अटल पूर्णांक hugetlb_release_pages(अक्षर *rel_area)
अणु
	पूर्णांक ret = 0;

	अगर (fallocate(huge_fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
				rel_area == huge_fd_off0 ? 0 :
				nr_pages * page_size,
				nr_pages * page_size)) अणु
		लिखो_त्रुटि("fallocate");
		ret = 1;
	पूर्ण

	वापस ret;
पूर्ण

अटल व्योम hugetlb_allocate_area(व्योम **alloc_area)
अणु
	व्योम *area_alias = शून्य;
	अक्षर **alloc_area_alias;

	*alloc_area = mmap(शून्य, nr_pages * page_size, PROT_READ | PROT_WRITE,
			   (map_shared ? MAP_SHARED : MAP_PRIVATE) |
			   MAP_HUGETLB,
			   huge_fd, *alloc_area == area_src ? 0 :
			   nr_pages * page_size);
	अगर (*alloc_area == MAP_FAILED) अणु
		लिखो_त्रुटि("mmap of hugetlbfs file failed");
		जाओ fail;
	पूर्ण

	अगर (map_shared) अणु
		area_alias = mmap(शून्य, nr_pages * page_size, PROT_READ | PROT_WRITE,
				  MAP_SHARED | MAP_HUGETLB,
				  huge_fd, *alloc_area == area_src ? 0 :
				  nr_pages * page_size);
		अगर (area_alias == MAP_FAILED) अणु
			लिखो_त्रुटि("mmap of hugetlb file alias failed");
			जाओ fail_munmap;
		पूर्ण
	पूर्ण

	अगर (*alloc_area == area_src) अणु
		huge_fd_off0 = *alloc_area;
		alloc_area_alias = &area_src_alias;
	पूर्ण अन्यथा अणु
		alloc_area_alias = &area_dst_alias;
	पूर्ण
	अगर (area_alias)
		*alloc_area_alias = area_alias;

	वापस;

fail_munmap:
	अगर (munmap(*alloc_area, nr_pages * page_size) < 0) अणु
		लिखो_त्रुटि("hugetlb munmap");
		निकास(1);
	पूर्ण
fail:
	*alloc_area = शून्य;
पूर्ण

अटल व्योम hugetlb_alias_mapping(__u64 *start, माप_प्रकार len, अचिन्हित दीर्घ offset)
अणु
	अगर (!map_shared)
		वापस;
	/*
	 * We can't zap just the pagetable with hugetlbfs because
	 * MADV_DONTEED won't work. So exercise -EEXIST on a alias
	 * mapping where the pagetables are not established initially,
	 * this way we'll exercise the -EEXEC at the fs level.
	 */
	*start = (अचिन्हित दीर्घ) area_dst_alias + offset;
पूर्ण

/* Shared memory */
अटल पूर्णांक shmem_release_pages(अक्षर *rel_area)
अणु
	पूर्णांक ret = 0;

	अगर (madvise(rel_area, nr_pages * page_size, MADV_REMOVE)) अणु
		लिखो_त्रुटि("madvise");
		ret = 1;
	पूर्ण

	वापस ret;
पूर्ण

अटल व्योम shmem_allocate_area(व्योम **alloc_area)
अणु
	*alloc_area = mmap(शून्य, nr_pages * page_size, PROT_READ | PROT_WRITE,
			   MAP_ANONYMOUS | MAP_SHARED, -1, 0);
	अगर (*alloc_area == MAP_FAILED) अणु
		ख_लिखो(मानक_त्रुटि, "shared memory mmap failed\n");
		*alloc_area = शून्य;
	पूर्ण
पूर्ण

काष्ठा uffd_test_ops अणु
	अचिन्हित दीर्घ expected_ioctls;
	व्योम (*allocate_area)(व्योम **alloc_area);
	पूर्णांक (*release_pages)(अक्षर *rel_area);
	व्योम (*alias_mapping)(__u64 *start, माप_प्रकार len, अचिन्हित दीर्घ offset);
पूर्ण;

#घोषणा SHMEM_EXPECTED_IOCTLS		((1 << _UFFDIO_WAKE) | \
					 (1 << _UFFDIO_COPY) | \
					 (1 << _UFFDIO_ZEROPAGE))

#घोषणा ANON_EXPECTED_IOCTLS		((1 << _UFFDIO_WAKE) | \
					 (1 << _UFFDIO_COPY) | \
					 (1 << _UFFDIO_ZEROPAGE) | \
					 (1 << _UFFDIO_WRITEPROTECT))

अटल काष्ठा uffd_test_ops anon_uffd_test_ops = अणु
	.expected_ioctls = ANON_EXPECTED_IOCTLS,
	.allocate_area	= anon_allocate_area,
	.release_pages	= anon_release_pages,
	.alias_mapping = noop_alias_mapping,
पूर्ण;

अटल काष्ठा uffd_test_ops shmem_uffd_test_ops = अणु
	.expected_ioctls = SHMEM_EXPECTED_IOCTLS,
	.allocate_area	= shmem_allocate_area,
	.release_pages	= shmem_release_pages,
	.alias_mapping = noop_alias_mapping,
पूर्ण;

अटल काष्ठा uffd_test_ops hugetlb_uffd_test_ops = अणु
	.expected_ioctls = UFFD_API_RANGE_IOCTLS_BASIC & ~(1 << _UFFDIO_CONTINUE),
	.allocate_area	= hugetlb_allocate_area,
	.release_pages	= hugetlb_release_pages,
	.alias_mapping = hugetlb_alias_mapping,
पूर्ण;

अटल काष्ठा uffd_test_ops *uffd_test_ops;

अटल पूर्णांक my_bcmp(अक्षर *str1, अक्षर *str2, माप_प्रकार n)
अणु
	अचिन्हित दीर्घ i;
	क्रम (i = 0; i < n; i++)
		अगर (str1[i] != str2[i])
			वापस 1;
	वापस 0;
पूर्ण

अटल व्योम wp_range(पूर्णांक ufd, __u64 start, __u64 len, bool wp)
अणु
	काष्ठा uffdio_ग_लिखोprotect prms;

	/* Write protection page faults */
	prms.range.start = start;
	prms.range.len = len;
	/* Unकरो ग_लिखो-protect, करो wakeup after that */
	prms.mode = wp ? UFFDIO_WRITEPROTECT_MODE_WP : 0;

	अगर (ioctl(ufd, UFFDIO_WRITEPROTECT, &prms)) अणु
		ख_लिखो(मानक_त्रुटि, "clear WP failed for address 0x%" PRIx64 "\n",
			(uपूर्णांक64_t)start);
		निकास(1);
	पूर्ण
पूर्ण

अटल व्योम जारी_range(पूर्णांक ufd, __u64 start, __u64 len)
अणु
	काष्ठा uffdio_जारी req;

	req.range.start = start;
	req.range.len = len;
	req.mode = 0;

	अगर (ioctl(ufd, UFFDIO_CONTINUE, &req)) अणु
		ख_लिखो(मानक_त्रुटि,
			"UFFDIO_CONTINUE failed for address 0x%" PRIx64 "\n",
			(uपूर्णांक64_t)start);
		निकास(1);
	पूर्ण
पूर्ण

अटल व्योम *locking_thपढ़ो(व्योम *arg)
अणु
	अचिन्हित दीर्घ cpu = (अचिन्हित दीर्घ) arg;
	काष्ठा अक्रमom_data अक्रम;
	अचिन्हित दीर्घ page_nr = *(&(page_nr)); /* uninitialized warning */
	पूर्णांक32_t अक्रम_nr;
	अचिन्हित दीर्घ दीर्घ count;
	अक्षर अक्रमstate[64];
	अचिन्हित पूर्णांक seed;
	समय_प्रकार start;

	अगर (bounces & BOUNCE_RANDOM) अणु
		seed = (अचिन्हित पूर्णांक) समय(शून्य) - bounces;
		अगर (!(bounces & BOUNCE_RACINGFAULTS))
			seed += cpu;
		bzero(&अक्रम, माप(अक्रम));
		bzero(&अक्रमstate, माप(अक्रमstate));
		अगर (initstate_r(seed, अक्रमstate, माप(अक्रमstate), &अक्रम)) अणु
			ख_लिखो(मानक_त्रुटि, "srandom_r error\n");
			निकास(1);
		पूर्ण
	पूर्ण अन्यथा अणु
		page_nr = -bounces;
		अगर (!(bounces & BOUNCE_RACINGFAULTS))
			page_nr += cpu * nr_pages_per_cpu;
	पूर्ण

	जबतक (!finished) अणु
		अगर (bounces & BOUNCE_RANDOM) अणु
			अगर (अक्रमom_r(&अक्रम, &अक्रम_nr)) अणु
				ख_लिखो(मानक_त्रुटि, "random_r 1 error\n");
				निकास(1);
			पूर्ण
			page_nr = अक्रम_nr;
			अगर (माप(page_nr) > माप(अक्रम_nr)) अणु
				अगर (अक्रमom_r(&अक्रम, &अक्रम_nr)) अणु
					ख_लिखो(मानक_त्रुटि, "random_r 2 error\n");
					निकास(1);
				पूर्ण
				page_nr |= (((अचिन्हित दीर्घ) अक्रम_nr) << 16) <<
					   16;
			पूर्ण
		पूर्ण अन्यथा
			page_nr += 1;
		page_nr %= nr_pages;

		start = समय(शून्य);
		अगर (bounces & BOUNCE_VERIFY) अणु
			count = *area_count(area_dst, page_nr);
			अगर (!count) अणु
				ख_लिखो(मानक_त्रुटि,
					"page_nr %lu wrong count %Lu %Lu\n",
					page_nr, count,
					count_verअगरy[page_nr]);
				निकास(1);
			पूर्ण


			/*
			 * We can't use bcmp (or स_भेद) because that
			 * वापसs 0 erroneously अगर the memory is
			 * changing under it (even अगर the end of the
			 * page is never changing and always
			 * dअगरferent).
			 */
#अगर 1
			अगर (!my_bcmp(area_dst + page_nr * page_size, zeropage,
				     page_size)) अणु
				ख_लिखो(मानक_त्रुटि,
					"my_bcmp page_nr %lu wrong count %Lu %Lu\n",
					page_nr, count, count_verअगरy[page_nr]);
				निकास(1);
			पूर्ण
#अन्यथा
			अचिन्हित दीर्घ loops;

			loops = 0;
			/* uncomment the below line to test with mutex */
			/* pthपढ़ो_mutex_lock(area_mutex(area_dst, page_nr)); */
			जबतक (!bcmp(area_dst + page_nr * page_size, zeropage,
				     page_size)) अणु
				loops += 1;
				अगर (loops > 10)
					अवरोध;
			पूर्ण
			/* uncomment below line to test with mutex */
			/* pthपढ़ो_mutex_unlock(area_mutex(area_dst, page_nr)); */
			अगर (loops) अणु
				ख_लिखो(मानक_त्रुटि,
					"page_nr %lu all zero thread %lu %p %lu\n",
					page_nr, cpu, area_dst + page_nr * page_size,
					loops);
				अगर (loops > 10)
					निकास(1);
			पूर्ण
#पूर्ण_अगर
		पूर्ण

		pthपढ़ो_mutex_lock(area_mutex(area_dst, page_nr));
		count = *area_count(area_dst, page_nr);
		अगर (count != count_verअगरy[page_nr]) अणु
			ख_लिखो(मानक_त्रुटि,
				"page_nr %lu memory corruption %Lu %Lu\n",
				page_nr, count,
				count_verअगरy[page_nr]); निकास(1);
		पूर्ण
		count++;
		*area_count(area_dst, page_nr) = count_verअगरy[page_nr] = count;
		pthपढ़ो_mutex_unlock(area_mutex(area_dst, page_nr));

		अगर (समय(शून्य) - start > 1)
			ख_लिखो(मानक_त्रुटि,
				"userfault too slow %ld "
				"possible false positive with overcommit\n",
				समय(शून्य) - start);
	पूर्ण

	वापस शून्य;
पूर्ण

अटल व्योम retry_copy_page(पूर्णांक ufd, काष्ठा uffdio_copy *uffdio_copy,
			    अचिन्हित दीर्घ offset)
अणु
	uffd_test_ops->alias_mapping(&uffdio_copy->dst,
				     uffdio_copy->len,
				     offset);
	अगर (ioctl(ufd, UFFDIO_COPY, uffdio_copy)) अणु
		/* real retval in ufdio_copy.copy */
		अगर (uffdio_copy->copy != -EEXIST) अणु
			uffd_error(uffdio_copy->copy,
				   "UFFDIO_COPY retry error");
		पूर्ण
	पूर्ण अन्यथा
		uffd_error(uffdio_copy->copy, "UFFDIO_COPY retry unexpected");
पूर्ण

अटल पूर्णांक __copy_page(पूर्णांक ufd, अचिन्हित दीर्घ offset, bool retry)
अणु
	काष्ठा uffdio_copy uffdio_copy;

	अगर (offset >= nr_pages * page_size) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected offset %lu\n", offset);
		निकास(1);
	पूर्ण
	uffdio_copy.dst = (अचिन्हित दीर्घ) area_dst + offset;
	uffdio_copy.src = (अचिन्हित दीर्घ) area_src + offset;
	uffdio_copy.len = page_size;
	अगर (test_uffdio_wp)
		uffdio_copy.mode = UFFDIO_COPY_MODE_WP;
	अन्यथा
		uffdio_copy.mode = 0;
	uffdio_copy.copy = 0;
	अगर (ioctl(ufd, UFFDIO_COPY, &uffdio_copy)) अणु
		/* real retval in ufdio_copy.copy */
		अगर (uffdio_copy.copy != -EEXIST)
			uffd_error(uffdio_copy.copy, "UFFDIO_COPY error");
	पूर्ण अन्यथा अगर (uffdio_copy.copy != page_size) अणु
		uffd_error(uffdio_copy.copy, "UFFDIO_COPY unexpected copy");
	पूर्ण अन्यथा अणु
		अगर (test_uffdio_copy_eexist && retry) अणु
			test_uffdio_copy_eexist = false;
			retry_copy_page(ufd, &uffdio_copy, offset);
		पूर्ण
		वापस 1;
	पूर्ण
	वापस 0;
पूर्ण

अटल पूर्णांक copy_page_retry(पूर्णांक ufd, अचिन्हित दीर्घ offset)
अणु
	वापस __copy_page(ufd, offset, true);
पूर्ण

अटल पूर्णांक copy_page(पूर्णांक ufd, अचिन्हित दीर्घ offset)
अणु
	वापस __copy_page(ufd, offset, false);
पूर्ण

अटल पूर्णांक uffd_पढ़ो_msg(पूर्णांक ufd, काष्ठा uffd_msg *msg)
अणु
	पूर्णांक ret = पढ़ो(uffd, msg, माप(*msg));

	अगर (ret != माप(*msg)) अणु
		अगर (ret < 0) अणु
			अगर (त्रुटि_सं == EAGAIN)
				वापस 1;
			लिखो_त्रुटि("blocking read error");
		पूर्ण अन्यथा अणु
			ख_लिखो(मानक_त्रुटि, "short read\n");
		पूर्ण
		निकास(1);
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम uffd_handle_page_fault(काष्ठा uffd_msg *msg,
				   काष्ठा uffd_stats *stats)
अणु
	अचिन्हित दीर्घ offset;

	अगर (msg->event != UFFD_EVENT_PAGEFAULT) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected msg event %u\n", msg->event);
		निकास(1);
	पूर्ण

	अगर (msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WP) अणु
		/* Write protect page faults */
		wp_range(uffd, msg->arg.pagefault.address, page_size, false);
		stats->wp_faults++;
	पूर्ण अन्यथा अगर (msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_MINOR) अणु
		uपूर्णांक8_t *area;
		पूर्णांक b;

		/*
		 * Minor page faults
		 *
		 * To prove we can modअगरy the original range क्रम testing
		 * purposes, we're going to bit flip this range beक्रमe
		 * continuing.
		 *
		 * Note that this requires all minor page fault tests operate on
		 * area_dst (non-UFFD-रेजिस्टरed) and area_dst_alias
		 * (UFFD-रेजिस्टरed).
		 */

		area = (uपूर्णांक8_t *)(area_dst +
				   ((अक्षर *)msg->arg.pagefault.address -
				    area_dst_alias));
		क्रम (b = 0; b < page_size; ++b)
			area[b] = ~area[b];
		जारी_range(uffd, msg->arg.pagefault.address, page_size);
		stats->minor_faults++;
	पूर्ण अन्यथा अणु
		/* Missing page faults */
		अगर (bounces & BOUNCE_VERIFY &&
		    msg->arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE) अणु
			ख_लिखो(मानक_त्रुटि, "unexpected write fault\n");
			निकास(1);
		पूर्ण

		offset = (अक्षर *)(अचिन्हित दीर्घ)msg->arg.pagefault.address - area_dst;
		offset &= ~(page_size-1);

		अगर (copy_page(uffd, offset))
			stats->missing_faults++;
	पूर्ण
पूर्ण

अटल व्योम *uffd_poll_thपढ़ो(व्योम *arg)
अणु
	काष्ठा uffd_stats *stats = (काष्ठा uffd_stats *)arg;
	अचिन्हित दीर्घ cpu = stats->cpu;
	काष्ठा pollfd pollfd[2];
	काष्ठा uffd_msg msg;
	काष्ठा uffdio_रेजिस्टर uffd_reg;
	पूर्णांक ret;
	अक्षर पंचांगp_chr;

	pollfd[0].fd = uffd;
	pollfd[0].events = POLLIN;
	pollfd[1].fd = pipefd[cpu*2];
	pollfd[1].events = POLLIN;

	क्रम (;;) अणु
		ret = poll(pollfd, 2, -1);
		अगर (!ret) अणु
			ख_लिखो(मानक_त्रुटि, "poll error %d\n", ret);
			निकास(1);
		पूर्ण
		अगर (ret < 0) अणु
			लिखो_त्रुटि("poll");
			निकास(1);
		पूर्ण
		अगर (pollfd[1].revents & POLLIN) अणु
			अगर (पढ़ो(pollfd[1].fd, &पंचांगp_chr, 1) != 1) अणु
				ख_लिखो(मानक_त्रुटि, "read pipefd error\n");
				निकास(1);
			पूर्ण
			अवरोध;
		पूर्ण
		अगर (!(pollfd[0].revents & POLLIN)) अणु
			ख_लिखो(मानक_त्रुटि, "pollfd[0].revents %d\n",
				pollfd[0].revents);
			निकास(1);
		पूर्ण
		अगर (uffd_पढ़ो_msg(uffd, &msg))
			जारी;
		चयन (msg.event) अणु
		शेष:
			ख_लिखो(मानक_त्रुटि, "unexpected msg event %u\n",
				msg.event); निकास(1);
			अवरोध;
		हाल UFFD_EVENT_PAGEFAULT:
			uffd_handle_page_fault(&msg, stats);
			अवरोध;
		हाल UFFD_EVENT_FORK:
			बंद(uffd);
			uffd = msg.arg.विभाजन.ufd;
			pollfd[0].fd = uffd;
			अवरोध;
		हाल UFFD_EVENT_REMOVE:
			uffd_reg.range.start = msg.arg.हटाओ.start;
			uffd_reg.range.len = msg.arg.हटाओ.end -
				msg.arg.हटाओ.start;
			अगर (ioctl(uffd, UFFDIO_UNREGISTER, &uffd_reg.range)) अणु
				ख_लिखो(मानक_त्रुटि, "remove failure\n");
				निकास(1);
			पूर्ण
			अवरोध;
		हाल UFFD_EVENT_REMAP:
			area_dst = (अक्षर *)(अचिन्हित दीर्घ)msg.arg.remap.to;
			अवरोध;
		पूर्ण
	पूर्ण

	वापस शून्य;
पूर्ण

pthपढ़ो_mutex_t uffd_पढ़ो_mutex = PTHREAD_MUTEX_INITIALIZER;

अटल व्योम *uffd_पढ़ो_thपढ़ो(व्योम *arg)
अणु
	काष्ठा uffd_stats *stats = (काष्ठा uffd_stats *)arg;
	काष्ठा uffd_msg msg;

	pthपढ़ो_mutex_unlock(&uffd_पढ़ो_mutex);
	/* from here cancellation is ok */

	क्रम (;;) अणु
		अगर (uffd_पढ़ो_msg(uffd, &msg))
			जारी;
		uffd_handle_page_fault(&msg, stats);
	पूर्ण

	वापस शून्य;
पूर्ण

अटल व्योम *background_thपढ़ो(व्योम *arg)
अणु
	अचिन्हित दीर्घ cpu = (अचिन्हित दीर्घ) arg;
	अचिन्हित दीर्घ page_nr, start_nr, mid_nr, end_nr;

	start_nr = cpu * nr_pages_per_cpu;
	end_nr = (cpu+1) * nr_pages_per_cpu;
	mid_nr = (start_nr + end_nr) / 2;

	/* Copy the first half of the pages */
	क्रम (page_nr = start_nr; page_nr < mid_nr; page_nr++)
		copy_page_retry(uffd, page_nr * page_size);

	/*
	 * If we need to test uffd-wp, set it up now.  Then we'll have
	 * at least the first half of the pages mapped alपढ़ोy which
	 * can be ग_लिखो-रक्षित क्रम testing
	 */
	अगर (test_uffdio_wp)
		wp_range(uffd, (अचिन्हित दीर्घ)area_dst + start_nr * page_size,
			nr_pages_per_cpu * page_size, true);

	/*
	 * Continue the 2nd half of the page copying, handling ग_लिखो
	 * protection faults अगर any
	 */
	क्रम (page_nr = mid_nr; page_nr < end_nr; page_nr++)
		copy_page_retry(uffd, page_nr * page_size);

	वापस शून्य;
पूर्ण

अटल पूर्णांक stress(काष्ठा uffd_stats *uffd_stats)
अणु
	अचिन्हित दीर्घ cpu;
	pthपढ़ो_t locking_thपढ़ोs[nr_cpus];
	pthपढ़ो_t uffd_thपढ़ोs[nr_cpus];
	pthपढ़ो_t background_thपढ़ोs[nr_cpus];

	finished = 0;
	क्रम (cpu = 0; cpu < nr_cpus; cpu++) अणु
		अगर (pthपढ़ो_create(&locking_thपढ़ोs[cpu], &attr,
				   locking_thपढ़ो, (व्योम *)cpu))
			वापस 1;
		अगर (bounces & BOUNCE_POLL) अणु
			अगर (pthपढ़ो_create(&uffd_thपढ़ोs[cpu], &attr,
					   uffd_poll_thपढ़ो,
					   (व्योम *)&uffd_stats[cpu]))
				वापस 1;
		पूर्ण अन्यथा अणु
			अगर (pthपढ़ो_create(&uffd_thपढ़ोs[cpu], &attr,
					   uffd_पढ़ो_thपढ़ो,
					   (व्योम *)&uffd_stats[cpu]))
				वापस 1;
			pthपढ़ो_mutex_lock(&uffd_पढ़ो_mutex);
		पूर्ण
		अगर (pthपढ़ो_create(&background_thपढ़ोs[cpu], &attr,
				   background_thपढ़ो, (व्योम *)cpu))
			वापस 1;
	पूर्ण
	क्रम (cpu = 0; cpu < nr_cpus; cpu++)
		अगर (pthपढ़ो_join(background_thपढ़ोs[cpu], शून्य))
			वापस 1;

	/*
	 * Be strict and immediately zap area_src, the whole area has
	 * been transferred alपढ़ोy by the background tपढ़ोs. The
	 * area_src could then be faulted in in a racy way by still
	 * running uffdio_thपढ़ोs पढ़ोing zeropages after we zapped
	 * area_src (but they're guaranteed to get -EEXIST from
	 * UFFDIO_COPY without writing zero pages पूर्णांकo area_dst
	 * because the background thपढ़ोs alपढ़ोy completed).
	 */
	अगर (uffd_test_ops->release_pages(area_src))
		वापस 1;


	finished = 1;
	क्रम (cpu = 0; cpu < nr_cpus; cpu++)
		अगर (pthपढ़ो_join(locking_thपढ़ोs[cpu], शून्य))
			वापस 1;

	क्रम (cpu = 0; cpu < nr_cpus; cpu++) अणु
		अक्षर c;
		अगर (bounces & BOUNCE_POLL) अणु
			अगर (ग_लिखो(pipefd[cpu*2+1], &c, 1) != 1) अणु
				ख_लिखो(मानक_त्रुटि, "pipefd write error\n");
				वापस 1;
			पूर्ण
			अगर (pthपढ़ो_join(uffd_thपढ़ोs[cpu],
					 (व्योम *)&uffd_stats[cpu]))
				वापस 1;
		पूर्ण अन्यथा अणु
			अगर (pthपढ़ो_cancel(uffd_thपढ़ोs[cpu]))
				वापस 1;
			अगर (pthपढ़ो_join(uffd_thपढ़ोs[cpu], शून्य))
				वापस 1;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक userfaultfd_खोलो_ext(uपूर्णांक64_t *features)
अणु
	काष्ठा uffdio_api uffdio_api;

	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	अगर (uffd < 0) अणु
		ख_लिखो(मानक_त्रुटि,
			"userfaultfd syscall not available in this kernel\n");
		वापस 1;
	पूर्ण
	uffd_flags = fcntl(uffd, F_GETFD, शून्य);

	uffdio_api.api = UFFD_API;
	uffdio_api.features = *features;
	अगर (ioctl(uffd, UFFDIO_API, &uffdio_api)) अणु
		ख_लिखो(मानक_त्रुटि, "UFFDIO_API failed.\nPlease make sure to "
			"run with either root or ptrace capability.\n");
		वापस 1;
	पूर्ण
	अगर (uffdio_api.api != UFFD_API) अणु
		ख_लिखो(मानक_त्रुटि, "UFFDIO_API error: %" PRIu64 "\n",
			(uपूर्णांक64_t)uffdio_api.api);
		वापस 1;
	पूर्ण

	*features = uffdio_api.features;
	वापस 0;
पूर्ण

अटल पूर्णांक userfaultfd_खोलो(uपूर्णांक64_t features)
अणु
	वापस userfaultfd_खोलो_ext(&features);
पूर्ण

sigलाँघ_बफ jbuf, *sigbuf;

अटल व्योम sighndl(पूर्णांक sig, siginfo_t *siginfo, व्योम *ptr)
अणु
	अगर (sig == SIGBUS) अणु
		अगर (sigbuf)
			sigदीर्घ_लाँघ(*sigbuf, 1);
		पात();
	पूर्ण
पूर्ण

/*
 * For non-cooperative userfaultfd test we विभाजन() a process that will
 * generate pagefaults, will mremap the area monitored by the
 * userfaultfd and at last this process will release the monitored
 * area.
 * For the anonymous and shared memory the area is भागided पूर्णांकo two
 * parts, the first part is accessed beक्रमe mremap, and the second
 * part is accessed after mremap. Since hugetlbfs करोes not support
 * mremap, the entire monitored area is accessed in a single pass क्रम
 * HUGETLB_TEST.
 * The release of the pages currently generates event क्रम shmem and
 * anonymous memory (UFFD_EVENT_REMOVE), hence it is not checked
 * क्रम hugetlb.
 * For संकेत test(UFFD_FEATURE_SIGBUS), संकेत_test = 1, we रेजिस्टर
 * monitored area, generate pagefaults and test that संकेत is delivered.
 * Use UFFDIO_COPY to allocate missing page and retry. For संकेत_test = 2
 * test robustness use हाल - we release monitored area, विभाजन a process
 * that will generate pagefaults and verअगरy संकेत is generated.
 * This also tests UFFD_FEATURE_EVENT_FORK event aदीर्घ with the संकेत
 * feature. Using monitor thपढ़ो, verअगरy no userfault events are generated.
 */
अटल पूर्णांक faulting_process(पूर्णांक संकेत_test)
अणु
	अचिन्हित दीर्घ nr;
	अचिन्हित दीर्घ दीर्घ count;
	अचिन्हित दीर्घ split_nr_pages;
	अचिन्हित दीर्घ lastnr;
	काष्ठा sigaction act;
	अचिन्हित दीर्घ संकेतled = 0;

	अगर (test_type != TEST_HUGETLB)
		split_nr_pages = (nr_pages + 1) / 2;
	अन्यथा
		split_nr_pages = nr_pages;

	अगर (संकेत_test) अणु
		sigbuf = &jbuf;
		स_रखो(&act, 0, माप(act));
		act.sa_sigaction = sighndl;
		act.sa_flags = SA_SIGINFO;
		अगर (sigaction(SIGBUS, &act, 0)) अणु
			लिखो_त्रुटि("sigaction");
			वापस 1;
		पूर्ण
		lastnr = (अचिन्हित दीर्घ)-1;
	पूर्ण

	क्रम (nr = 0; nr < split_nr_pages; nr++) अणु
		पूर्णांक steps = 1;
		अचिन्हित दीर्घ offset = nr * page_size;

		अगर (संकेत_test) अणु
			अगर (sigबनाओ_लाँघ(*sigbuf, 1) != 0) अणु
				अगर (steps == 1 && nr == lastnr) अणु
					ख_लिखो(मानक_त्रुटि, "Signal repeated\n");
					वापस 1;
				पूर्ण

				lastnr = nr;
				अगर (संकेत_test == 1) अणु
					अगर (steps == 1) अणु
						/* This is a MISSING request */
						steps++;
						अगर (copy_page(uffd, offset))
							संकेतled++;
					पूर्ण अन्यथा अणु
						/* This is a WP request */
						निश्चित(steps == 2);
						wp_range(uffd,
							 (__u64)area_dst +
							 offset,
							 page_size, false);
					पूर्ण
				पूर्ण अन्यथा अणु
					संकेतled++;
					जारी;
				पूर्ण
			पूर्ण
		पूर्ण

		count = *area_count(area_dst, nr);
		अगर (count != count_verअगरy[nr]) अणु
			ख_लिखो(मानक_त्रुटि,
				"nr %lu memory corruption %Lu %Lu\n",
				nr, count,
				count_verअगरy[nr]);
	        पूर्ण
		/*
		 * Trigger ग_लिखो protection अगर there is by writing
		 * the same value back.
		 */
		*area_count(area_dst, nr) = count;
	पूर्ण

	अगर (संकेत_test)
		वापस संकेतled != split_nr_pages;

	अगर (test_type == TEST_HUGETLB)
		वापस 0;

	area_dst = mremap(area_dst, nr_pages * page_size,  nr_pages * page_size,
			  MREMAP_MAYMOVE | MREMAP_FIXED, area_src);
	अगर (area_dst == MAP_FAILED) अणु
		लिखो_त्रुटि("mremap");
		निकास(1);
	पूर्ण

	क्रम (; nr < nr_pages; nr++) अणु
		count = *area_count(area_dst, nr);
		अगर (count != count_verअगरy[nr]) अणु
			ख_लिखो(मानक_त्रुटि,
				"nr %lu memory corruption %Lu %Lu\n",
				nr, count,
				count_verअगरy[nr]); निकास(1);
		पूर्ण
		/*
		 * Trigger ग_लिखो protection अगर there is by writing
		 * the same value back.
		 */
		*area_count(area_dst, nr) = count;
	पूर्ण

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	क्रम (nr = 0; nr < nr_pages; nr++) अणु
		अगर (my_bcmp(area_dst + nr * page_size, zeropage, page_size)) अणु
			ख_लिखो(मानक_त्रुटि, "nr %lu is not zero\n", nr);
			निकास(1);
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम retry_uffdio_zeropage(पूर्णांक ufd,
				  काष्ठा uffdio_zeropage *uffdio_zeropage,
				  अचिन्हित दीर्घ offset)
अणु
	uffd_test_ops->alias_mapping(&uffdio_zeropage->range.start,
				     uffdio_zeropage->range.len,
				     offset);
	अगर (ioctl(ufd, UFFDIO_ZEROPAGE, uffdio_zeropage)) अणु
		अगर (uffdio_zeropage->zeropage != -EEXIST) अणु
			uffd_error(uffdio_zeropage->zeropage,
				   "UFFDIO_ZEROPAGE retry error");
		पूर्ण
	पूर्ण अन्यथा अणु
		uffd_error(uffdio_zeropage->zeropage,
			   "UFFDIO_ZEROPAGE retry unexpected");
	पूर्ण
पूर्ण

अटल पूर्णांक __uffdio_zeropage(पूर्णांक ufd, अचिन्हित दीर्घ offset, bool retry)
अणु
	काष्ठा uffdio_zeropage uffdio_zeropage;
	पूर्णांक ret;
	अचिन्हित दीर्घ has_zeropage;
	__s64 res;

	has_zeropage = uffd_test_ops->expected_ioctls & (1 << _UFFDIO_ZEROPAGE);

	अगर (offset >= nr_pages * page_size) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected offset %lu\n", offset);
		निकास(1);
	पूर्ण
	uffdio_zeropage.range.start = (अचिन्हित दीर्घ) area_dst + offset;
	uffdio_zeropage.range.len = page_size;
	uffdio_zeropage.mode = 0;
	ret = ioctl(ufd, UFFDIO_ZEROPAGE, &uffdio_zeropage);
	res = uffdio_zeropage.zeropage;
	अगर (ret) अणु
		/* real retval in ufdio_zeropage.zeropage */
		अगर (has_zeropage) अणु
			uffd_error(res, "UFFDIO_ZEROPAGE %s",
				   res == -EEXIST ? "-EEXIST" : "error");
		पूर्ण अन्यथा अगर (res != -EINVAL)
			uffd_error(res, "UFFDIO_ZEROPAGE not -EINVAL");
	पूर्ण अन्यथा अगर (has_zeropage) अणु
		अगर (res != page_size) अणु
			uffd_error(res, "UFFDIO_ZEROPAGE unexpected");
		पूर्ण अन्यथा अणु
			अगर (test_uffdio_zeropage_eexist && retry) अणु
				test_uffdio_zeropage_eexist = false;
				retry_uffdio_zeropage(ufd, &uffdio_zeropage,
						      offset);
			पूर्ण
			वापस 1;
		पूर्ण
	पूर्ण अन्यथा
		uffd_error(res, "UFFDIO_ZEROPAGE succeeded");

	वापस 0;
पूर्ण

अटल पूर्णांक uffdio_zeropage(पूर्णांक ufd, अचिन्हित दीर्घ offset)
अणु
	वापस __uffdio_zeropage(ufd, offset, false);
पूर्ण

/* exercise UFFDIO_ZEROPAGE */
अटल पूर्णांक userfaultfd_zeropage_test(व्योम)
अणु
	काष्ठा uffdio_रेजिस्टर uffdio_रेजिस्टर;
	अचिन्हित दीर्घ expected_ioctls;

	म_लिखो("testing UFFDIO_ZEROPAGE: ");
	ख_साफ(मानक_निकास);

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	अगर (userfaultfd_खोलो(0))
		वापस 1;
	uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ) area_dst;
	uffdio_रेजिस्टर.range.len = nr_pages * page_size;
	uffdio_रेजिस्टर.mode = UFFDIO_REGISTER_MODE_MISSING;
	अगर (test_uffdio_wp)
		uffdio_रेजिस्टर.mode |= UFFDIO_REGISTER_MODE_WP;
	अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
		ख_लिखो(मानक_त्रुटि, "register failure\n");
		निकास(1);
	पूर्ण

	expected_ioctls = uffd_test_ops->expected_ioctls;
	अगर ((uffdio_रेजिस्टर.ioctls & expected_ioctls) !=
	    expected_ioctls) अणु
		ख_लिखो(मानक_त्रुटि,
			"unexpected missing ioctl for anon memory\n");
		निकास(1);
	पूर्ण

	अगर (uffdio_zeropage(uffd, 0)) अणु
		अगर (my_bcmp(area_dst, zeropage, page_size)) अणु
			ख_लिखो(मानक_त्रुटि, "zeropage is not zero\n");
			निकास(1);
		पूर्ण
	पूर्ण

	बंद(uffd);
	म_लिखो("done.\n");
	वापस 0;
पूर्ण

अटल पूर्णांक userfaultfd_events_test(व्योम)
अणु
	काष्ठा uffdio_रेजिस्टर uffdio_रेजिस्टर;
	अचिन्हित दीर्घ expected_ioctls;
	pthपढ़ो_t uffd_mon;
	पूर्णांक err, features;
	pid_t pid;
	अक्षर c;
	काष्ठा uffd_stats stats = अणु 0 पूर्ण;

	म_लिखो("testing events (fork, remap, remove): ");
	ख_साफ(मानक_निकास);

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	features = UFFD_FEATURE_EVENT_FORK | UFFD_FEATURE_EVENT_REMAP |
		UFFD_FEATURE_EVENT_REMOVE;
	अगर (userfaultfd_खोलो(features))
		वापस 1;
	fcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);

	uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ) area_dst;
	uffdio_रेजिस्टर.range.len = nr_pages * page_size;
	uffdio_रेजिस्टर.mode = UFFDIO_REGISTER_MODE_MISSING;
	अगर (test_uffdio_wp)
		uffdio_रेजिस्टर.mode |= UFFDIO_REGISTER_MODE_WP;
	अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
		ख_लिखो(मानक_त्रुटि, "register failure\n");
		निकास(1);
	पूर्ण

	expected_ioctls = uffd_test_ops->expected_ioctls;
	अगर ((uffdio_रेजिस्टर.ioctls & expected_ioctls) != expected_ioctls) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected missing ioctl for anon memory\n");
		निकास(1);
	पूर्ण

	अगर (pthपढ़ो_create(&uffd_mon, &attr, uffd_poll_thपढ़ो, &stats)) अणु
		लिखो_त्रुटि("uffd_poll_thread create");
		निकास(1);
	पूर्ण

	pid = विभाजन();
	अगर (pid < 0) अणु
		लिखो_त्रुटि("fork");
		निकास(1);
	पूर्ण

	अगर (!pid)
		निकास(faulting_process(0));

	रुकोpid(pid, &err, 0);
	अगर (err) अणु
		ख_लिखो(मानक_त्रुटि, "faulting process failed\n");
		निकास(1);
	पूर्ण

	अगर (ग_लिखो(pipefd[1], &c, माप(c)) != माप(c)) अणु
		लिखो_त्रुटि("pipe write");
		निकास(1);
	पूर्ण
	अगर (pthपढ़ो_join(uffd_mon, शून्य))
		वापस 1;

	बंद(uffd);

	uffd_stats_report(&stats, 1);

	वापस stats.missing_faults != nr_pages;
पूर्ण

अटल पूर्णांक userfaultfd_sig_test(व्योम)
अणु
	काष्ठा uffdio_रेजिस्टर uffdio_रेजिस्टर;
	अचिन्हित दीर्घ expected_ioctls;
	अचिन्हित दीर्घ userfaults;
	pthपढ़ो_t uffd_mon;
	पूर्णांक err, features;
	pid_t pid;
	अक्षर c;
	काष्ठा uffd_stats stats = अणु 0 पूर्ण;

	म_लिखो("testing signal delivery: ");
	ख_साफ(मानक_निकास);

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	features = UFFD_FEATURE_EVENT_FORK|UFFD_FEATURE_SIGBUS;
	अगर (userfaultfd_खोलो(features))
		वापस 1;
	fcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);

	uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ) area_dst;
	uffdio_रेजिस्टर.range.len = nr_pages * page_size;
	uffdio_रेजिस्टर.mode = UFFDIO_REGISTER_MODE_MISSING;
	अगर (test_uffdio_wp)
		uffdio_रेजिस्टर.mode |= UFFDIO_REGISTER_MODE_WP;
	अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
		ख_लिखो(मानक_त्रुटि, "register failure\n");
		निकास(1);
	पूर्ण

	expected_ioctls = uffd_test_ops->expected_ioctls;
	अगर ((uffdio_रेजिस्टर.ioctls & expected_ioctls) != expected_ioctls) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected missing ioctl for anon memory\n");
		निकास(1);
	पूर्ण

	अगर (faulting_process(1)) अणु
		ख_लिखो(मानक_त्रुटि, "faulting process failed\n");
		निकास(1);
	पूर्ण

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	अगर (pthपढ़ो_create(&uffd_mon, &attr, uffd_poll_thपढ़ो, &stats)) अणु
		लिखो_त्रुटि("uffd_poll_thread create");
		निकास(1);
	पूर्ण

	pid = विभाजन();
	अगर (pid < 0) अणु
		लिखो_त्रुटि("fork");
		निकास(1);
	पूर्ण

	अगर (!pid)
		निकास(faulting_process(2));

	रुकोpid(pid, &err, 0);
	अगर (err) अणु
		ख_लिखो(मानक_त्रुटि, "faulting process failed\n");
		निकास(1);
	पूर्ण

	अगर (ग_लिखो(pipefd[1], &c, माप(c)) != माप(c)) अणु
		लिखो_त्रुटि("pipe write");
		निकास(1);
	पूर्ण
	अगर (pthपढ़ो_join(uffd_mon, (व्योम **)&userfaults))
		वापस 1;

	म_लिखो("done.\n");
	अगर (userfaults)
		ख_लिखो(मानक_त्रुटि, "Signal test failed, userfaults: %ld\n",
			userfaults);
	बंद(uffd);
	वापस userfaults != 0;
पूर्ण

अटल पूर्णांक userfaultfd_minor_test(व्योम)
अणु
	काष्ठा uffdio_रेजिस्टर uffdio_रेजिस्टर;
	अचिन्हित दीर्घ expected_ioctls;
	अचिन्हित दीर्घ p;
	pthपढ़ो_t uffd_mon;
	uपूर्णांक8_t expected_byte;
	व्योम *expected_page;
	अक्षर c;
	काष्ठा uffd_stats stats = अणु 0 पूर्ण;
	uपूर्णांक64_t features = UFFD_FEATURE_MINOR_HUGETLBFS;

	अगर (!test_uffdio_minor)
		वापस 0;

	म_लिखो("testing minor faults: ");
	ख_साफ(मानक_निकास);

	अगर (uffd_test_ops->release_pages(area_dst))
		वापस 1;

	अगर (userfaultfd_खोलो_ext(&features))
		वापस 1;
	/* If kernel reports the feature isn't supported, skip the test. */
	अगर (!(features & UFFD_FEATURE_MINOR_HUGETLBFS)) अणु
		म_लिखो("skipping test due to lack of feature support\n");
		ख_साफ(मानक_निकास);
		वापस 0;
	पूर्ण

	uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ)area_dst_alias;
	uffdio_रेजिस्टर.range.len = nr_pages * page_size;
	uffdio_रेजिस्टर.mode = UFFDIO_REGISTER_MODE_MINOR;
	अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
		ख_लिखो(मानक_त्रुटि, "register failure\n");
		निकास(1);
	पूर्ण

	expected_ioctls = uffd_test_ops->expected_ioctls;
	expected_ioctls |= 1 << _UFFDIO_CONTINUE;
	अगर ((uffdio_रेजिस्टर.ioctls & expected_ioctls) != expected_ioctls) अणु
		ख_लिखो(मानक_त्रुटि, "unexpected missing ioctl(s)\n");
		निकास(1);
	पूर्ण

	/*
	 * After रेजिस्टरing with UFFD, populate the non-UFFD-रेजिस्टरed side of
	 * the shared mapping. This should *not* trigger any UFFD minor faults.
	 */
	क्रम (p = 0; p < nr_pages; ++p) अणु
		स_रखो(area_dst + (p * page_size), p % ((uपूर्णांक8_t)-1),
		       page_size);
	पूर्ण

	अगर (pthपढ़ो_create(&uffd_mon, &attr, uffd_poll_thपढ़ो, &stats)) अणु
		लिखो_त्रुटि("uffd_poll_thread create");
		निकास(1);
	पूर्ण

	/*
	 * Read each of the pages back using the UFFD-रेजिस्टरed mapping. We
	 * expect that the first समय we touch a page, it will result in a minor
	 * fault. uffd_poll_thपढ़ो will resolve the fault by bit-flipping the
	 * page's contents, and then issuing a CONTINUE ioctl.
	 */

	अगर (posix_memalign(&expected_page, page_size, page_size)) अणु
		ख_लिखो(मानक_त्रुटि, "out of memory\n");
		वापस 1;
	पूर्ण

	क्रम (p = 0; p < nr_pages; ++p) अणु
		expected_byte = ~((uपूर्णांक8_t)(p % ((uपूर्णांक8_t)-1)));
		स_रखो(expected_page, expected_byte, page_size);
		अगर (my_bcmp(expected_page, area_dst_alias + (p * page_size),
			    page_size)) अणु
			ख_लिखो(मानक_त्रुटि,
				"unexpected page contents after minor fault\n");
			निकास(1);
		पूर्ण
	पूर्ण

	अगर (ग_लिखो(pipefd[1], &c, माप(c)) != माप(c)) अणु
		लिखो_त्रुटि("pipe write");
		निकास(1);
	पूर्ण
	अगर (pthपढ़ो_join(uffd_mon, शून्य))
		वापस 1;

	बंद(uffd);

	uffd_stats_report(&stats, 1);

	वापस stats.missing_faults != 0 || stats.minor_faults != nr_pages;
पूर्ण

अटल पूर्णांक userfaultfd_stress(व्योम)
अणु
	व्योम *area;
	अक्षर *पंचांगp_area;
	अचिन्हित दीर्घ nr;
	काष्ठा uffdio_रेजिस्टर uffdio_रेजिस्टर;
	अचिन्हित दीर्घ cpu;
	पूर्णांक err;
	काष्ठा uffd_stats uffd_stats[nr_cpus];

	uffd_test_ops->allocate_area((व्योम **)&area_src);
	अगर (!area_src)
		वापस 1;
	uffd_test_ops->allocate_area((व्योम **)&area_dst);
	अगर (!area_dst)
		वापस 1;

	अगर (userfaultfd_खोलो(0))
		वापस 1;

	count_verअगरy = दो_स्मृति(nr_pages * माप(अचिन्हित दीर्घ दीर्घ));
	अगर (!count_verअगरy) अणु
		लिखो_त्रुटि("count_verify");
		वापस 1;
	पूर्ण

	क्रम (nr = 0; nr < nr_pages; nr++) अणु
		*area_mutex(area_src, nr) = (pthपढ़ो_mutex_t)
			PTHREAD_MUTEX_INITIALIZER;
		count_verअगरy[nr] = *area_count(area_src, nr) = 1;
		/*
		 * In the transition between 255 to 256, घातerpc will
		 * पढ़ो out of order in my_bcmp and see both bytes as
		 * zero, so leave a placeholder below always non-zero
		 * after the count, to aव्योम my_bcmp to trigger false
		 * positives.
		 */
		*(area_count(area_src, nr) + 1) = 1;
	पूर्ण

	pipefd = दो_स्मृति(माप(पूर्णांक) * nr_cpus * 2);
	अगर (!pipefd) अणु
		लिखो_त्रुटि("pipefd");
		वापस 1;
	पूर्ण
	क्रम (cpu = 0; cpu < nr_cpus; cpu++) अणु
		अगर (pipe2(&pipefd[cpu*2], O_CLOEXEC | O_NONBLOCK)) अणु
			लिखो_त्रुटि("pipe");
			वापस 1;
		पूर्ण
	पूर्ण

	अगर (posix_memalign(&area, page_size, page_size)) अणु
		ख_लिखो(मानक_त्रुटि, "out of memory\n");
		वापस 1;
	पूर्ण
	zeropage = area;
	bzero(zeropage, page_size);

	pthपढ़ो_mutex_lock(&uffd_पढ़ो_mutex);

	pthपढ़ो_attr_init(&attr);
	pthपढ़ो_attr_setstacksize(&attr, 16*1024*1024);

	err = 0;
	जबतक (bounces--) अणु
		अचिन्हित दीर्घ expected_ioctls;

		म_लिखो("bounces: %d, mode:", bounces);
		अगर (bounces & BOUNCE_RANDOM)
			म_लिखो(" rnd");
		अगर (bounces & BOUNCE_RACINGFAULTS)
			म_लिखो(" racing");
		अगर (bounces & BOUNCE_VERIFY)
			म_लिखो(" ver");
		अगर (bounces & BOUNCE_POLL)
			म_लिखो(" poll");
		अन्यथा
			म_लिखो(" read");
		म_लिखो(", ");
		ख_साफ(मानक_निकास);

		अगर (bounces & BOUNCE_POLL)
			fcntl(uffd, F_SETFL, uffd_flags | O_NONBLOCK);
		अन्यथा
			fcntl(uffd, F_SETFL, uffd_flags & ~O_NONBLOCK);

		/* रेजिस्टर */
		uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ) area_dst;
		uffdio_रेजिस्टर.range.len = nr_pages * page_size;
		uffdio_रेजिस्टर.mode = UFFDIO_REGISTER_MODE_MISSING;
		अगर (test_uffdio_wp)
			uffdio_रेजिस्टर.mode |= UFFDIO_REGISTER_MODE_WP;
		अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
			ख_लिखो(मानक_त्रुटि, "register failure\n");
			वापस 1;
		पूर्ण
		expected_ioctls = uffd_test_ops->expected_ioctls;
		अगर ((uffdio_रेजिस्टर.ioctls & expected_ioctls) !=
		    expected_ioctls) अणु
			ख_लिखो(मानक_त्रुटि,
				"unexpected missing ioctl for anon memory\n");
			वापस 1;
		पूर्ण

		अगर (area_dst_alias) अणु
			uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ)
				area_dst_alias;
			अगर (ioctl(uffd, UFFDIO_REGISTER, &uffdio_रेजिस्टर)) अणु
				ख_लिखो(मानक_त्रुटि, "register failure alias\n");
				वापस 1;
			पूर्ण
		पूर्ण

		/*
		 * The madvise करोne previously isn't enough: some
		 * uffd_thपढ़ो could have पढ़ो userfaults (one of
		 * those alपढ़ोy resolved by the background thपढ़ो)
		 * and it may be in the process of calling
		 * UFFDIO_COPY. UFFDIO_COPY will पढ़ो the zapped
		 * area_src and it would map a zero page in it (of
		 * course such a UFFDIO_COPY is perfectly safe as it'd
		 * वापस -EEXIST). The problem comes at the next
		 * bounce though: that racing UFFDIO_COPY would
		 * generate zeropages in the area_src, so invalidating
		 * the previous MADV_DONTNEED. Without this additional
		 * MADV_DONTNEED those zeropages leftovers in the
		 * area_src would lead to -EEXIST failure during the
		 * next bounce, effectively leaving a zeropage in the
		 * area_dst.
		 *
		 * Try to comment this out madvise to see the memory
		 * corruption being caught pretty quick.
		 *
		 * khugepaged is also inhibited to collapse THP after
		 * MADV_DONTNEED only after the UFFDIO_REGISTER, so it's
		 * required to MADV_DONTNEED here.
		 */
		अगर (uffd_test_ops->release_pages(area_dst))
			वापस 1;

		uffd_stats_reset(uffd_stats, nr_cpus);

		/* bounce pass */
		अगर (stress(uffd_stats))
			वापस 1;

		/* Clear all the ग_लिखो protections अगर there is any */
		अगर (test_uffdio_wp)
			wp_range(uffd, (अचिन्हित दीर्घ)area_dst,
				 nr_pages * page_size, false);

		/* unरेजिस्टर */
		अगर (ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_रेजिस्टर.range)) अणु
			ख_लिखो(मानक_त्रुटि, "unregister failure\n");
			वापस 1;
		पूर्ण
		अगर (area_dst_alias) अणु
			uffdio_रेजिस्टर.range.start = (अचिन्हित दीर्घ) area_dst;
			अगर (ioctl(uffd, UFFDIO_UNREGISTER,
				  &uffdio_रेजिस्टर.range)) अणु
				ख_लिखो(मानक_त्रुटि, "unregister failure alias\n");
				वापस 1;
			पूर्ण
		पूर्ण

		/* verअगरication */
		अगर (bounces & BOUNCE_VERIFY) अणु
			क्रम (nr = 0; nr < nr_pages; nr++) अणु
				अगर (*area_count(area_dst, nr) != count_verअगरy[nr]) अणु
					ख_लिखो(मानक_त्रुटि,
						"error area_count %Lu %Lu %lu\n",
						*area_count(area_src, nr),
						count_verअगरy[nr],
						nr);
					err = 1;
					bounces = 0;
				पूर्ण
			पूर्ण
		पूर्ण

		/* prepare next bounce */
		पंचांगp_area = area_src;
		area_src = area_dst;
		area_dst = पंचांगp_area;

		पंचांगp_area = area_src_alias;
		area_src_alias = area_dst_alias;
		area_dst_alias = पंचांगp_area;

		uffd_stats_report(uffd_stats, nr_cpus);
	पूर्ण

	अगर (err)
		वापस err;

	बंद(uffd);
	वापस userfaultfd_zeropage_test() || userfaultfd_sig_test()
		|| userfaultfd_events_test() || userfaultfd_minor_test();
पूर्ण

/*
 * Copied from mlock2-tests.c
 */
अचिन्हित दीर्घ शेष_huge_page_size(व्योम)
अणु
	अचिन्हित दीर्घ hps = 0;
	अक्षर *line = शून्य;
	माप_प्रकार linelen = 0;
	खाता *f = ख_खोलो("/proc/meminfo", "r");

	अगर (!f)
		वापस 0;
	जबतक (getline(&line, &linelen, f) > 0) अणु
		अगर (माला_पूछो(line, "Hugepagesize:       %lu kB", &hps) == 1) अणु
			hps <<= 10;
			अवरोध;
		पूर्ण
	पूर्ण

	मुक्त(line);
	ख_बंद(f);
	वापस hps;
पूर्ण

अटल व्योम set_test_type(स्थिर अक्षर *type)
अणु
	अगर (!म_भेद(type, "anon")) अणु
		test_type = TEST_ANON;
		uffd_test_ops = &anon_uffd_test_ops;
		/* Only enable ग_लिखो-protect test क्रम anonymous test */
		test_uffdio_wp = true;
	पूर्ण अन्यथा अगर (!म_भेद(type, "hugetlb")) अणु
		test_type = TEST_HUGETLB;
		uffd_test_ops = &hugetlb_uffd_test_ops;
	पूर्ण अन्यथा अगर (!म_भेद(type, "hugetlb_shared")) अणु
		map_shared = true;
		test_type = TEST_HUGETLB;
		uffd_test_ops = &hugetlb_uffd_test_ops;
		/* Minor faults require shared hugetlb; only enable here. */
		test_uffdio_minor = true;
	पूर्ण अन्यथा अगर (!म_भेद(type, "shmem")) अणु
		map_shared = true;
		test_type = TEST_SHMEM;
		uffd_test_ops = &shmem_uffd_test_ops;
	पूर्ण अन्यथा अणु
		ख_लिखो(मानक_त्रुटि, "Unknown test type: %s\n", type); निकास(1);
	पूर्ण

	अगर (test_type == TEST_HUGETLB)
		page_size = शेष_huge_page_size();
	अन्यथा
		page_size = sysconf(_SC_PAGE_SIZE);

	अगर (!page_size) अणु
		ख_लिखो(मानक_त्रुटि, "Unable to determine page size\n");
		निकास(2);
	पूर्ण
	अगर ((अचिन्हित दीर्घ) area_count(शून्य, 0) + माप(अचिन्हित दीर्घ दीर्घ) * 2
	    > page_size) अणु
		ख_लिखो(मानक_त्रुटि, "Impossible to run this test\n");
		निकास(2);
	पूर्ण
पूर्ण

अटल व्योम sigalrm(पूर्णांक sig)
अणु
	अगर (sig != SIGALRM)
		पात();
	test_uffdio_copy_eexist = true;
	test_uffdio_zeropage_eexist = true;
	alarm(ALARM_INTERVAL_SECS);
पूर्ण

पूर्णांक मुख्य(पूर्णांक argc, अक्षर **argv)
अणु
	अगर (argc < 4)
		usage();

	अगर (संकेत(SIGALRM, sigalrm) == संक_त्रुटि) अणु
		ख_लिखो(मानक_त्रुटि, "failed to arm SIGALRM");
		निकास(1);
	पूर्ण
	alarm(ALARM_INTERVAL_SECS);

	set_test_type(argv[1]);

	nr_cpus = sysconf(_SC_NPROCESSORS_ONLN);
	nr_pages_per_cpu = म_से_द(argv[2]) * 1024*1024 / page_size /
		nr_cpus;
	अगर (!nr_pages_per_cpu) अणु
		ख_लिखो(मानक_त्रुटि, "invalid MiB\n");
		usage();
	पूर्ण

	bounces = म_से_प(argv[3]);
	अगर (bounces <= 0) अणु
		ख_लिखो(मानक_त्रुटि, "invalid bounces\n");
		usage();
	पूर्ण
	nr_pages = nr_pages_per_cpu * nr_cpus;

	अगर (test_type == TEST_HUGETLB) अणु
		अगर (argc < 5)
			usage();
		huge_fd = खोलो(argv[4], O_CREAT | O_RDWR, 0755);
		अगर (huge_fd < 0) अणु
			ख_लिखो(मानक_त्रुटि, "Open of %s failed", argv[3]);
			लिखो_त्रुटि("open");
			निकास(1);
		पूर्ण
		अगर (ftruncate(huge_fd, 0)) अणु
			ख_लिखो(मानक_त्रुटि, "ftruncate %s to size 0 failed", argv[3]);
			लिखो_त्रुटि("ftruncate");
			निकास(1);
		पूर्ण
	पूर्ण
	म_लिखो("nr_pages: %lu, nr_pages_per_cpu: %lu\n",
	       nr_pages, nr_pages_per_cpu);
	वापस userfaultfd_stress();
पूर्ण

#अन्यथा /* __NR_userfaultfd */

#warning "missing __NR_userfaultfd definition"

पूर्णांक मुख्य(व्योम)
अणु
	म_लिखो("skip: Skipping userfaultfd test (missing __NR_userfaultfd)\n");
	वापस KSFT_SKIP;
पूर्ण

#पूर्ण_अगर /* __NR_userfaultfd */
