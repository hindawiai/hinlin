<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/* Copyright (C) 2019 ARM Limited */

#समावेश <मानकपन.स>
#समावेश <मानककोष.स>
#समावेश <संकेत.स>
#समावेश <माला.स>
#समावेश <unistd.h>
#समावेश <निश्चित.स>
#समावेश <sys/auxv.h>
#समावेश <linux/auxvec.h>
#समावेश <ucontext.h>

#समावेश <यंत्र/unistd.h>

#समावेश <kselftest.h>

#समावेश "test_signals.h"
#समावेश "test_signals_utils.h"
#समावेश "testcases/testcases.h"


बाह्य काष्ठा tdescr *current;

अटल पूर्णांक sig_copyctx = SIGTRAP;

अटल अक्षर स्थिर *स्थिर feats_names[FMAX_END] = अणु
	" SSBS ",
पूर्ण;

#घोषणा MAX_FEATS_SZ	128
अटल अक्षर feats_string[MAX_FEATS_SZ];

अटल अंतरभूत अक्षर *feats_to_string(अचिन्हित दीर्घ feats)
अणु
	माप_प्रकार flen = MAX_FEATS_SZ - 1;

	क्रम (पूर्णांक i = 0; i < FMAX_END; i++) अणु
		अगर (feats & (1UL << i)) अणु
			माप_प्रकार tlen = म_माप(feats_names[i]);

			निश्चित(flen > tlen);
			flen -= tlen;
			म_जोड़न(feats_string, feats_names[i], flen);
		पूर्ण
	पूर्ण

	वापस feats_string;
पूर्ण

अटल व्योम unblock_संकेत(पूर्णांक signum)
अणु
	sigset_t sset;

	sigemptyset(&sset);
	sigaddset(&sset, signum);
	sigprocmask(SIG_UNBLOCK, &sset, शून्य);
पूर्ण

अटल व्योम शेष_result(काष्ठा tdescr *td, bool क्रमce_निकास)
अणु
	अगर (td->result == KSFT_SKIP) अणु
		ख_लिखो(मानक_त्रुटि, "==>> completed. SKIP.\n");
	पूर्ण अन्यथा अगर (td->pass) अणु
		ख_लिखो(मानक_त्रुटि, "==>> completed. PASS(1)\n");
		td->result = KSFT_PASS;
	पूर्ण अन्यथा अणु
		ख_लिखो(मानक_निकास, "==>> completed. FAIL(0)\n");
		td->result = KSFT_FAIL;
	पूर्ण

	अगर (क्रमce_निकास)
		निकास(td->result);
पूर्ण

/*
 * The following handle_संकेत_* helpers are used by मुख्य शेष_handler
 * and are meant to वापस true when संकेत is handled successfully:
 * when false is वापसed instead, it means that the संकेत was somehow
 * unexpected in that context and it was NOT handled; शेष_handler will
 * take care of such unexpected situations.
 */

अटल bool handle_संकेत_unsupported(काष्ठा tdescr *td,
				      siginfo_t *si, व्योम *uc)
अणु
	अगर (feats_ok(td))
		वापस false;

	/* Mangling PC to aव्योम loops on original संक_अवैध */
	((ucontext_t *)uc)->uc_mcontext.pc += 4;

	अगर (!td->initialized) अणु
		ख_लिखो(मानक_त्रुटि,
			"Got SIG_UNSUPP @test_init. Ignore.\n");
	पूर्ण अन्यथा अणु
		ख_लिखो(मानक_त्रुटि,
			"-- RX SIG_UNSUPP on unsupported feat...OK\n");
		td->pass = 1;
		शेष_result(current, 1);
	पूर्ण

	वापस true;
पूर्ण

अटल bool handle_संकेत_trigger(काष्ठा tdescr *td,
				  siginfo_t *si, व्योम *uc)
अणु
	td->triggered = 1;
	/* ->run was निश्चितed NON-शून्य in test_setup() alपढ़ोy */
	td->run(td, si, uc);

	वापस true;
पूर्ण

अटल bool handle_संकेत_ok(काष्ठा tdescr *td,
			     siginfo_t *si, व्योम *uc)
अणु
	/*
	 * it's a bug in the test code when this निश्चित fail:
	 * अगर sig_trig was defined, it must have been used beक्रमe getting here.
	 */
	निश्चित(!td->sig_trig || td->triggered);
	ख_लिखो(मानक_त्रुटि,
		"SIG_OK -- SP:0x%llX  si_addr@:%p  si_code:%d  token@:%p  offset:%ld\n",
		((ucontext_t *)uc)->uc_mcontext.sp,
		si->si_addr, si->si_code, td->token, td->token - si->si_addr);
	/*
	 * fake_sigवापस tests, which have sanity_enabled=1, set, at the very
	 * last समय, the token field to the SP address used to place the fake
	 * sigframe: so token==0 means we never made it to the end,
	 * segfaulting well-beक्रमe, and the test is possibly broken.
	 */
	अगर (!td->sanity_disabled && !td->token) अणु
		ख_लिखो(मानक_निकास,
			"current->token ZEROED...test is probably broken!\n");
		पात();
	पूर्ण
	/*
	 * Trying to narrow करोwn the SEGV to the ones generated by Kernel itself
	 * via arm64_notअगरy_segfault(). This is a best-efक्रमt check anyway, and
	 * the si_code check may need to change अगर this aspect of the kernel
	 * ABI changes.
	 */
	अगर (td->sig_ok == संक_अंश && si->si_code != SEGV_ACCERR) अणु
		ख_लिखो(मानक_निकास,
			"si_code != SEGV_ACCERR...test is probably broken!\n");
		पात();
	पूर्ण
	td->pass = 1;
	/*
	 * Some tests can lead to SEGV loops: in such a हाल we want to
	 * terminate immediately निकासing straight away; some others are not
	 * supposed to outlive the संकेत handler code, due to the content of
	 * the fake sigframe which caused the संकेत itself.
	 */
	शेष_result(current, 1);

	वापस true;
पूर्ण

अटल bool handle_संकेत_copyctx(काष्ठा tdescr *td,
				  siginfo_t *si, व्योम *uc)
अणु
	/* Mangling PC to aव्योम loops on original BRK instr */
	((ucontext_t *)uc)->uc_mcontext.pc += 4;
	स_नकल(td->live_uc, uc, td->live_sz);
	ASSERT_GOOD_CONTEXT(td->live_uc);
	td->live_uc_valid = 1;
	ख_लिखो(मानक_त्रुटि,
		"GOOD CONTEXT grabbed from sig_copyctx handler\n");

	वापस true;
पूर्ण

अटल व्योम शेष_handler(पूर्णांक signum, siginfo_t *si, व्योम *uc)
अणु
	अगर (current->sig_unsupp && signum == current->sig_unsupp &&
	    handle_संकेत_unsupported(current, si, uc)) अणु
		ख_लिखो(मानक_त्रुटि, "Handled SIG_UNSUPP\n");
	पूर्ण अन्यथा अगर (current->sig_trig && signum == current->sig_trig &&
		   handle_संकेत_trigger(current, si, uc)) अणु
		ख_लिखो(मानक_त्रुटि, "Handled SIG_TRIG\n");
	पूर्ण अन्यथा अगर (current->sig_ok && signum == current->sig_ok &&
		   handle_संकेत_ok(current, si, uc)) अणु
		ख_लिखो(मानक_त्रुटि, "Handled SIG_OK\n");
	पूर्ण अन्यथा अगर (signum == sig_copyctx && current->live_uc &&
		   handle_संकेत_copyctx(current, si, uc)) अणु
		ख_लिखो(मानक_त्रुटि, "Handled SIG_COPYCTX\n");
	पूर्ण अन्यथा अणु
		अगर (signum == SIGALRM && current->समयout) अणु
			ख_लिखो(मानक_त्रुटि, "-- Timeout !\n");
		पूर्ण अन्यथा अणु
			ख_लिखो(मानक_त्रुटि,
				"-- RX UNEXPECTED SIGNAL: %d\n", signum);
		पूर्ण
		शेष_result(current, 1);
	पूर्ण
पूर्ण

अटल पूर्णांक शेष_setup(काष्ठा tdescr *td)
अणु
	काष्ठा sigaction sa;

	sa.sa_sigaction = शेष_handler;
	sa.sa_flags = SA_SIGINFO | SA_RESTART;
	sa.sa_flags |= td->sa_flags;
	sigemptyset(&sa.sa_mask);
	/* uncatchable संकेतs naturally skipped ... */
	क्रम (पूर्णांक sig = 1; sig < 32; sig++)
		sigaction(sig, &sa, शून्य);
	/*
	 * RT Signals शेष disposition is Term but they cannot be
	 * generated by the Kernel in response to our tests; so just catch
	 * them all and report them as UNEXPECTED संकेतs.
	 */
	क्रम (पूर्णांक sig = SIGRTMIN; sig <= SIGRTMAX; sig++)
		sigaction(sig, &sa, शून्य);

	/* just in हाल...unblock explicitly all we need */
	अगर (td->sig_trig)
		unblock_संकेत(td->sig_trig);
	अगर (td->sig_ok)
		unblock_संकेत(td->sig_ok);
	अगर (td->sig_unsupp)
		unblock_संकेत(td->sig_unsupp);

	अगर (td->समयout) अणु
		unblock_संकेत(SIGALRM);
		alarm(td->समयout);
	पूर्ण
	ख_लिखो(मानक_त्रुटि, "Registered handlers for all signals.\n");

	वापस 1;
पूर्ण

अटल अंतरभूत पूर्णांक शेष_trigger(काष्ठा tdescr *td)
अणु
	वापस !उठाओ(td->sig_trig);
पूर्ण

पूर्णांक test_init(काष्ठा tdescr *td)
अणु
	अगर (td->sig_trig == sig_copyctx) अणु
		ख_लिखो(मानक_निकास,
			"Signal %d is RESERVED, cannot be used as a trigger. Aborting\n",
			sig_copyctx);
		वापस 0;
	पूर्ण
	/* just in हाल */
	unblock_संकेत(sig_copyctx);

	td->minsigstksz = getauxval(AT_MINSIGSTKSZ);
	अगर (!td->minsigstksz)
		td->minsigstksz = MINSIGSTKSZ;
	ख_लिखो(मानक_त्रुटि, "Detected MINSTKSIGSZ:%d\n", td->minsigstksz);

	अगर (td->feats_required) अणु
		td->feats_supported = 0;
		/*
		 * Checking क्रम CPU required features using both the
		 * auxval and the arm64 MRS Emulation to पढ़ो sysregs.
		 */
		अगर (getauxval(AT_HWCAP) & HWCAP_SSBS)
			td->feats_supported |= FEAT_SSBS;
		अगर (feats_ok(td))
			ख_लिखो(मानक_त्रुटि,
				"Required Features: [%s] supported\n",
				feats_to_string(td->feats_required &
						td->feats_supported));
		अन्यथा
			ख_लिखो(मानक_त्रुटि,
				"Required Features: [%s] NOT supported\n",
				feats_to_string(td->feats_required &
						~td->feats_supported));
	पूर्ण

	/* Perक्रमm test specअगरic additional initialization */
	अगर (td->init && !td->init(td)) अणु
		ख_लिखो(मानक_त्रुटि, "FAILED Testcase initialization.\n");
		वापस 0;
	पूर्ण
	td->initialized = 1;
	ख_लिखो(मानक_त्रुटि, "Testcase initialized.\n");

	वापस 1;
पूर्ण

पूर्णांक test_setup(काष्ठा tdescr *td)
अणु
	/* निश्चित core invariants symptom of a rotten testहाल */
	निश्चित(current);
	निश्चित(td);
	निश्चित(td->name);
	निश्चित(td->run);

	/* Default result is FAIL अगर test setup fails */
	td->result = KSFT_FAIL;
	अगर (td->setup)
		वापस td->setup(td);
	अन्यथा
		वापस शेष_setup(td);
पूर्ण

पूर्णांक test_run(काष्ठा tdescr *td)
अणु
	अगर (td->sig_trig) अणु
		अगर (td->trigger)
			वापस td->trigger(td);
		अन्यथा
			वापस शेष_trigger(td);
	पूर्ण अन्यथा अणु
		वापस td->run(td, शून्य, शून्य);
	पूर्ण
पूर्ण

व्योम test_result(काष्ठा tdescr *td)
अणु
	अगर (td->initialized && td->result != KSFT_SKIP && td->check_result)
		td->check_result(td);
	शेष_result(td, 0);
पूर्ण

व्योम test_cleanup(काष्ठा tdescr *td)
अणु
	अगर (td->cleanup)
		td->cleanup(td);
पूर्ण
