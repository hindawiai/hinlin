<शैली गुरु>
/* inftrees.c -- generate Huffman trees क्रम efficient decoding
 * Copyright (C) 1995-2005 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#समावेश <linux/zutil.h>
#समावेश "inftrees.h"

#घोषणा MAXBITS 15

/*
   Build a set of tables to decode the provided canonical Huffman code.
   The code lengths are lens[0..codes-1].  The result starts at *table,
   whose indices are 0..2^bits-1.  work is a writable array of at least
   lens लघुs, which is used as a work area.  type is the type of code
   to be generated, CODES, LENS, or DISTS.  On वापस, zero is success,
   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
   on वापस poपूर्णांकs to the next available entry's address.  bits is the
   requested root table index bits, and on वापस it is the actual root
   table index bits.  It will dअगरfer अगर the request is greater than the
   दीर्घest code or अगर it is less than the लघुest code.
 */
पूर्णांक zlib_inflate_table(codetype type, अचिन्हित लघु *lens, अचिन्हित codes,
			code **table, अचिन्हित *bits, अचिन्हित लघु *work)
अणु
    अचिन्हित len;               /* a code's length in bits */
    अचिन्हित sym;               /* index of code symbols */
    अचिन्हित min, max;          /* minimum and maximum code lengths */
    अचिन्हित root;              /* number of index bits क्रम root table */
    अचिन्हित curr;              /* number of index bits क्रम current table */
    अचिन्हित drop;              /* code bits to drop क्रम sub-table */
    पूर्णांक left;                   /* number of prefix codes available */
    अचिन्हित used;              /* code entries in table used */
    अचिन्हित huff;              /* Huffman code */
    अचिन्हित incr;              /* क्रम incrementing code, index */
    अचिन्हित fill;              /* index क्रम replicating entries */
    अचिन्हित low;               /* low bits क्रम current root entry */
    अचिन्हित mask;              /* mask क्रम low root bits */
    code this;                  /* table entry क्रम duplication */
    code *next;             /* next available space in table */
    स्थिर अचिन्हित लघु *base;     /* base value table to use */
    स्थिर अचिन्हित लघु *extra;    /* extra bits table to use */
    पूर्णांक end;                    /* use base and extra क्रम symbol > end */
    अचिन्हित लघु count[MAXBITS+1];    /* number of codes of each length */
    अचिन्हित लघु offs[MAXBITS+1];     /* offsets in table क्रम each length */
    अटल स्थिर अचिन्हित लघु lbase[31] = अणु /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0पूर्ण;
    अटल स्थिर अचिन्हित लघु lext[31] = अणु /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196पूर्ण;
    अटल स्थिर अचिन्हित लघु dbase[32] = अणु /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0पूर्ण;
    अटल स्थिर अचिन्हित लघु dext[32] = अणु /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64पूर्ण;

    /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from लघु to दीर्घ, and retaining the symbol order
       क्रम codes with equal lengths.  Then the code starts with all zero bits
       क्रम the first code of the लघुest length, and the codes are पूर्णांकeger
       increments क्रम the same length, and zeros are appended as the length
       increases.  For the deflate क्रमmat, these bits are stored backwards
       from their more natural पूर्णांकeger increment ordering, and so when the
       decoding tables are built in the large loop below, the पूर्णांकeger codes
       are incremented backwards.

       This routine assumes, but करोes not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is पूर्णांकerpreted as that code length.  zero means that that
       symbol करोes not occur in this code.

       The codes are sorted by computing a count of codes क्रम each length,
       creating from that a table of starting indices क्रम each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used क्रम other purposes as well, i.e. finding
       the minimum and maximum length codes, determining अगर there are any
       codes at all, checking क्रम a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths क्रम codes (assumes lens[] all in 0..MAXBITS) */
    क्रम (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    क्रम (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, क्रमce root to be within code lengths */
    root = *bits;
    क्रम (max = MAXBITS; max >= 1; max--)
        अगर (count[max] != 0) अवरोध;
    अगर (root > max) root = max;
    अगर (max == 0) अणु                     /* no symbols to code at all */
        this.op = (अचिन्हित अक्षर)64;    /* invalid code marker */
        this.bits = (अचिन्हित अक्षर)1;
        this.val = (अचिन्हित लघु)0;
        *(*table)++ = this;             /* make a table to क्रमce an error */
        *(*table)++ = this;
        *bits = 1;
        वापस 0;     /* no symbols, but रुको क्रम decoding to report error */
    पूर्ण
    क्रम (min = 1; min < MAXBITS; min++)
        अगर (count[min] != 0) अवरोध;
    अगर (root < min) root = min;

    /* check क्रम an over-subscribed or incomplete set of lengths */
    left = 1;
    क्रम (len = 1; len <= MAXBITS; len++) अणु
        left <<= 1;
        left -= count[len];
        अगर (left < 0) वापस -1;        /* over-subscribed */
    पूर्ण
    अगर (left > 0 && (type == CODES || max != 1))
        वापस -1;                      /* incomplete set */

    /* generate offsets पूर्णांकo symbol table क्रम each length क्रम sorting */
    offs[1] = 0;
    क्रम (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    क्रम (sym = 0; sym < codes; sym++)
        अगर (lens[sym] != 0) work[offs[lens[sym]]++] = (अचिन्हित लघु)sym;

    /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits क्रम the root table.  When len exceeds
       root, sub-tables are created poपूर्णांकed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check क्रम when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used क्रम this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked when a LENS table is being made
       against the space in *table, ENOUGH, minus the maximum space needed by
       the worst हाल distance code, MAXD.  This should never happen, but the
       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
       This assumes that when type == LENS, bits == 9.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up क्रम code type */
    चयन (type) अणु
    हाल CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
        अवरोध;
    हाल LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
        end = 256;
        अवरोध;
    शेष:            /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
    पूर्ण

    /* initialize state क्रम loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code क्रम index */
    low = (अचिन्हित)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask क्रम comparing low */

    /* check available table space */
    अगर (type == LENS && used >= ENOUGH - MAXD)
        वापस 1;

    /* process all codes and make table entries */
    क्रम (;;) अणु
        /* create table entry */
        this.bits = (अचिन्हित अक्षर)(len - drop);
        अगर ((पूर्णांक)(work[sym]) < end) अणु
            this.op = (अचिन्हित अक्षर)0;
            this.val = work[sym];
        पूर्ण
        अन्यथा अगर ((पूर्णांक)(work[sym]) > end) अणु
            this.op = (अचिन्हित अक्षर)(extra[work[sym]]);
            this.val = base[work[sym]];
        पूर्ण
        अन्यथा अणु
            this.op = (अचिन्हित अक्षर)(32 + 64);         /* end of block */
            this.val = 0;
        पूर्ण

        /* replicate क्रम those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        करो अणु
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        पूर्ण जबतक (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        जबतक (huff & incr)
            incr >>= 1;
        अगर (incr != 0) अणु
            huff &= incr - 1;
            huff += incr;
        पूर्ण
        अन्यथा
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        अगर (--(count[len]) == 0) अणु
            अगर (len == max) अवरोध;
            len = lens[work[sym]];
        पूर्ण

        /* create new sub-table अगर needed */
        अगर (len > root && (huff & mask) != low) अणु
            /* अगर first समय, transition to sub-tables */
            अगर (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (पूर्णांक)(1 << curr);
            जबतक (curr + drop < max) अणु
                left -= count[curr + drop];
                अगर (left <= 0) अवरोध;
                curr++;
                left <<= 1;
            पूर्ण

            /* check क्रम enough space */
            used += 1U << curr;
            अगर (type == LENS && used >= ENOUGH - MAXD)
                वापस 1;

            /* poपूर्णांक entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (अचिन्हित अक्षर)curr;
            (*table)[low].bits = (अचिन्हित अक्षर)root;
            (*table)[low].val = (अचिन्हित लघु)(next - *table);
        पूर्ण
    पूर्ण

    /*
       Fill in rest of table क्रम incomplete codes.  This loop is similar to the
       loop above in incrementing huff क्रम table indices.  It is assumed that
       len is equal to curr + drop, so there is no loop needed to increment
       through high index bits.  When the current sub-table is filled, the loop
       drops back to the root table to fill in any reमुख्यing entries there.
     */
    this.op = (अचिन्हित अक्षर)64;                /* invalid code marker */
    this.bits = (अचिन्हित अक्षर)(len - drop);
    this.val = (अचिन्हित लघु)0;
    जबतक (huff != 0) अणु
        /* when करोne with sub-table, drop back to root table */
        अगर (drop != 0 && (huff & mask) != low) अणु
            drop = 0;
            len = root;
            next = *table;
            this.bits = (अचिन्हित अक्षर)len;
        पूर्ण

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        जबतक (huff & incr)
            incr >>= 1;
        अगर (incr != 0) अणु
            huff &= incr - 1;
            huff += incr;
        पूर्ण
        अन्यथा
            huff = 0;
    पूर्ण

    /* set वापस parameters */
    *table += used;
    *bits = root;
    वापस 0;
पूर्ण
