<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 * Wrapper क्रम decompressing LZ4-compressed kernel, initramfs, and initrd
 *
 * Copyright (C) 2013, LG Electronics, Kyungsik Lee <kyungsik.lee@lge.com>
 */

#अगर_घोषित STATIC
#घोषणा PREBOOT
#समावेश "lz4/lz4_decompress.c"
#अन्यथा
#समावेश <linux/decompress/unlz4.h>
#पूर्ण_अगर
#समावेश <linux/types.h>
#समावेश <linux/lz4.h>
#समावेश <linux/decompress/mm.h>
#समावेश <linux/compiler.h>

#समावेश <यंत्र/unaligned.h>

/*
 * Note: Uncompressed chunk size is used in the compressor side
 * (userspace side क्रम compression).
 * It is hardcoded because there is not proper way to extract it
 * from the binary stream which is generated by the preliminary
 * version of LZ4 tool so far.
 */
#घोषणा LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE (8 << 20)
#घोषणा ARCHIVE_MAGICNUMBER 0x184C2102

STATIC अंतरभूत पूर्णांक INIT unlz4(u8 *input, दीर्घ in_len,
				दीर्घ (*fill)(व्योम *, अचिन्हित दीर्घ),
				दीर्घ (*flush)(व्योम *, अचिन्हित दीर्घ),
				u8 *output, दीर्घ *posp,
				व्योम (*error) (अक्षर *x))
अणु
	पूर्णांक ret = -1;
	माप_प्रकार chunksize = 0;
	माप_प्रकार uncomp_chunksize = LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE;
	u8 *inp;
	u8 *inp_start;
	u8 *outp;
	दीर्घ size = in_len;
#अगर_घोषित PREBOOT
	माप_प्रकार out_len = get_unaligned_le32(input + in_len);
#पूर्ण_अगर
	माप_प्रकार dest_len;


	अगर (output) अणु
		outp = output;
	पूर्ण अन्यथा अगर (!flush) अणु
		error("NULL output pointer and no flush function provided");
		जाओ निकास_0;
	पूर्ण अन्यथा अणु
		outp = large_दो_स्मृति(uncomp_chunksize);
		अगर (!outp) अणु
			error("Could not allocate output buffer");
			जाओ निकास_0;
		पूर्ण
	पूर्ण

	अगर (input && fill) अणु
		error("Both input pointer and fill function provided,");
		जाओ निकास_1;
	पूर्ण अन्यथा अगर (input) अणु
		inp = input;
	पूर्ण अन्यथा अगर (!fill) अणु
		error("NULL input pointer and missing fill function");
		जाओ निकास_1;
	पूर्ण अन्यथा अणु
		inp = large_दो_स्मृति(LZ4_compressBound(uncomp_chunksize));
		अगर (!inp) अणु
			error("Could not allocate input buffer");
			जाओ निकास_1;
		पूर्ण
	पूर्ण
	inp_start = inp;

	अगर (posp)
		*posp = 0;

	अगर (fill) अणु
		size = fill(inp, 4);
		अगर (size < 4) अणु
			error("data corrupted");
			जाओ निकास_2;
		पूर्ण
	पूर्ण

	chunksize = get_unaligned_le32(inp);
	अगर (chunksize == ARCHIVE_MAGICNUMBER) अणु
		अगर (!fill) अणु
			inp += 4;
			size -= 4;
		पूर्ण
	पूर्ण अन्यथा अणु
		error("invalid header");
		जाओ निकास_2;
	पूर्ण

	अगर (posp)
		*posp += 4;

	क्रम (;;) अणु

		अगर (fill) अणु
			size = fill(inp, 4);
			अगर (size == 0)
				अवरोध;
			अगर (size < 4) अणु
				error("data corrupted");
				जाओ निकास_2;
			पूर्ण
		पूर्ण

		chunksize = get_unaligned_le32(inp);
		अगर (chunksize == ARCHIVE_MAGICNUMBER) अणु
			अगर (!fill) अणु
				inp += 4;
				size -= 4;
			पूर्ण
			अगर (posp)
				*posp += 4;
			जारी;
		पूर्ण


		अगर (posp)
			*posp += 4;

		अगर (!fill) अणु
			inp += 4;
			size -= 4;
		पूर्ण अन्यथा अणु
			अगर (chunksize > LZ4_compressBound(uncomp_chunksize)) अणु
				error("chunk length is longer than allocated");
				जाओ निकास_2;
			पूर्ण
			size = fill(inp, chunksize);
			अगर (size < chunksize) अणु
				error("data corrupted");
				जाओ निकास_2;
			पूर्ण
		पूर्ण
#अगर_घोषित PREBOOT
		अगर (out_len >= uncomp_chunksize) अणु
			dest_len = uncomp_chunksize;
			out_len -= dest_len;
		पूर्ण अन्यथा
			dest_len = out_len;

		ret = LZ4_decompress_fast(inp, outp, dest_len);
		chunksize = ret;
#अन्यथा
		dest_len = uncomp_chunksize;

		ret = LZ4_decompress_safe(inp, outp, chunksize, dest_len);
		dest_len = ret;
#पूर्ण_अगर
		अगर (ret < 0) अणु
			error("Decoding failed");
			जाओ निकास_2;
		पूर्ण

		ret = -1;
		अगर (flush && flush(outp, dest_len) != dest_len)
			जाओ निकास_2;
		अगर (output)
			outp += dest_len;
		अगर (posp)
			*posp += chunksize;

		अगर (!fill) अणु
			size -= chunksize;

			अगर (size == 0)
				अवरोध;
			अन्यथा अगर (size < 0) अणु
				error("data corrupted");
				जाओ निकास_2;
			पूर्ण
			inp += chunksize;
		पूर्ण
	पूर्ण

	ret = 0;
निकास_2:
	अगर (!input)
		large_मुक्त(inp_start);
निकास_1:
	अगर (!output)
		large_मुक्त(outp);
निकास_0:
	वापस ret;
पूर्ण

#अगर_घोषित PREBOOT
STATIC पूर्णांक INIT __decompress(अचिन्हित अक्षर *buf, दीर्घ in_len,
			      दीर्घ (*fill)(व्योम*, अचिन्हित दीर्घ),
			      दीर्घ (*flush)(व्योम*, अचिन्हित दीर्घ),
			      अचिन्हित अक्षर *output, दीर्घ out_len,
			      दीर्घ *posp,
			      व्योम (*error)(अक्षर *x)
	)
अणु
	वापस unlz4(buf, in_len - 4, fill, flush, output, posp, error);
पूर्ण
#पूर्ण_अगर
