<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/* Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
 */
#समावेश <linux/अगर_vlan.h>
#समावेश <linux/dsa/sja1105.h>
#समावेश <linux/dsa/8021q.h>
#समावेश <linux/packing.h>
#समावेश "dsa_priv.h"

/* Similar to is_link_local_ether_addr(hdr->h_dest) but also covers PTP */
अटल अंतरभूत bool sja1105_is_link_local(स्थिर काष्ठा sk_buff *skb)
अणु
	स्थिर काष्ठा ethhdr *hdr = eth_hdr(skb);
	u64 dmac = ether_addr_to_u64(hdr->h_dest);

	अगर (ntohs(hdr->h_proto) == ETH_P_SJA1105_META)
		वापस false;
	अगर ((dmac & SJA1105_LINKLOCAL_FILTER_A_MASK) ==
		    SJA1105_LINKLOCAL_FILTER_A)
		वापस true;
	अगर ((dmac & SJA1105_LINKLOCAL_FILTER_B_MASK) ==
		    SJA1105_LINKLOCAL_FILTER_B)
		वापस true;
	वापस false;
पूर्ण

काष्ठा sja1105_meta अणु
	u64 tstamp;
	u64 dmac_byte_4;
	u64 dmac_byte_3;
	u64 source_port;
	u64 चयन_id;
पूर्ण;

अटल व्योम sja1105_meta_unpack(स्थिर काष्ठा sk_buff *skb,
				काष्ठा sja1105_meta *meta)
अणु
	u8 *buf = skb_mac_header(skb) + ETH_HLEN;

	/* UM10944.pdf section 4.2.17 AVB Parameters:
	 * Structure of the meta-data follow-up frame.
	 * It is in network byte order, so there are no quirks
	 * जबतक unpacking the meta frame.
	 *
	 * Also SJA1105 E/T only populates bits 23:0 of the बारtamp
	 * whereas P/Q/R/S करोes 32 bits. Since the काष्ठाure is the
	 * same and the E/T माला_दो zeroes in the high-order byte, use
	 * a unअगरied unpacking command क्रम both device series.
	 */
	packing(buf,     &meta->tstamp,     31, 0, 4, UNPACK, 0);
	packing(buf + 4, &meta->dmac_byte_4, 7, 0, 1, UNPACK, 0);
	packing(buf + 5, &meta->dmac_byte_3, 7, 0, 1, UNPACK, 0);
	packing(buf + 6, &meta->source_port, 7, 0, 1, UNPACK, 0);
	packing(buf + 7, &meta->चयन_id,   7, 0, 1, UNPACK, 0);
पूर्ण

अटल अंतरभूत bool sja1105_is_meta_frame(स्थिर काष्ठा sk_buff *skb)
अणु
	स्थिर काष्ठा ethhdr *hdr = eth_hdr(skb);
	u64 smac = ether_addr_to_u64(hdr->h_source);
	u64 dmac = ether_addr_to_u64(hdr->h_dest);

	अगर (smac != SJA1105_META_SMAC)
		वापस false;
	अगर (dmac != SJA1105_META_DMAC)
		वापस false;
	अगर (ntohs(hdr->h_proto) != ETH_P_SJA1105_META)
		वापस false;
	वापस true;
पूर्ण

अटल bool sja1105_can_use_vlan_as_tags(स्थिर काष्ठा sk_buff *skb)
अणु
	काष्ठा vlan_ethhdr *hdr = vlan_eth_hdr(skb);
	u16 vlan_tci;

	अगर (hdr->h_vlan_proto == htons(ETH_P_SJA1105))
		वापस true;

	अगर (hdr->h_vlan_proto != htons(ETH_P_8021Q) &&
	    !skb_vlan_tag_present(skb))
		वापस false;

	अगर (skb_vlan_tag_present(skb))
		vlan_tci = skb_vlan_tag_get(skb);
	अन्यथा
		vlan_tci = ntohs(hdr->h_vlan_TCI);

	वापस vid_is_dsa_8021q(vlan_tci & VLAN_VID_MASK);
पूर्ण

/* This is the first समय the tagger sees the frame on RX.
 * Figure out अगर we can decode it.
 */
अटल bool sja1105_filter(स्थिर काष्ठा sk_buff *skb, काष्ठा net_device *dev)
अणु
	अगर (sja1105_can_use_vlan_as_tags(skb))
		वापस true;
	अगर (sja1105_is_link_local(skb))
		वापस true;
	अगर (sja1105_is_meta_frame(skb))
		वापस true;
	वापस false;
पूर्ण

/* Calls sja1105_port_deferred_xmit in sja1105_मुख्य.c */
अटल काष्ठा sk_buff *sja1105_defer_xmit(काष्ठा sja1105_port *sp,
					  काष्ठा sk_buff *skb)
अणु
	/* Increase refcount so the kमुक्त_skb in dsa_slave_xmit
	 * won't really मुक्त the packet.
	 */
	skb_queue_tail(&sp->xmit_queue, skb_get(skb));
	kthपढ़ो_queue_work(sp->xmit_worker, &sp->xmit_work);

	वापस शून्य;
पूर्ण

अटल u16 sja1105_xmit_tpid(काष्ठा sja1105_port *sp)
अणु
	वापस sp->xmit_tpid;
पूर्ण

अटल काष्ठा sk_buff *sja1105_xmit(काष्ठा sk_buff *skb,
				    काष्ठा net_device *netdev)
अणु
	काष्ठा dsa_port *dp = dsa_slave_to_port(netdev);
	u16 tx_vid = dsa_8021q_tx_vid(dp->ds, dp->index);
	u16 queue_mapping = skb_get_queue_mapping(skb);
	u8 pcp = netdev_txq_to_tc(netdev, queue_mapping);

	/* Transmitting management traffic करोes not rely upon चयन tagging,
	 * but instead SPI-installed management routes. Part 2 of this
	 * is the .port_deferred_xmit driver callback.
	 */
	अगर (unlikely(sja1105_is_link_local(skb)))
		वापस sja1105_defer_xmit(dp->priv, skb);

	वापस dsa_8021q_xmit(skb, netdev, sja1105_xmit_tpid(dp->priv),
			     ((pcp << VLAN_PRIO_SHIFT) | tx_vid));
पूर्ण

अटल व्योम sja1105_transfer_meta(काष्ठा sk_buff *skb,
				  स्थिर काष्ठा sja1105_meta *meta)
अणु
	काष्ठा ethhdr *hdr = eth_hdr(skb);

	hdr->h_dest[3] = meta->dmac_byte_3;
	hdr->h_dest[4] = meta->dmac_byte_4;
	SJA1105_SKB_CB(skb)->meta_tstamp = meta->tstamp;
पूर्ण

/* This is a simple state machine which follows the hardware mechanism of
 * generating RX बारtamps:
 *
 * After each बारtampable skb (all traffic क्रम which send_meta1 and
 * send_meta0 is true, aka all MAC-filtered link-local traffic) a meta frame
 * containing a partial बारtamp is immediately generated by the चयन and
 * sent as a follow-up to the link-local frame on the CPU port.
 *
 * The meta frames have no unique identअगरier (such as sequence number) by which
 * one may pair them to the correct बारtampable frame.
 * Instead, the चयन has पूर्णांकernal logic that ensures no frames are sent on
 * the CPU port between a link-local बारtampable frame and its corresponding
 * meta follow-up. It also ensures strict ordering between ports (lower ports
 * have higher priority towards the CPU port). For this reason, a per-port
 * data काष्ठाure is not needed/desirable.
 *
 * This function pairs the link-local frame with its partial बारtamp from the
 * meta follow-up frame. The full बारtamp will be reस्थिरructed later in a
 * work queue.
 */
अटल काष्ठा sk_buff
*sja1105_rcv_meta_state_machine(काष्ठा sk_buff *skb,
				काष्ठा sja1105_meta *meta,
				bool is_link_local,
				bool is_meta)
अणु
	काष्ठा sja1105_port *sp;
	काष्ठा dsa_port *dp;

	dp = dsa_slave_to_port(skb->dev);
	sp = dp->priv;

	/* Step 1: A बारtampable frame was received.
	 * Buffer it until we get its meta frame.
	 */
	अगर (is_link_local) अणु
		अगर (!test_bit(SJA1105_HWTS_RX_EN, &sp->data->state))
			/* Do normal processing. */
			वापस skb;

		spin_lock(&sp->data->meta_lock);
		/* Was this a link-local frame instead of the meta
		 * that we were expecting?
		 */
		अगर (sp->data->stampable_skb) अणु
			dev_err_ratelimited(dp->ds->dev,
					    "Expected meta frame, is %12llx "
					    "in the DSA master multicast filter?\n",
					    SJA1105_META_DMAC);
			kमुक्त_skb(sp->data->stampable_skb);
		पूर्ण

		/* Hold a reference to aव्योम dsa_चयन_rcv
		 * from मुक्तing the skb.
		 */
		sp->data->stampable_skb = skb_get(skb);
		spin_unlock(&sp->data->meta_lock);

		/* Tell DSA we got nothing */
		वापस शून्य;

	/* Step 2: The meta frame arrived.
	 * Time to take the stampable skb out of the बंदt, annotate it
	 * with the partial बारtamp, and pretend that we received it
	 * just now (basically masquerade the buffered frame as the meta
	 * frame, which serves no further purpose).
	 */
	पूर्ण अन्यथा अगर (is_meta) अणु
		काष्ठा sk_buff *stampable_skb;

		/* Drop the meta frame अगर we're not in the right state
		 * to process it.
		 */
		अगर (!test_bit(SJA1105_HWTS_RX_EN, &sp->data->state))
			वापस शून्य;

		spin_lock(&sp->data->meta_lock);

		stampable_skb = sp->data->stampable_skb;
		sp->data->stampable_skb = शून्य;

		/* Was this a meta frame instead of the link-local
		 * that we were expecting?
		 */
		अगर (!stampable_skb) अणु
			dev_err_ratelimited(dp->ds->dev,
					    "Unexpected meta frame\n");
			spin_unlock(&sp->data->meta_lock);
			वापस शून्य;
		पूर्ण

		अगर (stampable_skb->dev != skb->dev) अणु
			dev_err_ratelimited(dp->ds->dev,
					    "Meta frame on wrong port\n");
			spin_unlock(&sp->data->meta_lock);
			वापस शून्य;
		पूर्ण

		/* Free the meta frame and give DSA the buffered stampable_skb
		 * क्रम further processing up the network stack.
		 */
		kमुक्त_skb(skb);
		skb = stampable_skb;
		sja1105_transfer_meta(skb, meta);

		spin_unlock(&sp->data->meta_lock);
	पूर्ण

	वापस skb;
पूर्ण

अटल व्योम sja1105_decode_subvlan(काष्ठा sk_buff *skb, u16 subvlan)
अणु
	काष्ठा dsa_port *dp = dsa_slave_to_port(skb->dev);
	काष्ठा sja1105_port *sp = dp->priv;
	u16 vid = sp->subvlan_map[subvlan];
	u16 vlan_tci;

	अगर (vid == VLAN_N_VID)
		वापस;

	vlan_tci = (skb->priority << VLAN_PRIO_SHIFT) | vid;
	__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tci);
पूर्ण

अटल काष्ठा sk_buff *sja1105_rcv(काष्ठा sk_buff *skb,
				   काष्ठा net_device *netdev,
				   काष्ठा packet_type *pt)
अणु
	काष्ठा sja1105_meta meta = अणु0पूर्ण;
	पूर्णांक source_port, चयन_id;
	काष्ठा ethhdr *hdr;
	u16 tpid, vid, tci;
	bool is_link_local;
	u16 subvlan = 0;
	bool is_tagged;
	bool is_meta;

	hdr = eth_hdr(skb);
	tpid = ntohs(hdr->h_proto);
	is_tagged = (tpid == ETH_P_SJA1105 || tpid == ETH_P_8021Q ||
		     skb_vlan_tag_present(skb));
	is_link_local = sja1105_is_link_local(skb);
	is_meta = sja1105_is_meta_frame(skb);

	skb->offload_fwd_mark = 1;

	अगर (is_tagged) अणु
		/* Normal traffic path. */
		skb_push_rcsum(skb, ETH_HLEN);
		अगर (skb_vlan_tag_present(skb)) अणु
			tci = skb_vlan_tag_get(skb);
			__vlan_hwaccel_clear_tag(skb);
		पूर्ण अन्यथा अणु
			__skb_vlan_pop(skb, &tci);
		पूर्ण
		skb_pull_rcsum(skb, ETH_HLEN);
		skb_reset_network_header(skb);
		skb_reset_transport_header(skb);

		vid = tci & VLAN_VID_MASK;
		source_port = dsa_8021q_rx_source_port(vid);
		चयन_id = dsa_8021q_rx_चयन_id(vid);
		skb->priority = (tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
		subvlan = dsa_8021q_rx_subvlan(vid);
	पूर्ण अन्यथा अगर (is_link_local) अणु
		/* Management traffic path. Switch embeds the चयन ID and
		 * port ID पूर्णांकo bytes of the destination MAC, courtesy of
		 * the incl_srcpt options.
		 */
		source_port = hdr->h_dest[3];
		चयन_id = hdr->h_dest[4];
		/* Clear the DMAC bytes that were mangled by the चयन */
		hdr->h_dest[3] = 0;
		hdr->h_dest[4] = 0;
	पूर्ण अन्यथा अगर (is_meta) अणु
		sja1105_meta_unpack(skb, &meta);
		source_port = meta.source_port;
		चयन_id = meta.चयन_id;
	पूर्ण अन्यथा अणु
		वापस शून्य;
	पूर्ण

	skb->dev = dsa_master_find_slave(netdev, चयन_id, source_port);
	अगर (!skb->dev) अणु
		netdev_warn(netdev, "Couldn't decode source port\n");
		वापस शून्य;
	पूर्ण

	अगर (subvlan)
		sja1105_decode_subvlan(skb, subvlan);

	वापस sja1105_rcv_meta_state_machine(skb, &meta, is_link_local,
					      is_meta);
पूर्ण

अटल व्योम sja1105_flow_dissect(स्थिर काष्ठा sk_buff *skb, __be16 *proto,
				 पूर्णांक *offset)
अणु
	/* No tag added क्रम management frames, all ok */
	अगर (unlikely(sja1105_is_link_local(skb)))
		वापस;

	dsa_tag_generic_flow_dissect(skb, proto, offset);
पूर्ण

अटल स्थिर काष्ठा dsa_device_ops sja1105_netdev_ops = अणु
	.name = "sja1105",
	.proto = DSA_TAG_PROTO_SJA1105,
	.xmit = sja1105_xmit,
	.rcv = sja1105_rcv,
	.filter = sja1105_filter,
	.overhead = VLAN_HLEN,
	.flow_dissect = sja1105_flow_dissect,
	.promisc_on_master = true,
पूर्ण;

MODULE_LICENSE("GPL v2");
MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_SJA1105);

module_dsa_tag_driver(sja1105_netdev_ops);
