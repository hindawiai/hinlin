<शैली गुरु>
/*
 * net/tipc/link.c: TIPC link code
 *
 * Copyright (c) 1996-2007, 2012-2016, Ericsson AB
 * Copyright (c) 2004-2007, 2010-2013, Wind River Systems
 * All rights reserved.
 *
 * Redistribution and use in source and binary क्रमms, with or without
 * modअगरication, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary क्रमm must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    करोcumentation and/or other materials provided with the distribution.
 * 3. Neither the names of the copyright holders nor the names of its
 *    contributors may be used to enकरोrse or promote products derived from
 *    this software without specअगरic prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY सूचीECT, INसूचीECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#समावेश "core.h"
#समावेश "subscr.h"
#समावेश "link.h"
#समावेश "bcast.h"
#समावेश "socket.h"
#समावेश "name_distr.h"
#समावेश "discover.h"
#समावेश "netlink.h"
#समावेश "monitor.h"
#समावेश "trace.h"
#समावेश "crypto.h"

#समावेश <linux/pkt_sched.h>

काष्ठा tipc_stats अणु
	u32 sent_pkts;
	u32 recv_pkts;
	u32 sent_states;
	u32 recv_states;
	u32 sent_probes;
	u32 recv_probes;
	u32 sent_nacks;
	u32 recv_nacks;
	u32 sent_acks;
	u32 sent_bundled;
	u32 sent_bundles;
	u32 recv_bundled;
	u32 recv_bundles;
	u32 retransmitted;
	u32 sent_fragmented;
	u32 sent_fragments;
	u32 recv_fragmented;
	u32 recv_fragments;
	u32 link_congs;		/* # port sends blocked by congestion */
	u32 deferred_recv;
	u32 duplicates;
	u32 max_queue_sz;	/* send queue size high water mark */
	u32 accu_queue_sz;	/* used क्रम send queue size profiling */
	u32 queue_sz_counts;	/* used क्रम send queue size profiling */
	u32 msg_length_counts;	/* used क्रम message length profiling */
	u32 msg_lengths_total;	/* used क्रम message length profiling */
	u32 msg_length_profile[7]; /* used क्रम msg. length profiling */
पूर्ण;

/**
 * काष्ठा tipc_link - TIPC link data काष्ठाure
 * @addr: network address of link's peer node
 * @name: link name अक्षरacter string
 * @media_addr: media address to use when sending messages over link
 * @समयr: link समयr
 * @net: poपूर्णांकer to namespace काष्ठा
 * @refcnt: reference counter क्रम permanent references (owner node & समयr)
 * @peer_session: link session # being used by peer end of link
 * @peer_bearer_id: bearer id used by link's peer endpoपूर्णांक
 * @bearer_id: local bearer id used by link
 * @tolerance: minimum link continuity loss needed to reset link [in ms]
 * @पात_limit: # of unacknowledged continuity probes needed to reset link
 * @state: current state of link FSM
 * @peer_caps: biपंचांगap describing capabilities of peer node
 * @silent_पूर्णांकv_cnt: # of समयr पूर्णांकervals without any reception from peer
 * @proto_msg: ढाँचा क्रम control messages generated by link
 * @pmsg: convenience poपूर्णांकer to "proto_msg" field
 * @priority: current link priority
 * @net_plane: current link network plane ('A' through 'H')
 * @mon_state: cookie with inक्रमmation needed by link monitor
 * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
 * @exp_msg_count: # of tunnelled messages expected during link changeover
 * @reset_rcv_checkpt: seq # of last acknowledged message at समय of link reset
 * @mtu: current maximum packet size क्रम this link
 * @advertised_mtu: advertised own mtu when link is being established
 * @transmitq: queue क्रम sent, non-acked messages
 * @backlogq: queue क्रम messages रुकोing to be sent
 * @snt_nxt: next sequence number to use क्रम outbound messages
 * @ackers: # of peers that needs to ack each packet beक्रमe it can be released
 * @acked: # last packet acked by a certain peer. Used क्रम broadcast.
 * @rcv_nxt: next sequence number to expect क्रम inbound messages
 * @deferred_queue: deferred queue saved OOS b'cast message received from node
 * @unacked_winकरोw: # of inbound messages rx'd without ack'ing back to peer
 * @inputq: buffer queue क्रम messages to be delivered upwards
 * @namedq: buffer queue क्रम name table messages to be delivered upwards
 * @next_out: ptr to first unsent outbound message in queue
 * @wakeupq: linked list of wakeup msgs रुकोing क्रम link congestion to abate
 * @दीर्घ_msg_seq_no: next identअगरier to use क्रम outbound fragmented messages
 * @reयंत्र_buf: head of partially reassembled inbound message fragments
 * @bc_rcvr: marks that this is a broadcast receiver link
 * @stats: collects statistics regarding link activity
 * @session: session to be used by link
 * @snd_nxt_state: next send seq number
 * @rcv_nxt_state: next rcv seq number
 * @in_session: have received ACTIVATE_MSG from peer
 * @active: link is active
 * @अगर_name: associated पूर्णांकerface name
 * @rst_cnt: link reset counter
 * @drop_poपूर्णांक: seq number क्रम failover handling (FIXME)
 * @failover_reयंत्र_skb: saved failover msg ptr (FIXME)
 * @failover_deferdq: deferred message queue क्रम failover processing (FIXME)
 * @transmq: the link's transmit queue
 * @backlog: link's backlog by priority (importance)
 * @snd_nxt: next sequence number to be used
 * @rcv_unacked: # messages पढ़ो by user, but not yet acked back to peer
 * @deferdq: deferred receive queue
 * @winकरोw: sliding winकरोw size क्रम congestion handling
 * @min_win: minimal send winकरोw to be used by link
 * @ssthresh: slow start threshold क्रम congestion handling
 * @max_win: maximal send winकरोw to be used by link
 * @cong_acks: congestion acks क्रम congestion aव्योमance (FIXME)
 * @checkpoपूर्णांक: seq number क्रम congestion winकरोw size handling
 * @reयंत्र_tnlmsg: fragmentation/reassembly area क्रम tunnel protocol message
 * @last_gap: last gap ack blocks क्रम bcast (FIXME)
 * @last_ga: ptr to gap ack blocks
 * @bc_rcvlink: the peer specअगरic link used क्रम broadcast reception
 * @bc_sndlink: the namespace global link used क्रम broadcast sending
 * @nack_state: bcast nack state
 * @bc_peer_is_up: peer has acked the bcast init msg
 */
काष्ठा tipc_link अणु
	u32 addr;
	अक्षर name[TIPC_MAX_LINK_NAME];
	काष्ठा net *net;

	/* Management and link supervision data */
	u16 peer_session;
	u16 session;
	u16 snd_nxt_state;
	u16 rcv_nxt_state;
	u32 peer_bearer_id;
	u32 bearer_id;
	u32 tolerance;
	u32 पात_limit;
	u32 state;
	u16 peer_caps;
	bool in_session;
	bool active;
	u32 silent_पूर्णांकv_cnt;
	अक्षर अगर_name[TIPC_MAX_IF_NAME];
	u32 priority;
	अक्षर net_plane;
	काष्ठा tipc_mon_state mon_state;
	u16 rst_cnt;

	/* Failover/synch */
	u16 drop_poपूर्णांक;
	काष्ठा sk_buff *failover_reयंत्र_skb;
	काष्ठा sk_buff_head failover_deferdq;

	/* Max packet negotiation */
	u16 mtu;
	u16 advertised_mtu;

	/* Sending */
	काष्ठा sk_buff_head transmq;
	काष्ठा sk_buff_head backlogq;
	काष्ठा अणु
		u16 len;
		u16 limit;
		काष्ठा sk_buff *target_bskb;
	पूर्ण backlog[5];
	u16 snd_nxt;

	/* Reception */
	u16 rcv_nxt;
	u32 rcv_unacked;
	काष्ठा sk_buff_head deferdq;
	काष्ठा sk_buff_head *inputq;
	काष्ठा sk_buff_head *namedq;

	/* Congestion handling */
	काष्ठा sk_buff_head wakeupq;
	u16 winकरोw;
	u16 min_win;
	u16 ssthresh;
	u16 max_win;
	u16 cong_acks;
	u16 checkpoपूर्णांक;

	/* Fragmentation/reassembly */
	काष्ठा sk_buff *reयंत्र_buf;
	काष्ठा sk_buff *reयंत्र_tnlmsg;

	/* Broadcast */
	u16 ackers;
	u16 acked;
	u16 last_gap;
	काष्ठा tipc_gap_ack_blks *last_ga;
	काष्ठा tipc_link *bc_rcvlink;
	काष्ठा tipc_link *bc_sndlink;
	u8 nack_state;
	bool bc_peer_is_up;

	/* Statistics */
	काष्ठा tipc_stats stats;
पूर्ण;

/*
 * Error message prefixes
 */
अटल स्थिर अक्षर *link_co_err = "Link tunneling error, ";
अटल स्थिर अक्षर *link_rst_msg = "Resetting link ";

/* Send states क्रम broadcast NACKs
 */
क्रमागत अणु
	BC_NACK_SND_CONDITIONAL,
	BC_NACK_SND_UNCONDITIONAL,
	BC_NACK_SND_SUPPRESS,
पूर्ण;

#घोषणा TIPC_BC_RETR_LIM  (jअगरfies + msecs_to_jअगरfies(10))
#घोषणा TIPC_UC_RETR_TIME (jअगरfies + msecs_to_jअगरfies(1))

/* Link FSM states:
 */
क्रमागत अणु
	LINK_ESTABLISHED     = 0xe,
	LINK_ESTABLISHING    = 0xe  << 4,
	LINK_RESET           = 0x1  << 8,
	LINK_RESETTING       = 0x2  << 12,
	LINK_PEER_RESET      = 0xd  << 16,
	LINK_FAILINGOVER     = 0xf  << 20,
	LINK_SYNCHING        = 0xc  << 24
पूर्ण;

/* Link FSM state checking routines
 */
अटल पूर्णांक link_is_up(काष्ठा tipc_link *l)
अणु
	वापस l->state & (LINK_ESTABLISHED | LINK_SYNCHING);
पूर्ण

अटल पूर्णांक tipc_link_proto_rcv(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			       काष्ठा sk_buff_head *xmitq);
अटल व्योम tipc_link_build_proto_msg(काष्ठा tipc_link *l, पूर्णांक mtyp, bool probe,
				      bool probe_reply, u16 rcvgap,
				      पूर्णांक tolerance, पूर्णांक priority,
				      काष्ठा sk_buff_head *xmitq);
अटल व्योम link_prपूर्णांक(काष्ठा tipc_link *l, स्थिर अक्षर *str);
अटल पूर्णांक tipc_link_build_nack_msg(काष्ठा tipc_link *l,
				    काष्ठा sk_buff_head *xmitq);
अटल व्योम tipc_link_build_bc_init_msg(काष्ठा tipc_link *l,
					काष्ठा sk_buff_head *xmitq);
अटल u8 __tipc_build_gap_ack_blks(काष्ठा tipc_gap_ack_blks *ga,
				    काष्ठा tipc_link *l, u8 start_index);
अटल u16 tipc_build_gap_ack_blks(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr);
अटल पूर्णांक tipc_link_advance_transmq(काष्ठा tipc_link *l, काष्ठा tipc_link *r,
				     u16 acked, u16 gap,
				     काष्ठा tipc_gap_ack_blks *ga,
				     काष्ठा sk_buff_head *xmitq,
				     bool *retransmitted, पूर्णांक *rc);
अटल व्योम tipc_link_update_cwin(काष्ठा tipc_link *l, पूर्णांक released,
				  bool retransmitted);
/*
 *  Simple non-अटल link routines (i.e. referenced outside this file)
 */
bool tipc_link_is_up(काष्ठा tipc_link *l)
अणु
	वापस link_is_up(l);
पूर्ण

bool tipc_link_peer_is_करोwn(काष्ठा tipc_link *l)
अणु
	वापस l->state == LINK_PEER_RESET;
पूर्ण

bool tipc_link_is_reset(काष्ठा tipc_link *l)
अणु
	वापस l->state & (LINK_RESET | LINK_FAILINGOVER | LINK_ESTABLISHING);
पूर्ण

bool tipc_link_is_establishing(काष्ठा tipc_link *l)
अणु
	वापस l->state == LINK_ESTABLISHING;
पूर्ण

bool tipc_link_is_synching(काष्ठा tipc_link *l)
अणु
	वापस l->state == LINK_SYNCHING;
पूर्ण

bool tipc_link_is_failingover(काष्ठा tipc_link *l)
अणु
	वापस l->state == LINK_FAILINGOVER;
पूर्ण

bool tipc_link_is_blocked(काष्ठा tipc_link *l)
अणु
	वापस l->state & (LINK_RESETTING | LINK_PEER_RESET | LINK_FAILINGOVER);
पूर्ण

अटल bool link_is_bc_sndlink(काष्ठा tipc_link *l)
अणु
	वापस !l->bc_sndlink;
पूर्ण

अटल bool link_is_bc_rcvlink(काष्ठा tipc_link *l)
अणु
	वापस ((l->bc_rcvlink == l) && !link_is_bc_sndlink(l));
पूर्ण

व्योम tipc_link_set_active(काष्ठा tipc_link *l, bool active)
अणु
	l->active = active;
पूर्ण

u32 tipc_link_id(काष्ठा tipc_link *l)
अणु
	वापस l->peer_bearer_id << 16 | l->bearer_id;
पूर्ण

पूर्णांक tipc_link_min_win(काष्ठा tipc_link *l)
अणु
	वापस l->min_win;
पूर्ण

पूर्णांक tipc_link_max_win(काष्ठा tipc_link *l)
अणु
	वापस l->max_win;
पूर्ण

पूर्णांक tipc_link_prio(काष्ठा tipc_link *l)
अणु
	वापस l->priority;
पूर्ण

अचिन्हित दीर्घ tipc_link_tolerance(काष्ठा tipc_link *l)
अणु
	वापस l->tolerance;
पूर्ण

काष्ठा sk_buff_head *tipc_link_inputq(काष्ठा tipc_link *l)
अणु
	वापस l->inputq;
पूर्ण

अक्षर tipc_link_plane(काष्ठा tipc_link *l)
अणु
	वापस l->net_plane;
पूर्ण

काष्ठा net *tipc_link_net(काष्ठा tipc_link *l)
अणु
	वापस l->net;
पूर्ण

व्योम tipc_link_update_caps(काष्ठा tipc_link *l, u16 capabilities)
अणु
	l->peer_caps = capabilities;
पूर्ण

व्योम tipc_link_add_bc_peer(काष्ठा tipc_link *snd_l,
			   काष्ठा tipc_link *uc_l,
			   काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा tipc_link *rcv_l = uc_l->bc_rcvlink;

	snd_l->ackers++;
	rcv_l->acked = snd_l->snd_nxt - 1;
	snd_l->state = LINK_ESTABLISHED;
	tipc_link_build_bc_init_msg(uc_l, xmitq);
पूर्ण

व्योम tipc_link_हटाओ_bc_peer(काष्ठा tipc_link *snd_l,
			      काष्ठा tipc_link *rcv_l,
			      काष्ठा sk_buff_head *xmitq)
अणु
	u16 ack = snd_l->snd_nxt - 1;

	snd_l->ackers--;
	rcv_l->bc_peer_is_up = true;
	rcv_l->state = LINK_ESTABLISHED;
	tipc_link_bc_ack_rcv(rcv_l, ack, 0, शून्य, xmitq, शून्य);
	trace_tipc_link_reset(rcv_l, TIPC_DUMP_ALL, "bclink removed!");
	tipc_link_reset(rcv_l);
	rcv_l->state = LINK_RESET;
	अगर (!snd_l->ackers) अणु
		trace_tipc_link_reset(snd_l, TIPC_DUMP_ALL, "zero ackers!");
		tipc_link_reset(snd_l);
		snd_l->state = LINK_RESET;
		__skb_queue_purge(xmitq);
	पूर्ण
पूर्ण

पूर्णांक tipc_link_bc_peers(काष्ठा tipc_link *l)
अणु
	वापस l->ackers;
पूर्ण

अटल u16 link_bc_rcv_gap(काष्ठा tipc_link *l)
अणु
	काष्ठा sk_buff *skb = skb_peek(&l->deferdq);
	u16 gap = 0;

	अगर (more(l->snd_nxt, l->rcv_nxt))
		gap = l->snd_nxt - l->rcv_nxt;
	अगर (skb)
		gap = buf_seqno(skb) - l->rcv_nxt;
	वापस gap;
पूर्ण

व्योम tipc_link_set_mtu(काष्ठा tipc_link *l, पूर्णांक mtu)
अणु
	l->mtu = mtu;
पूर्ण

पूर्णांक tipc_link_mtu(काष्ठा tipc_link *l)
अणु
	वापस l->mtu;
पूर्ण

पूर्णांक tipc_link_mss(काष्ठा tipc_link *l)
अणु
#अगर_घोषित CONFIG_TIPC_CRYPTO
	वापस l->mtu - INT_H_SIZE - EMSG_OVERHEAD;
#अन्यथा
	वापस l->mtu - INT_H_SIZE;
#पूर्ण_अगर
पूर्ण

u16 tipc_link_rcv_nxt(काष्ठा tipc_link *l)
अणु
	वापस l->rcv_nxt;
पूर्ण

u16 tipc_link_acked(काष्ठा tipc_link *l)
अणु
	वापस l->acked;
पूर्ण

अक्षर *tipc_link_name(काष्ठा tipc_link *l)
अणु
	वापस l->name;
पूर्ण

u32 tipc_link_state(काष्ठा tipc_link *l)
अणु
	वापस l->state;
पूर्ण

/**
 * tipc_link_create - create a new link
 * @net: poपूर्णांकer to associated network namespace
 * @अगर_name: associated पूर्णांकerface name
 * @bearer_id: id (index) of associated bearer
 * @tolerance: link tolerance to be used by link
 * @net_plane: network plane (A,B,c..) this link beदीर्घs to
 * @mtu: mtu to be advertised by link
 * @priority: priority to be used by link
 * @min_win: minimal send winकरोw to be used by link
 * @max_win: maximal send winकरोw to be used by link
 * @session: session to be used by link
 * @peer: node id of peer node
 * @peer_caps: biपंचांगap describing peer node capabilities
 * @bc_sndlink: the namespace global link used क्रम broadcast sending
 * @bc_rcvlink: the peer specअगरic link used क्रम broadcast reception
 * @inputq: queue to put messages पढ़ोy क्रम delivery
 * @namedq: queue to put binding table update messages पढ़ोy क्रम delivery
 * @link: वापस value, poपूर्णांकer to put the created link
 * @self: local unicast link id
 * @peer_id: 128-bit ID of peer
 *
 * Return: true अगर link was created, otherwise false
 */
bool tipc_link_create(काष्ठा net *net, अक्षर *अगर_name, पूर्णांक bearer_id,
		      पूर्णांक tolerance, अक्षर net_plane, u32 mtu, पूर्णांक priority,
		      u32 min_win, u32 max_win, u32 session, u32 self,
		      u32 peer, u8 *peer_id, u16 peer_caps,
		      काष्ठा tipc_link *bc_sndlink,
		      काष्ठा tipc_link *bc_rcvlink,
		      काष्ठा sk_buff_head *inputq,
		      काष्ठा sk_buff_head *namedq,
		      काष्ठा tipc_link **link)
अणु
	अक्षर peer_str[NODE_ID_STR_LEN] = अणु0,पूर्ण;
	अक्षर self_str[NODE_ID_STR_LEN] = अणु0,पूर्ण;
	काष्ठा tipc_link *l;

	l = kzalloc(माप(*l), GFP_ATOMIC);
	अगर (!l)
		वापस false;
	*link = l;
	l->session = session;

	/* Set link name क्रम unicast links only */
	अगर (peer_id) अणु
		tipc_nodeid2string(self_str, tipc_own_id(net));
		अगर (म_माप(self_str) > 16)
			प्र_लिखो(self_str, "%x", self);
		tipc_nodeid2string(peer_str, peer_id);
		अगर (म_माप(peer_str) > 16)
			प्र_लिखो(peer_str, "%x", peer);
	पूर्ण
	/* Peer i/f name will be completed by reset/activate message */
	snम_लिखो(l->name, माप(l->name), "%s:%s-%s:unknown",
		 self_str, अगर_name, peer_str);

	म_नकल(l->अगर_name, अगर_name);
	l->addr = peer;
	l->peer_caps = peer_caps;
	l->net = net;
	l->in_session = false;
	l->bearer_id = bearer_id;
	l->tolerance = tolerance;
	अगर (bc_rcvlink)
		bc_rcvlink->tolerance = tolerance;
	l->net_plane = net_plane;
	l->advertised_mtu = mtu;
	l->mtu = mtu;
	l->priority = priority;
	tipc_link_set_queue_limits(l, min_win, max_win);
	l->ackers = 1;
	l->bc_sndlink = bc_sndlink;
	l->bc_rcvlink = bc_rcvlink;
	l->inputq = inputq;
	l->namedq = namedq;
	l->state = LINK_RESETTING;
	__skb_queue_head_init(&l->transmq);
	__skb_queue_head_init(&l->backlogq);
	__skb_queue_head_init(&l->deferdq);
	__skb_queue_head_init(&l->failover_deferdq);
	skb_queue_head_init(&l->wakeupq);
	skb_queue_head_init(l->inputq);
	वापस true;
पूर्ण

/**
 * tipc_link_bc_create - create new link to be used क्रम broadcast
 * @net: poपूर्णांकer to associated network namespace
 * @mtu: mtu to be used initially अगर no peers
 * @min_win: minimal send winकरोw to be used by link
 * @max_win: maximal send winकरोw to be used by link
 * @inputq: queue to put messages पढ़ोy क्रम delivery
 * @namedq: queue to put binding table update messages पढ़ोy क्रम delivery
 * @link: वापस value, poपूर्णांकer to put the created link
 * @ownnode: identity of own node
 * @peer: node id of peer node
 * @peer_id: 128-bit ID of peer
 * @peer_caps: biपंचांगap describing peer node capabilities
 * @bc_sndlink: the namespace global link used क्रम broadcast sending
 *
 * Return: true अगर link was created, otherwise false
 */
bool tipc_link_bc_create(काष्ठा net *net, u32 ownnode, u32 peer, u8 *peer_id,
			 पूर्णांक mtu, u32 min_win, u32 max_win, u16 peer_caps,
			 काष्ठा sk_buff_head *inputq,
			 काष्ठा sk_buff_head *namedq,
			 काष्ठा tipc_link *bc_sndlink,
			 काष्ठा tipc_link **link)
अणु
	काष्ठा tipc_link *l;

	अगर (!tipc_link_create(net, "", MAX_BEARERS, 0, 'Z', mtu, 0, min_win,
			      max_win, 0, ownnode, peer, शून्य, peer_caps,
			      bc_sndlink, शून्य, inputq, namedq, link))
		वापस false;

	l = *link;
	अगर (peer_id) अणु
		अक्षर peer_str[NODE_ID_STR_LEN] = अणु0,पूर्ण;

		tipc_nodeid2string(peer_str, peer_id);
		अगर (म_माप(peer_str) > 16)
			प्र_लिखो(peer_str, "%x", peer);
		/* Broadcast receiver link name: "broadcast-link:<peer>" */
		snम_लिखो(l->name, माप(l->name), "%s:%s", tipc_bclink_name,
			 peer_str);
	पूर्ण अन्यथा अणु
		म_नकल(l->name, tipc_bclink_name);
	पूर्ण
	trace_tipc_link_reset(l, TIPC_DUMP_ALL, "bclink created!");
	tipc_link_reset(l);
	l->state = LINK_RESET;
	l->ackers = 0;
	l->bc_rcvlink = l;

	/* Broadcast send link is always up */
	अगर (link_is_bc_sndlink(l))
		l->state = LINK_ESTABLISHED;

	/* Disable replicast अगर even a single peer करोesn't support it */
	अगर (link_is_bc_rcvlink(l) && !(peer_caps & TIPC_BCAST_RCAST))
		tipc_bcast_toggle_rcast(net, false);

	वापस true;
पूर्ण

/**
 * tipc_link_fsm_evt - link finite state machine
 * @l: poपूर्णांकer to link
 * @evt: state machine event to be processed
 */
पूर्णांक tipc_link_fsm_evt(काष्ठा tipc_link *l, पूर्णांक evt)
अणु
	पूर्णांक rc = 0;
	पूर्णांक old_state = l->state;

	चयन (l->state) अणु
	हाल LINK_RESETTING:
		चयन (evt) अणु
		हाल LINK_PEER_RESET_EVT:
			l->state = LINK_PEER_RESET;
			अवरोध;
		हाल LINK_RESET_EVT:
			l->state = LINK_RESET;
			अवरोध;
		हाल LINK_FAILURE_EVT:
		हाल LINK_FAILOVER_BEGIN_EVT:
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_FAILOVER_END_EVT:
		हाल LINK_SYNCH_BEGIN_EVT:
		हाल LINK_SYNCH_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_RESET:
		चयन (evt) अणु
		हाल LINK_PEER_RESET_EVT:
			l->state = LINK_ESTABLISHING;
			अवरोध;
		हाल LINK_FAILOVER_BEGIN_EVT:
			l->state = LINK_FAILINGOVER;
		हाल LINK_FAILURE_EVT:
		हाल LINK_RESET_EVT:
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_FAILOVER_END_EVT:
			अवरोध;
		हाल LINK_SYNCH_BEGIN_EVT:
		हाल LINK_SYNCH_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_PEER_RESET:
		चयन (evt) अणु
		हाल LINK_RESET_EVT:
			l->state = LINK_ESTABLISHING;
			अवरोध;
		हाल LINK_PEER_RESET_EVT:
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_FAILURE_EVT:
			अवरोध;
		हाल LINK_SYNCH_BEGIN_EVT:
		हाल LINK_SYNCH_END_EVT:
		हाल LINK_FAILOVER_BEGIN_EVT:
		हाल LINK_FAILOVER_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_FAILINGOVER:
		चयन (evt) अणु
		हाल LINK_FAILOVER_END_EVT:
			l->state = LINK_RESET;
			अवरोध;
		हाल LINK_PEER_RESET_EVT:
		हाल LINK_RESET_EVT:
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_FAILURE_EVT:
			अवरोध;
		हाल LINK_FAILOVER_BEGIN_EVT:
		हाल LINK_SYNCH_BEGIN_EVT:
		हाल LINK_SYNCH_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_ESTABLISHING:
		चयन (evt) अणु
		हाल LINK_ESTABLISH_EVT:
			l->state = LINK_ESTABLISHED;
			अवरोध;
		हाल LINK_FAILOVER_BEGIN_EVT:
			l->state = LINK_FAILINGOVER;
			अवरोध;
		हाल LINK_RESET_EVT:
			l->state = LINK_RESET;
			अवरोध;
		हाल LINK_FAILURE_EVT:
		हाल LINK_PEER_RESET_EVT:
		हाल LINK_SYNCH_BEGIN_EVT:
		हाल LINK_FAILOVER_END_EVT:
			अवरोध;
		हाल LINK_SYNCH_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_ESTABLISHED:
		चयन (evt) अणु
		हाल LINK_PEER_RESET_EVT:
			l->state = LINK_PEER_RESET;
			rc |= TIPC_LINK_DOWN_EVT;
			अवरोध;
		हाल LINK_FAILURE_EVT:
			l->state = LINK_RESETTING;
			rc |= TIPC_LINK_DOWN_EVT;
			अवरोध;
		हाल LINK_RESET_EVT:
			l->state = LINK_RESET;
			अवरोध;
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_SYNCH_END_EVT:
			अवरोध;
		हाल LINK_SYNCH_BEGIN_EVT:
			l->state = LINK_SYNCHING;
			अवरोध;
		हाल LINK_FAILOVER_BEGIN_EVT:
		हाल LINK_FAILOVER_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	हाल LINK_SYNCHING:
		चयन (evt) अणु
		हाल LINK_PEER_RESET_EVT:
			l->state = LINK_PEER_RESET;
			rc |= TIPC_LINK_DOWN_EVT;
			अवरोध;
		हाल LINK_FAILURE_EVT:
			l->state = LINK_RESETTING;
			rc |= TIPC_LINK_DOWN_EVT;
			अवरोध;
		हाल LINK_RESET_EVT:
			l->state = LINK_RESET;
			अवरोध;
		हाल LINK_ESTABLISH_EVT:
		हाल LINK_SYNCH_BEGIN_EVT:
			अवरोध;
		हाल LINK_SYNCH_END_EVT:
			l->state = LINK_ESTABLISHED;
			अवरोध;
		हाल LINK_FAILOVER_BEGIN_EVT:
		हाल LINK_FAILOVER_END_EVT:
		शेष:
			जाओ illegal_evt;
		पूर्ण
		अवरोध;
	शेष:
		pr_err("Unknown FSM state %x in %s\n", l->state, l->name);
	पूर्ण
	trace_tipc_link_fsm(l->name, old_state, l->state, evt);
	वापस rc;
illegal_evt:
	pr_err("Illegal FSM event %x in state %x on link %s\n",
	       evt, l->state, l->name);
	trace_tipc_link_fsm(l->name, old_state, l->state, evt);
	वापस rc;
पूर्ण

/* link_profile_stats - update statistical profiling of traffic
 */
अटल व्योम link_profile_stats(काष्ठा tipc_link *l)
अणु
	काष्ठा sk_buff *skb;
	काष्ठा tipc_msg *msg;
	पूर्णांक length;

	/* Update counters used in statistical profiling of send traffic */
	l->stats.accu_queue_sz += skb_queue_len(&l->transmq);
	l->stats.queue_sz_counts++;

	skb = skb_peek(&l->transmq);
	अगर (!skb)
		वापस;
	msg = buf_msg(skb);
	length = msg_size(msg);

	अगर (msg_user(msg) == MSG_FRAGMENTER) अणु
		अगर (msg_type(msg) != FIRST_FRAGMENT)
			वापस;
		length = msg_size(msg_inner_hdr(msg));
	पूर्ण
	l->stats.msg_lengths_total += length;
	l->stats.msg_length_counts++;
	अगर (length <= 64)
		l->stats.msg_length_profile[0]++;
	अन्यथा अगर (length <= 256)
		l->stats.msg_length_profile[1]++;
	अन्यथा अगर (length <= 1024)
		l->stats.msg_length_profile[2]++;
	अन्यथा अगर (length <= 4096)
		l->stats.msg_length_profile[3]++;
	अन्यथा अगर (length <= 16384)
		l->stats.msg_length_profile[4]++;
	अन्यथा अगर (length <= 32768)
		l->stats.msg_length_profile[5]++;
	अन्यथा
		l->stats.msg_length_profile[6]++;
पूर्ण

/**
 * tipc_link_too_silent - check अगर link is "too silent"
 * @l: tipc link to be checked
 *
 * Return: true अगर the link 'silent_intv_cnt' is about to reach the
 * 'abort_limit' value, otherwise false
 */
bool tipc_link_too_silent(काष्ठा tipc_link *l)
अणु
	वापस (l->silent_पूर्णांकv_cnt + 2 > l->पात_limit);
पूर्ण

/* tipc_link_समयout - perक्रमm periodic task as inकाष्ठाed from node समयout
 */
पूर्णांक tipc_link_समयout(काष्ठा tipc_link *l, काष्ठा sk_buff_head *xmitq)
अणु
	पूर्णांक mtyp = 0;
	पूर्णांक rc = 0;
	bool state = false;
	bool probe = false;
	bool setup = false;
	u16 bc_snt = l->bc_sndlink->snd_nxt - 1;
	u16 bc_acked = l->bc_rcvlink->acked;
	काष्ठा tipc_mon_state *mstate = &l->mon_state;

	trace_tipc_link_समयout(l, TIPC_DUMP_NONE, " ");
	trace_tipc_link_too_silent(l, TIPC_DUMP_ALL, " ");
	चयन (l->state) अणु
	हाल LINK_ESTABLISHED:
	हाल LINK_SYNCHING:
		mtyp = STATE_MSG;
		link_profile_stats(l);
		tipc_mon_get_state(l->net, l->addr, mstate, l->bearer_id);
		अगर (mstate->reset || (l->silent_पूर्णांकv_cnt > l->पात_limit))
			वापस tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
		state = bc_acked != bc_snt;
		state |= l->bc_rcvlink->rcv_unacked;
		state |= l->rcv_unacked;
		state |= !skb_queue_empty(&l->transmq);
		probe = mstate->probing;
		probe |= l->silent_पूर्णांकv_cnt;
		अगर (probe || mstate->monitoring)
			l->silent_पूर्णांकv_cnt++;
		probe |= !skb_queue_empty(&l->deferdq);
		अगर (l->snd_nxt == l->checkpoपूर्णांक) अणु
			tipc_link_update_cwin(l, 0, 0);
			probe = true;
		पूर्ण
		l->checkpoपूर्णांक = l->snd_nxt;
		अवरोध;
	हाल LINK_RESET:
		setup = l->rst_cnt++ <= 4;
		setup |= !(l->rst_cnt % 16);
		mtyp = RESET_MSG;
		अवरोध;
	हाल LINK_ESTABLISHING:
		setup = true;
		mtyp = ACTIVATE_MSG;
		अवरोध;
	हाल LINK_PEER_RESET:
	हाल LINK_RESETTING:
	हाल LINK_FAILINGOVER:
		अवरोध;
	शेष:
		अवरोध;
	पूर्ण

	अगर (state || probe || setup)
		tipc_link_build_proto_msg(l, mtyp, probe, 0, 0, 0, 0, xmitq);

	वापस rc;
पूर्ण

/**
 * link_schedule_user - schedule a message sender क्रम wakeup after congestion
 * @l: congested link
 * @hdr: header of message that is being sent
 * Create pseuकरो msg to send back to user when congestion abates
 */
अटल पूर्णांक link_schedule_user(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr)
अणु
	u32 dnode = tipc_own_addr(l->net);
	u32 dport = msg_origport(hdr);
	काष्ठा sk_buff *skb;

	/* Create and schedule wakeup pseuकरो message */
	skb = tipc_msg_create(SOCK_WAKEUP, 0, INT_H_SIZE, 0,
			      dnode, l->addr, dport, 0, 0);
	अगर (!skb)
		वापस -ENOBUFS;
	msg_set_dest_droppable(buf_msg(skb), true);
	TIPC_SKB_CB(skb)->chain_imp = msg_importance(hdr);
	skb_queue_tail(&l->wakeupq, skb);
	l->stats.link_congs++;
	trace_tipc_link_conges(l, TIPC_DUMP_ALL, "wakeup scheduled!");
	वापस -ELINKCONG;
पूर्ण

/**
 * link_prepare_wakeup - prepare users क्रम wakeup after congestion
 * @l: congested link
 * Wake up a number of रुकोing users, as permitted by available space
 * in the send queue
 */
अटल व्योम link_prepare_wakeup(काष्ठा tipc_link *l)
अणु
	काष्ठा sk_buff_head *wakeupq = &l->wakeupq;
	काष्ठा sk_buff_head *inputq = l->inputq;
	काष्ठा sk_buff *skb, *पंचांगp;
	काष्ठा sk_buff_head पंचांगpq;
	पूर्णांक avail[5] = अणु0,पूर्ण;
	पूर्णांक imp = 0;

	__skb_queue_head_init(&पंचांगpq);

	क्रम (; imp <= TIPC_SYSTEM_IMPORTANCE; imp++)
		avail[imp] = l->backlog[imp].limit - l->backlog[imp].len;

	skb_queue_walk_safe(wakeupq, skb, पंचांगp) अणु
		imp = TIPC_SKB_CB(skb)->chain_imp;
		अगर (avail[imp] <= 0)
			जारी;
		avail[imp]--;
		__skb_unlink(skb, wakeupq);
		__skb_queue_tail(&पंचांगpq, skb);
	पूर्ण

	spin_lock_bh(&inputq->lock);
	skb_queue_splice_tail(&पंचांगpq, inputq);
	spin_unlock_bh(&inputq->lock);

पूर्ण

/**
 * tipc_link_set_skb_retransmit_समय - set the समय at which retransmission of
 *                                     the given skb should be next attempted
 * @skb: skb to set a future retransmission समय क्रम
 * @l: link the skb will be transmitted on
 */
अटल व्योम tipc_link_set_skb_retransmit_समय(काष्ठा sk_buff *skb,
					      काष्ठा tipc_link *l)
अणु
	अगर (link_is_bc_sndlink(l))
		TIPC_SKB_CB(skb)->nxt_retr = TIPC_BC_RETR_LIM;
	अन्यथा
		TIPC_SKB_CB(skb)->nxt_retr = TIPC_UC_RETR_TIME;
पूर्ण

व्योम tipc_link_reset(काष्ठा tipc_link *l)
अणु
	काष्ठा sk_buff_head list;
	u32 imp;

	__skb_queue_head_init(&list);

	l->in_session = false;
	/* Force re-synch of peer session number beक्रमe establishing */
	l->peer_session--;
	l->session++;
	l->mtu = l->advertised_mtu;

	spin_lock_bh(&l->wakeupq.lock);
	skb_queue_splice_init(&l->wakeupq, &list);
	spin_unlock_bh(&l->wakeupq.lock);

	spin_lock_bh(&l->inputq->lock);
	skb_queue_splice_init(&list, l->inputq);
	spin_unlock_bh(&l->inputq->lock);

	__skb_queue_purge(&l->transmq);
	__skb_queue_purge(&l->deferdq);
	__skb_queue_purge(&l->backlogq);
	__skb_queue_purge(&l->failover_deferdq);
	क्रम (imp = 0; imp <= TIPC_SYSTEM_IMPORTANCE; imp++) अणु
		l->backlog[imp].len = 0;
		l->backlog[imp].target_bskb = शून्य;
	पूर्ण
	kमुक्त_skb(l->reयंत्र_buf);
	kमुक्त_skb(l->reयंत्र_tnlmsg);
	kमुक्त_skb(l->failover_reयंत्र_skb);
	l->reयंत्र_buf = शून्य;
	l->reयंत्र_tnlmsg = शून्य;
	l->failover_reयंत्र_skb = शून्य;
	l->rcv_unacked = 0;
	l->snd_nxt = 1;
	l->rcv_nxt = 1;
	l->snd_nxt_state = 1;
	l->rcv_nxt_state = 1;
	l->acked = 0;
	l->last_gap = 0;
	kमुक्त(l->last_ga);
	l->last_ga = शून्य;
	l->silent_पूर्णांकv_cnt = 0;
	l->rst_cnt = 0;
	l->bc_peer_is_up = false;
	स_रखो(&l->mon_state, 0, माप(l->mon_state));
	tipc_link_reset_stats(l);
पूर्ण

/**
 * tipc_link_xmit(): enqueue buffer list according to queue situation
 * @l: link to use
 * @list: chain of buffers containing message
 * @xmitq: वापसed list of packets to be sent by caller
 *
 * Consumes the buffer chain.
 * Messages at TIPC_SYSTEM_IMPORTANCE are always accepted
 * Return: 0 अगर success, or त्रुटि_सं: -ELINKCONG, -EMSGSIZE or -ENOBUFS
 */
पूर्णांक tipc_link_xmit(काष्ठा tipc_link *l, काष्ठा sk_buff_head *list,
		   काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff_head *backlogq = &l->backlogq;
	काष्ठा sk_buff_head *transmq = &l->transmq;
	काष्ठा sk_buff *skb, *_skb;
	u16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;
	u16 ack = l->rcv_nxt - 1;
	u16 seqno = l->snd_nxt;
	पूर्णांक pkt_cnt = skb_queue_len(list);
	अचिन्हित पूर्णांक mss = tipc_link_mss(l);
	अचिन्हित पूर्णांक cwin = l->winकरोw;
	अचिन्हित पूर्णांक mtu = l->mtu;
	काष्ठा tipc_msg *hdr;
	bool new_bundle;
	पूर्णांक rc = 0;
	पूर्णांक imp;

	अगर (pkt_cnt <= 0)
		वापस 0;

	hdr = buf_msg(skb_peek(list));
	अगर (unlikely(msg_size(hdr) > mtu)) अणु
		pr_warn("Too large msg, purging xmit list %d %d %d %d %d!\n",
			skb_queue_len(list), msg_user(hdr),
			msg_type(hdr), msg_size(hdr), mtu);
		__skb_queue_purge(list);
		वापस -EMSGSIZE;
	पूर्ण

	imp = msg_importance(hdr);
	/* Allow oversubscription of one data msg per source at congestion */
	अगर (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) अणु
		अगर (imp == TIPC_SYSTEM_IMPORTANCE) अणु
			pr_warn("%s<%s>, link overflow", link_rst_msg, l->name);
			वापस -ENOBUFS;
		पूर्ण
		rc = link_schedule_user(l, hdr);
	पूर्ण

	अगर (pkt_cnt > 1) अणु
		l->stats.sent_fragmented++;
		l->stats.sent_fragments += pkt_cnt;
	पूर्ण

	/* Prepare each packet क्रम sending, and add to relevant queue: */
	जबतक ((skb = __skb_dequeue(list))) अणु
		अगर (likely(skb_queue_len(transmq) < cwin)) अणु
			hdr = buf_msg(skb);
			msg_set_seqno(hdr, seqno);
			msg_set_ack(hdr, ack);
			msg_set_bcast_ack(hdr, bc_ack);
			_skb = skb_clone(skb, GFP_ATOMIC);
			अगर (!_skb) अणु
				kमुक्त_skb(skb);
				__skb_queue_purge(list);
				वापस -ENOBUFS;
			पूर्ण
			__skb_queue_tail(transmq, skb);
			tipc_link_set_skb_retransmit_समय(skb, l);
			__skb_queue_tail(xmitq, _skb);
			TIPC_SKB_CB(skb)->ackers = l->ackers;
			l->rcv_unacked = 0;
			l->stats.sent_pkts++;
			seqno++;
			जारी;
		पूर्ण
		अगर (tipc_msg_try_bundle(l->backlog[imp].target_bskb, &skb,
					mss, l->addr, &new_bundle)) अणु
			अगर (skb) अणु
				/* Keep a ref. to the skb क्रम next try */
				l->backlog[imp].target_bskb = skb;
				l->backlog[imp].len++;
				__skb_queue_tail(backlogq, skb);
			पूर्ण अन्यथा अणु
				अगर (new_bundle) अणु
					l->stats.sent_bundles++;
					l->stats.sent_bundled++;
				पूर्ण
				l->stats.sent_bundled++;
			पूर्ण
			जारी;
		पूर्ण
		l->backlog[imp].target_bskb = शून्य;
		l->backlog[imp].len += (1 + skb_queue_len(list));
		__skb_queue_tail(backlogq, skb);
		skb_queue_splice_tail_init(list, backlogq);
	पूर्ण
	l->snd_nxt = seqno;
	वापस rc;
पूर्ण

अटल व्योम tipc_link_update_cwin(काष्ठा tipc_link *l, पूर्णांक released,
				  bool retransmitted)
अणु
	पूर्णांक bklog_len = skb_queue_len(&l->backlogq);
	काष्ठा sk_buff_head *txq = &l->transmq;
	पूर्णांक txq_len = skb_queue_len(txq);
	u16 cwin = l->winकरोw;

	/* Enter fast recovery */
	अगर (unlikely(retransmitted)) अणु
		l->ssthresh = max_t(u16, l->winकरोw / 2, 300);
		l->winकरोw = min_t(u16, l->ssthresh, l->winकरोw);
		वापस;
	पूर्ण
	/* Enter slow start */
	अगर (unlikely(!released)) अणु
		l->ssthresh = max_t(u16, l->winकरोw / 2, 300);
		l->winकरोw = l->min_win;
		वापस;
	पूर्ण
	/* Don't increase winकरोw अगर no pressure on the transmit queue */
	अगर (txq_len + bklog_len < cwin)
		वापस;

	/* Don't increase winकरोw अगर there are holes the transmit queue */
	अगर (txq_len && l->snd_nxt - buf_seqno(skb_peek(txq)) != txq_len)
		वापस;

	l->cong_acks += released;

	/* Slow start  */
	अगर (cwin <= l->ssthresh) अणु
		l->winकरोw = min_t(u16, cwin + released, l->max_win);
		वापस;
	पूर्ण
	/* Congestion aव्योमance */
	अगर (l->cong_acks < cwin)
		वापस;
	l->winकरोw = min_t(u16, ++cwin, l->max_win);
	l->cong_acks = 0;
पूर्ण

अटल व्योम tipc_link_advance_backlog(काष्ठा tipc_link *l,
				      काष्ठा sk_buff_head *xmitq)
अणु
	u16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;
	काष्ठा sk_buff_head *txq = &l->transmq;
	काष्ठा sk_buff *skb, *_skb;
	u16 ack = l->rcv_nxt - 1;
	u16 seqno = l->snd_nxt;
	काष्ठा tipc_msg *hdr;
	u16 cwin = l->winकरोw;
	u32 imp;

	जबतक (skb_queue_len(txq) < cwin) अणु
		skb = skb_peek(&l->backlogq);
		अगर (!skb)
			अवरोध;
		_skb = skb_clone(skb, GFP_ATOMIC);
		अगर (!_skb)
			अवरोध;
		__skb_dequeue(&l->backlogq);
		hdr = buf_msg(skb);
		imp = msg_importance(hdr);
		l->backlog[imp].len--;
		अगर (unlikely(skb == l->backlog[imp].target_bskb))
			l->backlog[imp].target_bskb = शून्य;
		__skb_queue_tail(&l->transmq, skb);
		tipc_link_set_skb_retransmit_समय(skb, l);

		__skb_queue_tail(xmitq, _skb);
		TIPC_SKB_CB(skb)->ackers = l->ackers;
		msg_set_seqno(hdr, seqno);
		msg_set_ack(hdr, ack);
		msg_set_bcast_ack(hdr, bc_ack);
		l->rcv_unacked = 0;
		l->stats.sent_pkts++;
		seqno++;
	पूर्ण
	l->snd_nxt = seqno;
पूर्ण

/**
 * link_retransmit_failure() - Detect repeated retransmit failures
 * @l: tipc link sender
 * @r: tipc link receiver (= l in हाल of unicast)
 * @rc: वापसed code
 *
 * Return: true अगर the repeated retransmit failures happens, otherwise
 * false
 */
अटल bool link_retransmit_failure(काष्ठा tipc_link *l, काष्ठा tipc_link *r,
				    पूर्णांक *rc)
अणु
	काष्ठा sk_buff *skb = skb_peek(&l->transmq);
	काष्ठा tipc_msg *hdr;

	अगर (!skb)
		वापस false;

	अगर (!TIPC_SKB_CB(skb)->retr_cnt)
		वापस false;

	अगर (!समय_after(jअगरfies, TIPC_SKB_CB(skb)->retr_stamp +
			msecs_to_jअगरfies(r->tolerance * 10)))
		वापस false;

	hdr = buf_msg(skb);
	अगर (link_is_bc_sndlink(l) && !less(r->acked, msg_seqno(hdr)))
		वापस false;

	pr_warn("Retransmission failure on link <%s>\n", l->name);
	link_prपूर्णांक(l, "State of link ");
	pr_info("Failed msg: usr %u, typ %u, len %u, err %u\n",
		msg_user(hdr), msg_type(hdr), msg_size(hdr), msg_errcode(hdr));
	pr_info("sqno %u, prev: %x, dest: %x\n",
		msg_seqno(hdr), msg_prevnode(hdr), msg_destnode(hdr));
	pr_info("retr_stamp %d, retr_cnt %d\n",
		jअगरfies_to_msecs(TIPC_SKB_CB(skb)->retr_stamp),
		TIPC_SKB_CB(skb)->retr_cnt);

	trace_tipc_list_dump(&l->transmq, true, "retrans failure!");
	trace_tipc_link_dump(l, TIPC_DUMP_NONE, "retrans failure!");
	trace_tipc_link_dump(r, TIPC_DUMP_NONE, "retrans failure!");

	अगर (link_is_bc_sndlink(l)) अणु
		r->state = LINK_RESET;
		*rc |= TIPC_LINK_DOWN_EVT;
	पूर्ण अन्यथा अणु
		*rc |= tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
	पूर्ण

	वापस true;
पूर्ण

/* tipc_data_input - deliver data and name distr msgs to upper layer
 *
 * Consumes buffer अगर message is of right type
 * Node lock must be held
 */
अटल bool tipc_data_input(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			    काष्ठा sk_buff_head *inputq)
अणु
	काष्ठा sk_buff_head *mc_inputq = l->bc_rcvlink->inputq;
	काष्ठा tipc_msg *hdr = buf_msg(skb);

	चयन (msg_user(hdr)) अणु
	हाल TIPC_LOW_IMPORTANCE:
	हाल TIPC_MEDIUM_IMPORTANCE:
	हाल TIPC_HIGH_IMPORTANCE:
	हाल TIPC_CRITICAL_IMPORTANCE:
		अगर (unlikely(msg_in_group(hdr) || msg_mcast(hdr))) अणु
			skb_queue_tail(mc_inputq, skb);
			वापस true;
		पूर्ण
		fallthrough;
	हाल CONN_MANAGER:
		skb_queue_tail(inputq, skb);
		वापस true;
	हाल GROUP_PROTOCOL:
		skb_queue_tail(mc_inputq, skb);
		वापस true;
	हाल NAME_DISTRIBUTOR:
		l->bc_rcvlink->state = LINK_ESTABLISHED;
		skb_queue_tail(l->namedq, skb);
		वापस true;
	हाल MSG_BUNDLER:
	हाल TUNNEL_PROTOCOL:
	हाल MSG_FRAGMENTER:
	हाल BCAST_PROTOCOL:
		वापस false;
#अगर_घोषित CONFIG_TIPC_CRYPTO
	हाल MSG_CRYPTO:
		tipc_crypto_msg_rcv(l->net, skb);
		वापस true;
#पूर्ण_अगर
	शेष:
		pr_warn("Dropping received illegal msg type\n");
		kमुक्त_skb(skb);
		वापस true;
	पूर्ण
पूर्ण

/* tipc_link_input - process packet that has passed link protocol check
 *
 * Consumes buffer
 */
अटल पूर्णांक tipc_link_input(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			   काष्ठा sk_buff_head *inputq,
			   काष्ठा sk_buff **reयंत्र_skb)
अणु
	काष्ठा tipc_msg *hdr = buf_msg(skb);
	काष्ठा sk_buff *iskb;
	काष्ठा sk_buff_head पंचांगpq;
	पूर्णांक usr = msg_user(hdr);
	पूर्णांक pos = 0;

	अगर (usr == MSG_BUNDLER) अणु
		skb_queue_head_init(&पंचांगpq);
		l->stats.recv_bundles++;
		l->stats.recv_bundled += msg_msgcnt(hdr);
		जबतक (tipc_msg_extract(skb, &iskb, &pos))
			tipc_data_input(l, iskb, &पंचांगpq);
		tipc_skb_queue_splice_tail(&पंचांगpq, inputq);
		वापस 0;
	पूर्ण अन्यथा अगर (usr == MSG_FRAGMENTER) अणु
		l->stats.recv_fragments++;
		अगर (tipc_buf_append(reयंत्र_skb, &skb)) अणु
			l->stats.recv_fragmented++;
			tipc_data_input(l, skb, inputq);
		पूर्ण अन्यथा अगर (!*reयंत्र_skb && !link_is_bc_rcvlink(l)) अणु
			pr_warn_ratelimited("Unable to build fragment list\n");
			वापस tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
		पूर्ण
		वापस 0;
	पूर्ण अन्यथा अगर (usr == BCAST_PROTOCOL) अणु
		tipc_bcast_lock(l->net);
		tipc_link_bc_init_rcv(l->bc_rcvlink, hdr);
		tipc_bcast_unlock(l->net);
	पूर्ण

	kमुक्त_skb(skb);
	वापस 0;
पूर्ण

/* tipc_link_tnl_rcv() - receive TUNNEL_PROTOCOL message, drop or process the
 *			 inner message aदीर्घ with the ones in the old link's
 *			 deferdq
 * @l: tunnel link
 * @skb: TUNNEL_PROTOCOL message
 * @inputq: queue to put messages पढ़ोy क्रम delivery
 */
अटल पूर्णांक tipc_link_tnl_rcv(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			     काष्ठा sk_buff_head *inputq)
अणु
	काष्ठा sk_buff **reयंत्र_skb = &l->failover_reयंत्र_skb;
	काष्ठा sk_buff **reयंत्र_tnlmsg = &l->reयंत्र_tnlmsg;
	काष्ठा sk_buff_head *fdefq = &l->failover_deferdq;
	काष्ठा tipc_msg *hdr = buf_msg(skb);
	काष्ठा sk_buff *iskb;
	पूर्णांक ipos = 0;
	पूर्णांक rc = 0;
	u16 seqno;

	अगर (msg_type(hdr) == SYNCH_MSG) अणु
		kमुक्त_skb(skb);
		वापस 0;
	पूर्ण

	/* Not a fragment? */
	अगर (likely(!msg_nof_fragms(hdr))) अणु
		अगर (unlikely(!tipc_msg_extract(skb, &iskb, &ipos))) अणु
			pr_warn_ratelimited("Unable to extract msg, defq: %d\n",
					    skb_queue_len(fdefq));
			वापस 0;
		पूर्ण
		kमुक्त_skb(skb);
	पूर्ण अन्यथा अणु
		/* Set fragment type क्रम buf_append */
		अगर (msg_fragm_no(hdr) == 1)
			msg_set_type(hdr, FIRST_FRAGMENT);
		अन्यथा अगर (msg_fragm_no(hdr) < msg_nof_fragms(hdr))
			msg_set_type(hdr, FRAGMENT);
		अन्यथा
			msg_set_type(hdr, LAST_FRAGMENT);

		अगर (!tipc_buf_append(reयंत्र_tnlmsg, &skb)) अणु
			/* Successful but non-complete reassembly? */
			अगर (*reयंत्र_tnlmsg || link_is_bc_rcvlink(l))
				वापस 0;
			pr_warn_ratelimited("Unable to reassemble tunnel msg\n");
			वापस tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
		पूर्ण
		iskb = skb;
	पूर्ण

	करो अणु
		seqno = buf_seqno(iskb);
		अगर (unlikely(less(seqno, l->drop_poपूर्णांक))) अणु
			kमुक्त_skb(iskb);
			जारी;
		पूर्ण
		अगर (unlikely(seqno != l->drop_poपूर्णांक)) अणु
			__tipc_skb_queue_sorted(fdefq, seqno, iskb);
			जारी;
		पूर्ण

		l->drop_poपूर्णांक++;
		अगर (!tipc_data_input(l, iskb, inputq))
			rc |= tipc_link_input(l, iskb, inputq, reयंत्र_skb);
		अगर (unlikely(rc))
			अवरोध;
	पूर्ण जबतक ((iskb = __tipc_skb_dequeue(fdefq, l->drop_poपूर्णांक)));

	वापस rc;
पूर्ण

/**
 * tipc_get_gap_ack_blks - get Gap ACK blocks from PROTOCOL/STATE_MSG
 * @ga: वापसed poपूर्णांकer to the Gap ACK blocks अगर any
 * @l: the tipc link
 * @hdr: the PROTOCOL/STATE_MSG header
 * @uc: desired Gap ACK blocks type, i.e. unicast (= 1) or broadcast (= 0)
 *
 * Return: the total Gap ACK blocks size
 */
u16 tipc_get_gap_ack_blks(काष्ठा tipc_gap_ack_blks **ga, काष्ठा tipc_link *l,
			  काष्ठा tipc_msg *hdr, bool uc)
अणु
	काष्ठा tipc_gap_ack_blks *p;
	u16 sz = 0;

	/* Does peer support the Gap ACK blocks feature? */
	अगर (l->peer_caps & TIPC_GAP_ACK_BLOCK) अणु
		p = (काष्ठा tipc_gap_ack_blks *)msg_data(hdr);
		sz = ntohs(p->len);
		/* Sanity check */
		अगर (sz == काष्ठा_size(p, gacks, p->ugack_cnt + p->bgack_cnt)) अणु
			/* Good, check अगर the desired type exists */
			अगर ((uc && p->ugack_cnt) || (!uc && p->bgack_cnt))
				जाओ ok;
		/* Backward compatible: peer might not support bc, but uc? */
		पूर्ण अन्यथा अगर (uc && sz == काष्ठा_size(p, gacks, p->ugack_cnt)) अणु
			अगर (p->ugack_cnt) अणु
				p->bgack_cnt = 0;
				जाओ ok;
			पूर्ण
		पूर्ण
	पूर्ण
	/* Other हालs: ignore! */
	p = शून्य;

ok:
	*ga = p;
	वापस sz;
पूर्ण

अटल u8 __tipc_build_gap_ack_blks(काष्ठा tipc_gap_ack_blks *ga,
				    काष्ठा tipc_link *l, u8 start_index)
अणु
	काष्ठा tipc_gap_ack *gacks = &ga->gacks[start_index];
	काष्ठा sk_buff *skb = skb_peek(&l->deferdq);
	u16 expect, seqno = 0;
	u8 n = 0;

	अगर (!skb)
		वापस 0;

	expect = buf_seqno(skb);
	skb_queue_walk(&l->deferdq, skb) अणु
		seqno = buf_seqno(skb);
		अगर (unlikely(more(seqno, expect))) अणु
			gacks[n].ack = htons(expect - 1);
			gacks[n].gap = htons(seqno - expect);
			अगर (++n >= MAX_GAP_ACK_BLKS / 2) अणु
				pr_info_ratelimited("Gacks on %s: %d, ql: %d!\n",
						    l->name, n,
						    skb_queue_len(&l->deferdq));
				वापस n;
			पूर्ण
		पूर्ण अन्यथा अगर (unlikely(less(seqno, expect))) अणु
			pr_warn("Unexpected skb in deferdq!\n");
			जारी;
		पूर्ण
		expect = seqno + 1;
	पूर्ण

	/* last block */
	gacks[n].ack = htons(seqno);
	gacks[n].gap = 0;
	n++;
	वापस n;
पूर्ण

/* tipc_build_gap_ack_blks - build Gap ACK blocks
 * @l: tipc unicast link
 * @hdr: the tipc message buffer to store the Gap ACK blocks after built
 *
 * The function builds Gap ACK blocks क्रम both the unicast & broadcast receiver
 * links of a certain peer, the buffer after built has the network data क्रमmat
 * as found at the काष्ठा tipc_gap_ack_blks definition.
 *
 * वापसs the actual allocated memory size
 */
अटल u16 tipc_build_gap_ack_blks(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr)
अणु
	काष्ठा tipc_link *bcl = l->bc_rcvlink;
	काष्ठा tipc_gap_ack_blks *ga;
	u16 len;

	ga = (काष्ठा tipc_gap_ack_blks *)msg_data(hdr);

	/* Start with broadcast link first */
	tipc_bcast_lock(bcl->net);
	msg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);
	msg_set_bc_gap(hdr, link_bc_rcv_gap(bcl));
	ga->bgack_cnt = __tipc_build_gap_ack_blks(ga, bcl, 0);
	tipc_bcast_unlock(bcl->net);

	/* Now क्रम unicast link, but an explicit NACK only (???) */
	ga->ugack_cnt = (msg_seq_gap(hdr)) ?
			__tipc_build_gap_ack_blks(ga, l, ga->bgack_cnt) : 0;

	/* Total len */
	len = काष्ठा_size(ga, gacks, ga->bgack_cnt + ga->ugack_cnt);
	ga->len = htons(len);
	वापस len;
पूर्ण

/* tipc_link_advance_transmq - advance TIPC link transmq queue by releasing
 *			       acked packets, also करोing retransmissions अगर
 *			       gaps found
 * @l: tipc link with transmq queue to be advanced
 * @r: tipc link "receiver" i.e. in हाल of broadcast (= "l" अगर unicast)
 * @acked: seqno of last packet acked by peer without any gaps beक्रमe
 * @gap: # of gap packets
 * @ga: buffer poपूर्णांकer to Gap ACK blocks from peer
 * @xmitq: queue क्रम accumulating the retransmitted packets अगर any
 * @retransmitted: वापसed boolean value अगर a retransmission is really issued
 * @rc: वापसed code e.g. TIPC_LINK_DOWN_EVT अगर a repeated retransmit failures
 *      happens (- unlikely हाल)
 *
 * Return: the number of packets released from the link transmq
 */
अटल पूर्णांक tipc_link_advance_transmq(काष्ठा tipc_link *l, काष्ठा tipc_link *r,
				     u16 acked, u16 gap,
				     काष्ठा tipc_gap_ack_blks *ga,
				     काष्ठा sk_buff_head *xmitq,
				     bool *retransmitted, पूर्णांक *rc)
अणु
	काष्ठा tipc_gap_ack_blks *last_ga = r->last_ga, *this_ga = शून्य;
	काष्ठा tipc_gap_ack *gacks = शून्य;
	काष्ठा sk_buff *skb, *_skb, *पंचांगp;
	काष्ठा tipc_msg *hdr;
	u32 qlen = skb_queue_len(&l->transmq);
	u16 nacked = acked, ngap = gap, gack_cnt = 0;
	u16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;
	u16 ack = l->rcv_nxt - 1;
	u16 seqno, n = 0;
	u16 end = r->acked, start = end, offset = r->last_gap;
	u16 si = (last_ga) ? last_ga->start_index : 0;
	bool is_uc = !link_is_bc_sndlink(l);
	bool bc_has_acked = false;

	trace_tipc_link_retrans(r, acked + 1, acked + gap, &l->transmq);

	/* Determine Gap ACK blocks अगर any क्रम the particular link */
	अगर (ga && is_uc) अणु
		/* Get the Gap ACKs, uc part */
		gack_cnt = ga->ugack_cnt;
		gacks = &ga->gacks[ga->bgack_cnt];
	पूर्ण अन्यथा अगर (ga) अणु
		/* Copy the Gap ACKs, bc part, क्रम later renewal अगर needed */
		this_ga = kmemdup(ga, काष्ठा_size(ga, gacks, ga->bgack_cnt),
				  GFP_ATOMIC);
		अगर (likely(this_ga)) अणु
			this_ga->start_index = 0;
			/* Start with the bc Gap ACKs */
			gack_cnt = this_ga->bgack_cnt;
			gacks = &this_ga->gacks[0];
		पूर्ण अन्यथा अणु
			/* Hmm, we can get in trouble..., simply ignore it */
			pr_warn_ratelimited("Ignoring bc Gap ACKs, no memory\n");
		पूर्ण
	पूर्ण

	/* Advance the link transmq */
	skb_queue_walk_safe(&l->transmq, skb, पंचांगp) अणु
		seqno = buf_seqno(skb);

next_gap_ack:
		अगर (less_eq(seqno, nacked)) अणु
			अगर (is_uc)
				जाओ release;
			/* Skip packets peer has alपढ़ोy acked */
			अगर (!more(seqno, r->acked))
				जारी;
			/* Get the next of last Gap ACK blocks */
			जबतक (more(seqno, end)) अणु
				अगर (!last_ga || si >= last_ga->bgack_cnt)
					अवरोध;
				start = end + offset + 1;
				end = ntohs(last_ga->gacks[si].ack);
				offset = ntohs(last_ga->gacks[si].gap);
				si++;
				WARN_ONCE(more(start, end) ||
					  (!offset &&
					   si < last_ga->bgack_cnt) ||
					  si > MAX_GAP_ACK_BLKS,
					  "Corrupted Gap ACK: %d %d %d %d %d\n",
					  start, end, offset, si,
					  last_ga->bgack_cnt);
			पूर्ण
			/* Check against the last Gap ACK block */
			अगर (in_range(seqno, start, end))
				जारी;
			/* Update/release the packet peer is acking */
			bc_has_acked = true;
			अगर (--TIPC_SKB_CB(skb)->ackers)
				जारी;
release:
			/* release skb */
			__skb_unlink(skb, &l->transmq);
			kमुक्त_skb(skb);
		पूर्ण अन्यथा अगर (less_eq(seqno, nacked + ngap)) अणु
			/* First gap: check अगर repeated retrans failures? */
			अगर (unlikely(seqno == acked + 1 &&
				     link_retransmit_failure(l, r, rc))) अणु
				/* Ignore this bc Gap ACKs अगर any */
				kमुक्त(this_ga);
				this_ga = शून्य;
				अवरोध;
			पूर्ण
			/* retransmit skb अगर unrestricted*/
			अगर (समय_beक्रमe(jअगरfies, TIPC_SKB_CB(skb)->nxt_retr))
				जारी;
			tipc_link_set_skb_retransmit_समय(skb, l);
			_skb = pskb_copy(skb, GFP_ATOMIC);
			अगर (!_skb)
				जारी;
			hdr = buf_msg(_skb);
			msg_set_ack(hdr, ack);
			msg_set_bcast_ack(hdr, bc_ack);
			_skb->priority = TC_PRIO_CONTROL;
			__skb_queue_tail(xmitq, _skb);
			l->stats.retransmitted++;
			अगर (!is_uc)
				r->stats.retransmitted++;
			*retransmitted = true;
			/* Increase actual retrans counter & mark first समय */
			अगर (!TIPC_SKB_CB(skb)->retr_cnt++)
				TIPC_SKB_CB(skb)->retr_stamp = jअगरfies;
		पूर्ण अन्यथा अणु
			/* retry with Gap ACK blocks अगर any */
			अगर (n >= gack_cnt)
				अवरोध;
			nacked = ntohs(gacks[n].ack);
			ngap = ntohs(gacks[n].gap);
			n++;
			जाओ next_gap_ack;
		पूर्ण
	पूर्ण

	/* Renew last Gap ACK blocks क्रम bc अगर needed */
	अगर (bc_has_acked) अणु
		अगर (this_ga) अणु
			kमुक्त(last_ga);
			r->last_ga = this_ga;
			r->last_gap = gap;
		पूर्ण अन्यथा अगर (last_ga) अणु
			अगर (less(acked, start)) अणु
				si--;
				offset = start - acked - 1;
			पूर्ण अन्यथा अगर (less(acked, end)) अणु
				acked = end;
			पूर्ण
			अगर (si < last_ga->bgack_cnt) अणु
				last_ga->start_index = si;
				r->last_gap = offset;
			पूर्ण अन्यथा अणु
				kमुक्त(last_ga);
				r->last_ga = शून्य;
				r->last_gap = 0;
			पूर्ण
		पूर्ण अन्यथा अणु
			r->last_gap = 0;
		पूर्ण
		r->acked = acked;
	पूर्ण अन्यथा अणु
		kमुक्त(this_ga);
	पूर्ण

	वापस qlen - skb_queue_len(&l->transmq);
पूर्ण

/* tipc_link_build_state_msg: prepare link state message क्रम transmission
 *
 * Note that sending of broadcast ack is coordinated among nodes, to reduce
 * risk of ack storms towards the sender
 */
पूर्णांक tipc_link_build_state_msg(काष्ठा tipc_link *l, काष्ठा sk_buff_head *xmitq)
अणु
	अगर (!l)
		वापस 0;

	/* Broadcast ACK must be sent via a unicast link => defer to caller */
	अगर (link_is_bc_rcvlink(l)) अणु
		अगर (((l->rcv_nxt ^ tipc_own_addr(l->net)) & 0xf) != 0xf)
			वापस 0;
		l->rcv_unacked = 0;

		/* Use snd_nxt to store peer's snd_nxt in broadcast rcv link */
		l->snd_nxt = l->rcv_nxt;
		वापस TIPC_LINK_SND_STATE;
	पूर्ण
	/* Unicast ACK */
	l->rcv_unacked = 0;
	l->stats.sent_acks++;
	tipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, 0, xmitq);
	वापस 0;
पूर्ण

/* tipc_link_build_reset_msg: prepare link RESET or ACTIVATE message
 */
व्योम tipc_link_build_reset_msg(काष्ठा tipc_link *l, काष्ठा sk_buff_head *xmitq)
अणु
	पूर्णांक mtyp = RESET_MSG;
	काष्ठा sk_buff *skb;

	अगर (l->state == LINK_ESTABLISHING)
		mtyp = ACTIVATE_MSG;

	tipc_link_build_proto_msg(l, mtyp, 0, 0, 0, 0, 0, xmitq);

	/* Inक्रमm peer that this endpoपूर्णांक is going करोwn अगर applicable */
	skb = skb_peek_tail(xmitq);
	अगर (skb && (l->state == LINK_RESET))
		msg_set_peer_stopping(buf_msg(skb), 1);
पूर्ण

/* tipc_link_build_nack_msg: prepare link nack message क्रम transmission
 * Note that sending of broadcast NACK is coordinated among nodes, to
 * reduce the risk of NACK storms towards the sender
 */
अटल पूर्णांक tipc_link_build_nack_msg(काष्ठा tipc_link *l,
				    काष्ठा sk_buff_head *xmitq)
अणु
	u32 def_cnt = ++l->stats.deferred_recv;
	काष्ठा sk_buff_head *dfq = &l->deferdq;
	u32 defq_len = skb_queue_len(dfq);
	पूर्णांक match1, match2;

	अगर (link_is_bc_rcvlink(l)) अणु
		match1 = def_cnt & 0xf;
		match2 = tipc_own_addr(l->net) & 0xf;
		अगर (match1 == match2)
			वापस TIPC_LINK_SND_STATE;
		वापस 0;
	पूर्ण

	अगर (defq_len >= 3 && !((defq_len - 3) % 16)) अणु
		u16 rcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;

		tipc_link_build_proto_msg(l, STATE_MSG, 0, 0,
					  rcvgap, 0, 0, xmitq);
	पूर्ण
	वापस 0;
पूर्ण

/* tipc_link_rcv - process TIPC packets/messages arriving from off-node
 * @l: the link that should handle the message
 * @skb: TIPC packet
 * @xmitq: queue to place packets to be sent after this call
 */
पूर्णांक tipc_link_rcv(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
		  काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff_head *defq = &l->deferdq;
	काष्ठा tipc_msg *hdr = buf_msg(skb);
	u16 seqno, rcv_nxt, win_lim;
	पूर्णांक released = 0;
	पूर्णांक rc = 0;

	/* Verअगरy and update link state */
	अगर (unlikely(msg_user(hdr) == LINK_PROTOCOL))
		वापस tipc_link_proto_rcv(l, skb, xmitq);

	/* Don't send probe at next समयout expiration */
	l->silent_पूर्णांकv_cnt = 0;

	करो अणु
		hdr = buf_msg(skb);
		seqno = msg_seqno(hdr);
		rcv_nxt = l->rcv_nxt;
		win_lim = rcv_nxt + TIPC_MAX_LINK_WIN;

		अगर (unlikely(!link_is_up(l))) अणु
			अगर (l->state == LINK_ESTABLISHING)
				rc = TIPC_LINK_UP_EVT;
			kमुक्त_skb(skb);
			अवरोध;
		पूर्ण

		/* Drop अगर outside receive winकरोw */
		अगर (unlikely(less(seqno, rcv_nxt) || more(seqno, win_lim))) अणु
			l->stats.duplicates++;
			kमुक्त_skb(skb);
			अवरोध;
		पूर्ण
		released += tipc_link_advance_transmq(l, l, msg_ack(hdr), 0,
						      शून्य, शून्य, शून्य, शून्य);

		/* Defer delivery अगर sequence gap */
		अगर (unlikely(seqno != rcv_nxt)) अणु
			अगर (!__tipc_skb_queue_sorted(defq, seqno, skb))
				l->stats.duplicates++;
			rc |= tipc_link_build_nack_msg(l, xmitq);
			अवरोध;
		पूर्ण

		/* Deliver packet */
		l->rcv_nxt++;
		l->stats.recv_pkts++;

		अगर (unlikely(msg_user(hdr) == TUNNEL_PROTOCOL))
			rc |= tipc_link_tnl_rcv(l, skb, l->inputq);
		अन्यथा अगर (!tipc_data_input(l, skb, l->inputq))
			rc |= tipc_link_input(l, skb, l->inputq, &l->reयंत्र_buf);
		अगर (unlikely(++l->rcv_unacked >= TIPC_MIN_LINK_WIN))
			rc |= tipc_link_build_state_msg(l, xmitq);
		अगर (unlikely(rc & ~TIPC_LINK_SND_STATE))
			अवरोध;
	पूर्ण जबतक ((skb = __tipc_skb_dequeue(defq, l->rcv_nxt)));

	/* Forward queues and wake up रुकोing users */
	अगर (released) अणु
		tipc_link_update_cwin(l, released, 0);
		tipc_link_advance_backlog(l, xmitq);
		अगर (unlikely(!skb_queue_empty(&l->wakeupq)))
			link_prepare_wakeup(l);
	पूर्ण
	वापस rc;
पूर्ण

अटल व्योम tipc_link_build_proto_msg(काष्ठा tipc_link *l, पूर्णांक mtyp, bool probe,
				      bool probe_reply, u16 rcvgap,
				      पूर्णांक tolerance, पूर्णांक priority,
				      काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा tipc_mon_state *mstate = &l->mon_state;
	काष्ठा sk_buff_head *dfq = &l->deferdq;
	काष्ठा tipc_link *bcl = l->bc_rcvlink;
	काष्ठा tipc_msg *hdr;
	काष्ठा sk_buff *skb;
	bool node_up = link_is_up(bcl);
	u16 glen = 0, bc_rcvgap = 0;
	पूर्णांक dlen = 0;
	व्योम *data;

	/* Don't send protocol message during reset or link failover */
	अगर (tipc_link_is_blocked(l))
		वापस;

	अगर (!tipc_link_is_up(l) && (mtyp == STATE_MSG))
		वापस;

	अगर ((probe || probe_reply) && !skb_queue_empty(dfq))
		rcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;

	skb = tipc_msg_create(LINK_PROTOCOL, mtyp, INT_H_SIZE,
			      tipc_max_करोमुख्य_size + MAX_GAP_ACK_BLKS_SZ,
			      l->addr, tipc_own_addr(l->net), 0, 0, 0);
	अगर (!skb)
		वापस;

	hdr = buf_msg(skb);
	data = msg_data(hdr);
	msg_set_session(hdr, l->session);
	msg_set_bearer_id(hdr, l->bearer_id);
	msg_set_net_plane(hdr, l->net_plane);
	msg_set_next_sent(hdr, l->snd_nxt);
	msg_set_ack(hdr, l->rcv_nxt - 1);
	msg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);
	msg_set_bc_ack_invalid(hdr, !node_up);
	msg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);
	msg_set_link_tolerance(hdr, tolerance);
	msg_set_linkprio(hdr, priority);
	msg_set_redundant_link(hdr, node_up);
	msg_set_seq_gap(hdr, 0);
	msg_set_seqno(hdr, l->snd_nxt + U16_MAX / 2);

	अगर (mtyp == STATE_MSG) अणु
		अगर (l->peer_caps & TIPC_LINK_PROTO_SEQNO)
			msg_set_seqno(hdr, l->snd_nxt_state++);
		msg_set_seq_gap(hdr, rcvgap);
		bc_rcvgap = link_bc_rcv_gap(bcl);
		msg_set_bc_gap(hdr, bc_rcvgap);
		msg_set_probe(hdr, probe);
		msg_set_is_keepalive(hdr, probe || probe_reply);
		अगर (l->peer_caps & TIPC_GAP_ACK_BLOCK)
			glen = tipc_build_gap_ack_blks(l, hdr);
		tipc_mon_prep(l->net, data + glen, &dlen, mstate, l->bearer_id);
		msg_set_size(hdr, INT_H_SIZE + glen + dlen);
		skb_trim(skb, INT_H_SIZE + glen + dlen);
		l->stats.sent_states++;
		l->rcv_unacked = 0;
	पूर्ण अन्यथा अणु
		/* RESET_MSG or ACTIVATE_MSG */
		अगर (mtyp == ACTIVATE_MSG) अणु
			msg_set_dest_session_valid(hdr, 1);
			msg_set_dest_session(hdr, l->peer_session);
		पूर्ण
		msg_set_max_pkt(hdr, l->advertised_mtu);
		म_नकल(data, l->अगर_name);
		msg_set_size(hdr, INT_H_SIZE + TIPC_MAX_IF_NAME);
		skb_trim(skb, INT_H_SIZE + TIPC_MAX_IF_NAME);
	पूर्ण
	अगर (probe)
		l->stats.sent_probes++;
	अगर (rcvgap)
		l->stats.sent_nacks++;
	अगर (bc_rcvgap)
		bcl->stats.sent_nacks++;
	skb->priority = TC_PRIO_CONTROL;
	__skb_queue_tail(xmitq, skb);
	trace_tipc_proto_build(skb, false, l->name);
पूर्ण

व्योम tipc_link_create_dummy_tnl_msg(काष्ठा tipc_link *l,
				    काष्ठा sk_buff_head *xmitq)
अणु
	u32 onode = tipc_own_addr(l->net);
	काष्ठा tipc_msg *hdr, *ihdr;
	काष्ठा sk_buff_head tnlq;
	काष्ठा sk_buff *skb;
	u32 dnode = l->addr;

	__skb_queue_head_init(&tnlq);
	skb = tipc_msg_create(TUNNEL_PROTOCOL, FAILOVER_MSG,
			      INT_H_SIZE, BASIC_H_SIZE,
			      dnode, onode, 0, 0, 0);
	अगर (!skb) अणु
		pr_warn("%sunable to create tunnel packet\n", link_co_err);
		वापस;
	पूर्ण

	hdr = buf_msg(skb);
	msg_set_msgcnt(hdr, 1);
	msg_set_bearer_id(hdr, l->peer_bearer_id);

	ihdr = (काष्ठा tipc_msg *)msg_data(hdr);
	tipc_msg_init(onode, ihdr, TIPC_LOW_IMPORTANCE, TIPC_सूचीECT_MSG,
		      BASIC_H_SIZE, dnode);
	msg_set_errcode(ihdr, TIPC_ERR_NO_PORT);
	__skb_queue_tail(&tnlq, skb);
	tipc_link_xmit(l, &tnlq, xmitq);
पूर्ण

/* tipc_link_tnl_prepare(): prepare and वापस a list of tunnel packets
 * with contents of the link's transmit and backlog queues.
 */
व्योम tipc_link_tnl_prepare(काष्ठा tipc_link *l, काष्ठा tipc_link *tnl,
			   पूर्णांक mtyp, काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff_head *fdefq = &tnl->failover_deferdq;
	काष्ठा sk_buff *skb, *tnlskb;
	काष्ठा tipc_msg *hdr, tnlhdr;
	काष्ठा sk_buff_head *queue = &l->transmq;
	काष्ठा sk_buff_head पंचांगpxq, tnlq, frags;
	u16 pktlen, pktcnt, seqno = l->snd_nxt;
	bool pktcnt_need_update = false;
	u16 syncpt;
	पूर्णांक rc;

	अगर (!tnl)
		वापस;

	__skb_queue_head_init(&tnlq);
	/* Link Synching:
	 * From now on, send only one single ("dummy") SYNCH message
	 * to peer. The SYNCH message करोes not contain any data, just
	 * a header conveying the synch poपूर्णांक to the peer.
	 */
	अगर (mtyp == SYNCH_MSG && (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) अणु
		tnlskb = tipc_msg_create(TUNNEL_PROTOCOL, SYNCH_MSG,
					 INT_H_SIZE, 0, l->addr,
					 tipc_own_addr(l->net),
					 0, 0, 0);
		अगर (!tnlskb) अणु
			pr_warn("%sunable to create dummy SYNCH_MSG\n",
				link_co_err);
			वापस;
		पूर्ण

		hdr = buf_msg(tnlskb);
		syncpt = l->snd_nxt + skb_queue_len(&l->backlogq) - 1;
		msg_set_syncpt(hdr, syncpt);
		msg_set_bearer_id(hdr, l->peer_bearer_id);
		__skb_queue_tail(&tnlq, tnlskb);
		tipc_link_xmit(tnl, &tnlq, xmitq);
		वापस;
	पूर्ण

	__skb_queue_head_init(&पंचांगpxq);
	__skb_queue_head_init(&frags);
	/* At least one packet required क्रम safe algorithm => add dummy */
	skb = tipc_msg_create(TIPC_LOW_IMPORTANCE, TIPC_सूचीECT_MSG,
			      BASIC_H_SIZE, 0, l->addr, tipc_own_addr(l->net),
			      0, 0, TIPC_ERR_NO_PORT);
	अगर (!skb) अणु
		pr_warn("%sunable to create tunnel packet\n", link_co_err);
		वापस;
	पूर्ण
	__skb_queue_tail(&tnlq, skb);
	tipc_link_xmit(l, &tnlq, &पंचांगpxq);
	__skb_queue_purge(&पंचांगpxq);

	/* Initialize reusable tunnel packet header */
	tipc_msg_init(tipc_own_addr(l->net), &tnlhdr, TUNNEL_PROTOCOL,
		      mtyp, INT_H_SIZE, l->addr);
	अगर (mtyp == SYNCH_MSG)
		pktcnt = l->snd_nxt - buf_seqno(skb_peek(&l->transmq));
	अन्यथा
		pktcnt = skb_queue_len(&l->transmq);
	pktcnt += skb_queue_len(&l->backlogq);
	msg_set_msgcnt(&tnlhdr, pktcnt);
	msg_set_bearer_id(&tnlhdr, l->peer_bearer_id);
tnl:
	/* Wrap each packet पूर्णांकo a tunnel packet */
	skb_queue_walk(queue, skb) अणु
		hdr = buf_msg(skb);
		अगर (queue == &l->backlogq)
			msg_set_seqno(hdr, seqno++);
		pktlen = msg_size(hdr);

		/* Tunnel link MTU is not large enough? This could be
		 * due to:
		 * 1) Link MTU has just changed or set dअगरferently;
		 * 2) Or FAILOVER on the top of a SYNCH message
		 *
		 * The 2nd हाल should not happen अगर peer supports
		 * TIPC_TUNNEL_ENHANCED
		 */
		अगर (pktlen > tnl->mtu - INT_H_SIZE) अणु
			अगर (mtyp == FAILOVER_MSG &&
			    (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) अणु
				rc = tipc_msg_fragment(skb, &tnlhdr, tnl->mtu,
						       &frags);
				अगर (rc) अणु
					pr_warn("%sunable to frag msg: rc %d\n",
						link_co_err, rc);
					वापस;
				पूर्ण
				pktcnt += skb_queue_len(&frags) - 1;
				pktcnt_need_update = true;
				skb_queue_splice_tail_init(&frags, &tnlq);
				जारी;
			पूर्ण
			/* Unluckily, peer करोesn't have TIPC_TUNNEL_ENHANCED
			 * => Just warn it and वापस!
			 */
			pr_warn_ratelimited("%stoo large msg <%d, %d>: %d!\n",
					    link_co_err, msg_user(hdr),
					    msg_type(hdr), msg_size(hdr));
			वापस;
		पूर्ण

		msg_set_size(&tnlhdr, pktlen + INT_H_SIZE);
		tnlskb = tipc_buf_acquire(pktlen + INT_H_SIZE, GFP_ATOMIC);
		अगर (!tnlskb) अणु
			pr_warn("%sunable to send packet\n", link_co_err);
			वापस;
		पूर्ण
		skb_copy_to_linear_data(tnlskb, &tnlhdr, INT_H_SIZE);
		skb_copy_to_linear_data_offset(tnlskb, INT_H_SIZE, hdr, pktlen);
		__skb_queue_tail(&tnlq, tnlskb);
	पूर्ण
	अगर (queue != &l->backlogq) अणु
		queue = &l->backlogq;
		जाओ tnl;
	पूर्ण

	अगर (pktcnt_need_update)
		skb_queue_walk(&tnlq, skb) अणु
			hdr = buf_msg(skb);
			msg_set_msgcnt(hdr, pktcnt);
		पूर्ण

	tipc_link_xmit(tnl, &tnlq, xmitq);

	अगर (mtyp == FAILOVER_MSG) अणु
		tnl->drop_poपूर्णांक = l->rcv_nxt;
		tnl->failover_reयंत्र_skb = l->reयंत्र_buf;
		l->reयंत्र_buf = शून्य;

		/* Failover the link's deferdq */
		अगर (unlikely(!skb_queue_empty(fdefq))) अणु
			pr_warn("Link failover deferdq not empty: %d!\n",
				skb_queue_len(fdefq));
			__skb_queue_purge(fdefq);
		पूर्ण
		skb_queue_splice_init(&l->deferdq, fdefq);
	पूर्ण
पूर्ण

/**
 * tipc_link_failover_prepare() - prepare tnl क्रम link failover
 *
 * This is a special version of the precursor - tipc_link_tnl_prepare(),
 * see the tipc_node_link_failover() क्रम details
 *
 * @l: failover link
 * @tnl: tunnel link
 * @xmitq: queue क्रम messages to be xmited
 */
व्योम tipc_link_failover_prepare(काष्ठा tipc_link *l, काष्ठा tipc_link *tnl,
				काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff_head *fdefq = &tnl->failover_deferdq;

	tipc_link_create_dummy_tnl_msg(tnl, xmitq);

	/* This failover link endpoपूर्णांक was never established beक्रमe,
	 * so it has not received anything from peer.
	 * Otherwise, it must be a normal failover situation or the
	 * node has entered SELF_DOWN_PEER_LEAVING and both peer nodes
	 * would have to start over from scratch instead.
	 */
	tnl->drop_poपूर्णांक = 1;
	tnl->failover_reयंत्र_skb = शून्य;

	/* Initiate the link's failover deferdq */
	अगर (unlikely(!skb_queue_empty(fdefq))) अणु
		pr_warn("Link failover deferdq not empty: %d!\n",
			skb_queue_len(fdefq));
		__skb_queue_purge(fdefq);
	पूर्ण
पूर्ण

/* tipc_link_validate_msg(): validate message against current link state
 * Returns true अगर message should be accepted, otherwise false
 */
bool tipc_link_validate_msg(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr)
अणु
	u16 curr_session = l->peer_session;
	u16 session = msg_session(hdr);
	पूर्णांक mtyp = msg_type(hdr);

	अगर (msg_user(hdr) != LINK_PROTOCOL)
		वापस true;

	चयन (mtyp) अणु
	हाल RESET_MSG:
		अगर (!l->in_session)
			वापस true;
		/* Accept only RESET with new session number */
		वापस more(session, curr_session);
	हाल ACTIVATE_MSG:
		अगर (!l->in_session)
			वापस true;
		/* Accept only ACTIVATE with new or current session number */
		वापस !less(session, curr_session);
	हाल STATE_MSG:
		/* Accept only STATE with current session number */
		अगर (!l->in_session)
			वापस false;
		अगर (session != curr_session)
			वापस false;
		/* Extra sanity check */
		अगर (!link_is_up(l) && msg_ack(hdr))
			वापस false;
		अगर (!(l->peer_caps & TIPC_LINK_PROTO_SEQNO))
			वापस true;
		/* Accept only STATE with new sequence number */
		वापस !less(msg_seqno(hdr), l->rcv_nxt_state);
	शेष:
		वापस false;
	पूर्ण
पूर्ण

/* tipc_link_proto_rcv(): receive link level protocol message :
 * Note that network plane id propagates through the network, and may
 * change at any समय. The node with lowest numerical id determines
 * network plane
 */
अटल पूर्णांक tipc_link_proto_rcv(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			       काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा tipc_msg *hdr = buf_msg(skb);
	काष्ठा tipc_gap_ack_blks *ga = शून्य;
	bool reply = msg_probe(hdr), retransmitted = false;
	u16 dlen = msg_data_sz(hdr), glen = 0;
	u16 peers_snd_nxt =  msg_next_sent(hdr);
	u16 peers_tol = msg_link_tolerance(hdr);
	u16 peers_prio = msg_linkprio(hdr);
	u16 gap = msg_seq_gap(hdr);
	u16 ack = msg_ack(hdr);
	u16 rcv_nxt = l->rcv_nxt;
	u16 rcvgap = 0;
	पूर्णांक mtyp = msg_type(hdr);
	पूर्णांक rc = 0, released;
	अक्षर *अगर_name;
	व्योम *data;

	trace_tipc_proto_rcv(skb, false, l->name);
	अगर (tipc_link_is_blocked(l) || !xmitq)
		जाओ निकास;

	अगर (tipc_own_addr(l->net) > msg_prevnode(hdr))
		l->net_plane = msg_net_plane(hdr);

	skb_linearize(skb);
	hdr = buf_msg(skb);
	data = msg_data(hdr);

	अगर (!tipc_link_validate_msg(l, hdr)) अणु
		trace_tipc_skb_dump(skb, false, "PROTO invalid (1)!");
		trace_tipc_link_dump(l, TIPC_DUMP_NONE, "PROTO invalid (1)!");
		जाओ निकास;
	पूर्ण

	चयन (mtyp) अणु
	हाल RESET_MSG:
	हाल ACTIVATE_MSG:
		/* Complete own link name with peer's पूर्णांकerface name */
		अगर_name =  म_खोजप(l->name, ':') + 1;
		अगर (माप(l->name) - (अगर_name - l->name) <= TIPC_MAX_IF_NAME)
			अवरोध;
		अगर (msg_data_sz(hdr) < TIPC_MAX_IF_NAME)
			अवरोध;
		म_नकलन(अगर_name, data, TIPC_MAX_IF_NAME);

		/* Update own tolerance अगर peer indicates a non-zero value */
		अगर (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) अणु
			l->tolerance = peers_tol;
			l->bc_rcvlink->tolerance = peers_tol;
		पूर्ण
		/* Update own priority अगर peer's priority is higher */
		अगर (in_range(peers_prio, l->priority + 1, TIPC_MAX_LINK_PRI))
			l->priority = peers_prio;

		/* If peer is going करोwn we want full re-establish cycle */
		अगर (msg_peer_stopping(hdr)) अणु
			rc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
			अवरोध;
		पूर्ण

		/* If this endpoपूर्णांक was re-created जबतक peer was ESTABLISHING
		 * it करोesn't know current session number. Force re-synch.
		 */
		अगर (mtyp == ACTIVATE_MSG && msg_dest_session_valid(hdr) &&
		    l->session != msg_dest_session(hdr)) अणु
			अगर (less(l->session, msg_dest_session(hdr)))
				l->session = msg_dest_session(hdr) + 1;
			अवरोध;
		पूर्ण

		/* ACTIVATE_MSG serves as PEER_RESET अगर link is alपढ़ोy करोwn */
		अगर (mtyp == RESET_MSG || !link_is_up(l))
			rc = tipc_link_fsm_evt(l, LINK_PEER_RESET_EVT);

		/* ACTIVATE_MSG takes up link अगर it was alपढ़ोy locally reset */
		अगर (mtyp == ACTIVATE_MSG && l->state == LINK_ESTABLISHING)
			rc = TIPC_LINK_UP_EVT;

		l->peer_session = msg_session(hdr);
		l->in_session = true;
		l->peer_bearer_id = msg_bearer_id(hdr);
		अगर (l->mtu > msg_max_pkt(hdr))
			l->mtu = msg_max_pkt(hdr);
		अवरोध;

	हाल STATE_MSG:
		l->rcv_nxt_state = msg_seqno(hdr) + 1;

		/* Update own tolerance अगर peer indicates a non-zero value */
		अगर (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) अणु
			l->tolerance = peers_tol;
			l->bc_rcvlink->tolerance = peers_tol;
		पूर्ण
		/* Update own prio अगर peer indicates a dअगरferent value */
		अगर ((peers_prio != l->priority) &&
		    in_range(peers_prio, 1, TIPC_MAX_LINK_PRI)) अणु
			l->priority = peers_prio;
			rc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);
		पूर्ण

		l->silent_पूर्णांकv_cnt = 0;
		l->stats.recv_states++;
		अगर (msg_probe(hdr))
			l->stats.recv_probes++;

		अगर (!link_is_up(l)) अणु
			अगर (l->state == LINK_ESTABLISHING)
				rc = TIPC_LINK_UP_EVT;
			अवरोध;
		पूर्ण

		/* Receive Gap ACK blocks from peer अगर any */
		glen = tipc_get_gap_ack_blks(&ga, l, hdr, true);

		tipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,
			     &l->mon_state, l->bearer_id);

		/* Send NACK अगर peer has sent pkts we haven't received yet */
		अगर ((reply || msg_is_keepalive(hdr)) &&
		    more(peers_snd_nxt, rcv_nxt) &&
		    !tipc_link_is_synching(l) &&
		    skb_queue_empty(&l->deferdq))
			rcvgap = peers_snd_nxt - l->rcv_nxt;
		अगर (rcvgap || reply)
			tipc_link_build_proto_msg(l, STATE_MSG, 0, reply,
						  rcvgap, 0, 0, xmitq);

		released = tipc_link_advance_transmq(l, l, ack, gap, ga, xmitq,
						     &retransmitted, &rc);
		अगर (gap)
			l->stats.recv_nacks++;
		अगर (released || retransmitted)
			tipc_link_update_cwin(l, released, retransmitted);
		अगर (released)
			tipc_link_advance_backlog(l, xmitq);
		अगर (unlikely(!skb_queue_empty(&l->wakeupq)))
			link_prepare_wakeup(l);
	पूर्ण
निकास:
	kमुक्त_skb(skb);
	वापस rc;
पूर्ण

/* tipc_link_build_bc_proto_msg() - create broadcast protocol message
 */
अटल bool tipc_link_build_bc_proto_msg(काष्ठा tipc_link *l, bool bcast,
					 u16 peers_snd_nxt,
					 काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff *skb;
	काष्ठा tipc_msg *hdr;
	काष्ठा sk_buff *dfrd_skb = skb_peek(&l->deferdq);
	u16 ack = l->rcv_nxt - 1;
	u16 gap_to = peers_snd_nxt - 1;

	skb = tipc_msg_create(BCAST_PROTOCOL, STATE_MSG, INT_H_SIZE,
			      0, l->addr, tipc_own_addr(l->net), 0, 0, 0);
	अगर (!skb)
		वापस false;
	hdr = buf_msg(skb);
	msg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);
	msg_set_bcast_ack(hdr, ack);
	msg_set_bcgap_after(hdr, ack);
	अगर (dfrd_skb)
		gap_to = buf_seqno(dfrd_skb) - 1;
	msg_set_bcgap_to(hdr, gap_to);
	msg_set_non_seq(hdr, bcast);
	__skb_queue_tail(xmitq, skb);
	वापस true;
पूर्ण

/* tipc_link_build_bc_init_msg() - synchronize broadcast link endpoपूर्णांकs.
 *
 * Give a newly added peer node the sequence number where it should
 * start receiving and acking broadcast packets.
 */
अटल व्योम tipc_link_build_bc_init_msg(काष्ठा tipc_link *l,
					काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा sk_buff_head list;

	__skb_queue_head_init(&list);
	अगर (!tipc_link_build_bc_proto_msg(l->bc_rcvlink, false, 0, &list))
		वापस;
	msg_set_bc_ack_invalid(buf_msg(skb_peek(&list)), true);
	tipc_link_xmit(l, &list, xmitq);
पूर्ण

/* tipc_link_bc_init_rcv - receive initial broadcast synch data from peer
 */
व्योम tipc_link_bc_init_rcv(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr)
अणु
	पूर्णांक mtyp = msg_type(hdr);
	u16 peers_snd_nxt = msg_bc_snd_nxt(hdr);

	अगर (link_is_up(l))
		वापस;

	अगर (msg_user(hdr) == BCAST_PROTOCOL) अणु
		l->rcv_nxt = peers_snd_nxt;
		l->state = LINK_ESTABLISHED;
		वापस;
	पूर्ण

	अगर (l->peer_caps & TIPC_BCAST_SYNCH)
		वापस;

	अगर (msg_peer_node_is_up(hdr))
		वापस;

	/* Compatibility: accept older, less safe initial synch data */
	अगर ((mtyp == RESET_MSG) || (mtyp == ACTIVATE_MSG))
		l->rcv_nxt = peers_snd_nxt;
पूर्ण

/* tipc_link_bc_sync_rcv - update rcv link according to peer's send state
 */
पूर्णांक tipc_link_bc_sync_rcv(काष्ठा tipc_link *l, काष्ठा tipc_msg *hdr,
			  काष्ठा sk_buff_head *xmitq)
अणु
	u16 peers_snd_nxt = msg_bc_snd_nxt(hdr);
	पूर्णांक rc = 0;

	अगर (!link_is_up(l))
		वापस rc;

	अगर (!msg_peer_node_is_up(hdr))
		वापस rc;

	/* Open when peer acknowledges our bcast init msg (pkt #1) */
	अगर (msg_ack(hdr))
		l->bc_peer_is_up = true;

	अगर (!l->bc_peer_is_up)
		वापस rc;

	/* Ignore अगर peers_snd_nxt goes beyond receive winकरोw */
	अगर (more(peers_snd_nxt, l->rcv_nxt + l->winकरोw))
		वापस rc;

	l->snd_nxt = peers_snd_nxt;
	अगर (link_bc_rcv_gap(l))
		rc |= TIPC_LINK_SND_STATE;

	/* Return now अगर sender supports nack via STATE messages */
	अगर (l->peer_caps & TIPC_BCAST_STATE_NACK)
		वापस rc;

	/* Otherwise, be backwards compatible */

	अगर (!more(peers_snd_nxt, l->rcv_nxt)) अणु
		l->nack_state = BC_NACK_SND_CONDITIONAL;
		वापस 0;
	पूर्ण

	/* Don't NACK अगर one was recently sent or peeked */
	अगर (l->nack_state == BC_NACK_SND_SUPPRESS) अणु
		l->nack_state = BC_NACK_SND_UNCONDITIONAL;
		वापस 0;
	पूर्ण

	/* Conditionally delay NACK sending until next synch rcv */
	अगर (l->nack_state == BC_NACK_SND_CONDITIONAL) अणु
		l->nack_state = BC_NACK_SND_UNCONDITIONAL;
		अगर ((peers_snd_nxt - l->rcv_nxt) < TIPC_MIN_LINK_WIN)
			वापस 0;
	पूर्ण

	/* Send NACK now but suppress next one */
	tipc_link_build_bc_proto_msg(l, true, peers_snd_nxt, xmitq);
	l->nack_state = BC_NACK_SND_SUPPRESS;
	वापस 0;
पूर्ण

पूर्णांक tipc_link_bc_ack_rcv(काष्ठा tipc_link *r, u16 acked, u16 gap,
			 काष्ठा tipc_gap_ack_blks *ga,
			 काष्ठा sk_buff_head *xmitq,
			 काष्ठा sk_buff_head *retrq)
अणु
	काष्ठा tipc_link *l = r->bc_sndlink;
	bool unused = false;
	पूर्णांक rc = 0;

	अगर (!link_is_up(r) || !r->bc_peer_is_up)
		वापस 0;

	अगर (gap) अणु
		l->stats.recv_nacks++;
		r->stats.recv_nacks++;
	पूर्ण

	अगर (less(acked, r->acked) || (acked == r->acked && !gap && !ga))
		वापस 0;

	trace_tipc_link_bc_ack(r, acked, gap, &l->transmq);
	tipc_link_advance_transmq(l, r, acked, gap, ga, retrq, &unused, &rc);

	tipc_link_advance_backlog(l, xmitq);
	अगर (unlikely(!skb_queue_empty(&l->wakeupq)))
		link_prepare_wakeup(l);

	वापस rc;
पूर्ण

/* tipc_link_bc_nack_rcv(): receive broadcast nack message
 * This function is here क्रम backwards compatibility, since
 * no BCAST_PROTOCOL/STATE messages occur from TIPC v2.5.
 */
पूर्णांक tipc_link_bc_nack_rcv(काष्ठा tipc_link *l, काष्ठा sk_buff *skb,
			  काष्ठा sk_buff_head *xmitq)
अणु
	काष्ठा tipc_msg *hdr = buf_msg(skb);
	u32 dnode = msg_destnode(hdr);
	पूर्णांक mtyp = msg_type(hdr);
	u16 acked = msg_bcast_ack(hdr);
	u16 from = acked + 1;
	u16 to = msg_bcgap_to(hdr);
	u16 peers_snd_nxt = to + 1;
	पूर्णांक rc = 0;

	kमुक्त_skb(skb);

	अगर (!tipc_link_is_up(l) || !l->bc_peer_is_up)
		वापस 0;

	अगर (mtyp != STATE_MSG)
		वापस 0;

	अगर (dnode == tipc_own_addr(l->net)) अणु
		rc = tipc_link_bc_ack_rcv(l, acked, to - acked, शून्य, xmitq,
					  xmitq);
		l->stats.recv_nacks++;
		वापस rc;
	पूर्ण

	/* Msg क्रम other node => suppress own NACK at next sync अगर applicable */
	अगर (more(peers_snd_nxt, l->rcv_nxt) && !less(l->rcv_nxt, from))
		l->nack_state = BC_NACK_SND_SUPPRESS;

	वापस 0;
पूर्ण

व्योम tipc_link_set_queue_limits(काष्ठा tipc_link *l, u32 min_win, u32 max_win)
अणु
	पूर्णांक max_bulk = TIPC_MAX_PUBL / (l->mtu / ITEM_SIZE);

	l->min_win = min_win;
	l->ssthresh = max_win;
	l->max_win = max_win;
	l->winकरोw = min_win;
	l->backlog[TIPC_LOW_IMPORTANCE].limit      = min_win * 2;
	l->backlog[TIPC_MEDIUM_IMPORTANCE].limit   = min_win * 4;
	l->backlog[TIPC_HIGH_IMPORTANCE].limit     = min_win * 6;
	l->backlog[TIPC_CRITICAL_IMPORTANCE].limit = min_win * 8;
	l->backlog[TIPC_SYSTEM_IMPORTANCE].limit   = max_bulk;
पूर्ण

/**
 * tipc_link_reset_stats - reset link statistics
 * @l: poपूर्णांकer to link
 */
व्योम tipc_link_reset_stats(काष्ठा tipc_link *l)
अणु
	स_रखो(&l->stats, 0, माप(l->stats));
पूर्ण

अटल व्योम link_prपूर्णांक(काष्ठा tipc_link *l, स्थिर अक्षर *str)
अणु
	काष्ठा sk_buff *hskb = skb_peek(&l->transmq);
	u16 head = hskb ? msg_seqno(buf_msg(hskb)) : l->snd_nxt - 1;
	u16 tail = l->snd_nxt - 1;

	pr_info("%s Link <%s> state %x\n", str, l->name, l->state);
	pr_info("XMTQ: %u [%u-%u], BKLGQ: %u, SNDNX: %u, RCVNX: %u\n",
		skb_queue_len(&l->transmq), head, tail,
		skb_queue_len(&l->backlogq), l->snd_nxt, l->rcv_nxt);
पूर्ण

/* Parse and validate nested (link) properties valid क्रम media, bearer and link
 */
पूर्णांक tipc_nl_parse_link_prop(काष्ठा nlattr *prop, काष्ठा nlattr *props[])
अणु
	पूर्णांक err;

	err = nla_parse_nested_deprecated(props, TIPC_NLA_PROP_MAX, prop,
					  tipc_nl_prop_policy, शून्य);
	अगर (err)
		वापस err;

	अगर (props[TIPC_NLA_PROP_PRIO]) अणु
		u32 prio;

		prio = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);
		अगर (prio > TIPC_MAX_LINK_PRI)
			वापस -EINVAL;
	पूर्ण

	अगर (props[TIPC_NLA_PROP_TOL]) अणु
		u32 tol;

		tol = nla_get_u32(props[TIPC_NLA_PROP_TOL]);
		अगर ((tol < TIPC_MIN_LINK_TOL) || (tol > TIPC_MAX_LINK_TOL))
			वापस -EINVAL;
	पूर्ण

	अगर (props[TIPC_NLA_PROP_WIN]) अणु
		u32 max_win;

		max_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);
		अगर (max_win < TIPC_DEF_LINK_WIN || max_win > TIPC_MAX_LINK_WIN)
			वापस -EINVAL;
	पूर्ण

	वापस 0;
पूर्ण

अटल पूर्णांक __tipc_nl_add_stats(काष्ठा sk_buff *skb, काष्ठा tipc_stats *s)
अणु
	पूर्णांक i;
	काष्ठा nlattr *stats;

	काष्ठा nla_map अणु
		u32 key;
		u32 val;
	पूर्ण;

	काष्ठा nla_map map[] = अणु
		अणुTIPC_NLA_STATS_RX_INFO, 0पूर्ण,
		अणुTIPC_NLA_STATS_RX_FRAGMENTS, s->recv_fragmentsपूर्ण,
		अणुTIPC_NLA_STATS_RX_FRAGMENTED, s->recv_fragmentedपूर्ण,
		अणुTIPC_NLA_STATS_RX_BUNDLES, s->recv_bundlesपूर्ण,
		अणुTIPC_NLA_STATS_RX_BUNDLED, s->recv_bundledपूर्ण,
		अणुTIPC_NLA_STATS_TX_INFO, 0पूर्ण,
		अणुTIPC_NLA_STATS_TX_FRAGMENTS, s->sent_fragmentsपूर्ण,
		अणुTIPC_NLA_STATS_TX_FRAGMENTED, s->sent_fragmentedपूर्ण,
		अणुTIPC_NLA_STATS_TX_BUNDLES, s->sent_bundlesपूर्ण,
		अणुTIPC_NLA_STATS_TX_BUNDLED, s->sent_bundledपूर्ण,
		अणुTIPC_NLA_STATS_MSG_PROF_TOT, (s->msg_length_counts) ?
			s->msg_length_counts : 1पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_CNT, s->msg_length_countsपूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_TOT, s->msg_lengths_totalपूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P0, s->msg_length_profile[0]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P1, s->msg_length_profile[1]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P2, s->msg_length_profile[2]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P3, s->msg_length_profile[3]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P4, s->msg_length_profile[4]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P5, s->msg_length_profile[5]पूर्ण,
		अणुTIPC_NLA_STATS_MSG_LEN_P6, s->msg_length_profile[6]पूर्ण,
		अणुTIPC_NLA_STATS_RX_STATES, s->recv_statesपूर्ण,
		अणुTIPC_NLA_STATS_RX_PROBES, s->recv_probesपूर्ण,
		अणुTIPC_NLA_STATS_RX_NACKS, s->recv_nacksपूर्ण,
		अणुTIPC_NLA_STATS_RX_DEFERRED, s->deferred_recvपूर्ण,
		अणुTIPC_NLA_STATS_TX_STATES, s->sent_statesपूर्ण,
		अणुTIPC_NLA_STATS_TX_PROBES, s->sent_probesपूर्ण,
		अणुTIPC_NLA_STATS_TX_NACKS, s->sent_nacksपूर्ण,
		अणुTIPC_NLA_STATS_TX_ACKS, s->sent_acksपूर्ण,
		अणुTIPC_NLA_STATS_RETRANSMITTED, s->retransmittedपूर्ण,
		अणुTIPC_NLA_STATS_DUPLICATES, s->duplicatesपूर्ण,
		अणुTIPC_NLA_STATS_LINK_CONGS, s->link_congsपूर्ण,
		अणुTIPC_NLA_STATS_MAX_QUEUE, s->max_queue_szपूर्ण,
		अणुTIPC_NLA_STATS_AVG_QUEUE, s->queue_sz_counts ?
			(s->accu_queue_sz / s->queue_sz_counts) : 0पूर्ण
	पूर्ण;

	stats = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);
	अगर (!stats)
		वापस -EMSGSIZE;

	क्रम (i = 0; i <  ARRAY_SIZE(map); i++)
		अगर (nla_put_u32(skb, map[i].key, map[i].val))
			जाओ msg_full;

	nla_nest_end(skb, stats);

	वापस 0;
msg_full:
	nla_nest_cancel(skb, stats);

	वापस -EMSGSIZE;
पूर्ण

/* Caller should hold appropriate locks to protect the link */
पूर्णांक __tipc_nl_add_link(काष्ठा net *net, काष्ठा tipc_nl_msg *msg,
		       काष्ठा tipc_link *link, पूर्णांक nlflags)
अणु
	u32 self = tipc_own_addr(net);
	काष्ठा nlattr *attrs;
	काष्ठा nlattr *prop;
	व्योम *hdr;
	पूर्णांक err;

	hdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,
			  nlflags, TIPC_NL_LINK_GET);
	अगर (!hdr)
		वापस -EMSGSIZE;

	attrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);
	अगर (!attrs)
		जाओ msg_full;

	अगर (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, link->name))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_DEST, tipc_cluster_mask(self)))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_MTU, link->mtu))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, link->stats.recv_pkts))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, link->stats.sent_pkts))
		जाओ attr_msg_full;

	अगर (tipc_link_is_up(link))
		अगर (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))
			जाओ attr_msg_full;
	अगर (link->active)
		अगर (nla_put_flag(msg->skb, TIPC_NLA_LINK_ACTIVE))
			जाओ attr_msg_full;

	prop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);
	अगर (!prop)
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))
		जाओ prop_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_TOL, link->tolerance))
		जाओ prop_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN,
			link->winकरोw))
		जाओ prop_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))
		जाओ prop_msg_full;
	nla_nest_end(msg->skb, prop);

	err = __tipc_nl_add_stats(msg->skb, &link->stats);
	अगर (err)
		जाओ attr_msg_full;

	nla_nest_end(msg->skb, attrs);
	genlmsg_end(msg->skb, hdr);

	वापस 0;

prop_msg_full:
	nla_nest_cancel(msg->skb, prop);
attr_msg_full:
	nla_nest_cancel(msg->skb, attrs);
msg_full:
	genlmsg_cancel(msg->skb, hdr);

	वापस -EMSGSIZE;
पूर्ण

अटल पूर्णांक __tipc_nl_add_bc_link_stat(काष्ठा sk_buff *skb,
				      काष्ठा tipc_stats *stats)
अणु
	पूर्णांक i;
	काष्ठा nlattr *nest;

	काष्ठा nla_map अणु
		__u32 key;
		__u32 val;
	पूर्ण;

	काष्ठा nla_map map[] = अणु
		अणुTIPC_NLA_STATS_RX_INFO, stats->recv_pktsपूर्ण,
		अणुTIPC_NLA_STATS_RX_FRAGMENTS, stats->recv_fragmentsपूर्ण,
		अणुTIPC_NLA_STATS_RX_FRAGMENTED, stats->recv_fragmentedपूर्ण,
		अणुTIPC_NLA_STATS_RX_BUNDLES, stats->recv_bundlesपूर्ण,
		अणुTIPC_NLA_STATS_RX_BUNDLED, stats->recv_bundledपूर्ण,
		अणुTIPC_NLA_STATS_TX_INFO, stats->sent_pktsपूर्ण,
		अणुTIPC_NLA_STATS_TX_FRAGMENTS, stats->sent_fragmentsपूर्ण,
		अणुTIPC_NLA_STATS_TX_FRAGMENTED, stats->sent_fragmentedपूर्ण,
		अणुTIPC_NLA_STATS_TX_BUNDLES, stats->sent_bundlesपूर्ण,
		अणुTIPC_NLA_STATS_TX_BUNDLED, stats->sent_bundledपूर्ण,
		अणुTIPC_NLA_STATS_RX_NACKS, stats->recv_nacksपूर्ण,
		अणुTIPC_NLA_STATS_RX_DEFERRED, stats->deferred_recvपूर्ण,
		अणुTIPC_NLA_STATS_TX_NACKS, stats->sent_nacksपूर्ण,
		अणुTIPC_NLA_STATS_TX_ACKS, stats->sent_acksपूर्ण,
		अणुTIPC_NLA_STATS_RETRANSMITTED, stats->retransmittedपूर्ण,
		अणुTIPC_NLA_STATS_DUPLICATES, stats->duplicatesपूर्ण,
		अणुTIPC_NLA_STATS_LINK_CONGS, stats->link_congsपूर्ण,
		अणुTIPC_NLA_STATS_MAX_QUEUE, stats->max_queue_szपूर्ण,
		अणुTIPC_NLA_STATS_AVG_QUEUE, stats->queue_sz_counts ?
			(stats->accu_queue_sz / stats->queue_sz_counts) : 0पूर्ण
	पूर्ण;

	nest = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);
	अगर (!nest)
		वापस -EMSGSIZE;

	क्रम (i = 0; i <  ARRAY_SIZE(map); i++)
		अगर (nla_put_u32(skb, map[i].key, map[i].val))
			जाओ msg_full;

	nla_nest_end(skb, nest);

	वापस 0;
msg_full:
	nla_nest_cancel(skb, nest);

	वापस -EMSGSIZE;
पूर्ण

पूर्णांक tipc_nl_add_bc_link(काष्ठा net *net, काष्ठा tipc_nl_msg *msg,
			काष्ठा tipc_link *bcl)
अणु
	पूर्णांक err;
	व्योम *hdr;
	काष्ठा nlattr *attrs;
	काष्ठा nlattr *prop;
	u32 bc_mode = tipc_bcast_get_mode(net);
	u32 bc_ratio = tipc_bcast_get_broadcast_ratio(net);

	अगर (!bcl)
		वापस 0;

	tipc_bcast_lock(net);

	hdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,
			  NLM_F_MULTI, TIPC_NL_LINK_GET);
	अगर (!hdr) अणु
		tipc_bcast_unlock(net);
		वापस -EMSGSIZE;
	पूर्ण

	attrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);
	अगर (!attrs)
		जाओ msg_full;

	/* The broadcast link is always up */
	अगर (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))
		जाओ attr_msg_full;

	अगर (nla_put_flag(msg->skb, TIPC_NLA_LINK_BROADCAST))
		जाओ attr_msg_full;
	अगर (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, bcl->name))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, 0))
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, 0))
		जाओ attr_msg_full;

	prop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);
	अगर (!prop)
		जाओ attr_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN, bcl->max_win))
		जाओ prop_msg_full;
	अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST, bc_mode))
		जाओ prop_msg_full;
	अगर (bc_mode & BCLINK_MODE_SEL)
		अगर (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST_RATIO,
				bc_ratio))
			जाओ prop_msg_full;
	nla_nest_end(msg->skb, prop);

	err = __tipc_nl_add_bc_link_stat(msg->skb, &bcl->stats);
	अगर (err)
		जाओ attr_msg_full;

	tipc_bcast_unlock(net);
	nla_nest_end(msg->skb, attrs);
	genlmsg_end(msg->skb, hdr);

	वापस 0;

prop_msg_full:
	nla_nest_cancel(msg->skb, prop);
attr_msg_full:
	nla_nest_cancel(msg->skb, attrs);
msg_full:
	tipc_bcast_unlock(net);
	genlmsg_cancel(msg->skb, hdr);

	वापस -EMSGSIZE;
पूर्ण

व्योम tipc_link_set_tolerance(काष्ठा tipc_link *l, u32 tol,
			     काष्ठा sk_buff_head *xmitq)
अणु
	l->tolerance = tol;
	अगर (l->bc_rcvlink)
		l->bc_rcvlink->tolerance = tol;
	अगर (link_is_up(l))
		tipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, tol, 0, xmitq);
पूर्ण

व्योम tipc_link_set_prio(काष्ठा tipc_link *l, u32 prio,
			काष्ठा sk_buff_head *xmitq)
अणु
	l->priority = prio;
	tipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, prio, xmitq);
पूर्ण

व्योम tipc_link_set_पात_limit(काष्ठा tipc_link *l, u32 limit)
अणु
	l->पात_limit = limit;
पूर्ण

/**
 * tipc_link_dump - dump TIPC link data
 * @l: tipc link to be dumped
 * @dqueues: biपंचांगask to decide अगर any link queue to be dumped?
 *           - TIPC_DUMP_NONE: करोn't dump link queues
 *           - TIPC_DUMP_TRANSMQ: dump link transmq queue
 *           - TIPC_DUMP_BACKLOGQ: dump link backlog queue
 *           - TIPC_DUMP_DEFERDQ: dump link deferd queue
 *           - TIPC_DUMP_INPUTQ: dump link input queue
 *           - TIPC_DUMP_WAKEUP: dump link wakeup queue
 *           - TIPC_DUMP_ALL: dump all the link queues above
 * @buf: वापसed buffer of dump data in क्रमmat
 */
पूर्णांक tipc_link_dump(काष्ठा tipc_link *l, u16 dqueues, अक्षर *buf)
अणु
	पूर्णांक i = 0;
	माप_प्रकार sz = (dqueues) ? LINK_LMAX : LINK_LMIN;
	काष्ठा sk_buff_head *list;
	काष्ठा sk_buff *hskb, *tskb;
	u32 len;

	अगर (!l) अणु
		i += scnम_लिखो(buf, sz, "link data: (null)\n");
		वापस i;
	पूर्ण

	i += scnम_लिखो(buf, sz, "link data: %x", l->addr);
	i += scnम_लिखो(buf + i, sz - i, " %x", l->state);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->in_session);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->session);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->peer_session);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->snd_nxt);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->rcv_nxt);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->snd_nxt_state);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->rcv_nxt_state);
	i += scnम_लिखो(buf + i, sz - i, " %x", l->peer_caps);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->silent_पूर्णांकv_cnt);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->rst_cnt);
	i += scnम_लिखो(buf + i, sz - i, " %u", 0);
	i += scnम_लिखो(buf + i, sz - i, " %u", 0);
	i += scnम_लिखो(buf + i, sz - i, " %u", l->acked);

	list = &l->transmq;
	len = skb_queue_len(list);
	hskb = skb_peek(list);
	tskb = skb_peek_tail(list);
	i += scnम_लिखो(buf + i, sz - i, " | %u %u %u", len,
		       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,
		       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);

	list = &l->deferdq;
	len = skb_queue_len(list);
	hskb = skb_peek(list);
	tskb = skb_peek_tail(list);
	i += scnम_लिखो(buf + i, sz - i, " | %u %u %u", len,
		       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,
		       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);

	list = &l->backlogq;
	len = skb_queue_len(list);
	hskb = skb_peek(list);
	tskb = skb_peek_tail(list);
	i += scnम_लिखो(buf + i, sz - i, " | %u %u %u", len,
		       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,
		       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);

	list = l->inputq;
	len = skb_queue_len(list);
	hskb = skb_peek(list);
	tskb = skb_peek_tail(list);
	i += scnम_लिखो(buf + i, sz - i, " | %u %u %u\n", len,
		       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,
		       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);

	अगर (dqueues & TIPC_DUMP_TRANSMQ) अणु
		i += scnम_लिखो(buf + i, sz - i, "transmq: ");
		i += tipc_list_dump(&l->transmq, false, buf + i);
	पूर्ण
	अगर (dqueues & TIPC_DUMP_BACKLOGQ) अणु
		i += scnम_लिखो(buf + i, sz - i,
			       "backlogq: <%u %u %u %u %u>, ",
			       l->backlog[TIPC_LOW_IMPORTANCE].len,
			       l->backlog[TIPC_MEDIUM_IMPORTANCE].len,
			       l->backlog[TIPC_HIGH_IMPORTANCE].len,
			       l->backlog[TIPC_CRITICAL_IMPORTANCE].len,
			       l->backlog[TIPC_SYSTEM_IMPORTANCE].len);
		i += tipc_list_dump(&l->backlogq, false, buf + i);
	पूर्ण
	अगर (dqueues & TIPC_DUMP_DEFERDQ) अणु
		i += scnम_लिखो(buf + i, sz - i, "deferdq: ");
		i += tipc_list_dump(&l->deferdq, false, buf + i);
	पूर्ण
	अगर (dqueues & TIPC_DUMP_INPUTQ) अणु
		i += scnम_लिखो(buf + i, sz - i, "inputq: ");
		i += tipc_list_dump(l->inputq, false, buf + i);
	पूर्ण
	अगर (dqueues & TIPC_DUMP_WAKEUP) अणु
		i += scnम_लिखो(buf + i, sz - i, "wakeup: ");
		i += tipc_list_dump(&l->wakeupq, false, buf + i);
	पूर्ण

	वापस i;
पूर्ण
