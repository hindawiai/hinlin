<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/*
 * SGI NMI support routines
 *
 * (C) Copyright 2020 Hewlett Packard Enterprise Development LP
 * Copyright (C) 2007-2017 Silicon Graphics, Inc. All rights reserved.
 * Copyright (c) Mike Travis
 */

#समावेश <linux/cpu.h>
#समावेश <linux/delay.h>
#समावेश <linux/kdb.h>
#समावेश <linux/kexec.h>
#समावेश <linux/kgdb.h>
#समावेश <linux/moduleparam.h>
#समावेश <linux/nmi.h>
#समावेश <linux/sched.h>
#समावेश <linux/sched/debug.h>
#समावेश <linux/slab.h>
#समावेश <linux/घड़ीsource.h>

#समावेश <यंत्र/apic.h>
#समावेश <यंत्र/current.h>
#समावेश <यंत्र/kdebug.h>
#समावेश <यंत्र/local64.h>
#समावेश <यंत्र/nmi.h>
#समावेश <यंत्र/reboot.h>
#समावेश <यंत्र/traps.h>
#समावेश <यंत्र/uv/uv.h>
#समावेश <यंत्र/uv/uv_hub.h>
#समावेश <यंत्र/uv/uv_mmrs.h>

/*
 * UV handler क्रम NMI
 *
 * Handle प्रणाली-wide NMI events generated by the global 'power nmi' command.
 *
 * Basic operation is to field the NMI पूर्णांकerrupt on each CPU and रुको
 * until all CPU's have arrived into the nmi handler.  If some CPU's करो not
 * make it पूर्णांकo the handler, try and क्रमce them in with the IPI(NMI) संकेत.
 *
 * We also have to lessen UV Hub MMR accesses as much as possible as this
 * disrupts the UV Hub's primary mission of directing NumaLink traffic and
 * can cause प्रणाली problems to occur.
 *
 * To करो this we रेजिस्टर our primary NMI notअगरier on the NMI_UNKNOWN
 * chain.  This reduces the number of false NMI calls when the perf
 * tools are running which generate an enormous number of NMIs per
 * second (~4M/s क्रम 1024 CPU thपढ़ोs).  Our secondary NMI handler is
 * very लघु as it only checks that अगर it has been "pinged" with the
 * IPI(NMI) संकेत as mentioned above, and करोes not पढ़ो the UV Hub's MMR.
 *
 */

अटल काष्ठा uv_hub_nmi_s **uv_hub_nmi_list;

DEFINE_PER_CPU(काष्ठा uv_cpu_nmi_s, uv_cpu_nmi);

/* Newer SMM NMI handler, not present in all प्रणालीs */
अटल अचिन्हित दीर्घ uvh_nmi_mmrx;		/* UVH_EVENT_OCCURRED0/1 */
अटल अचिन्हित दीर्घ uvh_nmi_mmrx_clear;	/* UVH_EVENT_OCCURRED0/1_ALIAS */
अटल पूर्णांक uvh_nmi_mmrx_shअगरt;			/* UVH_EVENT_OCCURRED0/1_EXTIO_INT0_SHFT */
अटल अक्षर *uvh_nmi_mmrx_type;			/* "EXTIO_INT0" */

/* Non-zero indicates newer SMM NMI handler present */
अटल अचिन्हित दीर्घ uvh_nmi_mmrx_supported;	/* UVH_EXTIO_INT0_BROADCAST */

/* Indicates to BIOS that we want to use the newer SMM NMI handler */
अटल अचिन्हित दीर्घ uvh_nmi_mmrx_req;		/* UVH_BIOS_KERNEL_MMR_ALIAS_2 */
अटल पूर्णांक uvh_nmi_mmrx_req_shअगरt;		/* 62 */

/* UV hubless values */
#घोषणा NMI_CONTROL_PORT	0x70
#घोषणा NMI_DUMMY_PORT		0x71
#घोषणा PAD_OWN_GPP_D_0		0x2c
#घोषणा GPI_NMI_STS_GPP_D_0	0x164
#घोषणा GPI_NMI_ENA_GPP_D_0	0x174
#घोषणा STS_GPP_D_0_MASK	0x1
#घोषणा PAD_CFG_DW0_GPP_D_0	0x4c0
#घोषणा GPIROUTNMI		(1ul << 17)
#घोषणा PCH_PCR_GPIO_1_BASE	0xfdae0000ul
#घोषणा PCH_PCR_GPIO_ADDRESS(offset) (पूर्णांक *)((u64)(pch_base) | (u64)(offset))

अटल u64 *pch_base;
अटल अचिन्हित दीर्घ nmi_mmr;
अटल अचिन्हित दीर्घ nmi_mmr_clear;
अटल अचिन्हित दीर्घ nmi_mmr_pending;

अटल atomic_t	uv_in_nmi;
अटल atomic_t uv_nmi_cpu = ATOMIC_INIT(-1);
अटल atomic_t uv_nmi_cpus_in_nmi = ATOMIC_INIT(-1);
अटल atomic_t uv_nmi_slave_जारी;
अटल cpumask_var_t uv_nmi_cpu_mask;

अटल atomic_t uv_nmi_kexec_failed;

/* Values क्रम uv_nmi_slave_जारी */
#घोषणा SLAVE_CLEAR	0
#घोषणा SLAVE_CONTINUE	1
#घोषणा SLAVE_EXIT	2

/*
 * Default is all stack dumps go to the console and buffer.
 * Lower level to send to log buffer only.
 */
अटल पूर्णांक uv_nmi_loglevel = CONSOLE_LOGLEVEL_DEFAULT;
module_param_named(dump_loglevel, uv_nmi_loglevel, पूर्णांक, 0644);

/*
 * The following values show statistics on how perf events are affecting
 * this प्रणाली.
 */
अटल पूर्णांक param_get_local64(अक्षर *buffer, स्थिर काष्ठा kernel_param *kp)
अणु
	वापस प्र_लिखो(buffer, "%lu\n", local64_पढ़ो((local64_t *)kp->arg));
पूर्ण

अटल पूर्णांक param_set_local64(स्थिर अक्षर *val, स्थिर काष्ठा kernel_param *kp)
अणु
	/* Clear on any ग_लिखो */
	local64_set((local64_t *)kp->arg, 0);
	वापस 0;
पूर्ण

अटल स्थिर काष्ठा kernel_param_ops param_ops_local64 = अणु
	.get = param_get_local64,
	.set = param_set_local64,
पूर्ण;
#घोषणा param_check_local64(name, p) __param_check(name, p, local64_t)

अटल local64_t uv_nmi_count;
module_param_named(nmi_count, uv_nmi_count, local64, 0644);

अटल local64_t uv_nmi_misses;
module_param_named(nmi_misses, uv_nmi_misses, local64, 0644);

अटल local64_t uv_nmi_ping_count;
module_param_named(ping_count, uv_nmi_ping_count, local64, 0644);

अटल local64_t uv_nmi_ping_misses;
module_param_named(ping_misses, uv_nmi_ping_misses, local64, 0644);

/*
 * Following values allow tuning क्रम large प्रणालीs under heavy loading
 */
अटल पूर्णांक uv_nmi_initial_delay = 100;
module_param_named(initial_delay, uv_nmi_initial_delay, पूर्णांक, 0644);

अटल पूर्णांक uv_nmi_slave_delay = 100;
module_param_named(slave_delay, uv_nmi_slave_delay, पूर्णांक, 0644);

अटल पूर्णांक uv_nmi_loop_delay = 100;
module_param_named(loop_delay, uv_nmi_loop_delay, पूर्णांक, 0644);

अटल पूर्णांक uv_nmi_trigger_delay = 10000;
module_param_named(trigger_delay, uv_nmi_trigger_delay, पूर्णांक, 0644);

अटल पूर्णांक uv_nmi_रुको_count = 100;
module_param_named(रुको_count, uv_nmi_रुको_count, पूर्णांक, 0644);

अटल पूर्णांक uv_nmi_retry_count = 500;
module_param_named(retry_count, uv_nmi_retry_count, पूर्णांक, 0644);

अटल bool uv_pch_पूर्णांकr_enable = true;
अटल bool uv_pch_पूर्णांकr_now_enabled;
module_param_named(pch_पूर्णांकr_enable, uv_pch_पूर्णांकr_enable, bool, 0644);

अटल bool uv_pch_init_enable = true;
module_param_named(pch_init_enable, uv_pch_init_enable, bool, 0644);

अटल पूर्णांक uv_nmi_debug;
module_param_named(debug, uv_nmi_debug, पूर्णांक, 0644);

#घोषणा nmi_debug(fmt, ...)				\
	करो अणु						\
		अगर (uv_nmi_debug)			\
			pr_info(fmt, ##__VA_ARGS__);	\
	पूर्ण जबतक (0)

/* Valid NMI Actions */
#घोषणा	ACTION_LEN	16
अटल काष्ठा nmi_action अणु
	अक्षर	*action;
	अक्षर	*desc;
पूर्ण valid_acts[] = अणु
	अणु	"kdump",	"do kernel crash dump"			पूर्ण,
	अणु	"dump",		"dump process stack for each cpu"	पूर्ण,
	अणु	"ips",		"dump Inst Ptr info for each cpu"	पूर्ण,
	अणु	"kdb",		"enter KDB (needs kgdboc= assignment)"	पूर्ण,
	अणु	"kgdb",		"enter KGDB (needs gdb target remote)"	पूर्ण,
	अणु	"health",	"check if CPUs respond to NMI"		पूर्ण,
पूर्ण;
प्रकार अक्षर action_t[ACTION_LEN];
अटल action_t uv_nmi_action = अणु "dump" पूर्ण;

अटल पूर्णांक param_get_action(अक्षर *buffer, स्थिर काष्ठा kernel_param *kp)
अणु
	वापस प्र_लिखो(buffer, "%s\n", uv_nmi_action);
पूर्ण

अटल पूर्णांक param_set_action(स्थिर अक्षर *val, स्थिर काष्ठा kernel_param *kp)
अणु
	पूर्णांक i;
	पूर्णांक n = ARRAY_SIZE(valid_acts);
	अक्षर arg[ACTION_LEN], *p;

	/* (हटाओ possible '\n') */
	म_नकलन(arg, val, ACTION_LEN - 1);
	arg[ACTION_LEN - 1] = '\0';
	p = म_अक्षर(arg, '\n');
	अगर (p)
		*p = '\0';

	क्रम (i = 0; i < n; i++)
		अगर (!म_भेद(arg, valid_acts[i].action))
			अवरोध;

	अगर (i < n) अणु
		म_नकल(uv_nmi_action, arg);
		pr_info("UV: New NMI action:%s\n", uv_nmi_action);
		वापस 0;
	पूर्ण

	pr_err("UV: Invalid NMI action:%s, valid actions are:\n", arg);
	क्रम (i = 0; i < n; i++)
		pr_err("UV: %-8s - %s\n",
			valid_acts[i].action, valid_acts[i].desc);
	वापस -EINVAL;
पूर्ण

अटल स्थिर काष्ठा kernel_param_ops param_ops_action = अणु
	.get = param_get_action,
	.set = param_set_action,
पूर्ण;
#घोषणा param_check_action(name, p) __param_check(name, p, action_t)

module_param_named(action, uv_nmi_action, action, 0644);

अटल अंतरभूत bool uv_nmi_action_is(स्थिर अक्षर *action)
अणु
	वापस (म_भेदन(uv_nmi_action, action, म_माप(action)) == 0);
पूर्ण

/* Setup which NMI support is present in प्रणाली */
अटल व्योम uv_nmi_setup_mmrs(व्योम)
अणु
	/* First determine arch specअगरic MMRs to handshake with BIOS */
	अगर (UVH_EVENT_OCCURRED0_EXTIO_INT0_MASK) अणु
		uvh_nmi_mmrx = UVH_EVENT_OCCURRED0;
		uvh_nmi_mmrx_clear = UVH_EVENT_OCCURRED0_ALIAS;
		uvh_nmi_mmrx_shअगरt = UVH_EVENT_OCCURRED0_EXTIO_INT0_SHFT;
		uvh_nmi_mmrx_type = "OCRD0-EXTIO_INT0";

		uvh_nmi_mmrx_supported = UVH_EXTIO_INT0_BROADCAST;
		uvh_nmi_mmrx_req = UVH_BIOS_KERNEL_MMR_ALIAS_2;
		uvh_nmi_mmrx_req_shअगरt = 62;

	पूर्ण अन्यथा अगर (UVH_EVENT_OCCURRED1_EXTIO_INT0_MASK) अणु
		uvh_nmi_mmrx = UVH_EVENT_OCCURRED1;
		uvh_nmi_mmrx_clear = UVH_EVENT_OCCURRED1_ALIAS;
		uvh_nmi_mmrx_shअगरt = UVH_EVENT_OCCURRED1_EXTIO_INT0_SHFT;
		uvh_nmi_mmrx_type = "OCRD1-EXTIO_INT0";

		uvh_nmi_mmrx_supported = UVH_EXTIO_INT0_BROADCAST;
		uvh_nmi_mmrx_req = UVH_BIOS_KERNEL_MMR_ALIAS_2;
		uvh_nmi_mmrx_req_shअगरt = 62;

	पूर्ण अन्यथा अणु
		pr_err("UV:%s:cannot find EVENT_OCCURRED*_EXTIO_INT0\n",
			__func__);
		वापस;
	पूर्ण

	/* Then find out अगर new NMI is supported */
	अगर (likely(uv_पढ़ो_local_mmr(uvh_nmi_mmrx_supported))) अणु
		uv_ग_लिखो_local_mmr(uvh_nmi_mmrx_req,
					1UL << uvh_nmi_mmrx_req_shअगरt);
		nmi_mmr = uvh_nmi_mmrx;
		nmi_mmr_clear = uvh_nmi_mmrx_clear;
		nmi_mmr_pending = 1UL << uvh_nmi_mmrx_shअगरt;
		pr_info("UV: SMI NMI support: %s\n", uvh_nmi_mmrx_type);
	पूर्ण अन्यथा अणु
		nmi_mmr = UVH_NMI_MMR;
		nmi_mmr_clear = UVH_NMI_MMR_CLEAR;
		nmi_mmr_pending = 1UL << UVH_NMI_MMR_SHIFT;
		pr_info("UV: SMI NMI support: %s\n", UVH_NMI_MMR_TYPE);
	पूर्ण
पूर्ण

/* Read NMI MMR and check अगर NMI flag was set by BMC. */
अटल अंतरभूत पूर्णांक uv_nmi_test_mmr(काष्ठा uv_hub_nmi_s *hub_nmi)
अणु
	hub_nmi->nmi_value = uv_पढ़ो_local_mmr(nmi_mmr);
	atomic_inc(&hub_nmi->पढ़ो_mmr_count);
	वापस !!(hub_nmi->nmi_value & nmi_mmr_pending);
पूर्ण

अटल अंतरभूत व्योम uv_local_mmr_clear_nmi(व्योम)
अणु
	uv_ग_लिखो_local_mmr(nmi_mmr_clear, nmi_mmr_pending);
पूर्ण

/*
 * UV hubless NMI handler functions
 */
अटल अंतरभूत व्योम uv_reनिश्चित_nmi(व्योम)
अणु
	/* (from arch/x86/include/यंत्र/mach_traps.h) */
	outb(0x8f, NMI_CONTROL_PORT);
	inb(NMI_DUMMY_PORT);		/* dummy पढ़ो */
	outb(0x0f, NMI_CONTROL_PORT);
	inb(NMI_DUMMY_PORT);		/* dummy पढ़ो */
पूर्ण

अटल व्योम uv_init_hubless_pch_io(पूर्णांक offset, पूर्णांक mask, पूर्णांक data)
अणु
	पूर्णांक *addr = PCH_PCR_GPIO_ADDRESS(offset);
	पूर्णांक पढ़ोd = पढ़ोl(addr);

	अगर (mask) अणु			/* OR in new data */
		पूर्णांक ग_लिखोd = (पढ़ोd & ~mask) | data;

		nmi_debug("UV:PCH: %p = %x & %x | %x (%x)\n",
			addr, पढ़ोd, ~mask, data, ग_लिखोd);
		ग_लिखोl(ग_लिखोd, addr);
	पूर्ण अन्यथा अगर (पढ़ोd & data) अणु	/* clear status bit */
		nmi_debug("UV:PCH: %p = %x\n", addr, data);
		ग_लिखोl(data, addr);
	पूर्ण

	(व्योम)पढ़ोl(addr);		/* flush ग_लिखो data */
पूर्ण

अटल व्योम uv_nmi_setup_hubless_पूर्णांकr(व्योम)
अणु
	uv_pch_पूर्णांकr_now_enabled = uv_pch_पूर्णांकr_enable;

	uv_init_hubless_pch_io(
		PAD_CFG_DW0_GPP_D_0, GPIROUTNMI,
		uv_pch_पूर्णांकr_now_enabled ? GPIROUTNMI : 0);

	nmi_debug("UV:NMI: GPP_D_0 interrupt %s\n",
		uv_pch_पूर्णांकr_now_enabled ? "enabled" : "disabled");
पूर्ण

अटल काष्ठा init_nmi अणु
	अचिन्हित पूर्णांक	offset;
	अचिन्हित पूर्णांक	mask;
	अचिन्हित पूर्णांक	data;
पूर्ण init_nmi[] = अणु
	अणु	/* HOSTSW_OWN_GPP_D_0 */
	.offset = 0x84,
	.mask = 0x1,
	.data = 0x0,	/* ACPI Mode */
	पूर्ण,

/* Clear status: */
	अणु	/* GPI_INT_STS_GPP_D_0 */
	.offset = 0x104,
	.mask = 0x0,
	.data = 0x1,	/* Clear Status */
	पूर्ण,
	अणु	/* GPI_GPE_STS_GPP_D_0 */
	.offset = 0x124,
	.mask = 0x0,
	.data = 0x1,	/* Clear Status */
	पूर्ण,
	अणु	/* GPI_SMI_STS_GPP_D_0 */
	.offset = 0x144,
	.mask = 0x0,
	.data = 0x1,	/* Clear Status */
	पूर्ण,
	अणु	/* GPI_NMI_STS_GPP_D_0 */
	.offset = 0x164,
	.mask = 0x0,
	.data = 0x1,	/* Clear Status */
	पूर्ण,

/* Disable पूर्णांकerrupts: */
	अणु	/* GPI_INT_EN_GPP_D_0 */
	.offset = 0x114,
	.mask = 0x1,
	.data = 0x0,	/* Disable पूर्णांकerrupt generation */
	पूर्ण,
	अणु	/* GPI_GPE_EN_GPP_D_0 */
	.offset = 0x134,
	.mask = 0x1,
	.data = 0x0,	/* Disable पूर्णांकerrupt generation */
	पूर्ण,
	अणु	/* GPI_SMI_EN_GPP_D_0 */
	.offset = 0x154,
	.mask = 0x1,
	.data = 0x0,	/* Disable पूर्णांकerrupt generation */
	पूर्ण,
	अणु	/* GPI_NMI_EN_GPP_D_0 */
	.offset = 0x174,
	.mask = 0x1,
	.data = 0x0,	/* Disable पूर्णांकerrupt generation */
	पूर्ण,

/* Setup GPP_D_0 Pad Config: */
	अणु	/* PAD_CFG_DW0_GPP_D_0 */
	.offset = 0x4c0,
	.mask = 0xffffffff,
	.data = 0x82020100,
/*
 *  31:30 Pad Reset Config (PADRSTCFG): = 2h  # PLTRST# (शेष)
 *
 *  29    RX Pad State Select (RXPADSTSEL): = 0 # Raw RX pad state directly
 *                                                from RX buffer (शेष)
 *
 *  28    RX Raw Override to '1' (RXRAW1): = 0 # No Override
 *
 *  26:25 RX Level/Edge Configuration (RXEVCFG):
 *      = 0h # Level
 *      = 1h # Edge
 *
 *  23    RX Invert (RXINV): = 0 # No Inversion (संकेत active high)
 *
 *  20    GPIO Input Route IOxAPIC (GPIROUTIOXAPIC):
 * = 0 # Routing करोes not cause peripheral IRQ...
 *     # (we want an NMI not an IRQ)
 *
 *  19    GPIO Input Route SCI (GPIROUTSCI): = 0 # Routing करोes not cause SCI.
 *  18    GPIO Input Route SMI (GPIROUTSMI): = 0 # Routing करोes not cause SMI.
 *  17    GPIO Input Route NMI (GPIROUTNMI): = 1 # Routing can cause NMI.
 *
 *  11:10 Pad Mode (PMODE1/0): = 0h = GPIO control the Pad.
 *   9    GPIO RX Disable (GPIORXDIS):
 * = 0 # Enable the input buffer (active low enable)
 *
 *   8    GPIO TX Disable (GPIOTXDIS):
 * = 1 # Disable the output buffer; i.e. Hi-Z
 *
 *   1 GPIO RX State (GPIORXSTATE): This is the current पूर्णांकernal RX pad state..
 *   0 GPIO TX State (GPIOTXSTATE):
 * = 0 # (Leave at शेष)
 */
	पूर्ण,

/* Pad Config DW1 */
	अणु	/* PAD_CFG_DW1_GPP_D_0 */
	.offset = 0x4c4,
	.mask = 0x3c00,
	.data = 0,	/* Termination = none (शेष) */
	पूर्ण,
पूर्ण;

अटल व्योम uv_init_hubless_pch_d0(व्योम)
अणु
	पूर्णांक i, पढ़ो;

	पढ़ो = *PCH_PCR_GPIO_ADDRESS(PAD_OWN_GPP_D_0);
	अगर (पढ़ो != 0) अणु
		pr_info("UV: Hubless NMI already configured\n");
		वापस;
	पूर्ण

	nmi_debug("UV: Initializing UV Hubless NMI on PCH\n");
	क्रम (i = 0; i < ARRAY_SIZE(init_nmi); i++) अणु
		uv_init_hubless_pch_io(init_nmi[i].offset,
					init_nmi[i].mask,
					init_nmi[i].data);
	पूर्ण
पूर्ण

अटल पूर्णांक uv_nmi_test_hubless(काष्ठा uv_hub_nmi_s *hub_nmi)
अणु
	पूर्णांक *pstat = PCH_PCR_GPIO_ADDRESS(GPI_NMI_STS_GPP_D_0);
	पूर्णांक status = *pstat;

	hub_nmi->nmi_value = status;
	atomic_inc(&hub_nmi->पढ़ो_mmr_count);

	अगर (!(status & STS_GPP_D_0_MASK))	/* Not a UV बाह्यal NMI */
		वापस 0;

	*pstat = STS_GPP_D_0_MASK;	/* Is a UV NMI: clear GPP_D_0 status */
	(व्योम)*pstat;			/* Flush ग_लिखो */

	वापस 1;
पूर्ण

अटल पूर्णांक uv_test_nmi(काष्ठा uv_hub_nmi_s *hub_nmi)
अणु
	अगर (hub_nmi->hub_present)
		वापस uv_nmi_test_mmr(hub_nmi);

	अगर (hub_nmi->pch_owner)		/* Only PCH owner can check status */
		वापस uv_nmi_test_hubless(hub_nmi);

	वापस -1;
पूर्ण

/*
 * If first CPU in on this hub, set hub_nmi "in_nmi" and "owner" values and
 * वापस true.  If first CPU in on the प्रणाली, set global "in_nmi" flag.
 */
अटल पूर्णांक uv_set_in_nmi(पूर्णांक cpu, काष्ठा uv_hub_nmi_s *hub_nmi)
अणु
	पूर्णांक first = atomic_add_unless(&hub_nmi->in_nmi, 1, 1);

	अगर (first) अणु
		atomic_set(&hub_nmi->cpu_owner, cpu);
		अगर (atomic_add_unless(&uv_in_nmi, 1, 1))
			atomic_set(&uv_nmi_cpu, cpu);

		atomic_inc(&hub_nmi->nmi_count);
	पूर्ण
	वापस first;
पूर्ण

/* Check अगर this is a प्रणाली NMI event */
अटल पूर्णांक uv_check_nmi(काष्ठा uv_hub_nmi_s *hub_nmi)
अणु
	पूर्णांक cpu = smp_processor_id();
	पूर्णांक nmi = 0;
	पूर्णांक nmi_detected = 0;

	local64_inc(&uv_nmi_count);
	this_cpu_inc(uv_cpu_nmi.queries);

	करो अणु
		nmi = atomic_पढ़ो(&hub_nmi->in_nmi);
		अगर (nmi)
			अवरोध;

		अगर (raw_spin_trylock(&hub_nmi->nmi_lock)) अणु
			nmi_detected = uv_test_nmi(hub_nmi);

			/* Check flag क्रम UV बाह्यal NMI */
			अगर (nmi_detected > 0) अणु
				uv_set_in_nmi(cpu, hub_nmi);
				nmi = 1;
				अवरोध;
			पूर्ण

			/* A non-PCH node in a hubless प्रणाली रुकोs क्रम NMI */
			अन्यथा अगर (nmi_detected < 0)
				जाओ slave_रुको;

			/* MMR/PCH NMI flag is clear */
			raw_spin_unlock(&hub_nmi->nmi_lock);

		पूर्ण अन्यथा अणु

			/* Wait a moment क्रम the HUB NMI locker to set flag */
slave_रुको:		cpu_relax();
			udelay(uv_nmi_slave_delay);

			/* Re-check hub in_nmi flag */
			nmi = atomic_पढ़ो(&hub_nmi->in_nmi);
			अगर (nmi)
				अवरोध;
		पूर्ण

		/*
		 * Check अगर this BMC missed setting the MMR NMI flag (or)
		 * UV hubless प्रणाली where only PCH owner can check flag
		 */
		अगर (!nmi) अणु
			nmi = atomic_पढ़ो(&uv_in_nmi);
			अगर (nmi)
				uv_set_in_nmi(cpu, hub_nmi);
		पूर्ण

		/* If we're holding the hub lock, release it now */
		अगर (nmi_detected < 0)
			raw_spin_unlock(&hub_nmi->nmi_lock);

	पूर्ण जबतक (0);

	अगर (!nmi)
		local64_inc(&uv_nmi_misses);

	वापस nmi;
पूर्ण

/* Need to reset the NMI MMR रेजिस्टर, but only once per hub. */
अटल अंतरभूत व्योम uv_clear_nmi(पूर्णांक cpu)
अणु
	काष्ठा uv_hub_nmi_s *hub_nmi = uv_hub_nmi;

	अगर (cpu == atomic_पढ़ो(&hub_nmi->cpu_owner)) अणु
		atomic_set(&hub_nmi->cpu_owner, -1);
		atomic_set(&hub_nmi->in_nmi, 0);
		अगर (hub_nmi->hub_present)
			uv_local_mmr_clear_nmi();
		अन्यथा
			uv_reनिश्चित_nmi();
		raw_spin_unlock(&hub_nmi->nmi_lock);
	पूर्ण
पूर्ण

/* Ping non-responding CPU's attempting to क्रमce them पूर्णांकo the NMI handler */
अटल व्योम uv_nmi_nr_cpus_ping(व्योम)
अणु
	पूर्णांक cpu;

	क्रम_each_cpu(cpu, uv_nmi_cpu_mask)
		uv_cpu_nmi_per(cpu).pinging = 1;

	apic->send_IPI_mask(uv_nmi_cpu_mask, APIC_DM_NMI);
पूर्ण

/* Clean up flags क्रम CPU's that ignored both NMI and ping */
अटल व्योम uv_nmi_cleanup_mask(व्योम)
अणु
	पूर्णांक cpu;

	क्रम_each_cpu(cpu, uv_nmi_cpu_mask) अणु
		uv_cpu_nmi_per(cpu).pinging =  0;
		uv_cpu_nmi_per(cpu).state = UV_NMI_STATE_OUT;
		cpumask_clear_cpu(cpu, uv_nmi_cpu_mask);
	पूर्ण
पूर्ण

/* Loop रुकोing as CPU's enter NMI handler */
अटल पूर्णांक uv_nmi_रुको_cpus(पूर्णांक first)
अणु
	पूर्णांक i, j, k, n = num_online_cpus();
	पूर्णांक last_k = 0, रुकोing = 0;
	पूर्णांक cpu = smp_processor_id();

	अगर (first) अणु
		cpumask_copy(uv_nmi_cpu_mask, cpu_online_mask);
		k = 0;
	पूर्ण अन्यथा अणु
		k = n - cpumask_weight(uv_nmi_cpu_mask);
	पूर्ण

	/* PCH NMI causes only one CPU to respond */
	अगर (first && uv_pch_पूर्णांकr_now_enabled) अणु
		cpumask_clear_cpu(cpu, uv_nmi_cpu_mask);
		वापस n - k - 1;
	पूर्ण

	udelay(uv_nmi_initial_delay);
	क्रम (i = 0; i < uv_nmi_retry_count; i++) अणु
		पूर्णांक loop_delay = uv_nmi_loop_delay;

		क्रम_each_cpu(j, uv_nmi_cpu_mask) अणु
			अगर (uv_cpu_nmi_per(j).state) अणु
				cpumask_clear_cpu(j, uv_nmi_cpu_mask);
				अगर (++k >= n)
					अवरोध;
			पूर्ण
		पूर्ण
		अगर (k >= n) अणु		/* all in? */
			k = n;
			अवरोध;
		पूर्ण
		अगर (last_k != k) अणु	/* पात अगर no new CPU's coming in */
			last_k = k;
			रुकोing = 0;
		पूर्ण अन्यथा अगर (++रुकोing > uv_nmi_रुको_count)
			अवरोध;

		/* Extend delay अगर रुकोing only क्रम CPU 0: */
		अगर (रुकोing && (n - k) == 1 &&
		    cpumask_test_cpu(0, uv_nmi_cpu_mask))
			loop_delay *= 100;

		udelay(loop_delay);
	पूर्ण
	atomic_set(&uv_nmi_cpus_in_nmi, k);
	वापस n - k;
पूर्ण

/* Wait until all slave CPU's have entered UV NMI handler */
अटल व्योम uv_nmi_रुको(पूर्णांक master)
अणु
	/* Indicate this CPU is in: */
	this_cpu_ग_लिखो(uv_cpu_nmi.state, UV_NMI_STATE_IN);

	/* If not the first CPU in (the master), then we are a slave CPU */
	अगर (!master)
		वापस;

	करो अणु
		/* Wait क्रम all other CPU's to gather here */
		अगर (!uv_nmi_रुको_cpus(1))
			अवरोध;

		/* If not all made it in, send IPI NMI to them */
		pr_alert("UV: Sending NMI IPI to %d CPUs: %*pbl\n",
			 cpumask_weight(uv_nmi_cpu_mask),
			 cpumask_pr_args(uv_nmi_cpu_mask));

		uv_nmi_nr_cpus_ping();

		/* If all CPU's are in, then करोne */
		अगर (!uv_nmi_रुको_cpus(0))
			अवरोध;

		pr_alert("UV: %d CPUs not in NMI loop: %*pbl\n",
			 cpumask_weight(uv_nmi_cpu_mask),
			 cpumask_pr_args(uv_nmi_cpu_mask));
	पूर्ण जबतक (0);

	pr_alert("UV: %d of %d CPUs in NMI\n",
		atomic_पढ़ो(&uv_nmi_cpus_in_nmi), num_online_cpus());
पूर्ण

/* Dump Inकाष्ठाion Poपूर्णांकer header */
अटल व्योम uv_nmi_dump_cpu_ip_hdr(व्योम)
अणु
	pr_info("\nUV: %4s %6s %-32s %s   (Note: PID 0 not listed)\n",
		"CPU", "PID", "COMMAND", "IP");
पूर्ण

/* Dump Inकाष्ठाion Poपूर्णांकer info */
अटल व्योम uv_nmi_dump_cpu_ip(पूर्णांक cpu, काष्ठा pt_regs *regs)
अणु
	pr_info("UV: %4d %6d %-32.32s %pS",
		cpu, current->pid, current->comm, (व्योम *)regs->ip);
पूर्ण

/*
 * Dump this CPU's state.  If action was set to "kdump" and the crash_kexec
 * failed, then we provide "dump" as an alternate action.  Action "dump" now
 * also includes the show "ips" (inकाष्ठाion poपूर्णांकers) action whereas the
 * action "ips" only displays inकाष्ठाion poपूर्णांकers क्रम the non-idle CPU's.
 * This is an abbreviated क्रमm of the "ps" command.
 */
अटल व्योम uv_nmi_dump_state_cpu(पूर्णांक cpu, काष्ठा pt_regs *regs)
अणु
	स्थिर अक्षर *करोts = " ................................. ";

	अगर (cpu == 0)
		uv_nmi_dump_cpu_ip_hdr();

	अगर (current->pid != 0 || !uv_nmi_action_is("ips"))
		uv_nmi_dump_cpu_ip(cpu, regs);

	अगर (uv_nmi_action_is("dump")) अणु
		pr_info("UV:%sNMI process trace for CPU %d\n", करोts, cpu);
		show_regs(regs);
	पूर्ण

	this_cpu_ग_लिखो(uv_cpu_nmi.state, UV_NMI_STATE_DUMP_DONE);
पूर्ण

/* Trigger a slave CPU to dump it's state */
अटल व्योम uv_nmi_trigger_dump(पूर्णांक cpu)
अणु
	पूर्णांक retry = uv_nmi_trigger_delay;

	अगर (uv_cpu_nmi_per(cpu).state != UV_NMI_STATE_IN)
		वापस;

	uv_cpu_nmi_per(cpu).state = UV_NMI_STATE_DUMP;
	करो अणु
		cpu_relax();
		udelay(10);
		अगर (uv_cpu_nmi_per(cpu).state
				!= UV_NMI_STATE_DUMP)
			वापस;
	पूर्ण जबतक (--retry > 0);

	pr_crit("UV: CPU %d stuck in process dump function\n", cpu);
	uv_cpu_nmi_per(cpu).state = UV_NMI_STATE_DUMP_DONE;
पूर्ण

/* Wait until all CPU's पढ़ोy to निकास */
अटल व्योम uv_nmi_sync_निकास(पूर्णांक master)
अणु
	atomic_dec(&uv_nmi_cpus_in_nmi);
	अगर (master) अणु
		जबतक (atomic_पढ़ो(&uv_nmi_cpus_in_nmi) > 0)
			cpu_relax();
		atomic_set(&uv_nmi_slave_जारी, SLAVE_CLEAR);
	पूर्ण अन्यथा अणु
		जबतक (atomic_पढ़ो(&uv_nmi_slave_जारी))
			cpu_relax();
	पूर्ण
पूर्ण

/* Current "health" check is to check which CPU's are responsive */
अटल व्योम uv_nmi_action_health(पूर्णांक cpu, काष्ठा pt_regs *regs, पूर्णांक master)
अणु
	अगर (master) अणु
		पूर्णांक in = atomic_पढ़ो(&uv_nmi_cpus_in_nmi);
		पूर्णांक out = num_online_cpus() - in;

		pr_alert("UV: NMI CPU health check (non-responding:%d)\n", out);
		atomic_set(&uv_nmi_slave_जारी, SLAVE_EXIT);
	पूर्ण अन्यथा अणु
		जबतक (!atomic_पढ़ो(&uv_nmi_slave_जारी))
			cpu_relax();
	पूर्ण
	uv_nmi_sync_निकास(master);
पूर्ण

/* Walk through CPU list and dump state of each */
अटल व्योम uv_nmi_dump_state(पूर्णांक cpu, काष्ठा pt_regs *regs, पूर्णांक master)
अणु
	अगर (master) अणु
		पूर्णांक tcpu;
		पूर्णांक ignored = 0;
		पूर्णांक saved_console_loglevel = console_loglevel;

		pr_alert("UV: tracing %s for %d CPUs from CPU %d\n",
			uv_nmi_action_is("ips") ? "IPs" : "processes",
			atomic_पढ़ो(&uv_nmi_cpus_in_nmi), cpu);

		console_loglevel = uv_nmi_loglevel;
		atomic_set(&uv_nmi_slave_जारी, SLAVE_EXIT);
		क्रम_each_online_cpu(tcpu) अणु
			अगर (cpumask_test_cpu(tcpu, uv_nmi_cpu_mask))
				ignored++;
			अन्यथा अगर (tcpu == cpu)
				uv_nmi_dump_state_cpu(tcpu, regs);
			अन्यथा
				uv_nmi_trigger_dump(tcpu);
		पूर्ण
		अगर (ignored)
			pr_alert("UV: %d CPUs ignored NMI\n", ignored);

		console_loglevel = saved_console_loglevel;
		pr_alert("UV: process trace complete\n");
	पूर्ण अन्यथा अणु
		जबतक (!atomic_पढ़ो(&uv_nmi_slave_जारी))
			cpu_relax();
		जबतक (this_cpu_पढ़ो(uv_cpu_nmi.state) != UV_NMI_STATE_DUMP)
			cpu_relax();
		uv_nmi_dump_state_cpu(cpu, regs);
	पूर्ण
	uv_nmi_sync_निकास(master);
पूर्ण

अटल व्योम uv_nmi_touch_watchकरोgs(व्योम)
अणु
	touch_softlockup_watchकरोg_sync();
	घड़ीsource_touch_watchकरोg();
	rcu_cpu_stall_reset();
	touch_nmi_watchकरोg();
पूर्ण

अटल व्योम uv_nmi_kdump(पूर्णांक cpu, पूर्णांक मुख्य, काष्ठा pt_regs *regs)
अणु
	/* Check अगर kdump kernel loaded क्रम both मुख्य and secondary CPUs */
	अगर (!kexec_crash_image) अणु
		अगर (मुख्य)
			pr_err("UV: NMI error: kdump kernel not loaded\n");
		वापस;
	पूर्ण

	/* Call crash to dump प्रणाली state */
	अगर (मुख्य) अणु
		pr_emerg("UV: NMI executing crash_kexec on CPU%d\n", cpu);
		crash_kexec(regs);

		pr_emerg("UV: crash_kexec unexpectedly returned\n");
		atomic_set(&uv_nmi_kexec_failed, 1);

	पूर्ण अन्यथा अणु /* secondary */

		/* If kdump kernel fails, secondaries will निकास this loop */
		जबतक (atomic_पढ़ो(&uv_nmi_kexec_failed) == 0) अणु

			/* Once shootकरोwn cpus starts, they करो not वापस */
			run_crash_ipi_callback(regs);

			mdelay(10);
		पूर्ण
	पूर्ण
पूर्ण

#अगर_घोषित CONFIG_KGDB
#अगर_घोषित CONFIG_KGDB_KDB
अटल अंतरभूत पूर्णांक uv_nmi_kdb_reason(व्योम)
अणु
	वापस KDB_REASON_SYSTEM_NMI;
पूर्ण
#अन्यथा /* !CONFIG_KGDB_KDB */
अटल अंतरभूत पूर्णांक uv_nmi_kdb_reason(व्योम)
अणु
	/* Ensure user is expecting to attach gdb remote */
	अगर (uv_nmi_action_is("kgdb"))
		वापस 0;

	pr_err("UV: NMI error: KDB is not enabled in this kernel\n");
	वापस -1;
पूर्ण
#पूर्ण_अगर /* CONFIG_KGDB_KDB */

/*
 * Call KGDB/KDB from NMI handler
 *
 * Note that अगर both KGDB and KDB are configured, then the action of 'kgdb' or
 * 'kdb' has no affect on which is used.  See the KGDB करोcumentation क्रम further
 * inक्रमmation.
 */
अटल व्योम uv_call_kgdb_kdb(पूर्णांक cpu, काष्ठा pt_regs *regs, पूर्णांक master)
अणु
	अगर (master) अणु
		पूर्णांक reason = uv_nmi_kdb_reason();
		पूर्णांक ret;

		अगर (reason < 0)
			वापस;

		/* Call KGDB NMI handler as MASTER */
		ret = kgdb_nmicallin(cpu, X86_TRAP_NMI, regs, reason,
				&uv_nmi_slave_जारी);
		अगर (ret) अणु
			pr_alert("KGDB returned error, is kgdboc set?\n");
			atomic_set(&uv_nmi_slave_जारी, SLAVE_EXIT);
		पूर्ण
	पूर्ण अन्यथा अणु
		/* Wait क्रम KGDB संकेत that it's पढ़ोy क्रम slaves to enter */
		पूर्णांक sig;

		करो अणु
			cpu_relax();
			sig = atomic_पढ़ो(&uv_nmi_slave_जारी);
		पूर्ण जबतक (!sig);

		/* Call KGDB as slave */
		अगर (sig == SLAVE_CONTINUE)
			kgdb_nmicallback(cpu, regs);
	पूर्ण
	uv_nmi_sync_निकास(master);
पूर्ण

#अन्यथा /* !CONFIG_KGDB */
अटल अंतरभूत व्योम uv_call_kgdb_kdb(पूर्णांक cpu, काष्ठा pt_regs *regs, पूर्णांक master)
अणु
	pr_err("UV: NMI error: KGDB is not enabled in this kernel\n");
पूर्ण
#पूर्ण_अगर /* !CONFIG_KGDB */

/*
 * UV NMI handler
 */
अटल पूर्णांक uv_handle_nmi(अचिन्हित पूर्णांक reason, काष्ठा pt_regs *regs)
अणु
	काष्ठा uv_hub_nmi_s *hub_nmi = uv_hub_nmi;
	पूर्णांक cpu = smp_processor_id();
	पूर्णांक master = 0;
	अचिन्हित दीर्घ flags;

	local_irq_save(flags);

	/* If not a UV System NMI, ignore */
	अगर (!this_cpu_पढ़ो(uv_cpu_nmi.pinging) && !uv_check_nmi(hub_nmi)) अणु
		local_irq_restore(flags);
		वापस NMI_DONE;
	पूर्ण

	/* Indicate we are the first CPU पूर्णांकo the NMI handler */
	master = (atomic_पढ़ो(&uv_nmi_cpu) == cpu);

	/* If NMI action is "kdump", then attempt to करो it */
	अगर (uv_nmi_action_is("kdump")) अणु
		uv_nmi_kdump(cpu, master, regs);

		/* Unexpected वापस, revert action to "dump" */
		अगर (master)
			म_नकलन(uv_nmi_action, "dump", म_माप(uv_nmi_action));
	पूर्ण

	/* Pause as all CPU's enter the NMI handler */
	uv_nmi_रुको(master);

	/* Process actions other than "kdump": */
	अगर (uv_nmi_action_is("health")) अणु
		uv_nmi_action_health(cpu, regs, master);
	पूर्ण अन्यथा अगर (uv_nmi_action_is("ips") || uv_nmi_action_is("dump")) अणु
		uv_nmi_dump_state(cpu, regs, master);
	पूर्ण अन्यथा अगर (uv_nmi_action_is("kdb") || uv_nmi_action_is("kgdb")) अणु
		uv_call_kgdb_kdb(cpu, regs, master);
	पूर्ण अन्यथा अणु
		अगर (master)
			pr_alert("UV: unknown NMI action: %s\n", uv_nmi_action);
		uv_nmi_sync_निकास(master);
	पूर्ण

	/* Clear per_cpu "in_nmi" flag */
	this_cpu_ग_लिखो(uv_cpu_nmi.state, UV_NMI_STATE_OUT);

	/* Clear MMR NMI flag on each hub */
	uv_clear_nmi(cpu);

	/* Clear global flags */
	अगर (master) अणु
		अगर (cpumask_weight(uv_nmi_cpu_mask))
			uv_nmi_cleanup_mask();
		atomic_set(&uv_nmi_cpus_in_nmi, -1);
		atomic_set(&uv_nmi_cpu, -1);
		atomic_set(&uv_in_nmi, 0);
		atomic_set(&uv_nmi_kexec_failed, 0);
		atomic_set(&uv_nmi_slave_जारी, SLAVE_CLEAR);
	पूर्ण

	uv_nmi_touch_watchकरोgs();
	local_irq_restore(flags);

	वापस NMI_HANDLED;
पूर्ण

/*
 * NMI handler क्रम pulling in CPU's when perf events are grabbing our NMI
 */
अटल पूर्णांक uv_handle_nmi_ping(अचिन्हित पूर्णांक reason, काष्ठा pt_regs *regs)
अणु
	पूर्णांक ret;

	this_cpu_inc(uv_cpu_nmi.queries);
	अगर (!this_cpu_पढ़ो(uv_cpu_nmi.pinging)) अणु
		local64_inc(&uv_nmi_ping_misses);
		वापस NMI_DONE;
	पूर्ण

	this_cpu_inc(uv_cpu_nmi.pings);
	local64_inc(&uv_nmi_ping_count);
	ret = uv_handle_nmi(reason, regs);
	this_cpu_ग_लिखो(uv_cpu_nmi.pinging, 0);
	वापस ret;
पूर्ण

अटल व्योम uv_रेजिस्टर_nmi_notअगरier(व्योम)
अणु
	अगर (रेजिस्टर_nmi_handler(NMI_UNKNOWN, uv_handle_nmi, 0, "uv"))
		pr_warn("UV: NMI handler failed to register\n");

	अगर (रेजिस्टर_nmi_handler(NMI_LOCAL, uv_handle_nmi_ping, 0, "uvping"))
		pr_warn("UV: PING NMI handler failed to register\n");
पूर्ण

व्योम uv_nmi_init(व्योम)
अणु
	अचिन्हित पूर्णांक value;

	/*
	 * Unmask NMI on all CPU's
	 */
	value = apic_पढ़ो(APIC_LVT1) | APIC_DM_NMI;
	value &= ~APIC_LVT_MASKED;
	apic_ग_लिखो(APIC_LVT1, value);
पूर्ण

/* Setup HUB NMI info */
अटल व्योम __init uv_nmi_setup_common(bool hubbed)
अणु
	पूर्णांक size = माप(व्योम *) * (1 << NODES_SHIFT);
	पूर्णांक cpu;

	uv_hub_nmi_list = kzalloc(size, GFP_KERNEL);
	nmi_debug("UV: NMI hub list @ 0x%p (%d)\n", uv_hub_nmi_list, size);
	BUG_ON(!uv_hub_nmi_list);
	size = माप(काष्ठा uv_hub_nmi_s);
	क्रम_each_present_cpu(cpu) अणु
		पूर्णांक nid = cpu_to_node(cpu);
		अगर (uv_hub_nmi_list[nid] == शून्य) अणु
			uv_hub_nmi_list[nid] = kzalloc_node(size,
							    GFP_KERNEL, nid);
			BUG_ON(!uv_hub_nmi_list[nid]);
			raw_spin_lock_init(&(uv_hub_nmi_list[nid]->nmi_lock));
			atomic_set(&uv_hub_nmi_list[nid]->cpu_owner, -1);
			uv_hub_nmi_list[nid]->hub_present = hubbed;
			uv_hub_nmi_list[nid]->pch_owner = (nid == 0);
		पूर्ण
		uv_hub_nmi_per(cpu) = uv_hub_nmi_list[nid];
	पूर्ण
	BUG_ON(!alloc_cpumask_var(&uv_nmi_cpu_mask, GFP_KERNEL));
पूर्ण

/* Setup क्रम UV Hub प्रणालीs */
व्योम __init uv_nmi_setup(व्योम)
अणु
	uv_nmi_setup_mmrs();
	uv_nmi_setup_common(true);
	uv_रेजिस्टर_nmi_notअगरier();
	pr_info("UV: Hub NMI enabled\n");
पूर्ण

/* Setup क्रम UV Hubless प्रणालीs */
व्योम __init uv_nmi_setup_hubless(व्योम)
अणु
	uv_nmi_setup_common(false);
	pch_base = xlate_dev_mem_ptr(PCH_PCR_GPIO_1_BASE);
	nmi_debug("UV: PCH base:%p from 0x%lx, GPP_D_0\n",
		pch_base, PCH_PCR_GPIO_1_BASE);
	अगर (uv_pch_init_enable)
		uv_init_hubless_pch_d0();
	uv_init_hubless_pch_io(GPI_NMI_ENA_GPP_D_0,
				STS_GPP_D_0_MASK, STS_GPP_D_0_MASK);
	uv_nmi_setup_hubless_पूर्णांकr();
	/* Ensure NMI enabled in Processor Interface Reg: */
	uv_reनिश्चित_nmi();
	uv_रेजिस्टर_nmi_notअगरier();
	pr_info("UV: PCH NMI enabled\n");
पूर्ण
