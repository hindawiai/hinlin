<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0
/* ptrace.c */
/* By Ross Biro 1/23/92 */
/* edited by Linus Torvalds */
/* mangled further by Bob Manson (manson@santafe.edu) */
/* more mutilation by David Mosberger (davidm@azstarnet.com) */

#समावेश <linux/kernel.h>
#समावेश <linux/sched.h>
#समावेश <linux/sched/task_stack.h>
#समावेश <linux/mm.h>
#समावेश <linux/smp.h>
#समावेश <linux/त्रुटिसं.स>
#समावेश <linux/ptrace.h>
#समावेश <linux/user.h>
#समावेश <linux/security.h>
#समावेश <linux/संकेत.स>
#समावेश <linux/tracehook.h>
#समावेश <linux/audit.h>

#समावेश <linux/uaccess.h>
#समावेश <यंत्र/fpu.h>

#समावेश "proto.h"

#घोषणा DEBUG	DBG_MEM
#अघोषित DEBUG

#अगर_घोषित DEBUG
क्रमागत अणु
	DBG_MEM		= (1<<0),
	DBG_BPT		= (1<<1),
	DBG_MEM_ALL	= (1<<2)
पूर्ण;
#घोषणा DBG(fac,args)	अणुअगर ((fac) & DEBUG) prपूर्णांकk args;पूर्ण
#अन्यथा
#घोषणा DBG(fac,args)
#पूर्ण_अगर

#घोषणा BREAKINST	0x00000080	/* call_pal bpt */

/*
 * करोes not yet catch संकेतs sent when the child dies.
 * in निकास.c or in संकेत.c.
 */

/*
 * Processes always block with the following stack-layout:
 *
 *  +================================+ <---- task + 2*PAGE_SIZE
 *  | PALcode saved frame (ps, pc,   | ^
 *  | gp, a0, a1, a2)		     | |
 *  +================================+ | काष्ठा pt_regs
 *  |	        		     | |
 *  | frame generated by SAVE_ALL    | |
 *  |	        		     | v
 *  +================================+
 *  |	        		     | ^
 *  | frame saved by करो_चयन_stack | | काष्ठा चयन_stack
 *  |	        		     | v
 *  +================================+
 */

/* 
 * The following table maps a रेजिस्टर index पूर्णांकo the stack offset at
 * which the रेजिस्टर is saved.  Register indices are 0-31 क्रम पूर्णांकeger
 * regs, 32-63 क्रम fp regs, and 64 क्रम the pc.  Notice that sp and
 * zero have no stack-slot and need to be treated specially (see
 * get_reg/put_reg below).
 */
क्रमागत अणु
	REG_R0 = 0, REG_F0 = 32, REG_FPCR = 63, REG_PC = 64
पूर्ण;

#घोषणा PT_REG(reg) \
  (PAGE_SIZE*2 - माप(काष्ठा pt_regs) + दुरत्व(काष्ठा pt_regs, reg))

#घोषणा SW_REG(reg) \
 (PAGE_SIZE*2 - माप(काष्ठा pt_regs) - माप(काष्ठा चयन_stack) \
  + दुरत्व(काष्ठा चयन_stack, reg))

अटल पूर्णांक regoff[] = अणु
	PT_REG(	   r0), PT_REG(	   r1), PT_REG(	   r2), PT_REG(	  r3),
	PT_REG(	   r4), PT_REG(	   r5), PT_REG(	   r6), PT_REG(	  r7),
	PT_REG(	   r8), SW_REG(	   r9), SW_REG(	  r10), SW_REG(	 r11),
	SW_REG(	  r12), SW_REG(	  r13), SW_REG(	  r14), SW_REG(	 r15),
	PT_REG(	  r16), PT_REG(	  r17), PT_REG(	  r18), PT_REG(	 r19),
	PT_REG(	  r20), PT_REG(	  r21), PT_REG(	  r22), PT_REG(	 r23),
	PT_REG(	  r24), PT_REG(	  r25), PT_REG(	  r26), PT_REG(	 r27),
	PT_REG(	  r28), PT_REG(	   gp),		   -1,		   -1,
	SW_REG(fp[ 0]), SW_REG(fp[ 1]), SW_REG(fp[ 2]), SW_REG(fp[ 3]),
	SW_REG(fp[ 4]), SW_REG(fp[ 5]), SW_REG(fp[ 6]), SW_REG(fp[ 7]),
	SW_REG(fp[ 8]), SW_REG(fp[ 9]), SW_REG(fp[10]), SW_REG(fp[11]),
	SW_REG(fp[12]), SW_REG(fp[13]), SW_REG(fp[14]), SW_REG(fp[15]),
	SW_REG(fp[16]), SW_REG(fp[17]), SW_REG(fp[18]), SW_REG(fp[19]),
	SW_REG(fp[20]), SW_REG(fp[21]), SW_REG(fp[22]), SW_REG(fp[23]),
	SW_REG(fp[24]), SW_REG(fp[25]), SW_REG(fp[26]), SW_REG(fp[27]),
	SW_REG(fp[28]), SW_REG(fp[29]), SW_REG(fp[30]), SW_REG(fp[31]),
	PT_REG(	   pc)
पूर्ण;

अटल अचिन्हित दीर्घ zero;

/*
 * Get address of रेजिस्टर REGNO in task TASK.
 */
अटल अचिन्हित दीर्घ *
get_reg_addr(काष्ठा task_काष्ठा * task, अचिन्हित दीर्घ regno)
अणु
	अचिन्हित दीर्घ *addr;

	अगर (regno == 30) अणु
		addr = &task_thपढ़ो_info(task)->pcb.usp;
	पूर्ण अन्यथा अगर (regno == 65) अणु
		addr = &task_thपढ़ो_info(task)->pcb.unique;
	पूर्ण अन्यथा अगर (regno == 31 || regno > 65) अणु
		zero = 0;
		addr = &zero;
	पूर्ण अन्यथा अणु
		addr = task_stack_page(task) + regoff[regno];
	पूर्ण
	वापस addr;
पूर्ण

/*
 * Get contents of रेजिस्टर REGNO in task TASK.
 */
अटल अचिन्हित दीर्घ
get_reg(काष्ठा task_काष्ठा * task, अचिन्हित दीर्घ regno)
अणु
	/* Special hack क्रम fpcr -- combine hardware and software bits.  */
	अगर (regno == 63) अणु
		अचिन्हित दीर्घ fpcr = *get_reg_addr(task, regno);
		अचिन्हित दीर्घ swcr
		  = task_thपढ़ो_info(task)->ieee_state & IEEE_SW_MASK;
		swcr = swcr_update_status(swcr, fpcr);
		वापस fpcr | swcr;
	पूर्ण
	वापस *get_reg_addr(task, regno);
पूर्ण

/*
 * Write contents of रेजिस्टर REGNO in task TASK.
 */
अटल पूर्णांक
put_reg(काष्ठा task_काष्ठा *task, अचिन्हित दीर्घ regno, अचिन्हित दीर्घ data)
अणु
	अगर (regno == 63) अणु
		task_thपढ़ो_info(task)->ieee_state
		  = ((task_thपढ़ो_info(task)->ieee_state & ~IEEE_SW_MASK)
		     | (data & IEEE_SW_MASK));
		data = (data & FPCR_DYN_MASK) | ieee_swcr_to_fpcr(data);
	पूर्ण
	*get_reg_addr(task, regno) = data;
	वापस 0;
पूर्ण

अटल अंतरभूत पूर्णांक
पढ़ो_पूर्णांक(काष्ठा task_काष्ठा *task, अचिन्हित दीर्घ addr, पूर्णांक * data)
अणु
	पूर्णांक copied = access_process_vm(task, addr, data, माप(पूर्णांक),
			FOLL_FORCE);
	वापस (copied == माप(पूर्णांक)) ? 0 : -EIO;
पूर्ण

अटल अंतरभूत पूर्णांक
ग_लिखो_पूर्णांक(काष्ठा task_काष्ठा *task, अचिन्हित दीर्घ addr, पूर्णांक data)
अणु
	पूर्णांक copied = access_process_vm(task, addr, &data, माप(पूर्णांक),
			FOLL_FORCE | FOLL_WRITE);
	वापस (copied == माप(पूर्णांक)) ? 0 : -EIO;
पूर्ण

/*
 * Set अवरोधpoपूर्णांक.
 */
पूर्णांक
ptrace_set_bpt(काष्ठा task_काष्ठा * child)
अणु
	पूर्णांक displ, i, res, reg_b, nsaved = 0;
	अचिन्हित पूर्णांक insn, op_code;
	अचिन्हित दीर्घ pc;

	pc  = get_reg(child, REG_PC);
	res = पढ़ो_पूर्णांक(child, pc, (पूर्णांक *) &insn);
	अगर (res < 0)
		वापस res;

	op_code = insn >> 26;
	अगर (op_code >= 0x30) अणु
		/*
		 * It's a branch: instead of trying to figure out
		 * whether the branch will be taken or not, we'll put
		 * a अवरोधpoपूर्णांक at either location.  This is simpler,
		 * more reliable, and probably not a whole lot slower
		 * than the alternative approach of emulating the
		 * branch (emulation can be tricky क्रम fp branches).
		 */
		displ = ((s32)(insn << 11)) >> 9;
		task_thपढ़ो_info(child)->bpt_addr[nsaved++] = pc + 4;
		अगर (displ)		/* guard against unoptimized code */
			task_thपढ़ो_info(child)->bpt_addr[nsaved++]
			  = pc + 4 + displ;
		DBG(DBG_BPT, ("execing branch\n"));
	पूर्ण अन्यथा अगर (op_code == 0x1a) अणु
		reg_b = (insn >> 16) & 0x1f;
		task_thपढ़ो_info(child)->bpt_addr[nsaved++] = get_reg(child, reg_b);
		DBG(DBG_BPT, ("execing jump\n"));
	पूर्ण अन्यथा अणु
		task_thपढ़ो_info(child)->bpt_addr[nsaved++] = pc + 4;
		DBG(DBG_BPT, ("execing normal insn\n"));
	पूर्ण

	/* install अवरोधpoपूर्णांकs: */
	क्रम (i = 0; i < nsaved; ++i) अणु
		res = पढ़ो_पूर्णांक(child, task_thपढ़ो_info(child)->bpt_addr[i],
			       (पूर्णांक *) &insn);
		अगर (res < 0)
			वापस res;
		task_thपढ़ो_info(child)->bpt_insn[i] = insn;
		DBG(DBG_BPT, ("    -> next_pc=%lx\n",
			      task_thपढ़ो_info(child)->bpt_addr[i]));
		res = ग_लिखो_पूर्णांक(child, task_thपढ़ो_info(child)->bpt_addr[i],
				BREAKINST);
		अगर (res < 0)
			वापस res;
	पूर्ण
	task_thपढ़ो_info(child)->bpt_nsaved = nsaved;
	वापस 0;
पूर्ण

/*
 * Ensure no single-step अवरोधpoपूर्णांक is pending.  Returns non-zero
 * value अगर child was being single-stepped.
 */
पूर्णांक
ptrace_cancel_bpt(काष्ठा task_काष्ठा * child)
अणु
	पूर्णांक i, nsaved = task_thपढ़ो_info(child)->bpt_nsaved;

	task_thपढ़ो_info(child)->bpt_nsaved = 0;

	अगर (nsaved > 2) अणु
		prपूर्णांकk("ptrace_cancel_bpt: bogus nsaved: %d!\n", nsaved);
		nsaved = 2;
	पूर्ण

	क्रम (i = 0; i < nsaved; ++i) अणु
		ग_लिखो_पूर्णांक(child, task_thपढ़ो_info(child)->bpt_addr[i],
			  task_thपढ़ो_info(child)->bpt_insn[i]);
	पूर्ण
	वापस (nsaved != 0);
पूर्ण

व्योम user_enable_single_step(काष्ठा task_काष्ठा *child)
अणु
	/* Mark single stepping.  */
	task_thपढ़ो_info(child)->bpt_nsaved = -1;
पूर्ण

व्योम user_disable_single_step(काष्ठा task_काष्ठा *child)
अणु
	ptrace_cancel_bpt(child);
पूर्ण

/*
 * Called by kernel/ptrace.c when detaching..
 *
 * Make sure the single step bit is not set.
 */
व्योम ptrace_disable(काष्ठा task_काष्ठा *child)
अणु 
	user_disable_single_step(child);
पूर्ण

दीर्घ arch_ptrace(काष्ठा task_काष्ठा *child, दीर्घ request,
		 अचिन्हित दीर्घ addr, अचिन्हित दीर्घ data)
अणु
	अचिन्हित दीर्घ पंचांगp;
	माप_प्रकार copied;
	दीर्घ ret;

	चयन (request) अणु
	/* When I and D space are separate, these will need to be fixed.  */
	हाल PTRACE_PEEKTEXT: /* पढ़ो word at location addr. */
	हाल PTRACE_PEEKDATA:
		copied = ptrace_access_vm(child, addr, &पंचांगp, माप(पंचांगp),
				FOLL_FORCE);
		ret = -EIO;
		अगर (copied != माप(पंचांगp))
			अवरोध;
		
		क्रमce_successful_syscall_वापस();
		ret = पंचांगp;
		अवरोध;

	/* Read रेजिस्टर number ADDR. */
	हाल PTRACE_PEEKUSR:
		क्रमce_successful_syscall_वापस();
		ret = get_reg(child, addr);
		DBG(DBG_MEM, ("peek $%lu->%#lx\n", addr, ret));
		अवरोध;

	/* When I and D space are separate, this will have to be fixed.  */
	हाल PTRACE_POKETEXT: /* ग_लिखो the word at location addr. */
	हाल PTRACE_POKEDATA:
		ret = generic_ptrace_pokedata(child, addr, data);
		अवरोध;

	हाल PTRACE_POKEUSR: /* ग_लिखो the specअगरied रेजिस्टर */
		DBG(DBG_MEM, ("poke $%lu<-%#lx\n", addr, data));
		ret = put_reg(child, addr, data);
		अवरोध;
	शेष:
		ret = ptrace_request(child, request, addr, data);
		अवरोध;
	पूर्ण
	वापस ret;
पूर्ण

यंत्रlinkage अचिन्हित दीर्घ syscall_trace_enter(व्योम)
अणु
	अचिन्हित दीर्घ ret = 0;
	काष्ठा pt_regs *regs = current_pt_regs();
	अगर (test_thपढ़ो_flag(TIF_SYSCALL_TRACE) &&
	    tracehook_report_syscall_entry(current_pt_regs()))
		ret = -1UL;
	audit_syscall_entry(regs->r0, regs->r16, regs->r17, regs->r18, regs->r19);
	वापस ret ?: current_pt_regs()->r0;
पूर्ण

यंत्रlinkage व्योम
syscall_trace_leave(व्योम)
अणु
	audit_syscall_निकास(current_pt_regs());
	अगर (test_thपढ़ो_flag(TIF_SYSCALL_TRACE))
		tracehook_report_syscall_निकास(current_pt_regs(), 0);
पूर्ण
