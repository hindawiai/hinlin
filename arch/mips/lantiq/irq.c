<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-only
/*
 *
 * Copyright (C) 2010 John Crispin <john@phrozen.org>
 * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
 */

#समावेश <linux/पूर्णांकerrupt.h>
#समावेश <linux/ioport.h>
#समावेश <linux/sched.h>
#समावेश <linux/irqchip.h>
#समावेश <linux/irqकरोमुख्य.h>
#समावेश <linux/of_platक्रमm.h>
#समावेश <linux/of_address.h>
#समावेश <linux/of_irq.h>

#समावेश <यंत्र/bootinfo.h>
#समावेश <यंत्र/irq_cpu.h>

#समावेश <lantiq_soc.h>
#समावेश <irq.h>

/* रेजिस्टर definitions - पूर्णांकernal irqs */
#घोषणा LTQ_ICU_ISR		0x0000
#घोषणा LTQ_ICU_IER		0x0008
#घोषणा LTQ_ICU_IOSR		0x0010
#घोषणा LTQ_ICU_IRSR		0x0018
#घोषणा LTQ_ICU_IMR		0x0020

#घोषणा LTQ_ICU_IM_SIZE		0x28

/* रेजिस्टर definitions - बाह्यal irqs */
#घोषणा LTQ_EIU_EXIN_C		0x0000
#घोषणा LTQ_EIU_EXIN_INIC	0x0004
#घोषणा LTQ_EIU_EXIN_INC	0x0008
#घोषणा LTQ_EIU_EXIN_INEN	0x000C

/* number of बाह्यal पूर्णांकerrupts */
#घोषणा MAX_EIU			6

/* the perक्रमmance counter */
#घोषणा LTQ_PERF_IRQ		(INT_NUM_IM4_IRL0 + 31)

/*
 * irqs generated by devices attached to the EBU need to be acked in
 * a special manner
 */
#घोषणा LTQ_ICU_EBU_IRQ		22

#घोषणा ltq_icu_w32(vpe, m, x, y)	\
	ltq_w32((x), ltq_icu_membase[vpe] + m*LTQ_ICU_IM_SIZE + (y))

#घोषणा ltq_icu_r32(vpe, m, x)		\
	ltq_r32(ltq_icu_membase[vpe] + m*LTQ_ICU_IM_SIZE + (x))

#घोषणा ltq_eiu_w32(x, y)	ltq_w32((x), ltq_eiu_membase + (y))
#घोषणा ltq_eiu_r32(x)		ltq_r32(ltq_eiu_membase + (x))

/* we have a cascade of 8 irqs */
#घोषणा MIPS_CPU_IRQ_CASCADE		8

अटल पूर्णांक exin_avail;
अटल u32 ltq_eiu_irq[MAX_EIU];
अटल व्योम __iomem *ltq_icu_membase[NR_CPUS];
अटल व्योम __iomem *ltq_eiu_membase;
अटल काष्ठा irq_करोमुख्य *ltq_करोमुख्य;
अटल DEFINE_SPINLOCK(ltq_eiu_lock);
अटल DEFINE_RAW_SPINLOCK(ltq_icu_lock);
अटल पूर्णांक ltq_perfcount_irq;

पूर्णांक ltq_eiu_get_irq(पूर्णांक exin)
अणु
	अगर (exin < exin_avail)
		वापस ltq_eiu_irq[exin];
	वापस -1;
पूर्ण

व्योम ltq_disable_irq(काष्ठा irq_data *d)
अणु
	अचिन्हित दीर्घ offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	अचिन्हित दीर्घ im = offset / INT_NUM_IM_OFFSET;
	अचिन्हित दीर्घ flags;
	पूर्णांक vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	क्रम_each_present_cpu(vpe) अणु
		ltq_icu_w32(vpe, im,
			    ltq_icu_r32(vpe, im, LTQ_ICU_IER) & ~BIT(offset),
			    LTQ_ICU_IER);
	पूर्ण
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
पूर्ण

व्योम ltq_mask_and_ack_irq(काष्ठा irq_data *d)
अणु
	अचिन्हित दीर्घ offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	अचिन्हित दीर्घ im = offset / INT_NUM_IM_OFFSET;
	अचिन्हित दीर्घ flags;
	पूर्णांक vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	क्रम_each_present_cpu(vpe) अणु
		ltq_icu_w32(vpe, im,
			    ltq_icu_r32(vpe, im, LTQ_ICU_IER) & ~BIT(offset),
			    LTQ_ICU_IER);
		ltq_icu_w32(vpe, im, BIT(offset), LTQ_ICU_ISR);
	पूर्ण
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
पूर्ण

अटल व्योम ltq_ack_irq(काष्ठा irq_data *d)
अणु
	अचिन्हित दीर्घ offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	अचिन्हित दीर्घ im = offset / INT_NUM_IM_OFFSET;
	अचिन्हित दीर्घ flags;
	पूर्णांक vpe;

	offset %= INT_NUM_IM_OFFSET;

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);
	क्रम_each_present_cpu(vpe) अणु
		ltq_icu_w32(vpe, im, BIT(offset), LTQ_ICU_ISR);
	पूर्ण
	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
पूर्ण

व्योम ltq_enable_irq(काष्ठा irq_data *d)
अणु
	अचिन्हित दीर्घ offset = d->hwirq - MIPS_CPU_IRQ_CASCADE;
	अचिन्हित दीर्घ im = offset / INT_NUM_IM_OFFSET;
	अचिन्हित दीर्घ flags;
	पूर्णांक vpe;

	offset %= INT_NUM_IM_OFFSET;

	vpe = cpumask_first(irq_data_get_effective_affinity_mask(d));

	/* This shouldn't be even possible, maybe during CPU hotplug spam */
	अगर (unlikely(vpe >= nr_cpu_ids))
		vpe = smp_processor_id();

	raw_spin_lock_irqsave(&ltq_icu_lock, flags);

	ltq_icu_w32(vpe, im, ltq_icu_r32(vpe, im, LTQ_ICU_IER) | BIT(offset),
		    LTQ_ICU_IER);

	raw_spin_unlock_irqrestore(&ltq_icu_lock, flags);
पूर्ण

अटल पूर्णांक ltq_eiu_settype(काष्ठा irq_data *d, अचिन्हित पूर्णांक type)
अणु
	पूर्णांक i;
	अचिन्हित दीर्घ flags;

	क्रम (i = 0; i < exin_avail; i++) अणु
		अगर (d->hwirq == ltq_eiu_irq[i]) अणु
			पूर्णांक val = 0;
			पूर्णांक edge = 0;

			चयन (type) अणु
			हाल IRQF_TRIGGER_NONE:
				अवरोध;
			हाल IRQF_TRIGGER_RISING:
				val = 1;
				edge = 1;
				अवरोध;
			हाल IRQF_TRIGGER_FALLING:
				val = 2;
				edge = 1;
				अवरोध;
			हाल IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING:
				val = 3;
				edge = 1;
				अवरोध;
			हाल IRQF_TRIGGER_HIGH:
				val = 5;
				अवरोध;
			हाल IRQF_TRIGGER_LOW:
				val = 6;
				अवरोध;
			शेष:
				pr_err("invalid type %d for irq %ld\n",
					type, d->hwirq);
				वापस -EINVAL;
			पूर्ण

			अगर (edge)
				irq_set_handler(d->hwirq, handle_edge_irq);

			spin_lock_irqsave(&ltq_eiu_lock, flags);
			ltq_eiu_w32((ltq_eiu_r32(LTQ_EIU_EXIN_C) &
				    (~(7 << (i * 4)))) | (val << (i * 4)),
				    LTQ_EIU_EXIN_C);
			spin_unlock_irqrestore(&ltq_eiu_lock, flags);
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल अचिन्हित पूर्णांक ltq_startup_eiu_irq(काष्ठा irq_data *d)
अणु
	पूर्णांक i;

	ltq_enable_irq(d);
	क्रम (i = 0; i < exin_avail; i++) अणु
		अगर (d->hwirq == ltq_eiu_irq[i]) अणु
			/* by शेष we are low level triggered */
			ltq_eiu_settype(d, IRQF_TRIGGER_LOW);
			/* clear all pending */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INC) & ~BIT(i),
				LTQ_EIU_EXIN_INC);
			/* enable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) | BIT(i),
				LTQ_EIU_EXIN_INEN);
			अवरोध;
		पूर्ण
	पूर्ण

	वापस 0;
पूर्ण

अटल व्योम ltq_shutकरोwn_eiu_irq(काष्ठा irq_data *d)
अणु
	पूर्णांक i;

	ltq_disable_irq(d);
	क्रम (i = 0; i < exin_avail; i++) अणु
		अगर (d->hwirq == ltq_eiu_irq[i]) अणु
			/* disable */
			ltq_eiu_w32(ltq_eiu_r32(LTQ_EIU_EXIN_INEN) & ~BIT(i),
				LTQ_EIU_EXIN_INEN);
			अवरोध;
		पूर्ण
	पूर्ण
पूर्ण

#अगर defined(CONFIG_SMP)
अटल पूर्णांक ltq_icu_irq_set_affinity(काष्ठा irq_data *d,
				    स्थिर काष्ठा cpumask *cpumask, bool क्रमce)
अणु
	काष्ठा cpumask पंचांगask;

	अगर (!cpumask_and(&पंचांगask, cpumask, cpu_online_mask))
		वापस -EINVAL;

	irq_data_update_effective_affinity(d, &पंचांगask);

	वापस IRQ_SET_MASK_OK;
पूर्ण
#पूर्ण_अगर

अटल काष्ठा irq_chip ltq_irq_type = अणु
	.name = "icu",
	.irq_enable = ltq_enable_irq,
	.irq_disable = ltq_disable_irq,
	.irq_unmask = ltq_enable_irq,
	.irq_ack = ltq_ack_irq,
	.irq_mask = ltq_disable_irq,
	.irq_mask_ack = ltq_mask_and_ack_irq,
#अगर defined(CONFIG_SMP)
	.irq_set_affinity = ltq_icu_irq_set_affinity,
#पूर्ण_अगर
पूर्ण;

अटल काष्ठा irq_chip ltq_eiu_type = अणु
	.name = "eiu",
	.irq_startup = ltq_startup_eiu_irq,
	.irq_shutकरोwn = ltq_shutकरोwn_eiu_irq,
	.irq_enable = ltq_enable_irq,
	.irq_disable = ltq_disable_irq,
	.irq_unmask = ltq_enable_irq,
	.irq_ack = ltq_ack_irq,
	.irq_mask = ltq_disable_irq,
	.irq_mask_ack = ltq_mask_and_ack_irq,
	.irq_set_type = ltq_eiu_settype,
#अगर defined(CONFIG_SMP)
	.irq_set_affinity = ltq_icu_irq_set_affinity,
#पूर्ण_अगर
पूर्ण;

अटल व्योम ltq_hw_irq_handler(काष्ठा irq_desc *desc)
अणु
	अचिन्हित पूर्णांक module = irq_desc_get_irq(desc) - 2;
	u32 irq;
	irq_hw_number_t hwirq;
	पूर्णांक vpe = smp_processor_id();

	irq = ltq_icu_r32(vpe, module, LTQ_ICU_IOSR);
	अगर (irq == 0)
		वापस;

	/*
	 * silicon bug causes only the msb set to 1 to be valid. all
	 * other bits might be bogus
	 */
	irq = __fls(irq);
	hwirq = irq + MIPS_CPU_IRQ_CASCADE + (INT_NUM_IM_OFFSET * module);
	generic_handle_irq(irq_linear_revmap(ltq_करोमुख्य, hwirq));

	/* अगर this is a EBU irq, we need to ack it or get a deadlock */
	अगर (irq == LTQ_ICU_EBU_IRQ && !module && LTQ_EBU_PCC_ISTAT != 0)
		ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_PCC_ISTAT) | 0x10,
			LTQ_EBU_PCC_ISTAT);
पूर्ण

अटल पूर्णांक icu_map(काष्ठा irq_करोमुख्य *d, अचिन्हित पूर्णांक irq, irq_hw_number_t hw)
अणु
	काष्ठा irq_chip *chip = &ltq_irq_type;
	काष्ठा irq_data *data;
	पूर्णांक i;

	अगर (hw < MIPS_CPU_IRQ_CASCADE)
		वापस 0;

	क्रम (i = 0; i < exin_avail; i++)
		अगर (hw == ltq_eiu_irq[i])
			chip = &ltq_eiu_type;

	data = irq_get_irq_data(irq);

	irq_data_update_effective_affinity(data, cpumask_of(0));

	irq_set_chip_and_handler(irq, chip, handle_level_irq);

	वापस 0;
पूर्ण

अटल स्थिर काष्ठा irq_करोमुख्य_ops irq_करोमुख्य_ops = अणु
	.xlate = irq_करोमुख्य_xlate_onetwocell,
	.map = icu_map,
पूर्ण;

पूर्णांक __init icu_of_init(काष्ठा device_node *node, काष्ठा device_node *parent)
अणु
	काष्ठा device_node *eiu_node;
	काष्ठा resource res;
	पूर्णांक i, ret, vpe;

	/* load रेजिस्टर regions of available ICUs */
	क्रम_each_possible_cpu(vpe) अणु
		अगर (of_address_to_resource(node, vpe, &res))
			panic("Failed to get icu%i memory range", vpe);

		अगर (!request_mem_region(res.start, resource_size(&res),
					res.name))
			pr_err("Failed to request icu%i memory\n", vpe);

		ltq_icu_membase[vpe] = ioremap(res.start,
					resource_size(&res));

		अगर (!ltq_icu_membase[vpe])
			panic("Failed to remap icu%i memory", vpe);
	पूर्ण

	/* turn off all irqs by शेष */
	क्रम_each_possible_cpu(vpe) अणु
		क्रम (i = 0; i < MAX_IM; i++) अणु
			/* make sure all irqs are turned off by शेष */
			ltq_icu_w32(vpe, i, 0, LTQ_ICU_IER);

			/* clear all possibly pending पूर्णांकerrupts */
			ltq_icu_w32(vpe, i, ~0, LTQ_ICU_ISR);
			ltq_icu_w32(vpe, i, ~0, LTQ_ICU_IMR);

			/* clear resend */
			ltq_icu_w32(vpe, i, 0, LTQ_ICU_IRSR);
		पूर्ण
	पूर्ण

	mips_cpu_irq_init();

	क्रम (i = 0; i < MAX_IM; i++)
		irq_set_chained_handler(i + 2, ltq_hw_irq_handler);

	ltq_करोमुख्य = irq_करोमुख्य_add_linear(node,
		(MAX_IM * INT_NUM_IM_OFFSET) + MIPS_CPU_IRQ_CASCADE,
		&irq_करोमुख्य_ops, 0);

	/* tell oprofile which irq to use */
	ltq_perfcount_irq = irq_create_mapping(ltq_करोमुख्य, LTQ_PERF_IRQ);

	/* the बाह्यal पूर्णांकerrupts are optional and xway only */
	eiu_node = of_find_compatible_node(शून्य, शून्य, "lantiq,eiu-xway");
	अगर (eiu_node && !of_address_to_resource(eiu_node, 0, &res)) अणु
		/* find out how many बाह्यal irq sources we have */
		exin_avail = of_property_count_u32_elems(eiu_node,
							 "lantiq,eiu-irqs");

		अगर (exin_avail > MAX_EIU)
			exin_avail = MAX_EIU;

		ret = of_property_पढ़ो_u32_array(eiu_node, "lantiq,eiu-irqs",
						ltq_eiu_irq, exin_avail);
		अगर (ret)
			panic("failed to load external irq resources");

		अगर (!request_mem_region(res.start, resource_size(&res),
							res.name))
			pr_err("Failed to request eiu memory");

		ltq_eiu_membase = ioremap(res.start,
							resource_size(&res));
		अगर (!ltq_eiu_membase)
			panic("Failed to remap eiu memory");
	पूर्ण

	वापस 0;
पूर्ण

पूर्णांक get_c0_perfcount_पूर्णांक(व्योम)
अणु
	वापस ltq_perfcount_irq;
पूर्ण
EXPORT_SYMBOL_GPL(get_c0_perfcount_पूर्णांक);

अचिन्हित पूर्णांक get_c0_compare_पूर्णांक(व्योम)
अणु
	वापस CP0_LEGACY_COMPARE_IRQ;
पूर्ण

IRQCHIP_DECLARE(lantiq_icu, "lantiq,icu", icu_of_init);

व्योम __init arch_init_irq(व्योम)
अणु
	irqchip_init();
पूर्ण
