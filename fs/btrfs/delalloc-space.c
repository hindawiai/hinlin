<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0

#समावेश "ctree.h"
#समावेश "delalloc-space.h"
#समावेश "block-rsv.h"
#समावेश "btrfs_inode.h"
#समावेश "space-info.h"
#समावेश "transaction.h"
#समावेश "qgroup.h"
#समावेश "block-group.h"

/*
 * HOW DOES THIS WORK
 *
 * There are two stages to data reservations, one क्रम data and one क्रम metadata
 * to handle the new extents and checksums generated by writing data.
 *
 *
 * DATA RESERVATION
 *   The general flow of the data reservation is as follows
 *
 *   -> Reserve
 *     We call पूर्णांकo btrfs_reserve_data_bytes() क्रम the user request bytes that
 *     they wish to ग_लिखो.  We make this reservation and add it to
 *     space_info->bytes_may_use.  We set EXTENT_DELALLOC on the inode io_tree
 *     क्रम the range and carry on अगर this is buffered, or follow up trying to
 *     make a real allocation अगर we are pre-allocating or करोing O_सूचीECT.
 *
 *   -> Use
 *     At ग_लिखोpages()/pपुनः_स्मृति/O_सूचीECT समय we will call पूर्णांकo
 *     btrfs_reserve_extent() क्रम some part or all of this range of bytes.  We
 *     will make the allocation and subtract space_info->bytes_may_use by the
 *     original requested length and increase the space_info->bytes_reserved by
 *     the allocated length.  This distinction is important because compression
 *     may allocate a smaller on disk extent than we previously reserved.
 *
 *   -> Allocation
 *     finish_ordered_io() will insert the new file extent item क्रम this range,
 *     and then add a delayed ref update क्रम the extent tree.  Once that delayed
 *     ref is written the extent size is subtracted from
 *     space_info->bytes_reserved and added to space_info->bytes_used.
 *
 *   Error handling
 *
 *   -> By the reservation maker
 *     This is the simplest हाल, we haven't completed our operation and we know
 *     how much we reserved, we can simply call
 *     btrfs_मुक्त_reserved_data_space*() and it will be हटाओd from
 *     space_info->bytes_may_use.
 *
 *   -> After the reservation has been made, but beक्रमe cow_file_range()
 *     This is specअगरically क्रम the delalloc हाल.  You must clear
 *     EXTENT_DELALLOC with the EXTENT_CLEAR_DATA_RESV bit, and the range will
 *     be subtracted from space_info->bytes_may_use.
 *
 * METADATA RESERVATION
 *   The general metadata reservation lअगरeबार are discussed अन्यथाwhere, this
 *   will just focus on how it is used क्रम delalloc space.
 *
 *   We keep track of two things on a per inode bases
 *
 *   ->outstanding_extents
 *     This is the number of file extent items we'll need to handle all of the
 *     outstanding DELALLOC space we have in this inode.  We limit the maximum
 *     size of an extent, so a large contiguous dirty area may require more than
 *     one outstanding_extent, which is why count_max_extents() is used to
 *     determine how many outstanding_extents get added.
 *
 *   ->csum_bytes
 *     This is essentially how many dirty bytes we have क्रम this inode, so we
 *     can calculate the number of checksum items we would have to add in order
 *     to checksum our outstanding data.
 *
 *   We keep a per-inode block_rsv in order to make it easier to keep track of
 *   our reservation.  We use btrfs_calculate_inode_block_rsv_size() to
 *   calculate the current theoretical maximum reservation we would need क्रम the
 *   metadata क्रम this inode.  We call this and then adjust our reservation as
 *   necessary, either by attempting to reserve more space, or मुक्तing up excess
 *   space.
 *
 * OUTSTANDING_EXTENTS HANDLING
 *
 *  ->outstanding_extents is used क्रम keeping track of how many extents we will
 *  need to use क्रम this inode, and it will fluctuate depending on where you are
 *  in the lअगरe cycle of the dirty data.  Consider the following normal हाल क्रम
 *  a completely clean inode, with a num_bytes < our maximum allowed extent size
 *
 *  -> reserve
 *    ->outstanding_extents += 1 (current value is 1)
 *
 *  -> set_delalloc
 *    ->outstanding_extents += 1 (currrent value is 2)
 *
 *  -> btrfs_delalloc_release_extents()
 *    ->outstanding_extents -= 1 (current value is 1)
 *
 *    We must call this once we are करोne, as we hold our reservation क्रम the
 *    duration of our operation, and then assume set_delalloc will update the
 *    counter appropriately.
 *
 *  -> add ordered extent
 *    ->outstanding_extents += 1 (current value is 2)
 *
 *  -> btrfs_clear_delalloc_extent
 *    ->outstanding_extents -= 1 (current value is 1)
 *
 *  -> finish_ordered_io/btrfs_हटाओ_ordered_extent
 *    ->outstanding_extents -= 1 (current value is 0)
 *
 *  Each stage is responsible क्रम their own accounting of the extent, thus
 *  making error handling and cleanup easier.
 */

पूर्णांक btrfs_alloc_data_chunk_ondemand(काष्ठा btrfs_inode *inode, u64 bytes)
अणु
	काष्ठा btrfs_root *root = inode->root;
	काष्ठा btrfs_fs_info *fs_info = root->fs_info;
	क्रमागत btrfs_reserve_flush_क्रमागत flush = BTRFS_RESERVE_FLUSH_DATA;

	/* Make sure bytes are sectorsize aligned */
	bytes = ALIGN(bytes, fs_info->sectorsize);

	अगर (btrfs_is_मुक्त_space_inode(inode))
		flush = BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE;

	वापस btrfs_reserve_data_bytes(fs_info, bytes, flush);
पूर्ण

पूर्णांक btrfs_check_data_मुक्त_space(काष्ठा btrfs_inode *inode,
			काष्ठा extent_changeset **reserved, u64 start, u64 len)
अणु
	काष्ठा btrfs_fs_info *fs_info = inode->root->fs_info;
	पूर्णांक ret;

	/* align the range */
	len = round_up(start + len, fs_info->sectorsize) -
	      round_करोwn(start, fs_info->sectorsize);
	start = round_करोwn(start, fs_info->sectorsize);

	ret = btrfs_alloc_data_chunk_ondemand(inode, len);
	अगर (ret < 0)
		वापस ret;

	/* Use new btrfs_qgroup_reserve_data to reserve precious data space. */
	ret = btrfs_qgroup_reserve_data(inode, reserved, start, len);
	अगर (ret < 0)
		btrfs_मुक्त_reserved_data_space_noquota(fs_info, len);
	अन्यथा
		ret = 0;
	वापस ret;
पूर्ण

/*
 * Called अगर we need to clear a data reservation क्रम this inode
 * Normally in a error हाल.
 *
 * This one will *NOT* use accurate qgroup reserved space API, just क्रम हाल
 * which we can't sleep and is sure it won't affect qgroup reserved space.
 * Like clear_bit_hook().
 */
व्योम btrfs_मुक्त_reserved_data_space_noquota(काष्ठा btrfs_fs_info *fs_info,
					    u64 len)
अणु
	काष्ठा btrfs_space_info *data_sinfo;

	ASSERT(IS_ALIGNED(len, fs_info->sectorsize));

	data_sinfo = fs_info->data_sinfo;
	btrfs_space_info_मुक्त_bytes_may_use(fs_info, data_sinfo, len);
पूर्ण

/*
 * Called अगर we need to clear a data reservation क्रम this inode
 * Normally in a error हाल.
 *
 * This one will handle the per-inode data rsv map क्रम accurate reserved
 * space framework.
 */
व्योम btrfs_मुक्त_reserved_data_space(काष्ठा btrfs_inode *inode,
			काष्ठा extent_changeset *reserved, u64 start, u64 len)
अणु
	काष्ठा btrfs_fs_info *fs_info = inode->root->fs_info;

	/* Make sure the range is aligned to sectorsize */
	len = round_up(start + len, fs_info->sectorsize) -
	      round_करोwn(start, fs_info->sectorsize);
	start = round_करोwn(start, fs_info->sectorsize);

	btrfs_मुक्त_reserved_data_space_noquota(fs_info, len);
	btrfs_qgroup_मुक्त_data(inode, reserved, start, len);
पूर्ण

/**
 * Release any excessive reservation
 *
 * @inode:       the inode we need to release from
 * @qgroup_मुक्त: मुक्त or convert qgroup meta. Unlike normal operation, qgroup
 *               meta reservation needs to know अगर we are मुक्तing qgroup
 *               reservation or just converting it पूर्णांकo per-trans.  Normally
 *               @qgroup_मुक्त is true क्रम error handling, and false क्रम normal
 *               release.
 *
 * This is the same as btrfs_block_rsv_release, except that it handles the
 * tracepoपूर्णांक क्रम the reservation.
 */
अटल व्योम btrfs_inode_rsv_release(काष्ठा btrfs_inode *inode, bool qgroup_मुक्त)
अणु
	काष्ठा btrfs_fs_info *fs_info = inode->root->fs_info;
	काष्ठा btrfs_block_rsv *block_rsv = &inode->block_rsv;
	u64 released = 0;
	u64 qgroup_to_release = 0;

	/*
	 * Since we अटलally set the block_rsv->size we just want to say we
	 * are releasing 0 bytes, and then we'll just get the reservation over
	 * the size मुक्त'd.
	 */
	released = btrfs_block_rsv_release(fs_info, block_rsv, 0,
					   &qgroup_to_release);
	अगर (released > 0)
		trace_btrfs_space_reservation(fs_info, "delalloc",
					      btrfs_ino(inode), released, 0);
	अगर (qgroup_मुक्त)
		btrfs_qgroup_मुक्त_meta_pपुनः_स्मृति(inode->root, qgroup_to_release);
	अन्यथा
		btrfs_qgroup_convert_reserved_meta(inode->root,
						   qgroup_to_release);
पूर्ण

अटल व्योम btrfs_calculate_inode_block_rsv_size(काष्ठा btrfs_fs_info *fs_info,
						 काष्ठा btrfs_inode *inode)
अणु
	काष्ठा btrfs_block_rsv *block_rsv = &inode->block_rsv;
	u64 reserve_size = 0;
	u64 qgroup_rsv_size = 0;
	u64 csum_leaves;
	अचिन्हित outstanding_extents;

	lockdep_निश्चित_held(&inode->lock);
	outstanding_extents = inode->outstanding_extents;

	/*
	 * Insert size क्रम the number of outstanding extents, 1 normal size क्रम
	 * updating the inode.
	 */
	अगर (outstanding_extents) अणु
		reserve_size = btrfs_calc_insert_metadata_size(fs_info,
						outstanding_extents);
		reserve_size += btrfs_calc_metadata_size(fs_info, 1);
	पूर्ण
	csum_leaves = btrfs_csum_bytes_to_leaves(fs_info,
						 inode->csum_bytes);
	reserve_size += btrfs_calc_insert_metadata_size(fs_info,
							csum_leaves);
	/*
	 * For qgroup rsv, the calculation is very simple:
	 * account one nodesize क्रम each outstanding extent
	 *
	 * This is overestimating in most हालs.
	 */
	qgroup_rsv_size = (u64)outstanding_extents * fs_info->nodesize;

	spin_lock(&block_rsv->lock);
	block_rsv->size = reserve_size;
	block_rsv->qgroup_rsv_size = qgroup_rsv_size;
	spin_unlock(&block_rsv->lock);
पूर्ण

अटल व्योम calc_inode_reservations(काष्ठा btrfs_fs_info *fs_info,
				    u64 num_bytes, u64 *meta_reserve,
				    u64 *qgroup_reserve)
अणु
	u64 nr_extents = count_max_extents(num_bytes);
	u64 csum_leaves = btrfs_csum_bytes_to_leaves(fs_info, num_bytes);
	u64 inode_update = btrfs_calc_metadata_size(fs_info, 1);

	*meta_reserve = btrfs_calc_insert_metadata_size(fs_info,
						nr_extents + csum_leaves);

	/*
	 * finish_ordered_io has to update the inode, so add the space required
	 * क्रम an inode update.
	 */
	*meta_reserve += inode_update;
	*qgroup_reserve = nr_extents * fs_info->nodesize;
पूर्ण

पूर्णांक btrfs_delalloc_reserve_metadata(काष्ठा btrfs_inode *inode, u64 num_bytes)
अणु
	काष्ठा btrfs_root *root = inode->root;
	काष्ठा btrfs_fs_info *fs_info = root->fs_info;
	काष्ठा btrfs_block_rsv *block_rsv = &inode->block_rsv;
	u64 meta_reserve, qgroup_reserve;
	अचिन्हित nr_extents;
	क्रमागत btrfs_reserve_flush_क्रमागत flush = BTRFS_RESERVE_FLUSH_ALL;
	पूर्णांक ret = 0;

	/*
	 * If we are a मुक्त space inode we need to not flush since we will be in
	 * the middle of a transaction commit.  We also करोn't need the delalloc
	 * mutex since we won't race with anybody.  We need this mostly to make
	 * lockdep shut its filthy mouth.
	 *
	 * If we have a transaction खोलो (can happen अगर we call truncate_block
	 * from truncate), then we need FLUSH_LIMIT so we करोn't deadlock.
	 */
	अगर (btrfs_is_मुक्त_space_inode(inode)) अणु
		flush = BTRFS_RESERVE_NO_FLUSH;
	पूर्ण अन्यथा अणु
		अगर (current->journal_info)
			flush = BTRFS_RESERVE_FLUSH_LIMIT;

		अगर (btrfs_transaction_in_commit(fs_info))
			schedule_समयout(1);
	पूर्ण

	num_bytes = ALIGN(num_bytes, fs_info->sectorsize);

	/*
	 * We always want to करो it this way, every other way is wrong and ends
	 * in tears.  Pre-reserving the amount we are going to add will always
	 * be the right way, because otherwise अगर we have enough parallelism we
	 * could end up with thousands of inodes all holding little bits of
	 * reservations they were able to make previously and the only way to
	 * reclaim that space is to ENOSPC out the operations and clear
	 * everything out and try again, which is bad.  This way we just
	 * over-reserve slightly, and clean up the mess when we are करोne.
	 */
	calc_inode_reservations(fs_info, num_bytes, &meta_reserve,
				&qgroup_reserve);
	ret = btrfs_qgroup_reserve_meta_pपुनः_स्मृति(root, qgroup_reserve, true);
	अगर (ret)
		वापस ret;
	ret = btrfs_reserve_metadata_bytes(root, block_rsv, meta_reserve, flush);
	अगर (ret) अणु
		btrfs_qgroup_मुक्त_meta_pपुनः_स्मृति(root, qgroup_reserve);
		वापस ret;
	पूर्ण

	/*
	 * Now we need to update our outstanding extents and csum bytes _first_
	 * and then add the reservation to the block_rsv.  This keeps us from
	 * racing with an ordered completion or some such that would think it
	 * needs to मुक्त the reservation we just made.
	 */
	spin_lock(&inode->lock);
	nr_extents = count_max_extents(num_bytes);
	btrfs_mod_outstanding_extents(inode, nr_extents);
	inode->csum_bytes += num_bytes;
	btrfs_calculate_inode_block_rsv_size(fs_info, inode);
	spin_unlock(&inode->lock);

	/* Now we can safely add our space to our block rsv */
	btrfs_block_rsv_add_bytes(block_rsv, meta_reserve, false);
	trace_btrfs_space_reservation(root->fs_info, "delalloc",
				      btrfs_ino(inode), meta_reserve, 1);

	spin_lock(&block_rsv->lock);
	block_rsv->qgroup_rsv_reserved += qgroup_reserve;
	spin_unlock(&block_rsv->lock);

	वापस 0;
पूर्ण

/**
 * Release a metadata reservation क्रम an inode
 *
 * @inode: the inode to release the reservation क्रम.
 * @num_bytes: the number of bytes we are releasing.
 * @qgroup_मुक्त: मुक्त qgroup reservation or convert it to per-trans reservation
 *
 * This will release the metadata reservation क्रम an inode.  This can be called
 * once we complete IO क्रम a given set of bytes to release their metadata
 * reservations, or on error क्रम the same reason.
 */
व्योम btrfs_delalloc_release_metadata(काष्ठा btrfs_inode *inode, u64 num_bytes,
				     bool qgroup_मुक्त)
अणु
	काष्ठा btrfs_fs_info *fs_info = inode->root->fs_info;

	num_bytes = ALIGN(num_bytes, fs_info->sectorsize);
	spin_lock(&inode->lock);
	inode->csum_bytes -= num_bytes;
	btrfs_calculate_inode_block_rsv_size(fs_info, inode);
	spin_unlock(&inode->lock);

	अगर (btrfs_is_testing(fs_info))
		वापस;

	btrfs_inode_rsv_release(inode, qgroup_मुक्त);
पूर्ण

/**
 * btrfs_delalloc_release_extents - release our outstanding_extents
 * @inode: the inode to balance the reservation क्रम.
 * @num_bytes: the number of bytes we originally reserved with
 *
 * When we reserve space we increase outstanding_extents क्रम the extents we may
 * add.  Once we've set the range as delalloc or created our ordered extents we
 * have outstanding_extents to track the real usage, so we use this to मुक्त our
 * temporarily tracked outstanding_extents.  This _must_ be used in conjunction
 * with btrfs_delalloc_reserve_metadata.
 */
व्योम btrfs_delalloc_release_extents(काष्ठा btrfs_inode *inode, u64 num_bytes)
अणु
	काष्ठा btrfs_fs_info *fs_info = inode->root->fs_info;
	अचिन्हित num_extents;

	spin_lock(&inode->lock);
	num_extents = count_max_extents(num_bytes);
	btrfs_mod_outstanding_extents(inode, -num_extents);
	btrfs_calculate_inode_block_rsv_size(fs_info, inode);
	spin_unlock(&inode->lock);

	अगर (btrfs_is_testing(fs_info))
		वापस;

	btrfs_inode_rsv_release(inode, true);
पूर्ण

/**
 * btrfs_delalloc_reserve_space - reserve data and metadata space क्रम
 * delalloc
 * @inode: inode we're writing to
 * @start: start range we are writing to
 * @len: how दीर्घ the range we are writing to
 * @reserved: mandatory parameter, record actually reserved qgroup ranges of
 * 	      current reservation.
 *
 * This will करो the following things
 *
 * - reserve space in data space info क्रम num bytes
 *   and reserve precious corresponding qgroup space
 *   (Done in check_data_मुक्त_space)
 *
 * - reserve space क्रम metadata space, based on the number of outstanding
 *   extents and how much csums will be needed
 *   also reserve metadata space in a per root over-reserve method.
 * - add to the inodes->delalloc_bytes
 * - add it to the fs_info's delalloc inodes list.
 *   (Above 3 all करोne in delalloc_reserve_metadata)
 *
 * Return 0 क्रम success
 * Return <0 क्रम error(-ENOSPC or -EQUOT)
 */
पूर्णांक btrfs_delalloc_reserve_space(काष्ठा btrfs_inode *inode,
			काष्ठा extent_changeset **reserved, u64 start, u64 len)
अणु
	पूर्णांक ret;

	ret = btrfs_check_data_मुक्त_space(inode, reserved, start, len);
	अगर (ret < 0)
		वापस ret;
	ret = btrfs_delalloc_reserve_metadata(inode, len);
	अगर (ret < 0)
		btrfs_मुक्त_reserved_data_space(inode, *reserved, start, len);
	वापस ret;
पूर्ण

/**
 * Release data and metadata space क्रम delalloc
 *
 * @inode:       inode we're releasing space क्रम
 * @reserved:    list of changed/reserved ranges
 * @start:       start position of the space alपढ़ोy reserved
 * @len:         length of the space alपढ़ोy reserved
 * @qgroup_मुक्त: should qgroup reserved-space also be मुक्तd
 *
 * This function will release the metadata space that was not used and will
 * decrement ->delalloc_bytes and हटाओ it from the fs_info delalloc_inodes
 * list अगर there are no delalloc bytes left.
 * Also it will handle the qgroup reserved space.
 */
व्योम btrfs_delalloc_release_space(काष्ठा btrfs_inode *inode,
				  काष्ठा extent_changeset *reserved,
				  u64 start, u64 len, bool qgroup_मुक्त)
अणु
	btrfs_delalloc_release_metadata(inode, len, qgroup_मुक्त);
	btrfs_मुक्त_reserved_data_space(inode, reserved, start, len);
पूर्ण
