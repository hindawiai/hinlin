<शैली गुरु>
// SPDX-License-Identअगरier: GPL-2.0-or-later
/* Storage object पढ़ो/ग_लिखो
 *
 * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.
 * Written by David Howells (dhowells@redhat.com)
 */

#समावेश <linux/mount.h>
#समावेश <linux/slab.h>
#समावेश <linux/file.h>
#समावेश <linux/swap.h>
#समावेश "internal.h"

/*
 * detect wake up events generated by the unlocking of pages in which we're
 * पूर्णांकerested
 * - we use this to detect पढ़ो completion of backing pages
 * - the caller holds the रुकोqueue lock
 */
अटल पूर्णांक cachefiles_पढ़ो_रुकोer(रुको_queue_entry_t *रुको, अचिन्हित mode,
				  पूर्णांक sync, व्योम *_key)
अणु
	काष्ठा cachefiles_one_पढ़ो *monitor =
		container_of(रुको, काष्ठा cachefiles_one_पढ़ो, monitor);
	काष्ठा cachefiles_object *object;
	काष्ठा fscache_retrieval *op = monitor->op;
	काष्ठा रुको_page_key *key = _key;
	काष्ठा page *page = रुको->निजी;

	ASSERT(key);

	_enter("{%lu},%u,%d,{%p,%u}",
	       monitor->netfs_page->index, mode, sync,
	       key->page, key->bit_nr);

	अगर (key->page != page || key->bit_nr != PG_locked)
		वापस 0;

	_debug("--- monitor %p %lx ---", page, page->flags);

	अगर (!PageUptodate(page) && !PageError(page)) अणु
		/* unlocked, not uptodate and not erronous? */
		_debug("page probably truncated");
	पूर्ण

	/* हटाओ from the रुकोqueue */
	list_del(&रुको->entry);

	/* move onto the action list and queue क्रम FS-Cache thपढ़ो pool */
	ASSERT(op);

	/* We need to temporarily bump the usage count as we करोn't own a ref
	 * here otherwise cachefiles_पढ़ो_copier() may मुक्त the op between the
	 * monitor being enqueued on the op->to_करो list and the op getting
	 * enqueued on the work queue.
	 */
	fscache_get_retrieval(op);

	object = container_of(op->op.object, काष्ठा cachefiles_object, fscache);
	spin_lock(&object->work_lock);
	list_add_tail(&monitor->op_link, &op->to_करो);
	fscache_enqueue_retrieval(op);
	spin_unlock(&object->work_lock);

	fscache_put_retrieval(op);
	वापस 0;
पूर्ण

/*
 * handle a probably truncated page
 * - check to see अगर the page is still relevant and reissue the पढ़ो अगर
 *   possible
 * - वापस -EIO on error, -ENODATA अगर the page is gone, -EINPROGRESS अगर we
 *   must रुको again and 0 अगर successful
 */
अटल पूर्णांक cachefiles_पढ़ो_reissue(काष्ठा cachefiles_object *object,
				   काष्ठा cachefiles_one_पढ़ो *monitor)
अणु
	काष्ठा address_space *bmapping = d_backing_inode(object->backer)->i_mapping;
	काष्ठा page *backpage = monitor->back_page, *backpage2;
	पूर्णांक ret;

	_enter("{ino=%lx},{%lx,%lx}",
	       d_backing_inode(object->backer)->i_ino,
	       backpage->index, backpage->flags);

	/* skip अगर the page was truncated away completely */
	अगर (backpage->mapping != bmapping) अणु
		_leave(" = -ENODATA [mapping]");
		वापस -ENODATA;
	पूर्ण

	backpage2 = find_get_page(bmapping, backpage->index);
	अगर (!backpage2) अणु
		_leave(" = -ENODATA [gone]");
		वापस -ENODATA;
	पूर्ण

	अगर (backpage != backpage2) अणु
		put_page(backpage2);
		_leave(" = -ENODATA [different]");
		वापस -ENODATA;
	पूर्ण

	/* the page is still there and we alपढ़ोy have a ref on it, so we करोn't
	 * need a second */
	put_page(backpage2);

	INIT_LIST_HEAD(&monitor->op_link);
	add_page_रुको_queue(backpage, &monitor->monitor);

	अगर (trylock_page(backpage)) अणु
		ret = -EIO;
		अगर (PageError(backpage))
			जाओ unlock_discard;
		ret = 0;
		अगर (PageUptodate(backpage))
			जाओ unlock_discard;

		_debug("reissue read");
		ret = bmapping->a_ops->पढ़ोpage(शून्य, backpage);
		अगर (ret < 0)
			जाओ discard;
	पूर्ण

	/* but the page may have been पढ़ो beक्रमe the monitor was installed, so
	 * the monitor may miss the event - so we have to ensure that we करो get
	 * one in such a हाल */
	अगर (trylock_page(backpage)) अणु
		_debug("jumpstart %p {%lx}", backpage, backpage->flags);
		unlock_page(backpage);
	पूर्ण

	/* it'll reappear on the toकरो list */
	_leave(" = -EINPROGRESS");
	वापस -EINPROGRESS;

unlock_discard:
	unlock_page(backpage);
discard:
	spin_lock_irq(&object->work_lock);
	list_del(&monitor->op_link);
	spin_unlock_irq(&object->work_lock);
	_leave(" = %d", ret);
	वापस ret;
पूर्ण

/*
 * copy data from backing pages to netfs pages to complete a पढ़ो operation
 * - driven by FS-Cache's thपढ़ो pool
 */
अटल व्योम cachefiles_पढ़ो_copier(काष्ठा fscache_operation *_op)
अणु
	काष्ठा cachefiles_one_पढ़ो *monitor;
	काष्ठा cachefiles_object *object;
	काष्ठा fscache_retrieval *op;
	पूर्णांक error, max;

	op = container_of(_op, काष्ठा fscache_retrieval, op);
	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);

	_enter("{ino=%lu}", d_backing_inode(object->backer)->i_ino);

	max = 8;
	spin_lock_irq(&object->work_lock);

	जबतक (!list_empty(&op->to_करो)) अणु
		monitor = list_entry(op->to_करो.next,
				     काष्ठा cachefiles_one_पढ़ो, op_link);
		list_del(&monitor->op_link);

		spin_unlock_irq(&object->work_lock);

		_debug("- copy {%lu}", monitor->back_page->index);

	recheck:
		अगर (test_bit(FSCACHE_COOKIE_INVALIDATING,
			     &object->fscache.cookie->flags)) अणु
			error = -ESTALE;
		पूर्ण अन्यथा अगर (PageUptodate(monitor->back_page)) अणु
			copy_highpage(monitor->netfs_page, monitor->back_page);
			fscache_mark_page_cached(monitor->op,
						 monitor->netfs_page);
			error = 0;
		पूर्ण अन्यथा अगर (!PageError(monitor->back_page)) अणु
			/* the page has probably been truncated */
			error = cachefiles_पढ़ो_reissue(object, monitor);
			अगर (error == -EINPROGRESS)
				जाओ next;
			जाओ recheck;
		पूर्ण अन्यथा अणु
			cachefiles_io_error_obj(
				object,
				"Readpage failed on backing file %lx",
				(अचिन्हित दीर्घ) monitor->back_page->flags);
			error = -EIO;
		पूर्ण

		put_page(monitor->back_page);

		fscache_end_io(op, monitor->netfs_page, error);
		put_page(monitor->netfs_page);
		fscache_retrieval_complete(op, 1);
		fscache_put_retrieval(op);
		kमुक्त(monitor);

	next:
		/* let the thपढ़ो pool have some air occasionally */
		max--;
		अगर (max < 0 || need_resched()) अणु
			अगर (!list_empty(&op->to_करो))
				fscache_enqueue_retrieval(op);
			_leave(" [maxed out]");
			वापस;
		पूर्ण

		spin_lock_irq(&object->work_lock);
	पूर्ण

	spin_unlock_irq(&object->work_lock);
	_leave("");
पूर्ण

/*
 * पढ़ो the corresponding page to the given set from the backing file
 * - an uncertain page is simply discarded, to be tried again another समय
 */
अटल पूर्णांक cachefiles_पढ़ो_backing_file_one(काष्ठा cachefiles_object *object,
					    काष्ठा fscache_retrieval *op,
					    काष्ठा page *netpage)
अणु
	काष्ठा cachefiles_one_पढ़ो *monitor;
	काष्ठा address_space *bmapping;
	काष्ठा page *newpage, *backpage;
	पूर्णांक ret;

	_enter("");

	_debug("read back %p{%lu,%d}",
	       netpage, netpage->index, page_count(netpage));

	monitor = kzalloc(माप(*monitor), cachefiles_gfp);
	अगर (!monitor)
		जाओ nomem;

	monitor->netfs_page = netpage;
	monitor->op = fscache_get_retrieval(op);

	init_रुकोqueue_func_entry(&monitor->monitor, cachefiles_पढ़ो_रुकोer);

	/* attempt to get hold of the backing page */
	bmapping = d_backing_inode(object->backer)->i_mapping;
	newpage = शून्य;

	क्रम (;;) अणु
		backpage = find_get_page(bmapping, netpage->index);
		अगर (backpage)
			जाओ backing_page_alपढ़ोy_present;

		अगर (!newpage) अणु
			newpage = __page_cache_alloc(cachefiles_gfp);
			अगर (!newpage)
				जाओ nomem_monitor;
		पूर्ण

		ret = add_to_page_cache_lru(newpage, bmapping,
					    netpage->index, cachefiles_gfp);
		अगर (ret == 0)
			जाओ installed_new_backing_page;
		अगर (ret != -EEXIST)
			जाओ nomem_page;
	पूर्ण

	/* we've installed a new backing page, so now we need to start
	 * it पढ़ोing */
installed_new_backing_page:
	_debug("- new %p", newpage);

	backpage = newpage;
	newpage = शून्य;

पढ़ो_backing_page:
	ret = bmapping->a_ops->पढ़ोpage(शून्य, backpage);
	अगर (ret < 0)
		जाओ पढ़ो_error;

	/* set the monitor to transfer the data across */
monitor_backing_page:
	_debug("- monitor add");

	/* install the monitor */
	get_page(monitor->netfs_page);
	get_page(backpage);
	monitor->back_page = backpage;
	monitor->monitor.निजी = backpage;
	add_page_रुको_queue(backpage, &monitor->monitor);
	monitor = शून्य;

	/* but the page may have been पढ़ो beक्रमe the monitor was installed, so
	 * the monitor may miss the event - so we have to ensure that we करो get
	 * one in such a हाल */
	अगर (trylock_page(backpage)) अणु
		_debug("jumpstart %p {%lx}", backpage, backpage->flags);
		unlock_page(backpage);
	पूर्ण
	जाओ success;

	/* अगर the backing page is alपढ़ोy present, it can be in one of
	 * three states: पढ़ो in progress, पढ़ो failed or पढ़ो okay */
backing_page_alपढ़ोy_present:
	_debug("- present");

	अगर (newpage) अणु
		put_page(newpage);
		newpage = शून्य;
	पूर्ण

	अगर (PageError(backpage))
		जाओ io_error;

	अगर (PageUptodate(backpage))
		जाओ backing_page_alपढ़ोy_uptodate;

	अगर (!trylock_page(backpage))
		जाओ monitor_backing_page;
	_debug("read %p {%lx}", backpage, backpage->flags);
	जाओ पढ़ो_backing_page;

	/* the backing page is alपढ़ोy up to date, attach the netfs
	 * page to the pagecache and LRU and copy the data across */
backing_page_alपढ़ोy_uptodate:
	_debug("- uptodate");

	fscache_mark_page_cached(op, netpage);

	copy_highpage(netpage, backpage);
	fscache_end_io(op, netpage, 0);
	fscache_retrieval_complete(op, 1);

success:
	_debug("success");
	ret = 0;

out:
	अगर (backpage)
		put_page(backpage);
	अगर (monitor) अणु
		fscache_put_retrieval(monitor->op);
		kमुक्त(monitor);
	पूर्ण
	_leave(" = %d", ret);
	वापस ret;

पढ़ो_error:
	_debug("read error %d", ret);
	अगर (ret == -ENOMEM) अणु
		fscache_retrieval_complete(op, 1);
		जाओ out;
	पूर्ण
io_error:
	cachefiles_io_error_obj(object, "Page read error on backing file");
	fscache_retrieval_complete(op, 1);
	ret = -ENOBUFS;
	जाओ out;

nomem_page:
	put_page(newpage);
nomem_monitor:
	fscache_put_retrieval(monitor->op);
	kमुक्त(monitor);
nomem:
	fscache_retrieval_complete(op, 1);
	_leave(" = -ENOMEM");
	वापस -ENOMEM;
पूर्ण

/*
 * पढ़ो a page from the cache or allocate a block in which to store it
 * - cache withdrawal is prevented by the caller
 * - वापसs -EINTR अगर पूर्णांकerrupted
 * - वापसs -ENOMEM अगर ran out of memory
 * - वापसs -ENOBUFS अगर no buffers can be made available
 * - वापसs -ENOBUFS अगर page is beyond खातापूर्ण
 * - अगर the page is backed by a block in the cache:
 *   - a पढ़ो will be started which will call the callback on completion
 *   - 0 will be वापसed
 * - अन्यथा अगर the page is unbacked:
 *   - the metadata will be retained
 *   - -ENODATA will be वापसed
 */
पूर्णांक cachefiles_पढ़ो_or_alloc_page(काष्ठा fscache_retrieval *op,
				  काष्ठा page *page,
				  gfp_t gfp)
अणु
	काष्ठा cachefiles_object *object;
	काष्ठा cachefiles_cache *cache;
	काष्ठा inode *inode;
	sector_t block;
	अचिन्हित shअगरt;
	पूर्णांक ret, ret2;

	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);
	cache = container_of(object->fscache.cache,
			     काष्ठा cachefiles_cache, cache);

	_enter("{%p},{%lx},,,", object, page->index);

	अगर (!object->backer)
		जाओ enobufs;

	inode = d_backing_inode(object->backer);
	ASSERT(S_ISREG(inode->i_mode));

	/* calculate the shअगरt required to use bmap */
	shअगरt = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;

	op->op.flags &= FSCACHE_OP_KEEP_FLAGS;
	op->op.flags |= FSCACHE_OP_ASYNC;
	op->op.processor = cachefiles_पढ़ो_copier;

	/* we assume the असलence or presence of the first block is a good
	 * enough indication क्रम the page as a whole
	 * - TODO: करोn't use bmap() क्रम this as it is _not_ actually good
	 *   enough क्रम this as it करोesn't indicate errors, but it's all we've
	 *   got क्रम the moment
	 */
	block = page->index;
	block <<= shअगरt;

	ret2 = bmap(inode, &block);
	ASSERT(ret2 == 0);

	_debug("%llx -> %llx",
	       (अचिन्हित दीर्घ दीर्घ) (page->index << shअगरt),
	       (अचिन्हित दीर्घ दीर्घ) block);

	अगर (block) अणु
		/* submit the apparently valid page to the backing fs to be
		 * पढ़ो from disk */
		ret = cachefiles_पढ़ो_backing_file_one(object, op, page);
	पूर्ण अन्यथा अगर (cachefiles_has_space(cache, 0, 1) == 0) अणु
		/* there's space in the cache we can use */
		fscache_mark_page_cached(op, page);
		fscache_retrieval_complete(op, 1);
		ret = -ENODATA;
	पूर्ण अन्यथा अणु
		जाओ enobufs;
	पूर्ण

	_leave(" = %d", ret);
	वापस ret;

enobufs:
	fscache_retrieval_complete(op, 1);
	_leave(" = -ENOBUFS");
	वापस -ENOBUFS;
पूर्ण

/*
 * पढ़ो the corresponding pages to the given set from the backing file
 * - any uncertain pages are simply discarded, to be tried again another समय
 */
अटल पूर्णांक cachefiles_पढ़ो_backing_file(काष्ठा cachefiles_object *object,
					काष्ठा fscache_retrieval *op,
					काष्ठा list_head *list)
अणु
	काष्ठा cachefiles_one_पढ़ो *monitor = शून्य;
	काष्ठा address_space *bmapping = d_backing_inode(object->backer)->i_mapping;
	काष्ठा page *newpage = शून्य, *netpage, *_n, *backpage = शून्य;
	पूर्णांक ret = 0;

	_enter("");

	list_क्रम_each_entry_safe(netpage, _n, list, lru) अणु
		list_del(&netpage->lru);

		_debug("read back %p{%lu,%d}",
		       netpage, netpage->index, page_count(netpage));

		अगर (!monitor) अणु
			monitor = kzalloc(माप(*monitor), cachefiles_gfp);
			अगर (!monitor)
				जाओ nomem;

			monitor->op = fscache_get_retrieval(op);
			init_रुकोqueue_func_entry(&monitor->monitor,
						  cachefiles_पढ़ो_रुकोer);
		पूर्ण

		क्रम (;;) अणु
			backpage = find_get_page(bmapping, netpage->index);
			अगर (backpage)
				जाओ backing_page_alपढ़ोy_present;

			अगर (!newpage) अणु
				newpage = __page_cache_alloc(cachefiles_gfp);
				अगर (!newpage)
					जाओ nomem;
			पूर्ण

			ret = add_to_page_cache_lru(newpage, bmapping,
						    netpage->index,
						    cachefiles_gfp);
			अगर (ret == 0)
				जाओ installed_new_backing_page;
			अगर (ret != -EEXIST)
				जाओ nomem;
		पूर्ण

		/* we've installed a new backing page, so now we need
		 * to start it पढ़ोing */
	installed_new_backing_page:
		_debug("- new %p", newpage);

		backpage = newpage;
		newpage = शून्य;

	reपढ़ो_backing_page:
		ret = bmapping->a_ops->पढ़ोpage(शून्य, backpage);
		अगर (ret < 0)
			जाओ पढ़ो_error;

		/* add the netfs page to the pagecache and LRU, and set the
		 * monitor to transfer the data across */
	monitor_backing_page:
		_debug("- monitor add");

		ret = add_to_page_cache_lru(netpage, op->mapping,
					    netpage->index, cachefiles_gfp);
		अगर (ret < 0) अणु
			अगर (ret == -EEXIST) अणु
				put_page(backpage);
				backpage = शून्य;
				put_page(netpage);
				netpage = शून्य;
				fscache_retrieval_complete(op, 1);
				जारी;
			पूर्ण
			जाओ nomem;
		पूर्ण

		/* install a monitor */
		get_page(netpage);
		monitor->netfs_page = netpage;

		get_page(backpage);
		monitor->back_page = backpage;
		monitor->monitor.निजी = backpage;
		add_page_रुको_queue(backpage, &monitor->monitor);
		monitor = शून्य;

		/* but the page may have been पढ़ो beक्रमe the monitor was
		 * installed, so the monitor may miss the event - so we have to
		 * ensure that we करो get one in such a हाल */
		अगर (trylock_page(backpage)) अणु
			_debug("2unlock %p {%lx}", backpage, backpage->flags);
			unlock_page(backpage);
		पूर्ण

		put_page(backpage);
		backpage = शून्य;

		put_page(netpage);
		netpage = शून्य;
		जारी;

		/* अगर the backing page is alपढ़ोy present, it can be in one of
		 * three states: पढ़ो in progress, पढ़ो failed or पढ़ो okay */
	backing_page_alपढ़ोy_present:
		_debug("- present %p", backpage);

		अगर (PageError(backpage))
			जाओ io_error;

		अगर (PageUptodate(backpage))
			जाओ backing_page_alपढ़ोy_uptodate;

		_debug("- not ready %p{%lx}", backpage, backpage->flags);

		अगर (!trylock_page(backpage))
			जाओ monitor_backing_page;

		अगर (PageError(backpage)) अणु
			_debug("error %lx", backpage->flags);
			unlock_page(backpage);
			जाओ io_error;
		पूर्ण

		अगर (PageUptodate(backpage))
			जाओ backing_page_alपढ़ोy_uptodate_unlock;

		/* we've locked a page that's neither up to date nor erroneous,
		 * so we need to attempt to पढ़ो it again */
		जाओ reपढ़ो_backing_page;

		/* the backing page is alपढ़ोy up to date, attach the netfs
		 * page to the pagecache and LRU and copy the data across */
	backing_page_alपढ़ोy_uptodate_unlock:
		_debug("uptodate %lx", backpage->flags);
		unlock_page(backpage);
	backing_page_alपढ़ोy_uptodate:
		_debug("- uptodate");

		ret = add_to_page_cache_lru(netpage, op->mapping,
					    netpage->index, cachefiles_gfp);
		अगर (ret < 0) अणु
			अगर (ret == -EEXIST) अणु
				put_page(backpage);
				backpage = शून्य;
				put_page(netpage);
				netpage = शून्य;
				fscache_retrieval_complete(op, 1);
				जारी;
			पूर्ण
			जाओ nomem;
		पूर्ण

		copy_highpage(netpage, backpage);

		put_page(backpage);
		backpage = शून्य;

		fscache_mark_page_cached(op, netpage);

		/* the netpage is unlocked and marked up to date here */
		fscache_end_io(op, netpage, 0);
		put_page(netpage);
		netpage = शून्य;
		fscache_retrieval_complete(op, 1);
		जारी;
	पूर्ण

	netpage = शून्य;

	_debug("out");

out:
	/* tidy up */
	अगर (newpage)
		put_page(newpage);
	अगर (netpage)
		put_page(netpage);
	अगर (backpage)
		put_page(backpage);
	अगर (monitor) अणु
		fscache_put_retrieval(op);
		kमुक्त(monitor);
	पूर्ण

	list_क्रम_each_entry_safe(netpage, _n, list, lru) अणु
		list_del(&netpage->lru);
		put_page(netpage);
		fscache_retrieval_complete(op, 1);
	पूर्ण

	_leave(" = %d", ret);
	वापस ret;

nomem:
	_debug("nomem");
	ret = -ENOMEM;
	जाओ record_page_complete;

पढ़ो_error:
	_debug("read error %d", ret);
	अगर (ret == -ENOMEM)
		जाओ record_page_complete;
io_error:
	cachefiles_io_error_obj(object, "Page read error on backing file");
	ret = -ENOBUFS;
record_page_complete:
	fscache_retrieval_complete(op, 1);
	जाओ out;
पूर्ण

/*
 * पढ़ो a list of pages from the cache or allocate blocks in which to store
 * them
 */
पूर्णांक cachefiles_पढ़ो_or_alloc_pages(काष्ठा fscache_retrieval *op,
				   काष्ठा list_head *pages,
				   अचिन्हित *nr_pages,
				   gfp_t gfp)
अणु
	काष्ठा cachefiles_object *object;
	काष्ठा cachefiles_cache *cache;
	काष्ठा list_head backpages;
	काष्ठा pagevec pagevec;
	काष्ठा inode *inode;
	काष्ठा page *page, *_n;
	अचिन्हित shअगरt, nrbackpages;
	पूर्णांक ret, ret2, space;

	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);
	cache = container_of(object->fscache.cache,
			     काष्ठा cachefiles_cache, cache);

	_enter("{OBJ%x,%d},,%d,,",
	       object->fscache.debug_id, atomic_पढ़ो(&op->op.usage),
	       *nr_pages);

	अगर (!object->backer)
		जाओ all_enobufs;

	space = 1;
	अगर (cachefiles_has_space(cache, 0, *nr_pages) < 0)
		space = 0;

	inode = d_backing_inode(object->backer);
	ASSERT(S_ISREG(inode->i_mode));

	/* calculate the shअगरt required to use bmap */
	shअगरt = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;

	pagevec_init(&pagevec);

	op->op.flags &= FSCACHE_OP_KEEP_FLAGS;
	op->op.flags |= FSCACHE_OP_ASYNC;
	op->op.processor = cachefiles_पढ़ो_copier;

	INIT_LIST_HEAD(&backpages);
	nrbackpages = 0;

	ret = space ? -ENODATA : -ENOBUFS;
	list_क्रम_each_entry_safe(page, _n, pages, lru) अणु
		sector_t block;

		/* we assume the असलence or presence of the first block is a
		 * good enough indication क्रम the page as a whole
		 * - TODO: करोn't use bmap() क्रम this as it is _not_ actually
		 *   good enough क्रम this as it करोesn't indicate errors, but
		 *   it's all we've got क्रम the moment
		 */
		block = page->index;
		block <<= shअगरt;

		ret2 = bmap(inode, &block);
		ASSERT(ret2 == 0);

		_debug("%llx -> %llx",
		       (अचिन्हित दीर्घ दीर्घ) (page->index << shअगरt),
		       (अचिन्हित दीर्घ दीर्घ) block);

		अगर (block) अणु
			/* we have data - add it to the list to give to the
			 * backing fs */
			list_move(&page->lru, &backpages);
			(*nr_pages)--;
			nrbackpages++;
		पूर्ण अन्यथा अगर (space && pagevec_add(&pagevec, page) == 0) अणु
			fscache_mark_pages_cached(op, &pagevec);
			fscache_retrieval_complete(op, 1);
			ret = -ENODATA;
		पूर्ण अन्यथा अणु
			fscache_retrieval_complete(op, 1);
		पूर्ण
	पूर्ण

	अगर (pagevec_count(&pagevec) > 0)
		fscache_mark_pages_cached(op, &pagevec);

	अगर (list_empty(pages))
		ret = 0;

	/* submit the apparently valid pages to the backing fs to be पढ़ो from
	 * disk */
	अगर (nrbackpages > 0) अणु
		ret2 = cachefiles_पढ़ो_backing_file(object, op, &backpages);
		अगर (ret2 == -ENOMEM || ret2 == -EINTR)
			ret = ret2;
	पूर्ण

	_leave(" = %d [nr=%u%s]",
	       ret, *nr_pages, list_empty(pages) ? " empty" : "");
	वापस ret;

all_enobufs:
	fscache_retrieval_complete(op, *nr_pages);
	वापस -ENOBUFS;
पूर्ण

/*
 * allocate a block in the cache in which to store a page
 * - cache withdrawal is prevented by the caller
 * - वापसs -EINTR अगर पूर्णांकerrupted
 * - वापसs -ENOMEM अगर ran out of memory
 * - वापसs -ENOBUFS अगर no buffers can be made available
 * - वापसs -ENOBUFS अगर page is beyond खातापूर्ण
 * - otherwise:
 *   - the metadata will be retained
 *   - 0 will be वापसed
 */
पूर्णांक cachefiles_allocate_page(काष्ठा fscache_retrieval *op,
			     काष्ठा page *page,
			     gfp_t gfp)
अणु
	काष्ठा cachefiles_object *object;
	काष्ठा cachefiles_cache *cache;
	पूर्णांक ret;

	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);
	cache = container_of(object->fscache.cache,
			     काष्ठा cachefiles_cache, cache);

	_enter("%p,{%lx},", object, page->index);

	ret = cachefiles_has_space(cache, 0, 1);
	अगर (ret == 0)
		fscache_mark_page_cached(op, page);
	अन्यथा
		ret = -ENOBUFS;

	fscache_retrieval_complete(op, 1);
	_leave(" = %d", ret);
	वापस ret;
पूर्ण

/*
 * allocate blocks in the cache in which to store a set of pages
 * - cache withdrawal is prevented by the caller
 * - वापसs -EINTR अगर पूर्णांकerrupted
 * - वापसs -ENOMEM अगर ran out of memory
 * - वापसs -ENOBUFS अगर some buffers couldn't be made available
 * - वापसs -ENOBUFS अगर some pages are beyond खातापूर्ण
 * - otherwise:
 *   - -ENODATA will be वापसed
 * - metadata will be retained क्रम any page marked
 */
पूर्णांक cachefiles_allocate_pages(काष्ठा fscache_retrieval *op,
			      काष्ठा list_head *pages,
			      अचिन्हित *nr_pages,
			      gfp_t gfp)
अणु
	काष्ठा cachefiles_object *object;
	काष्ठा cachefiles_cache *cache;
	काष्ठा pagevec pagevec;
	काष्ठा page *page;
	पूर्णांक ret;

	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);
	cache = container_of(object->fscache.cache,
			     काष्ठा cachefiles_cache, cache);

	_enter("%p,,,%d,", object, *nr_pages);

	ret = cachefiles_has_space(cache, 0, *nr_pages);
	अगर (ret == 0) अणु
		pagevec_init(&pagevec);

		list_क्रम_each_entry(page, pages, lru) अणु
			अगर (pagevec_add(&pagevec, page) == 0)
				fscache_mark_pages_cached(op, &pagevec);
		पूर्ण

		अगर (pagevec_count(&pagevec) > 0)
			fscache_mark_pages_cached(op, &pagevec);
		ret = -ENODATA;
	पूर्ण अन्यथा अणु
		ret = -ENOBUFS;
	पूर्ण

	fscache_retrieval_complete(op, *nr_pages);
	_leave(" = %d", ret);
	वापस ret;
पूर्ण

/*
 * request a page be stored in the cache
 * - cache withdrawal is prevented by the caller
 * - this request may be ignored अगर there's no cache block available, in which
 *   हाल -ENOBUFS will be वापसed
 * - अगर the op is in progress, 0 will be वापसed
 */
पूर्णांक cachefiles_ग_लिखो_page(काष्ठा fscache_storage *op, काष्ठा page *page)
अणु
	काष्ठा cachefiles_object *object;
	काष्ठा cachefiles_cache *cache;
	काष्ठा file *file;
	काष्ठा path path;
	loff_t pos, eof;
	माप_प्रकार len;
	व्योम *data;
	पूर्णांक ret = -ENOBUFS;

	ASSERT(op != शून्य);
	ASSERT(page != शून्य);

	object = container_of(op->op.object,
			      काष्ठा cachefiles_object, fscache);

	_enter("%p,%p{%lx},,,", object, page, page->index);

	अगर (!object->backer) अणु
		_leave(" = -ENOBUFS");
		वापस -ENOBUFS;
	पूर्ण

	ASSERT(d_is_reg(object->backer));

	cache = container_of(object->fscache.cache,
			     काष्ठा cachefiles_cache, cache);

	pos = (loff_t)page->index << PAGE_SHIFT;

	/* We mustn't ग_लिखो more data than we have, so we have to beware of a
	 * partial page at खातापूर्ण.
	 */
	eof = object->fscache.store_limit_l;
	अगर (pos >= eof)
		जाओ error;

	/* ग_लिखो the page to the backing fileप्रणाली and let it store it in its
	 * own समय */
	path.mnt = cache->mnt;
	path.dentry = object->backer;
	file = dentry_खोलो(&path, O_RDWR | O_LARGEखाता, cache->cache_cred);
	अगर (IS_ERR(file)) अणु
		ret = PTR_ERR(file);
		जाओ error_2;
	पूर्ण

	len = PAGE_SIZE;
	अगर (eof & ~PAGE_MASK) अणु
		अगर (eof - pos < PAGE_SIZE) अणु
			_debug("cut short %llx to %llx",
			       pos, eof);
			len = eof - pos;
			ASSERTCMP(pos + len, ==, eof);
		पूर्ण
	पूर्ण

	data = kmap(page);
	ret = kernel_ग_लिखो(file, data, len, &pos);
	kunmap(page);
	fput(file);
	अगर (ret != len)
		जाओ error_eio;

	_leave(" = 0");
	वापस 0;

error_eio:
	ret = -EIO;
error_2:
	अगर (ret == -EIO)
		cachefiles_io_error_obj(object,
					"Write page to backing file failed");
error:
	_leave(" = -ENOBUFS [%d]", ret);
	वापस -ENOBUFS;
पूर्ण

/*
 * detach a backing block from a page
 * - cache withdrawal is prevented by the caller
 */
व्योम cachefiles_uncache_page(काष्ठा fscache_object *_object, काष्ठा page *page)
	__releases(&object->fscache.cookie->lock)
अणु
	काष्ठा cachefiles_object *object;

	object = container_of(_object, काष्ठा cachefiles_object, fscache);

	_enter("%p,{%lu}", object, page->index);

	spin_unlock(&object->fscache.cookie->lock);
पूर्ण
