<शैली गुरु>
/* SPDX-License-Identअगरier: GPL-2.0 */
/*
 * fscrypt_निजी.h
 *
 * Copyright (C) 2015, Google, Inc.
 *
 * Originally written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar.
 * Heavily modअगरied since then.
 */

#अगर_अघोषित _FSCRYPT_PRIVATE_H
#घोषणा _FSCRYPT_PRIVATE_H

#समावेश <linux/fscrypt.h>
#समावेश <linux/siphash.h>
#समावेश <crypto/hash.h>
#समावेश <linux/blk-crypto.h>

#घोषणा CONST_STRLEN(str)	(माप(str) - 1)

#घोषणा FSCRYPT_खाता_NONCE_SIZE	16

#घोषणा FSCRYPT_MIN_KEY_SIZE	16

#घोषणा FSCRYPT_CONTEXT_V1	1
#घोषणा FSCRYPT_CONTEXT_V2	2

/* Keep this in sync with include/uapi/linux/fscrypt.h */
#घोषणा FSCRYPT_MODE_MAX	FSCRYPT_MODE_ADIANTUM

काष्ठा fscrypt_context_v1 अणु
	u8 version; /* FSCRYPT_CONTEXT_V1 */
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
	u8 nonce[FSCRYPT_खाता_NONCE_SIZE];
पूर्ण;

काष्ठा fscrypt_context_v2 अणु
	u8 version; /* FSCRYPT_CONTEXT_V2 */
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 __reserved[4];
	u8 master_key_identअगरier[FSCRYPT_KEY_IDENTIFIER_SIZE];
	u8 nonce[FSCRYPT_खाता_NONCE_SIZE];
पूर्ण;

/*
 * fscrypt_context - the encryption context of an inode
 *
 * This is the on-disk equivalent of an fscrypt_policy, stored aदीर्घside each
 * encrypted file usually in a hidden extended attribute.  It contains the
 * fields from the fscrypt_policy, in order to identअगरy the encryption algorithm
 * and key with which the file is encrypted.  It also contains a nonce that was
 * अक्रमomly generated by fscrypt itself; this is used as KDF input or as a tweak
 * to cause dअगरferent files to be encrypted dअगरferently.
 */
जोड़ fscrypt_context अणु
	u8 version;
	काष्ठा fscrypt_context_v1 v1;
	काष्ठा fscrypt_context_v2 v2;
पूर्ण;

/*
 * Return the size expected क्रम the given fscrypt_context based on its version
 * number, or 0 अगर the context version is unrecognized.
 */
अटल अंतरभूत पूर्णांक fscrypt_context_size(स्थिर जोड़ fscrypt_context *ctx)
अणु
	चयन (ctx->version) अणु
	हाल FSCRYPT_CONTEXT_V1:
		BUILD_BUG_ON(माप(ctx->v1) != 28);
		वापस माप(ctx->v1);
	हाल FSCRYPT_CONTEXT_V2:
		BUILD_BUG_ON(माप(ctx->v2) != 40);
		वापस माप(ctx->v2);
	पूर्ण
	वापस 0;
पूर्ण

/* Check whether an fscrypt_context has a recognized version number and size */
अटल अंतरभूत bool fscrypt_context_is_valid(स्थिर जोड़ fscrypt_context *ctx,
					    पूर्णांक ctx_size)
अणु
	वापस ctx_size >= 1 && ctx_size == fscrypt_context_size(ctx);
पूर्ण

/* Retrieve the context's nonce, assuming the context was alपढ़ोy validated */
अटल अंतरभूत स्थिर u8 *fscrypt_context_nonce(स्थिर जोड़ fscrypt_context *ctx)
अणु
	चयन (ctx->version) अणु
	हाल FSCRYPT_CONTEXT_V1:
		वापस ctx->v1.nonce;
	हाल FSCRYPT_CONTEXT_V2:
		वापस ctx->v2.nonce;
	पूर्ण
	WARN_ON(1);
	वापस शून्य;
पूर्ण

जोड़ fscrypt_policy अणु
	u8 version;
	काष्ठा fscrypt_policy_v1 v1;
	काष्ठा fscrypt_policy_v2 v2;
पूर्ण;

/*
 * Return the size expected क्रम the given fscrypt_policy based on its version
 * number, or 0 अगर the policy version is unrecognized.
 */
अटल अंतरभूत पूर्णांक fscrypt_policy_size(स्थिर जोड़ fscrypt_policy *policy)
अणु
	चयन (policy->version) अणु
	हाल FSCRYPT_POLICY_V1:
		वापस माप(policy->v1);
	हाल FSCRYPT_POLICY_V2:
		वापस माप(policy->v2);
	पूर्ण
	वापस 0;
पूर्ण

/* Return the contents encryption mode of a valid encryption policy */
अटल अंतरभूत u8
fscrypt_policy_contents_mode(स्थिर जोड़ fscrypt_policy *policy)
अणु
	चयन (policy->version) अणु
	हाल FSCRYPT_POLICY_V1:
		वापस policy->v1.contents_encryption_mode;
	हाल FSCRYPT_POLICY_V2:
		वापस policy->v2.contents_encryption_mode;
	पूर्ण
	BUG();
पूर्ण

/* Return the filenames encryption mode of a valid encryption policy */
अटल अंतरभूत u8
fscrypt_policy_fnames_mode(स्थिर जोड़ fscrypt_policy *policy)
अणु
	चयन (policy->version) अणु
	हाल FSCRYPT_POLICY_V1:
		वापस policy->v1.filenames_encryption_mode;
	हाल FSCRYPT_POLICY_V2:
		वापस policy->v2.filenames_encryption_mode;
	पूर्ण
	BUG();
पूर्ण

/* Return the flags (FSCRYPT_POLICY_FLAG*) of a valid encryption policy */
अटल अंतरभूत u8
fscrypt_policy_flags(स्थिर जोड़ fscrypt_policy *policy)
अणु
	चयन (policy->version) अणु
	हाल FSCRYPT_POLICY_V1:
		वापस policy->v1.flags;
	हाल FSCRYPT_POLICY_V2:
		वापस policy->v2.flags;
	पूर्ण
	BUG();
पूर्ण

/*
 * For encrypted symlinks, the ciphertext length is stored at the beginning
 * of the string in little-endian क्रमmat.
 */
काष्ठा fscrypt_symlink_data अणु
	__le16 len;
	अक्षर encrypted_path[1];
पूर्ण __packed;

/**
 * काष्ठा fscrypt_prepared_key - a key prepared क्रम actual encryption/decryption
 * @tfm: crypto API transक्रमm object
 * @blk_key: key क्रम blk-crypto
 *
 * Normally only one of the fields will be non-शून्य.
 */
काष्ठा fscrypt_prepared_key अणु
	काष्ठा crypto_skcipher *tfm;
#अगर_घोषित CONFIG_FS_ENCRYPTION_INLINE_CRYPT
	काष्ठा fscrypt_blk_crypto_key *blk_key;
#पूर्ण_अगर
पूर्ण;

/*
 * fscrypt_info - the "encryption key" क्रम an inode
 *
 * When an encrypted file's key is made available, an instance of this काष्ठा is
 * allocated and stored in ->i_crypt_info.  Once created, it reमुख्यs until the
 * inode is evicted.
 */
काष्ठा fscrypt_info अणु

	/* The key in a क्रमm prepared क्रम actual encryption/decryption */
	काष्ठा fscrypt_prepared_key ci_enc_key;

	/* True अगर ci_enc_key should be मुक्तd when this fscrypt_info is मुक्तd */
	bool ci_owns_key;

#अगर_घोषित CONFIG_FS_ENCRYPTION_INLINE_CRYPT
	/*
	 * True अगर this inode will use अंतरभूत encryption (blk-crypto) instead of
	 * the traditional fileप्रणाली-layer encryption.
	 */
	bool ci_अंतरभूतcrypt;
#पूर्ण_अगर

	/*
	 * Encryption mode used क्रम this inode.  It corresponds to either the
	 * contents or filenames encryption mode, depending on the inode type.
	 */
	काष्ठा fscrypt_mode *ci_mode;

	/* Back-poपूर्णांकer to the inode */
	काष्ठा inode *ci_inode;

	/*
	 * The master key with which this inode was unlocked (decrypted).  This
	 * will be शून्य अगर the master key was found in a process-subscribed
	 * keyring rather than in the fileप्रणाली-level keyring.
	 */
	काष्ठा key *ci_master_key;

	/*
	 * Link in list of inodes that were unlocked with the master key.
	 * Only used when ->ci_master_key is set.
	 */
	काष्ठा list_head ci_master_key_link;

	/*
	 * If non-शून्य, then encryption is करोne using the master key directly
	 * and ci_enc_key will equal ci_direct_key->dk_key.
	 */
	काष्ठा fscrypt_direct_key *ci_direct_key;

	/*
	 * This inode's hash key क्रम filenames.  This is a 128-bit SipHash-2-4
	 * key.  This is only set क्रम directories that use a keyed dirhash over
	 * the plaपूर्णांकext filenames -- currently just हालfolded directories.
	 */
	siphash_key_t ci_dirhash_key;
	bool ci_dirhash_key_initialized;

	/* The encryption policy used by this inode */
	जोड़ fscrypt_policy ci_policy;

	/* This inode's nonce, copied from the fscrypt_context */
	u8 ci_nonce[FSCRYPT_खाता_NONCE_SIZE];

	/* Hashed inode number.  Only set क्रम IV_INO_LBLK_32 */
	u32 ci_hashed_ino;
पूर्ण;

प्रकार क्रमागत अणु
	FS_DECRYPT = 0,
	FS_ENCRYPT,
पूर्ण fscrypt_direction_t;

/* crypto.c */
बाह्य काष्ठा kmem_cache *fscrypt_info_cachep;
पूर्णांक fscrypt_initialize(अचिन्हित पूर्णांक cop_flags);
पूर्णांक fscrypt_crypt_block(स्थिर काष्ठा inode *inode, fscrypt_direction_t rw,
			u64 lblk_num, काष्ठा page *src_page,
			काष्ठा page *dest_page, अचिन्हित पूर्णांक len,
			अचिन्हित पूर्णांक offs, gfp_t gfp_flags);
काष्ठा page *fscrypt_alloc_bounce_page(gfp_t gfp_flags);

व्योम __म_लिखो(3, 4) __cold
fscrypt_msg(स्थिर काष्ठा inode *inode, स्थिर अक्षर *level, स्थिर अक्षर *fmt, ...);

#घोषणा fscrypt_warn(inode, fmt, ...)		\
	fscrypt_msg((inode), KERN_WARNING, fmt, ##__VA_ARGS__)
#घोषणा fscrypt_err(inode, fmt, ...)		\
	fscrypt_msg((inode), KERN_ERR, fmt, ##__VA_ARGS__)

#घोषणा FSCRYPT_MAX_IV_SIZE	32

जोड़ fscrypt_iv अणु
	काष्ठा अणु
		/* logical block number within the file */
		__le64 lblk_num;

		/* per-file nonce; only set in सूचीECT_KEY mode */
		u8 nonce[FSCRYPT_खाता_NONCE_SIZE];
	पूर्ण;
	u8 raw[FSCRYPT_MAX_IV_SIZE];
	__le64 dun[FSCRYPT_MAX_IV_SIZE / माप(__le64)];
पूर्ण;

व्योम fscrypt_generate_iv(जोड़ fscrypt_iv *iv, u64 lblk_num,
			 स्थिर काष्ठा fscrypt_info *ci);

/* fname.c */
पूर्णांक fscrypt_fname_encrypt(स्थिर काष्ठा inode *inode, स्थिर काष्ठा qstr *iname,
			  u8 *out, अचिन्हित पूर्णांक olen);
bool fscrypt_fname_encrypted_size(स्थिर जोड़ fscrypt_policy *policy,
				  u32 orig_len, u32 max_len,
				  u32 *encrypted_len_ret);

/* hkdf.c */

काष्ठा fscrypt_hkdf अणु
	काष्ठा crypto_shash *hmac_tfm;
पूर्ण;

पूर्णांक fscrypt_init_hkdf(काष्ठा fscrypt_hkdf *hkdf, स्थिर u8 *master_key,
		      अचिन्हित पूर्णांक master_key_size);

/*
 * The list of contexts in which fscrypt uses HKDF.  These values are used as
 * the first byte of the HKDF application-specअगरic info string to guarantee that
 * info strings are never repeated between contexts.  This ensures that all HKDF
 * outमाला_दो are unique and cryptographically isolated, i.e. knowledge of one
 * output करोesn't reveal another.
 */
#घोषणा HKDF_CONTEXT_KEY_IDENTIFIER	1 /* info=<empty>		*/
#घोषणा HKDF_CONTEXT_PER_खाता_ENC_KEY	2 /* info=file_nonce		*/
#घोषणा HKDF_CONTEXT_सूचीECT_KEY		3 /* info=mode_num		*/
#घोषणा HKDF_CONTEXT_IV_INO_LBLK_64_KEY	4 /* info=mode_num||fs_uuid	*/
#घोषणा HKDF_CONTEXT_सूचीHASH_KEY	5 /* info=file_nonce		*/
#घोषणा HKDF_CONTEXT_IV_INO_LBLK_32_KEY	6 /* info=mode_num||fs_uuid	*/
#घोषणा HKDF_CONTEXT_INODE_HASH_KEY	7 /* info=<empty>		*/

पूर्णांक fscrypt_hkdf_expand(स्थिर काष्ठा fscrypt_hkdf *hkdf, u8 context,
			स्थिर u8 *info, अचिन्हित पूर्णांक infolen,
			u8 *okm, अचिन्हित पूर्णांक okmlen);

व्योम fscrypt_destroy_hkdf(काष्ठा fscrypt_hkdf *hkdf);

/* अंतरभूत_crypt.c */
#अगर_घोषित CONFIG_FS_ENCRYPTION_INLINE_CRYPT
पूर्णांक fscrypt_select_encryption_impl(काष्ठा fscrypt_info *ci);

अटल अंतरभूत bool
fscrypt_using_अंतरभूत_encryption(स्थिर काष्ठा fscrypt_info *ci)
अणु
	वापस ci->ci_अंतरभूतcrypt;
पूर्ण

पूर्णांक fscrypt_prepare_अंतरभूत_crypt_key(काष्ठा fscrypt_prepared_key *prep_key,
				     स्थिर u8 *raw_key,
				     स्थिर काष्ठा fscrypt_info *ci);

व्योम fscrypt_destroy_अंतरभूत_crypt_key(काष्ठा fscrypt_prepared_key *prep_key);

/*
 * Check whether the crypto transक्रमm or blk-crypto key has been allocated in
 * @prep_key, depending on which encryption implementation the file will use.
 */
अटल अंतरभूत bool
fscrypt_is_key_prepared(काष्ठा fscrypt_prepared_key *prep_key,
			स्थिर काष्ठा fscrypt_info *ci)
अणु
	/*
	 * The two smp_load_acquire()'s here pair with the smp_store_release()'s
	 * in fscrypt_prepare_अंतरभूत_crypt_key() and fscrypt_prepare_key().
	 * I.e., in some हालs (namely, अगर this prep_key is a per-mode
	 * encryption key) another task can publish blk_key or tfm concurrently,
	 * executing a RELEASE barrier.  We need to use smp_load_acquire() here
	 * to safely ACQUIRE the memory the other task published.
	 */
	अगर (fscrypt_using_अंतरभूत_encryption(ci))
		वापस smp_load_acquire(&prep_key->blk_key) != शून्य;
	वापस smp_load_acquire(&prep_key->tfm) != शून्य;
पूर्ण

#अन्यथा /* CONFIG_FS_ENCRYPTION_INLINE_CRYPT */

अटल अंतरभूत पूर्णांक fscrypt_select_encryption_impl(काष्ठा fscrypt_info *ci)
अणु
	वापस 0;
पूर्ण

अटल अंतरभूत bool
fscrypt_using_अंतरभूत_encryption(स्थिर काष्ठा fscrypt_info *ci)
अणु
	वापस false;
पूर्ण

अटल अंतरभूत पूर्णांक
fscrypt_prepare_अंतरभूत_crypt_key(काष्ठा fscrypt_prepared_key *prep_key,
				 स्थिर u8 *raw_key,
				 स्थिर काष्ठा fscrypt_info *ci)
अणु
	WARN_ON(1);
	वापस -EOPNOTSUPP;
पूर्ण

अटल अंतरभूत व्योम
fscrypt_destroy_अंतरभूत_crypt_key(काष्ठा fscrypt_prepared_key *prep_key)
अणु
पूर्ण

अटल अंतरभूत bool
fscrypt_is_key_prepared(काष्ठा fscrypt_prepared_key *prep_key,
			स्थिर काष्ठा fscrypt_info *ci)
अणु
	वापस smp_load_acquire(&prep_key->tfm) != शून्य;
पूर्ण
#पूर्ण_अगर /* !CONFIG_FS_ENCRYPTION_INLINE_CRYPT */

/* keyring.c */

/*
 * fscrypt_master_key_secret - secret key material of an in-use master key
 */
काष्ठा fscrypt_master_key_secret अणु

	/*
	 * For v2 policy keys: HKDF context keyed by this master key.
	 * For v1 policy keys: not set (hkdf.hmac_tfm == शून्य).
	 */
	काष्ठा fscrypt_hkdf	hkdf;

	/* Size of the raw key in bytes.  Set even अगर ->raw isn't set. */
	u32			size;

	/* For v1 policy keys: the raw key.  Wiped क्रम v2 policy keys. */
	u8			raw[FSCRYPT_MAX_KEY_SIZE];

पूर्ण __अक्रमomize_layout;

/*
 * fscrypt_master_key - an in-use master key
 *
 * This represents a master encryption key which has been added to the
 * fileप्रणाली and can be used to "unlock" the encrypted files which were
 * encrypted with it.
 */
काष्ठा fscrypt_master_key अणु

	/*
	 * The secret key material.  After FS_IOC_REMOVE_ENCRYPTION_KEY is
	 * executed, this is wiped and no new inodes can be unlocked with this
	 * key; however, there may still be inodes in ->mk_decrypted_inodes
	 * which could not be evicted.  As दीर्घ as some inodes still reमुख्य,
	 * FS_IOC_REMOVE_ENCRYPTION_KEY can be retried, or
	 * FS_IOC_ADD_ENCRYPTION_KEY can add the secret again.
	 *
	 * Locking: रक्षित by this master key's key->sem.
	 */
	काष्ठा fscrypt_master_key_secret	mk_secret;

	/*
	 * For v1 policy keys: an arbitrary key descriptor which was asचिन्हित by
	 * userspace (->descriptor).
	 *
	 * For v2 policy keys: a cryptographic hash of this key (->identअगरier).
	 */
	काष्ठा fscrypt_key_specअगरier		mk_spec;

	/*
	 * Keyring which contains a key of type 'key_type_fscrypt_user' क्रम each
	 * user who has added this key.  Normally each key will be added by just
	 * one user, but it's possible that multiple users share a key, and in
	 * that हाल we need to keep track of those users so that one user can't
	 * हटाओ the key beक्रमe the others want it हटाओd too.
	 *
	 * This is शून्य क्रम v1 policy keys; those can only be added by root.
	 *
	 * Locking: in addition to this keyring's own semaphore, this is
	 * रक्षित by this master key's key->sem, so we can करो atomic
	 * search+insert.  It can also be searched without taking any locks, but
	 * in that हाल the वापसed key may have alपढ़ोy been हटाओd.
	 */
	काष्ठा key		*mk_users;

	/*
	 * Length of ->mk_decrypted_inodes, plus one अगर mk_secret is present.
	 * Once this goes to 0, the master key is हटाओd from ->s_master_keys.
	 * The 'struct fscrypt_master_key' will जारी to live as दीर्घ as the
	 * 'struct key' whose payload it is, but we won't let this reference
	 * count rise again.
	 */
	refcount_t		mk_refcount;

	/*
	 * List of inodes that were unlocked using this key.  This allows the
	 * inodes to be evicted efficiently अगर the key is हटाओd.
	 */
	काष्ठा list_head	mk_decrypted_inodes;
	spinlock_t		mk_decrypted_inodes_lock;

	/*
	 * Per-mode encryption keys क्रम the various types of encryption policies
	 * that use them.  Allocated and derived on-demand.
	 */
	काष्ठा fscrypt_prepared_key mk_direct_keys[FSCRYPT_MODE_MAX + 1];
	काष्ठा fscrypt_prepared_key mk_iv_ino_lblk_64_keys[FSCRYPT_MODE_MAX + 1];
	काष्ठा fscrypt_prepared_key mk_iv_ino_lblk_32_keys[FSCRYPT_MODE_MAX + 1];

	/* Hash key क्रम inode numbers.  Initialized only when needed. */
	siphash_key_t		mk_ino_hash_key;
	bool			mk_ino_hash_key_initialized;

पूर्ण __अक्रमomize_layout;

अटल अंतरभूत bool
is_master_key_secret_present(स्थिर काष्ठा fscrypt_master_key_secret *secret)
अणु
	/*
	 * The READ_ONCE() is only necessary क्रम fscrypt_drop_inode() and
	 * fscrypt_key_describe().  These run in atomic context, so they can't
	 * take the key semaphore and thus 'secret' can change concurrently
	 * which would be a data race.  But they only need to know whether the
	 * secret *was* present at the समय of check, so READ_ONCE() suffices.
	 */
	वापस READ_ONCE(secret->size) != 0;
पूर्ण

अटल अंतरभूत स्थिर अक्षर *master_key_spec_type(
				स्थिर काष्ठा fscrypt_key_specअगरier *spec)
अणु
	चयन (spec->type) अणु
	हाल FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
		वापस "descriptor";
	हाल FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:
		वापस "identifier";
	पूर्ण
	वापस "[unknown]";
पूर्ण

अटल अंतरभूत पूर्णांक master_key_spec_len(स्थिर काष्ठा fscrypt_key_specअगरier *spec)
अणु
	चयन (spec->type) अणु
	हाल FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR:
		वापस FSCRYPT_KEY_DESCRIPTOR_SIZE;
	हाल FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER:
		वापस FSCRYPT_KEY_IDENTIFIER_SIZE;
	पूर्ण
	वापस 0;
पूर्ण

काष्ठा key *
fscrypt_find_master_key(काष्ठा super_block *sb,
			स्थिर काष्ठा fscrypt_key_specअगरier *mk_spec);

पूर्णांक fscrypt_add_test_dummy_key(काष्ठा super_block *sb,
			       काष्ठा fscrypt_key_specअगरier *key_spec);

पूर्णांक fscrypt_verअगरy_key_added(काष्ठा super_block *sb,
			     स्थिर u8 identअगरier[FSCRYPT_KEY_IDENTIFIER_SIZE]);

पूर्णांक __init fscrypt_init_keyring(व्योम);

/* keysetup.c */

काष्ठा fscrypt_mode अणु
	स्थिर अक्षर *मित्रly_name;
	स्थिर अक्षर *cipher_str;
	पूर्णांक keysize;
	पूर्णांक ivsize;
	पूर्णांक logged_impl_name;
	क्रमागत blk_crypto_mode_num blk_crypto_mode;
पूर्ण;

बाह्य काष्ठा fscrypt_mode fscrypt_modes[];

पूर्णांक fscrypt_prepare_key(काष्ठा fscrypt_prepared_key *prep_key,
			स्थिर u8 *raw_key, स्थिर काष्ठा fscrypt_info *ci);

व्योम fscrypt_destroy_prepared_key(काष्ठा fscrypt_prepared_key *prep_key);

पूर्णांक fscrypt_set_per_file_enc_key(काष्ठा fscrypt_info *ci, स्थिर u8 *raw_key);

पूर्णांक fscrypt_derive_dirhash_key(काष्ठा fscrypt_info *ci,
			       स्थिर काष्ठा fscrypt_master_key *mk);

व्योम fscrypt_hash_inode_number(काष्ठा fscrypt_info *ci,
			       स्थिर काष्ठा fscrypt_master_key *mk);

पूर्णांक fscrypt_get_encryption_info(काष्ठा inode *inode, bool allow_unsupported);

/**
 * fscrypt_require_key() - require an inode's encryption key
 * @inode: the inode we need the key क्रम
 *
 * If the inode is encrypted, set up its encryption key अगर not alपढ़ोy करोne.
 * Then require that the key be present and वापस -ENOKEY otherwise.
 *
 * No locks are needed, and the key will live as दीर्घ as the काष्ठा inode --- so
 * it won't go away from under you.
 *
 * Return: 0 on success, -ENOKEY अगर the key is missing, or another -त्रुटि_सं code
 * अगर a problem occurred जबतक setting up the encryption key.
 */
अटल अंतरभूत पूर्णांक fscrypt_require_key(काष्ठा inode *inode)
अणु
	अगर (IS_ENCRYPTED(inode)) अणु
		पूर्णांक err = fscrypt_get_encryption_info(inode, false);

		अगर (err)
			वापस err;
		अगर (!fscrypt_has_encryption_key(inode))
			वापस -ENOKEY;
	पूर्ण
	वापस 0;
पूर्ण

/* keysetup_v1.c */

व्योम fscrypt_put_direct_key(काष्ठा fscrypt_direct_key *dk);

पूर्णांक fscrypt_setup_v1_file_key(काष्ठा fscrypt_info *ci,
			      स्थिर u8 *raw_master_key);

पूर्णांक fscrypt_setup_v1_file_key_via_subscribed_keyrings(काष्ठा fscrypt_info *ci);

/* policy.c */

bool fscrypt_policies_equal(स्थिर जोड़ fscrypt_policy *policy1,
			    स्थिर जोड़ fscrypt_policy *policy2);
bool fscrypt_supported_policy(स्थिर जोड़ fscrypt_policy *policy_u,
			      स्थिर काष्ठा inode *inode);
पूर्णांक fscrypt_policy_from_context(जोड़ fscrypt_policy *policy_u,
				स्थिर जोड़ fscrypt_context *ctx_u,
				पूर्णांक ctx_size);
स्थिर जोड़ fscrypt_policy *fscrypt_policy_to_inherit(काष्ठा inode *dir);

#पूर्ण_अगर /* _FSCRYPT_PRIVATE_H */
